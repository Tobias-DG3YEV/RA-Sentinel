---------------------------------------------------------------------------
--
--  (c) Copyright 2012 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES.
--
---------------------------------------------------------------------------
-- Description:
-- This is an example testbench for the Viterbi Decoder LogiCORE module.
-- The testbench has been generated by the Xilinx CORE Generator software
-- to accompany the netlist you have generated.
--
-- This testbench is for demonstration purposes only.  See note below for
-- instructions on how to use it with the netlist created for your core.
--
-- See the Viterbi Decoder Product Guide for further information about
-- this core.
--
---------------------------------------------------------------------------
-- Using this testbench
--
-- This testbench instantiates your generated Viterbi Decoder core
-- named "viterbi_v7_0".
--
-- If your CORE Generator project options were set to generate a structural
-- model, a netlist named viterbi_v7_0.vhd or viterbi_v7_0.v was generated.
-- If this file is not present, execute the following command in the directory
-- containing your CORE Generator output files, to create a VHDL netlist:
--
--   netgen -sim -ofmt vhdl viterbi_v7_0.ngc viterbi_v7_0.vhd
--
-- Compile viterbi_v7_0.vhd into the work library.  See your simulator
-- documentation for more information on how to do this.
--
---------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

entity tb_viterbi_v7_0 is
end tb_viterbi_v7_0;

architecture tb of tb_viterbi_v7_0 is

  -----------------------------------------------------------------------
  -- Timing constants
  -----------------------------------------------------------------------
  constant CLOCK_PERIOD : time := 100 ns;
  constant T_HOLD       : time := 10 ns;
  constant T_STROBE     : time := CLOCK_PERIOD - (1 ns);

  -----------------------------------------------------------------------
  -- DUT signals
  -----------------------------------------------------------------------

  -- Global signals
  signal aclk                : std_logic := '0';  -- the master clock
  signal aresetn             : std_logic := '1';  -- synchronous active low reset
  signal aclken              : std_logic := '1';  -- clock enable

  -- Input data slave channel signals
  signal s_axis_data_tvalid  : std_logic := '0';  -- payload is valid
  signal s_axis_data_tready  : std_logic := '1';  -- slave is ready
  signal s_axis_data_tdata   : std_logic_vector(15 downto 0) := (others => '0');  -- data payload
  signal s_axis_data_tuser   : std_logic_vector(7 downto 0) := (others => '0');  -- sideband payload

  -- Output data master channel signals
  signal m_axis_data_tvalid  : std_logic := '0';  -- payload is valid
  signal m_axis_data_tdata   : std_logic_vector(7 downto 0) := (others => '0');  -- data payload

  -----------------------------------------------------------------------
  -- Aliases for AXI channel TDATA and TUSER fields
  -- These are a convenience for viewing data in a simulator waveform viewer.
  -- If using ModelSim or Questa, add "-voptargs=+acc=n" to the vsim command
  -- to prevent the simulator optimizing away these signals.
  -----------------------------------------------------------------------

  -- Input data slave channel alias signals
  signal s_axis_data_tdata_data_in0   : std_logic_vector(2 downto 0) := (others => '0');  -- DATA_IN0 field
  signal s_axis_data_tdata_data_in1   : std_logic_vector(2 downto 0) := (others => '0');  -- DATA_IN1 field

  signal s_axis_data_tuser_erase      : std_logic_vector(1 downto 0) := (others => '0');  -- ERASE field

  -- Output data master channel alias signals
  signal m_axis_data_tdata_data       : std_logic := '0';  -- DATA field

  -- Deserialized data input and output signals, to make it easy to visualize the data
  signal s_axis_data_tdata_src_des    : std_logic_vector(7 downto 0) := (others => '0');
  signal m_axis_data_tdata_des        : std_logic_vector(7 downto 0) := (others => '0');

  -----------------------------------------------------------------------
  -- Testbench constants, types and functions to create input data
  -----------------------------------------------------------------------

  -- Source data array
  type t_src_table is array (0 to 31) of std_logic_vector(7 downto 0);

  -- Function to generate source data table to be serialized and convolution-encoded to form input data
  -- Data is a sinusoid using 8 bit data words and a period of 32 samples
  function create_src_table return t_src_table is
    variable result   : t_src_table;
    variable theta    : real;
    variable sin_real : real;
    variable sin_int  : integer;
  begin
    for i in 0 to 31 loop
      theta     := real(i) / real(32) * 2.0 * MATH_PI;
      sin_real  := sin(theta);
      sin_int   := integer(round(sin_real * real(2**7 - 1)));
      result(i) := std_logic_vector(to_signed(sin_int, 8));
    end loop;
    return result;
  end function create_src_table;

  -- Call the function to create the source data
  constant SRC_DATA : t_src_table := create_src_table;

  -- Convolution codes array
  type t_conv_codes is array (0 to 1) of std_logic_vector(6 downto 0);
  constant CONV_CODES : t_conv_codes := ("1011011",
                                         "1111001");

  -- Puncture codes to control erasure.  The puncture codes are fixed and do not change during the test.
  -- The puncture codes defined here are for a standard 3/4 puncture rate.
  -- You can change the puncture rate and puncture codes by editing these constants.
  constant PUNC_INPUT_RATE  : integer := 3;  -- numerator of puncture rate
  constant PUNC_OUTPUT_RATE : integer := 4;  -- denominator of puncture rate
  type t_punc_codes_array is array (0 to 1) of std_logic_vector(PUNC_INPUT_RATE-1 downto 0);
  -- The total number of '1' bits in the following puncture codes array must equal PUNC_OUTPUT_RATE
  constant PUNC_CODES : t_punc_codes_array := ("101",
                                               "110");

  -----------------------------------------------------------------------
  -- Testbench types and signals
  -----------------------------------------------------------------------

  -- Overall simulation phase control enumerated type and signal
  type t_sim_phase is (phase_init,           -- testbench initialization
                       phase_no_errors,      -- decode data containing no errors
                       phase_correct_errors, -- decode and correct data containing errors
                       phase_toomany_errors, -- fail to correct data containing too many errors
                       phase_axi_handshake,  -- demonstrate AXI handshake signals
                       phase_aresetn,        -- demonstrate the use of synchronous reset
                       phase_aclken,         -- demonstrate the use of clock enable
                       phase_end             -- end of simulation
                       );
  signal sim_phase : t_sim_phase := phase_init;

  -- Indicate when errors are inserted between convolution encoder and Viterbi decoder
  signal errors_inserted : integer := 0;

  -- Indicate when inputs to the Viterbi decoder are erased
  signal erasures_inserted : integer := 0;

  -- Count data outputs within each simulation phase
  signal phase_outputs : integer := 0;

begin

  -----------------------------------------------------------------------
  -- Instantiate the DUT
  -----------------------------------------------------------------------

  dut : entity work.viterbi_v7_0
    port map (
      -- Global signals
      aclk                => aclk,
      aresetn             => aresetn,
      aclken              => aclken,
    -- AXI4-Stream slave channel for input data
      s_axis_data_tvalid  => s_axis_data_tvalid,
      s_axis_data_tready  => s_axis_data_tready,
      s_axis_data_tdata   => s_axis_data_tdata,
      s_axis_data_tuser   => s_axis_data_tuser,
      -- AXI4-Stream master channel for output data
      m_axis_data_tvalid  => m_axis_data_tvalid,
      m_axis_data_tdata   => m_axis_data_tdata
      );


  -----------------------------------------------------------------------
  -- Generate clock
  -----------------------------------------------------------------------

  clock_gen : process
  begin
    aclk <= '0';
    wait for CLOCK_PERIOD;
    loop
      aclk <= '0';
      wait for CLOCK_PERIOD/2;
      aclk <= '1';
      wait for CLOCK_PERIOD/2;
    end loop;
  end process clock_gen;


  -----------------------------------------------------------------------
  -- Simulation control
  -- Run a series of demonstrations, each in a separate test phase
  -- This process controls all other stimuli processes
  -----------------------------------------------------------------------

  sim_control : process
  begin

    -- Drive simulation control synchronous to the rising edge of the clock
    wait until rising_edge(aclk);

    -- Decode data containing no errors
    sim_phase <= phase_no_errors;
    wait until phase_outputs = 512;
    wait for 5 * CLOCK_PERIOD;

    -- Decode and correct data containing errors
    sim_phase <= phase_correct_errors;
    wait until phase_outputs = 512;
    wait for 5 * CLOCK_PERIOD;

    -- Fail to correct data containing too many errors
    sim_phase <= phase_toomany_errors;
    wait until phase_outputs = 512;
    wait for 5 * CLOCK_PERIOD;

    -- Demonstrate AXI handshake signals
    sim_phase <= phase_axi_handshake;
    wait until phase_outputs = 512;
    wait for 5 * CLOCK_PERIOD;

    -- Demonstrate the use of synchronous reset
    sim_phase <= phase_aresetn;
    wait until phase_outputs = 512;
    wait for 5 * CLOCK_PERIOD;

    -- Demonstrate the use of clock enable
    sim_phase <= phase_aclken;
    wait until phase_outputs = 512;
    wait for 5 * CLOCK_PERIOD;

    -- End of simulation
    sim_phase <= phase_end;
    wait for CLOCK_PERIOD;
    report "Not a real failure. Simulation finished successfully. Test completed successfully" severity failure;
    wait;

  end process sim_control;


  -----------------------------------------------------------------------
  -- Generate input data slave channel inputs
  -----------------------------------------------------------------------

  s_data_stimuli : process

    -- Variables for random number generation
    variable seed1, seed2 : positive;
    variable rand         : real;

    -- Procedure to drive a single transaction on the input data channel
    -- valid_mode defines how to drive TVALID: 0=TVALID always high, otherwise TVALID low 1 in valid_mode cycles
    -- tdata and tuser are the transaction payload
    -- abort is set if a reset aborts the transaction
    procedure drive_data(tdata          : std_logic_vector(15 downto 0);
                         tuser          : std_logic_vector(7 downto 0);
                         valid_mode     : integer := 0;
                         variable abort : out boolean) is
    begin
      -- Drive AXI payload signals
      s_axis_data_tdata <= tdata;
      s_axis_data_tuser <= tuser;

      -- Drive AXI control signal TVALID
      if valid_mode > 0 then
        uniform(seed1, seed2, rand);  -- generate random number
        if rand < 1.0 / real(valid_mode) then
          s_axis_data_tvalid <= '0';  -- deassert TVALID
          uniform(seed1, seed2, rand);  -- generate another random number
          wait for CLOCK_PERIOD * integer(ceil(rand * 4.0));  -- hold low for up to 4 cycles
        end if;
      end if;
      s_axis_data_tvalid <= '1';  -- assert TVALID
      abort := false;
      loop
        wait until rising_edge(aclk);
        if aresetn = '0' then
          abort := true;
          exit;
        end if;
        exit when s_axis_data_tready = '1' and aclken = '1';
      end loop;
      wait for T_HOLD;
      s_axis_data_tvalid <= '0';
    end procedure drive_data;

    -- Convolution-encoded data array
    type t_conv_data is array (0 to 1) of std_logic;

    -- Variable for the convolution encoding constraint register
    variable constraint_reg : std_logic_vector(6 downto 0) := (others => '0');

    -- Procedure to convolution-encode source data
    -- data is the source data bit to encode
    procedure conv_data(data            : std_logic;
                        variable result : out t_conv_data) is
      variable apply_code : std_logic_vector(6 downto 0);
      variable result_bit : std_logic;
    begin
      -- Shift constraint register along 1 bit and add the source data bit
      constraint_reg := data & constraint_reg(6 downto 1);
      for rate in 0 to 1 loop
        -- Apply the convolution code then XOR all bits together to generate the output bit
        apply_code := constraint_reg and conv_codes(rate);
        result_bit := '0';
        for xbit in 6 downto 0 loop
          result_bit := result_bit xor apply_code(xbit);
        end loop;
        result(rate) := result_bit;
      end loop;
    end procedure conv_data;

    -- Soft coded Viterbi input data array
    type t_soft_data is array (0 to 1) of std_logic_vector(2 downto 0);

    -- Variable for tracking erasure: this must be declared outside encode_data to retain its value across inputs
    variable punc_index : integer := 0;

    -- Procedure to encode and drive data on the input data channel,
    -- generating input data by convolution-encoding the pregenerated source data table
    -- and inserting errors that would occur due to a noisy communications channel.
    -- src_data is the source data bit to encode and drive
    -- error_rate controls error insertion: 0 = no errors, otherwise 1 in error_rate inputs have errors
    -- erase_mode controls erasure: 0 = no erasures, 1 = erasures using fixed puncture codes
    -- valid_mode defines how to drive TVALID: 0=TVALID always high, otherwise TVALID low 1 in valid_mode cycles
    -- abort indicates if reset interrupted the data transaction
    procedure encode_data(src_data       : std_logic;
                          error_rate     : integer   := 0;
                          erase_mode     : integer   := 0;
                          valid_mode     : integer   := 0;
                          variable abort : out boolean) is
      -- Variables for generating encoded input data
      variable enc_data    : t_conv_data;
      variable errors      : integer;
      variable erase       : std_logic_vector(1 downto 0);
      variable erasures    : integer;
      variable strength    : integer;
      variable in_data     : t_soft_data;
      -- Variables for driving AXI transaction
      variable tdata       : std_logic_vector(15 downto 0);
      variable tuser       : std_logic_vector(7 downto 0);
      variable abort_trans : boolean;
    begin

      -- Convolution-encode the source data bit
      conv_data(src_data, enc_data);

      -- If erasures are required, erase inputs in the pattern defined by the puncture codes
      erase    := (others => '0');
      erasures := 0;
      if erase_mode = 1 then
        for i in 0 to 1 loop
          if PUNC_CODES(i)(punc_index) = '0' then  -- erasure required
            enc_data(i) := '0';  -- clear the input
            erase(i)    := '1';  -- mark the input as erased
            erasures    := erasures + 1;  -- count number of inputs erased
          end if;
        end loop;
        -- Increment puncture code index, wrapping at puncture input rate
        punc_index := punc_index + 1;
        if punc_index = PUNC_INPUT_RATE then
          punc_index := 0;
        end if;
      end if;
      erasures_inserted <= erasures;

      -- Convert to soft coding and insert errors as required, indicating the number of errors inserted
      -- Ideally this would use an additive white Gaussian noise model, but avoid that level of complexity
      -- and instead use an x^2 curve to make strong correct data most likely and strong errors least likely
      errors := 0;
      for i in 0 to 1 loop
        -- No errors in erased inputs: these are null symbols inserted at the receiver so errors cannot occur
        if erase(i) = '1' then
          in_data(i) := (others => '0');  -- null symbol
          next;
        end if;
        uniform(seed1, seed2, rand);  -- generate random number
        strength := integer(floor((1.0 - (rand * rand)) * real(2**2)));  -- strength of soft coding
        uniform(seed1, seed2, rand);  -- generate another random number
        if error_rate = 0 or rand > 1.0 / real(error_rate) then
          -- do not insert error
          in_data(i)(2) := enc_data(i);  -- sign is data value
          in_data(i)(1 downto 0) := std_logic_vector(to_unsigned(strength, 2));  -- magnitude is strength
        else
          -- insert error
          errors := errors + 1;
          in_data(i)(2) := not enc_data(i);  -- data value in error
          in_data(i)(1 downto 0) := not std_logic_vector(to_unsigned(strength, 2));  -- weak errors most likely
        end if;
      end loop;
      errors_inserted <= errors;

      -- Construct TDATA value
      tdata(2 downto 0) := in_data(0);  -- DATA_IN0
      tdata(7 downto 3) := (others => '0');  -- zero pad
      tdata(10 downto 8) := in_data(1);  -- DATA_IN1
      tdata(15 downto 11) := (others => '0');  -- zero pad

      -- Construct TUSER value
      tuser(1 downto 0) := erase;  -- ERASE
      tuser(7 downto 2) := (others => '0');  -- zero pad

      -- Drive the AXI transaction
      drive_data(tdata      => tdata,
                 tuser      => tuser,
                 valid_mode => valid_mode,
                 abort      => abort_trans);

      -- If reset occurred, reset the constraint register used for convolution encoding
      if abort_trans then
        constraint_reg := (others => '0');
      end if;
      abort := abort_trans;

    end procedure encode_data;

    -- Variables for encoding and data driving parameters
    variable word         : integer;
    variable sbit         : integer;
    variable error_rate   : integer := 0;
    variable erase_mode   : integer := 0;
    variable valid_mode   : integer := 0;
    variable abort        : boolean;

  begin

    -- Wait for simulation control to signal the first phase
    wait until sim_phase = phase_no_errors;
    wait for T_HOLD;  -- drive inputs T_HOLD after the rising edge of the clock

    -- The Viterbi decoder requires input data to generate output data.  Pausing input data also pauses output.
    -- Therefore stream data into the Viterbi decoder continuously across all simulation phases.
    test_loop : while sim_phase /= phase_end loop

      -- Serialize the predefined source data (sine wave), LSB first for each sample
      word_loop : for word in 0 to 31 loop
        -- Assign deserialized source data to alias signal for easy simulator waveform viewing
        s_axis_data_tdata_src_des <= SRC_DATA(word);

        bit_loop : for sbit in 0 to 7 loop
          -- Set encoding and data driving parameters based on the current simulation phase
          set_error_rate : case sim_phase is
            when phase_no_errors =>
              error_rate := 0;
            when phase_toomany_errors =>
              error_rate := 35;
            when others =>
              error_rate := 1232;
          end case set_error_rate;
          if sim_phase = phase_no_errors then
            erase_mode := 0;
          else
            erase_mode := 1;
          end if;
          if sim_phase = phase_axi_handshake then
            valid_mode := 10;
          else
            valid_mode := 0;
          end if;

          -- Encode and drive Viterbi input data
          encode_data(src_data   => SRC_DATA(word)(sbit),
                      error_rate => error_rate,
                      erase_mode => erase_mode,
                      valid_mode => valid_mode,
                      abort      => abort);

          -- If reset occurred, go back to the start of the source data table
          exit word_loop when abort;

        end loop bit_loop;
      end loop word_loop;
    end loop test_loop;

    -- End of test
    wait;

  end process s_data_stimuli;

  -----------------------------------------------------------------------
  -- Generate synchronous reset input
  -----------------------------------------------------------------------

  aresetn_stimuli : process
  begin

    -- Synchronous reset input is active low.
    -- Synchronous reset is high (inactive) in all phases except reset demonstration
    aresetn <= '1';
    wait until sim_phase = phase_aresetn;

    -- Reset the core partway through the test phase.
    -- Note that reset must be asserted for a minimum of two clock cycles (see the datasheet for details).
    wait for CLOCK_PERIOD * 20;
    wait for T_HOLD;  -- drive inputs T_HOLD after the rising edge of the clock

    -- Assert reset for two clock cycles
    aresetn <= '0';  -- reset is active low
    wait for CLOCK_PERIOD * 2;
    aresetn <= '1';

    -- End of test
    wait;

  end process aresetn_stimuli;

  -----------------------------------------------------------------------
  -- Generate clock enable input
  -----------------------------------------------------------------------

  aclken_stimuli : process

    -- Variables for random number generation
    variable seed1, seed2 : positive;
    variable rand         : real;

  begin

    -- Clock enable is high in all phases except clock enable demonstration
    aclken <= '1';
    wait until sim_phase = phase_aclken;
    wait until rising_edge(aclk);  -- synchronize to the clock
    wait for T_HOLD;  -- drive inputs T_HOLD after the rising edge of the clock

    -- Demonstrate the use of clock enable
    -- Drive aclken with random values
    while sim_phase = phase_aclken loop

      -- Drive aclken
      uniform(seed1, seed2, rand);  -- generate random number
      if rand < 0.5 then
        aclken <= '0';
      else
        aclken <= '1';
      end if;

      wait until rising_edge(aclk);
      wait for T_HOLD;  -- drive inputs T_HOLD after the rising edge of the clock

    end loop;
    aclken <= '1';

    -- End of test
    wait;

  end process aclken_stimuli;

  -----------------------------------------------------------------------
  -- Check outputs
  -----------------------------------------------------------------------

  check_outputs : process

    -- Variables for checking the protocol of the output data master channel
    variable check_ok : boolean := true;
    -- Track changes in simulation phase
    variable sim_phase_prev : t_sim_phase := phase_init;

  begin

    -- Check outputs T_STROBE time after rising edge of clock
    wait until rising_edge(aclk);
    wait for T_STROBE;

    -- Do not check the output payload values, as this requires a numerical model
    -- which would make this demonstration testbench unwieldy.
    -- Instead, check the protocol of the output data master channel:
    -- check that the payload is valid (not X) when TVALID is high

    if m_axis_data_tvalid = '1' and aresetn = '1' and aclken = '1' then
      if is_x(m_axis_data_tdata) then
        report "ERROR: m_axis_data_tdata is invalid when m_axis_data_tvalid is high" severity error;
        check_ok := false;
      end if;
    end if;

    -- Count the number of data outputs within each simulation phase
    if sim_phase /= sim_phase_prev or aresetn = '0' then
      phase_outputs <= 0;
    elsif m_axis_data_tvalid = '1'  and aclken = '1'then
      phase_outputs <= phase_outputs + 1;
    end if;
    sim_phase_prev := sim_phase;

    -- Stop if any check failed
    assert check_ok
      report "ERROR: terminating test with failures." severity failure;

  end process check_outputs;

  -----------------------------------------------------------------------
  -- Assign TDATA / TUSER fields to aliases, for easy simulator waveform viewing
  -----------------------------------------------------------------------

  -- Input data slave channel alias signals
  s_axis_data_tdata_data_in0   <= s_axis_data_tdata(2 downto 0);
  s_axis_data_tdata_data_in1   <= s_axis_data_tdata(10 downto 8);

  s_axis_data_tuser_erase      <= s_axis_data_tuser(1 downto 0);

  -- Output data master channel alias signals
  m_axis_data_tdata_data       <= m_axis_data_tdata(0);


  -----------------------------------------------------------------------
  -- Deserialize data output to make it easy to visualize the output data
  -----------------------------------------------------------------------

  deserialize_output : process

    -- Variables for deserialization
    variable sbit      : integer := 0;
    variable data_word : std_logic_vector(7 downto 0);

  begin

    -- Examine outputs T_STROBE time after rising edge of clock
    wait until rising_edge(aclk);
    wait for T_STROBE;

    -- Reset restarts deserialization
    if aresetn = '0' then
      sbit      := 0;
      m_axis_data_tdata_des <= (others => '0');
    elsif m_axis_data_tvalid = '1'  and aclken = '1'then
      -- Deserialize valid output data bits to reconstruct the source data format
      data_word(sbit) := m_axis_data_tdata(0);
      if sbit = 7 then
        m_axis_data_tdata_des <= data_word;
        sbit := 0;
      else
        sbit := sbit + 1;
      end if;
    end if;

  end process deserialize_output;

end tb;

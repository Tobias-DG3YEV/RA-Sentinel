
ECHUTEST_CubeIDE.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000298  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00015030  080002a0  080002a0  000012a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00004878  080152d0  080152d0  000162d0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  08019b48  08019b48  0001ab48  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  08019b50  08019b50  0001ab50  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .fini_array   00000004  08019b54  08019b54  0001ab54  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .data         0000008c  24000000  08019b58  0001b000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .Rx_PoolSection 00003183  2400008c  08019be4  0001b08c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .TxDecripSection 00000060  24003210  0801cd67  0001e210  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .RxDecripSection 00000060  24003270  0801cdc7  0001e270  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .bss          000113ec  240032d0  0801ce27  0001e2d0  2**2
                  ALLOC
 11 ._user_heap_stack 00009004  240146bc  0801ce27  0001e6bc  2**0
                  ALLOC
 12 .ARM.attributes 0000002e  00000000  00000000  0001e2d0  2**0
                  CONTENTS, READONLY
 13 .debug_info   0005b267  00000000  00000000  0001e2fe  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 0000a9aa  00000000  00000000  00079565  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_loclists 0001f7b6  00000000  00000000  00083f0f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 00002bb0  00000000  00000000  000a36c8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_rnglists 00002694  00000000  00000000  000a6278  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  00049f0d  00000000  00000000  000a890c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   00055031  00000000  00000000  000f2819  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    0018dee4  00000000  00000000  0014784a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000043  00000000  00000000  002d572e  2**0
                  CONTENTS, READONLY
 22 .debug_frame  00008a44  00000000  00000000  002d5774  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .debug_line_str 00000061  00000000  00000000  002de1b8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080002a0 <__do_global_dtors_aux>:
 80002a0:	b510      	push	{r4, lr}
 80002a2:	4c05      	ldr	r4, [pc, #20]	@ (80002b8 <__do_global_dtors_aux+0x18>)
 80002a4:	7823      	ldrb	r3, [r4, #0]
 80002a6:	b933      	cbnz	r3, 80002b6 <__do_global_dtors_aux+0x16>
 80002a8:	4b04      	ldr	r3, [pc, #16]	@ (80002bc <__do_global_dtors_aux+0x1c>)
 80002aa:	b113      	cbz	r3, 80002b2 <__do_global_dtors_aux+0x12>
 80002ac:	4804      	ldr	r0, [pc, #16]	@ (80002c0 <__do_global_dtors_aux+0x20>)
 80002ae:	f3af 8000 	nop.w
 80002b2:	2301      	movs	r3, #1
 80002b4:	7023      	strb	r3, [r4, #0]
 80002b6:	bd10      	pop	{r4, pc}
 80002b8:	240032d0 	.word	0x240032d0
 80002bc:	00000000 	.word	0x00000000
 80002c0:	080152b8 	.word	0x080152b8

080002c4 <frame_dummy>:
 80002c4:	b508      	push	{r3, lr}
 80002c6:	4b03      	ldr	r3, [pc, #12]	@ (80002d4 <frame_dummy+0x10>)
 80002c8:	b11b      	cbz	r3, 80002d2 <frame_dummy+0xe>
 80002ca:	4903      	ldr	r1, [pc, #12]	@ (80002d8 <frame_dummy+0x14>)
 80002cc:	4803      	ldr	r0, [pc, #12]	@ (80002dc <frame_dummy+0x18>)
 80002ce:	f3af 8000 	nop.w
 80002d2:	bd08      	pop	{r3, pc}
 80002d4:	00000000 	.word	0x00000000
 80002d8:	240032d4 	.word	0x240032d4
 80002dc:	080152b8 	.word	0x080152b8

080002e0 <strlen>:
 80002e0:	4603      	mov	r3, r0
 80002e2:	f813 2b01 	ldrb.w	r2, [r3], #1
 80002e6:	2a00      	cmp	r2, #0
 80002e8:	d1fb      	bne.n	80002e2 <strlen+0x2>
 80002ea:	1a18      	subs	r0, r3, r0
 80002ec:	3801      	subs	r0, #1
 80002ee:	4770      	bx	lr

080002f0 <memchr>:
 80002f0:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 80002f4:	2a10      	cmp	r2, #16
 80002f6:	db2b      	blt.n	8000350 <memchr+0x60>
 80002f8:	f010 0f07 	tst.w	r0, #7
 80002fc:	d008      	beq.n	8000310 <memchr+0x20>
 80002fe:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000302:	3a01      	subs	r2, #1
 8000304:	428b      	cmp	r3, r1
 8000306:	d02d      	beq.n	8000364 <memchr+0x74>
 8000308:	f010 0f07 	tst.w	r0, #7
 800030c:	b342      	cbz	r2, 8000360 <memchr+0x70>
 800030e:	d1f6      	bne.n	80002fe <memchr+0xe>
 8000310:	b4f0      	push	{r4, r5, r6, r7}
 8000312:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000316:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800031a:	f022 0407 	bic.w	r4, r2, #7
 800031e:	f07f 0700 	mvns.w	r7, #0
 8000322:	2300      	movs	r3, #0
 8000324:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000328:	3c08      	subs	r4, #8
 800032a:	ea85 0501 	eor.w	r5, r5, r1
 800032e:	ea86 0601 	eor.w	r6, r6, r1
 8000332:	fa85 f547 	uadd8	r5, r5, r7
 8000336:	faa3 f587 	sel	r5, r3, r7
 800033a:	fa86 f647 	uadd8	r6, r6, r7
 800033e:	faa5 f687 	sel	r6, r5, r7
 8000342:	b98e      	cbnz	r6, 8000368 <memchr+0x78>
 8000344:	d1ee      	bne.n	8000324 <memchr+0x34>
 8000346:	bcf0      	pop	{r4, r5, r6, r7}
 8000348:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 800034c:	f002 0207 	and.w	r2, r2, #7
 8000350:	b132      	cbz	r2, 8000360 <memchr+0x70>
 8000352:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000356:	3a01      	subs	r2, #1
 8000358:	ea83 0301 	eor.w	r3, r3, r1
 800035c:	b113      	cbz	r3, 8000364 <memchr+0x74>
 800035e:	d1f8      	bne.n	8000352 <memchr+0x62>
 8000360:	2000      	movs	r0, #0
 8000362:	4770      	bx	lr
 8000364:	3801      	subs	r0, #1
 8000366:	4770      	bx	lr
 8000368:	2d00      	cmp	r5, #0
 800036a:	bf06      	itte	eq
 800036c:	4635      	moveq	r5, r6
 800036e:	3803      	subeq	r0, #3
 8000370:	3807      	subne	r0, #7
 8000372:	f015 0f01 	tst.w	r5, #1
 8000376:	d107      	bne.n	8000388 <memchr+0x98>
 8000378:	3001      	adds	r0, #1
 800037a:	f415 7f80 	tst.w	r5, #256	@ 0x100
 800037e:	bf02      	ittt	eq
 8000380:	3001      	addeq	r0, #1
 8000382:	f415 3fc0 	tsteq.w	r5, #98304	@ 0x18000
 8000386:	3001      	addeq	r0, #1
 8000388:	bcf0      	pop	{r4, r5, r6, r7}
 800038a:	3801      	subs	r0, #1
 800038c:	4770      	bx	lr
 800038e:	bf00      	nop

08000390 <__aeabi_uldivmod>:
 8000390:	b953      	cbnz	r3, 80003a8 <__aeabi_uldivmod+0x18>
 8000392:	b94a      	cbnz	r2, 80003a8 <__aeabi_uldivmod+0x18>
 8000394:	2900      	cmp	r1, #0
 8000396:	bf08      	it	eq
 8000398:	2800      	cmpeq	r0, #0
 800039a:	bf1c      	itt	ne
 800039c:	f04f 31ff 	movne.w	r1, #4294967295
 80003a0:	f04f 30ff 	movne.w	r0, #4294967295
 80003a4:	f000 b988 	b.w	80006b8 <__aeabi_idiv0>
 80003a8:	f1ad 0c08 	sub.w	ip, sp, #8
 80003ac:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80003b0:	f000 f806 	bl	80003c0 <__udivmoddi4>
 80003b4:	f8dd e004 	ldr.w	lr, [sp, #4]
 80003b8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80003bc:	b004      	add	sp, #16
 80003be:	4770      	bx	lr

080003c0 <__udivmoddi4>:
 80003c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80003c4:	9d08      	ldr	r5, [sp, #32]
 80003c6:	468e      	mov	lr, r1
 80003c8:	4604      	mov	r4, r0
 80003ca:	4688      	mov	r8, r1
 80003cc:	2b00      	cmp	r3, #0
 80003ce:	d14a      	bne.n	8000466 <__udivmoddi4+0xa6>
 80003d0:	428a      	cmp	r2, r1
 80003d2:	4617      	mov	r7, r2
 80003d4:	d962      	bls.n	800049c <__udivmoddi4+0xdc>
 80003d6:	fab2 f682 	clz	r6, r2
 80003da:	b14e      	cbz	r6, 80003f0 <__udivmoddi4+0x30>
 80003dc:	f1c6 0320 	rsb	r3, r6, #32
 80003e0:	fa01 f806 	lsl.w	r8, r1, r6
 80003e4:	fa20 f303 	lsr.w	r3, r0, r3
 80003e8:	40b7      	lsls	r7, r6
 80003ea:	ea43 0808 	orr.w	r8, r3, r8
 80003ee:	40b4      	lsls	r4, r6
 80003f0:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 80003f4:	fa1f fc87 	uxth.w	ip, r7
 80003f8:	fbb8 f1fe 	udiv	r1, r8, lr
 80003fc:	0c23      	lsrs	r3, r4, #16
 80003fe:	fb0e 8811 	mls	r8, lr, r1, r8
 8000402:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8000406:	fb01 f20c 	mul.w	r2, r1, ip
 800040a:	429a      	cmp	r2, r3
 800040c:	d909      	bls.n	8000422 <__udivmoddi4+0x62>
 800040e:	18fb      	adds	r3, r7, r3
 8000410:	f101 30ff 	add.w	r0, r1, #4294967295
 8000414:	f080 80ea 	bcs.w	80005ec <__udivmoddi4+0x22c>
 8000418:	429a      	cmp	r2, r3
 800041a:	f240 80e7 	bls.w	80005ec <__udivmoddi4+0x22c>
 800041e:	3902      	subs	r1, #2
 8000420:	443b      	add	r3, r7
 8000422:	1a9a      	subs	r2, r3, r2
 8000424:	b2a3      	uxth	r3, r4
 8000426:	fbb2 f0fe 	udiv	r0, r2, lr
 800042a:	fb0e 2210 	mls	r2, lr, r0, r2
 800042e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8000432:	fb00 fc0c 	mul.w	ip, r0, ip
 8000436:	459c      	cmp	ip, r3
 8000438:	d909      	bls.n	800044e <__udivmoddi4+0x8e>
 800043a:	18fb      	adds	r3, r7, r3
 800043c:	f100 32ff 	add.w	r2, r0, #4294967295
 8000440:	f080 80d6 	bcs.w	80005f0 <__udivmoddi4+0x230>
 8000444:	459c      	cmp	ip, r3
 8000446:	f240 80d3 	bls.w	80005f0 <__udivmoddi4+0x230>
 800044a:	443b      	add	r3, r7
 800044c:	3802      	subs	r0, #2
 800044e:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 8000452:	eba3 030c 	sub.w	r3, r3, ip
 8000456:	2100      	movs	r1, #0
 8000458:	b11d      	cbz	r5, 8000462 <__udivmoddi4+0xa2>
 800045a:	40f3      	lsrs	r3, r6
 800045c:	2200      	movs	r2, #0
 800045e:	e9c5 3200 	strd	r3, r2, [r5]
 8000462:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000466:	428b      	cmp	r3, r1
 8000468:	d905      	bls.n	8000476 <__udivmoddi4+0xb6>
 800046a:	b10d      	cbz	r5, 8000470 <__udivmoddi4+0xb0>
 800046c:	e9c5 0100 	strd	r0, r1, [r5]
 8000470:	2100      	movs	r1, #0
 8000472:	4608      	mov	r0, r1
 8000474:	e7f5      	b.n	8000462 <__udivmoddi4+0xa2>
 8000476:	fab3 f183 	clz	r1, r3
 800047a:	2900      	cmp	r1, #0
 800047c:	d146      	bne.n	800050c <__udivmoddi4+0x14c>
 800047e:	4573      	cmp	r3, lr
 8000480:	d302      	bcc.n	8000488 <__udivmoddi4+0xc8>
 8000482:	4282      	cmp	r2, r0
 8000484:	f200 8105 	bhi.w	8000692 <__udivmoddi4+0x2d2>
 8000488:	1a84      	subs	r4, r0, r2
 800048a:	eb6e 0203 	sbc.w	r2, lr, r3
 800048e:	2001      	movs	r0, #1
 8000490:	4690      	mov	r8, r2
 8000492:	2d00      	cmp	r5, #0
 8000494:	d0e5      	beq.n	8000462 <__udivmoddi4+0xa2>
 8000496:	e9c5 4800 	strd	r4, r8, [r5]
 800049a:	e7e2      	b.n	8000462 <__udivmoddi4+0xa2>
 800049c:	2a00      	cmp	r2, #0
 800049e:	f000 8090 	beq.w	80005c2 <__udivmoddi4+0x202>
 80004a2:	fab2 f682 	clz	r6, r2
 80004a6:	2e00      	cmp	r6, #0
 80004a8:	f040 80a4 	bne.w	80005f4 <__udivmoddi4+0x234>
 80004ac:	1a8a      	subs	r2, r1, r2
 80004ae:	0c03      	lsrs	r3, r0, #16
 80004b0:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 80004b4:	b280      	uxth	r0, r0
 80004b6:	b2bc      	uxth	r4, r7
 80004b8:	2101      	movs	r1, #1
 80004ba:	fbb2 fcfe 	udiv	ip, r2, lr
 80004be:	fb0e 221c 	mls	r2, lr, ip, r2
 80004c2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80004c6:	fb04 f20c 	mul.w	r2, r4, ip
 80004ca:	429a      	cmp	r2, r3
 80004cc:	d907      	bls.n	80004de <__udivmoddi4+0x11e>
 80004ce:	18fb      	adds	r3, r7, r3
 80004d0:	f10c 38ff 	add.w	r8, ip, #4294967295
 80004d4:	d202      	bcs.n	80004dc <__udivmoddi4+0x11c>
 80004d6:	429a      	cmp	r2, r3
 80004d8:	f200 80e0 	bhi.w	800069c <__udivmoddi4+0x2dc>
 80004dc:	46c4      	mov	ip, r8
 80004de:	1a9b      	subs	r3, r3, r2
 80004e0:	fbb3 f2fe 	udiv	r2, r3, lr
 80004e4:	fb0e 3312 	mls	r3, lr, r2, r3
 80004e8:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 80004ec:	fb02 f404 	mul.w	r4, r2, r4
 80004f0:	429c      	cmp	r4, r3
 80004f2:	d907      	bls.n	8000504 <__udivmoddi4+0x144>
 80004f4:	18fb      	adds	r3, r7, r3
 80004f6:	f102 30ff 	add.w	r0, r2, #4294967295
 80004fa:	d202      	bcs.n	8000502 <__udivmoddi4+0x142>
 80004fc:	429c      	cmp	r4, r3
 80004fe:	f200 80ca 	bhi.w	8000696 <__udivmoddi4+0x2d6>
 8000502:	4602      	mov	r2, r0
 8000504:	1b1b      	subs	r3, r3, r4
 8000506:	ea42 400c 	orr.w	r0, r2, ip, lsl #16
 800050a:	e7a5      	b.n	8000458 <__udivmoddi4+0x98>
 800050c:	f1c1 0620 	rsb	r6, r1, #32
 8000510:	408b      	lsls	r3, r1
 8000512:	fa22 f706 	lsr.w	r7, r2, r6
 8000516:	431f      	orrs	r7, r3
 8000518:	fa0e f401 	lsl.w	r4, lr, r1
 800051c:	fa20 f306 	lsr.w	r3, r0, r6
 8000520:	fa2e fe06 	lsr.w	lr, lr, r6
 8000524:	ea4f 4917 	mov.w	r9, r7, lsr #16
 8000528:	4323      	orrs	r3, r4
 800052a:	fa00 f801 	lsl.w	r8, r0, r1
 800052e:	fa1f fc87 	uxth.w	ip, r7
 8000532:	fbbe f0f9 	udiv	r0, lr, r9
 8000536:	0c1c      	lsrs	r4, r3, #16
 8000538:	fb09 ee10 	mls	lr, r9, r0, lr
 800053c:	ea44 440e 	orr.w	r4, r4, lr, lsl #16
 8000540:	fb00 fe0c 	mul.w	lr, r0, ip
 8000544:	45a6      	cmp	lr, r4
 8000546:	fa02 f201 	lsl.w	r2, r2, r1
 800054a:	d909      	bls.n	8000560 <__udivmoddi4+0x1a0>
 800054c:	193c      	adds	r4, r7, r4
 800054e:	f100 3aff 	add.w	sl, r0, #4294967295
 8000552:	f080 809c 	bcs.w	800068e <__udivmoddi4+0x2ce>
 8000556:	45a6      	cmp	lr, r4
 8000558:	f240 8099 	bls.w	800068e <__udivmoddi4+0x2ce>
 800055c:	3802      	subs	r0, #2
 800055e:	443c      	add	r4, r7
 8000560:	eba4 040e 	sub.w	r4, r4, lr
 8000564:	fa1f fe83 	uxth.w	lr, r3
 8000568:	fbb4 f3f9 	udiv	r3, r4, r9
 800056c:	fb09 4413 	mls	r4, r9, r3, r4
 8000570:	ea4e 4404 	orr.w	r4, lr, r4, lsl #16
 8000574:	fb03 fc0c 	mul.w	ip, r3, ip
 8000578:	45a4      	cmp	ip, r4
 800057a:	d908      	bls.n	800058e <__udivmoddi4+0x1ce>
 800057c:	193c      	adds	r4, r7, r4
 800057e:	f103 3eff 	add.w	lr, r3, #4294967295
 8000582:	f080 8082 	bcs.w	800068a <__udivmoddi4+0x2ca>
 8000586:	45a4      	cmp	ip, r4
 8000588:	d97f      	bls.n	800068a <__udivmoddi4+0x2ca>
 800058a:	3b02      	subs	r3, #2
 800058c:	443c      	add	r4, r7
 800058e:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8000592:	eba4 040c 	sub.w	r4, r4, ip
 8000596:	fba0 ec02 	umull	lr, ip, r0, r2
 800059a:	4564      	cmp	r4, ip
 800059c:	4673      	mov	r3, lr
 800059e:	46e1      	mov	r9, ip
 80005a0:	d362      	bcc.n	8000668 <__udivmoddi4+0x2a8>
 80005a2:	d05f      	beq.n	8000664 <__udivmoddi4+0x2a4>
 80005a4:	b15d      	cbz	r5, 80005be <__udivmoddi4+0x1fe>
 80005a6:	ebb8 0203 	subs.w	r2, r8, r3
 80005aa:	eb64 0409 	sbc.w	r4, r4, r9
 80005ae:	fa04 f606 	lsl.w	r6, r4, r6
 80005b2:	fa22 f301 	lsr.w	r3, r2, r1
 80005b6:	431e      	orrs	r6, r3
 80005b8:	40cc      	lsrs	r4, r1
 80005ba:	e9c5 6400 	strd	r6, r4, [r5]
 80005be:	2100      	movs	r1, #0
 80005c0:	e74f      	b.n	8000462 <__udivmoddi4+0xa2>
 80005c2:	fbb1 fcf2 	udiv	ip, r1, r2
 80005c6:	0c01      	lsrs	r1, r0, #16
 80005c8:	ea41 410e 	orr.w	r1, r1, lr, lsl #16
 80005cc:	b280      	uxth	r0, r0
 80005ce:	ea40 4201 	orr.w	r2, r0, r1, lsl #16
 80005d2:	463b      	mov	r3, r7
 80005d4:	4638      	mov	r0, r7
 80005d6:	463c      	mov	r4, r7
 80005d8:	46b8      	mov	r8, r7
 80005da:	46be      	mov	lr, r7
 80005dc:	2620      	movs	r6, #32
 80005de:	fbb1 f1f7 	udiv	r1, r1, r7
 80005e2:	eba2 0208 	sub.w	r2, r2, r8
 80005e6:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
 80005ea:	e766      	b.n	80004ba <__udivmoddi4+0xfa>
 80005ec:	4601      	mov	r1, r0
 80005ee:	e718      	b.n	8000422 <__udivmoddi4+0x62>
 80005f0:	4610      	mov	r0, r2
 80005f2:	e72c      	b.n	800044e <__udivmoddi4+0x8e>
 80005f4:	f1c6 0220 	rsb	r2, r6, #32
 80005f8:	fa2e f302 	lsr.w	r3, lr, r2
 80005fc:	40b7      	lsls	r7, r6
 80005fe:	40b1      	lsls	r1, r6
 8000600:	fa20 f202 	lsr.w	r2, r0, r2
 8000604:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000608:	430a      	orrs	r2, r1
 800060a:	fbb3 f8fe 	udiv	r8, r3, lr
 800060e:	b2bc      	uxth	r4, r7
 8000610:	fb0e 3318 	mls	r3, lr, r8, r3
 8000614:	0c11      	lsrs	r1, r2, #16
 8000616:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800061a:	fb08 f904 	mul.w	r9, r8, r4
 800061e:	40b0      	lsls	r0, r6
 8000620:	4589      	cmp	r9, r1
 8000622:	ea4f 4310 	mov.w	r3, r0, lsr #16
 8000626:	b280      	uxth	r0, r0
 8000628:	d93e      	bls.n	80006a8 <__udivmoddi4+0x2e8>
 800062a:	1879      	adds	r1, r7, r1
 800062c:	f108 3cff 	add.w	ip, r8, #4294967295
 8000630:	d201      	bcs.n	8000636 <__udivmoddi4+0x276>
 8000632:	4589      	cmp	r9, r1
 8000634:	d81f      	bhi.n	8000676 <__udivmoddi4+0x2b6>
 8000636:	eba1 0109 	sub.w	r1, r1, r9
 800063a:	fbb1 f9fe 	udiv	r9, r1, lr
 800063e:	fb09 f804 	mul.w	r8, r9, r4
 8000642:	fb0e 1119 	mls	r1, lr, r9, r1
 8000646:	b292      	uxth	r2, r2
 8000648:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 800064c:	4542      	cmp	r2, r8
 800064e:	d229      	bcs.n	80006a4 <__udivmoddi4+0x2e4>
 8000650:	18ba      	adds	r2, r7, r2
 8000652:	f109 31ff 	add.w	r1, r9, #4294967295
 8000656:	d2c4      	bcs.n	80005e2 <__udivmoddi4+0x222>
 8000658:	4542      	cmp	r2, r8
 800065a:	d2c2      	bcs.n	80005e2 <__udivmoddi4+0x222>
 800065c:	f1a9 0102 	sub.w	r1, r9, #2
 8000660:	443a      	add	r2, r7
 8000662:	e7be      	b.n	80005e2 <__udivmoddi4+0x222>
 8000664:	45f0      	cmp	r8, lr
 8000666:	d29d      	bcs.n	80005a4 <__udivmoddi4+0x1e4>
 8000668:	ebbe 0302 	subs.w	r3, lr, r2
 800066c:	eb6c 0c07 	sbc.w	ip, ip, r7
 8000670:	3801      	subs	r0, #1
 8000672:	46e1      	mov	r9, ip
 8000674:	e796      	b.n	80005a4 <__udivmoddi4+0x1e4>
 8000676:	eba7 0909 	sub.w	r9, r7, r9
 800067a:	4449      	add	r1, r9
 800067c:	f1a8 0c02 	sub.w	ip, r8, #2
 8000680:	fbb1 f9fe 	udiv	r9, r1, lr
 8000684:	fb09 f804 	mul.w	r8, r9, r4
 8000688:	e7db      	b.n	8000642 <__udivmoddi4+0x282>
 800068a:	4673      	mov	r3, lr
 800068c:	e77f      	b.n	800058e <__udivmoddi4+0x1ce>
 800068e:	4650      	mov	r0, sl
 8000690:	e766      	b.n	8000560 <__udivmoddi4+0x1a0>
 8000692:	4608      	mov	r0, r1
 8000694:	e6fd      	b.n	8000492 <__udivmoddi4+0xd2>
 8000696:	443b      	add	r3, r7
 8000698:	3a02      	subs	r2, #2
 800069a:	e733      	b.n	8000504 <__udivmoddi4+0x144>
 800069c:	f1ac 0c02 	sub.w	ip, ip, #2
 80006a0:	443b      	add	r3, r7
 80006a2:	e71c      	b.n	80004de <__udivmoddi4+0x11e>
 80006a4:	4649      	mov	r1, r9
 80006a6:	e79c      	b.n	80005e2 <__udivmoddi4+0x222>
 80006a8:	eba1 0109 	sub.w	r1, r1, r9
 80006ac:	46c4      	mov	ip, r8
 80006ae:	fbb1 f9fe 	udiv	r9, r1, lr
 80006b2:	fb09 f804 	mul.w	r8, r9, r4
 80006b6:	e7c4      	b.n	8000642 <__udivmoddi4+0x282>

080006b8 <__aeabi_idiv0>:
 80006b8:	4770      	bx	lr
 80006ba:	bf00      	nop

080006bc <Netif_Config>:
  * @brief  Initializes the lwIP stack
  * @param  None
  * @retval None
  */
static void Netif_Config(void)
{
 80006bc:	b510      	push	{r4, lr}
 80006be:	b088      	sub	sp, #32
#if LWIP_DHCP
  ip_addr_set_zero_ip4(&ipaddr);
  ip_addr_set_zero_ip4(&netmask);
  ip_addr_set_zero_ip4(&gw);
#else
  IP_ADDR4(&ipaddr,IP_ADDR0,IP_ADDR1,IP_ADDR2,IP_ADDR3);
 80006c0:	4b0e      	ldr	r3, [pc, #56]	@ (80006fc <Netif_Config+0x40>)
 80006c2:	9307      	str	r3, [sp, #28]
  IP_ADDR4(&netmask,NETMASK_ADDR0,NETMASK_ADDR1,NETMASK_ADDR2,NETMASK_ADDR3);
 80006c4:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 80006c8:	9306      	str	r3, [sp, #24]
  IP_ADDR4(&gw,GW_ADDR0,GW_ADDR1,GW_ADDR2,GW_ADDR3);
 80006ca:	f103 7386 	add.w	r3, r3, #17563648	@ 0x10c0000
 80006ce:	330b      	adds	r3, #11
 80006d0:	9305      	str	r3, [sp, #20]
#endif /* LWIP_DHCP */

  /* add the network interface */
  netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &tcpip_input);
 80006d2:	4c0b      	ldr	r4, [pc, #44]	@ (8000700 <Netif_Config+0x44>)
 80006d4:	4b0b      	ldr	r3, [pc, #44]	@ (8000704 <Netif_Config+0x48>)
 80006d6:	9302      	str	r3, [sp, #8]
 80006d8:	4b0b      	ldr	r3, [pc, #44]	@ (8000708 <Netif_Config+0x4c>)
 80006da:	9301      	str	r3, [sp, #4]
 80006dc:	2300      	movs	r3, #0
 80006de:	9300      	str	r3, [sp, #0]
 80006e0:	ab05      	add	r3, sp, #20
 80006e2:	aa06      	add	r2, sp, #24
 80006e4:	a907      	add	r1, sp, #28
 80006e6:	4620      	mov	r0, r4
 80006e8:	f00a ffde 	bl	800b6a8 <netif_add>

  /*  Registers the default network interface. */
  netif_set_default(&gnetif);
 80006ec:	4620      	mov	r0, r4
 80006ee:	f00b f875 	bl	800b7dc <netif_set_default>

  ethernet_link_status_updated(&gnetif);
 80006f2:	4620      	mov	r0, r4
 80006f4:	f012 ff3e 	bl	8013574 <ethernet_link_status_updated>
#if LWIP_DHCP
  /* Start DHCPClient */
  osThreadDef(DHCP, DHCP_Thread, osPriorityBelowNormal, 0, configMINIMAL_STACK_SIZE * 2);
  osThreadCreate (osThread(DHCP), &gnetif);
#endif
}
 80006f8:	b008      	add	sp, #32
 80006fa:	bd10      	pop	{r4, pc}
 80006fc:	4d0a000a 	.word	0x4d0a000a
 8000700:	2400354c 	.word	0x2400354c
 8000704:	0800aa39 	.word	0x0800aa39
 8000708:	080138a9 	.word	0x080138a9

0800070c <InitThread>:
*/


/* USER CODE END Header_InitThread */
void InitThread(void const * argument)
{
 800070c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN InitThread */
  HAL_GPIO_WritePin(ETH_RESET_GPIO_Port, ETH_RESET_Pin, GPIO_PIN_SET);
 800070e:	2201      	movs	r2, #1
 8000710:	4611      	mov	r1, r2
 8000712:	480a      	ldr	r0, [pc, #40]	@ (800073c <InitThread+0x30>)
 8000714:	f002 fa60 	bl	8002bd8 <HAL_GPIO_WritePin>
  HAL_Delay(200);
 8000718:	20c8      	movs	r0, #200	@ 0xc8
 800071a:	f000 fe73 	bl	8001404 <HAL_Delay>

  /* Create tcp_ip stack thread */
  tcpip_init(NULL, NULL);
 800071e:	2100      	movs	r1, #0
 8000720:	4608      	mov	r0, r1
 8000722:	f00a f9db 	bl	800aadc <tcpip_init>

  /* Initialize the LwIP stack */
  Netif_Config();
 8000726:	f7ff ffc9 	bl	80006bc <Netif_Config>

  /* Init uUPNP */
  UPNP_serverInit();
 800072a:	f000 fc89 	bl	8001040 <UPNP_serverInit>

  /* Initialize webserver demo */
  http_server_netconn_init();
 800072e:	f013 f9f1 	bl	8013b14 <http_server_netconn_init>

  /* Infinite loop */
  for(;;)
  {
    /* Delete the Init Thread */
    osThreadTerminate(NULL);
 8000732:	2000      	movs	r0, #0
 8000734:	f006 fae8 	bl	8006d08 <osThreadTerminate>
  for(;;)
 8000738:	e7fb      	b.n	8000732 <InitThread+0x26>
 800073a:	bf00      	nop
 800073c:	58020400 	.word	0x58020400

08000740 <vApplicationGetIdleTaskMemory>:
  *ppxIdleTaskTCBBuffer = &xIdleTaskTCBBuffer;
 8000740:	4b03      	ldr	r3, [pc, #12]	@ (8000750 <vApplicationGetIdleTaskMemory+0x10>)
 8000742:	6003      	str	r3, [r0, #0]
  *ppxIdleTaskStackBuffer = &xIdleStack[0];
 8000744:	4b03      	ldr	r3, [pc, #12]	@ (8000754 <vApplicationGetIdleTaskMemory+0x14>)
 8000746:	600b      	str	r3, [r1, #0]
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
 8000748:	2380      	movs	r3, #128	@ 0x80
 800074a:	6013      	str	r3, [r2, #0]
}
 800074c:	4770      	bx	lr
 800074e:	bf00      	nop
 8000750:	240034ec 	.word	0x240034ec
 8000754:	240032ec 	.word	0x240032ec

08000758 <MX_FREERTOS_Init>:
void MX_FREERTOS_Init(void) {
 8000758:	b510      	push	{r4, lr}
 800075a:	b088      	sub	sp, #32
  osThreadDef(Init, InitThread, osPriorityNormal, 0, 1024);
 800075c:	f10d 0c04 	add.w	ip, sp, #4
 8000760:	4c07      	ldr	r4, [pc, #28]	@ (8000780 <MX_FREERTOS_Init+0x28>)
 8000762:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000764:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 8000768:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 800076c:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
  InitHandle = osThreadCreate(osThread(Init), NULL);
 8000770:	2100      	movs	r1, #0
 8000772:	a801      	add	r0, sp, #4
 8000774:	f006 fa95 	bl	8006ca2 <osThreadCreate>
 8000778:	4b02      	ldr	r3, [pc, #8]	@ (8000784 <MX_FREERTOS_Init+0x2c>)
 800077a:	6018      	str	r0, [r3, #0]
}
 800077c:	b008      	add	sp, #32
 800077e:	bd10      	pop	{r4, pc}
 8000780:	080152d0 	.word	0x080152d0
 8000784:	24003548 	.word	0x24003548

08000788 <system_get_netif>:
/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */
struct netif* system_get_netif(void)
{
  return &gnetif;
}
 8000788:	4800      	ldr	r0, [pc, #0]	@ (800078c <system_get_netif+0x4>)
 800078a:	4770      	bx	lr
 800078c:	2400354c 	.word	0x2400354c

08000790 <MX_GPIO_Init>:
     PA15 (JTDI)   ------> DEBUG_JTDI
     PB3 (JTDO/TRACESWO)   ------> DEBUG_JTDO-SWO
     PB4 (NJTRST)   ------> DEBUG_JTRST
*/
void MX_GPIO_Init(void)
{
 8000790:	b530      	push	{r4, r5, lr}
 8000792:	b08b      	sub	sp, #44	@ 0x2c

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000794:	2400      	movs	r4, #0
 8000796:	9405      	str	r4, [sp, #20]
 8000798:	9406      	str	r4, [sp, #24]
 800079a:	9407      	str	r4, [sp, #28]
 800079c:	9408      	str	r4, [sp, #32]
 800079e:	9409      	str	r4, [sp, #36]	@ 0x24

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
 80007a0:	4b31      	ldr	r3, [pc, #196]	@ (8000868 <MX_GPIO_Init+0xd8>)
 80007a2:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 80007a6:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
 80007aa:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
 80007ae:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 80007b2:	f002 0280 	and.w	r2, r2, #128	@ 0x80
 80007b6:	9200      	str	r2, [sp, #0]
 80007b8:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80007ba:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 80007be:	f042 0204 	orr.w	r2, r2, #4
 80007c2:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
 80007c6:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 80007ca:	f002 0204 	and.w	r2, r2, #4
 80007ce:	9201      	str	r2, [sp, #4]
 80007d0:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80007d2:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 80007d6:	f042 0201 	orr.w	r2, r2, #1
 80007da:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
 80007de:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 80007e2:	f002 0201 	and.w	r2, r2, #1
 80007e6:	9202      	str	r2, [sp, #8]
 80007e8:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80007ea:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 80007ee:	f042 0202 	orr.w	r2, r2, #2
 80007f2:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
 80007f6:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 80007fa:	f002 0202 	and.w	r2, r2, #2
 80007fe:	9203      	str	r2, [sp, #12]
 8000800:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8000802:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 8000806:	f042 0208 	orr.w	r2, r2, #8
 800080a:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
 800080e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8000812:	f003 0308 	and.w	r3, r3, #8
 8000816:	9304      	str	r3, [sp, #16]
 8000818:	9b04      	ldr	r3, [sp, #16]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(ETH_RESET_GPIO_Port, ETH_RESET_Pin, GPIO_PIN_RESET);
 800081a:	4d14      	ldr	r5, [pc, #80]	@ (800086c <MX_GPIO_Init+0xdc>)
 800081c:	4622      	mov	r2, r4
 800081e:	2101      	movs	r1, #1
 8000820:	4628      	mov	r0, r5
 8000822:	f002 f9d9 	bl	8002bd8 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = ETH_RESET_Pin;
 8000826:	2301      	movs	r3, #1
 8000828:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800082a:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800082c:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800082e:	9408      	str	r4, [sp, #32]
  HAL_GPIO_Init(ETH_RESET_GPIO_Port, &GPIO_InitStruct);
 8000830:	a905      	add	r1, sp, #20
 8000832:	4628      	mov	r0, r5
 8000834:	f002 f806 	bl	8002844 <HAL_GPIO_Init>

  /*Configure GPIO pin : PA8 */
  GPIO_InitStruct.Pin = GPIO_PIN_8;
 8000838:	f44f 7380 	mov.w	r3, #256	@ 0x100
 800083c:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800083e:	2302      	movs	r3, #2
 8000840:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000842:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000844:	9408      	str	r4, [sp, #32]
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 8000846:	9409      	str	r4, [sp, #36]	@ 0x24
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000848:	a905      	add	r1, sp, #20
 800084a:	4809      	ldr	r0, [pc, #36]	@ (8000870 <MX_GPIO_Init+0xe0>)
 800084c:	f001 fffa 	bl	8002844 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = SPI3_NCS_Pin;
 8000850:	2304      	movs	r3, #4
 8000852:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8000854:	2303      	movs	r3, #3
 8000856:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000858:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(SPI3_NCS_GPIO_Port, &GPIO_InitStruct);
 800085a:	a905      	add	r1, sp, #20
 800085c:	4805      	ldr	r0, [pc, #20]	@ (8000874 <MX_GPIO_Init+0xe4>)
 800085e:	f001 fff1 	bl	8002844 <HAL_GPIO_Init>

}
 8000862:	b00b      	add	sp, #44	@ 0x2c
 8000864:	bd30      	pop	{r4, r5, pc}
 8000866:	bf00      	nop
 8000868:	58024400 	.word	0x58024400
 800086c:	58020400 	.word	0x58020400
 8000870:	58020000 	.word	0x58020000
 8000874:	58020c00 	.word	0x58020c00

08000878 <MPU_Config>:
  * @brief  Configure the MPU attributes
  * @param  None
  * @retval None
  */
static void MPU_Config(void)
{
 8000878:	b570      	push	{r4, r5, r6, lr}
 800087a:	b084      	sub	sp, #16
  MPU_Region_InitTypeDef MPU_InitStruct;

  /* Disable the MPU */
  HAL_MPU_Disable();
 800087c:	f000 fe84 	bl	8001588 <HAL_MPU_Disable>

  /* Configure the MPU as Strongly ordered for not defined regions */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 8000880:	2501      	movs	r5, #1
 8000882:	f88d 5000 	strb.w	r5, [sp]
  MPU_InitStruct.BaseAddress = 0x00;
 8000886:	2400      	movs	r4, #0
 8000888:	9401      	str	r4, [sp, #4]
  MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
 800088a:	231f      	movs	r3, #31
 800088c:	f88d 3008 	strb.w	r3, [sp, #8]
  MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;
 8000890:	f88d 400b 	strb.w	r4, [sp, #11]
  MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
 8000894:	f88d 400f 	strb.w	r4, [sp, #15]
  MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
 8000898:	f88d 400e 	strb.w	r4, [sp, #14]
  MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
 800089c:	f88d 500d 	strb.w	r5, [sp, #13]
  MPU_InitStruct.Number = MPU_REGION_NUMBER0;
 80008a0:	f88d 4001 	strb.w	r4, [sp, #1]
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
 80008a4:	f88d 400a 	strb.w	r4, [sp, #10]
  MPU_InitStruct.SubRegionDisable = 0x87;
 80008a8:	2387      	movs	r3, #135	@ 0x87
 80008aa:	f88d 3009 	strb.w	r3, [sp, #9]
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
 80008ae:	f88d 500c 	strb.w	r5, [sp, #12]

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 80008b2:	4668      	mov	r0, sp
 80008b4:	f000 fe86 	bl	80015c4 <HAL_MPU_ConfigRegion>

  /* Configure the MPU attributes as Device not cacheable
     for ETH DMA descriptors */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 80008b8:	f88d 5000 	strb.w	r5, [sp]
  MPU_InitStruct.BaseAddress = 0x30000000;
 80008bc:	f04f 5340 	mov.w	r3, #805306368	@ 0x30000000
 80008c0:	9301      	str	r3, [sp, #4]
  MPU_InitStruct.Size = MPU_REGION_SIZE_1KB;
 80008c2:	2309      	movs	r3, #9
 80008c4:	f88d 3008 	strb.w	r3, [sp, #8]
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
 80008c8:	2603      	movs	r6, #3
 80008ca:	f88d 600b 	strb.w	r6, [sp, #11]
  MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE;
 80008ce:	f88d 500f 	strb.w	r5, [sp, #15]
  MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
 80008d2:	f88d 400e 	strb.w	r4, [sp, #14]
  MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
 80008d6:	f88d 400d 	strb.w	r4, [sp, #13]
  MPU_InitStruct.Number = MPU_REGION_NUMBER1;
 80008da:	f88d 5001 	strb.w	r5, [sp, #1]
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
 80008de:	f88d 400a 	strb.w	r4, [sp, #10]
  MPU_InitStruct.SubRegionDisable = 0x00;
 80008e2:	f88d 4009 	strb.w	r4, [sp, #9]
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
 80008e6:	f88d 400c 	strb.w	r4, [sp, #12]

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 80008ea:	4668      	mov	r0, sp
 80008ec:	f000 fe6a 	bl	80015c4 <HAL_MPU_ConfigRegion>

  /* Configure the MPU attributes as Normal Non Cacheable
     for LwIP RAM heap which contains the Tx buffers */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 80008f0:	f88d 5000 	strb.w	r5, [sp]
  MPU_InitStruct.BaseAddress = 0x30004000;
 80008f4:	4b0e      	ldr	r3, [pc, #56]	@ (8000930 <MPU_Config+0xb8>)
 80008f6:	9301      	str	r3, [sp, #4]
  MPU_InitStruct.Size = MPU_REGION_SIZE_16KB;
 80008f8:	230d      	movs	r3, #13
 80008fa:	f88d 3008 	strb.w	r3, [sp, #8]
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
 80008fe:	f88d 600b 	strb.w	r6, [sp, #11]
  MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
 8000902:	f88d 400f 	strb.w	r4, [sp, #15]
  MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
 8000906:	f88d 400e 	strb.w	r4, [sp, #14]
  MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
 800090a:	f88d 500d 	strb.w	r5, [sp, #13]
  MPU_InitStruct.Number = MPU_REGION_NUMBER2;
 800090e:	2302      	movs	r3, #2
 8000910:	f88d 3001 	strb.w	r3, [sp, #1]
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL1;
 8000914:	f88d 500a 	strb.w	r5, [sp, #10]
  MPU_InitStruct.SubRegionDisable = 0x00;
 8000918:	f88d 4009 	strb.w	r4, [sp, #9]
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
 800091c:	f88d 400c 	strb.w	r4, [sp, #12]

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 8000920:	4668      	mov	r0, sp
 8000922:	f000 fe4f 	bl	80015c4 <HAL_MPU_ConfigRegion>

  /* Enable the MPU */
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
 8000926:	2004      	movs	r0, #4
 8000928:	f000 fe3c 	bl	80015a4 <HAL_MPU_Enable>
}
 800092c:	b004      	add	sp, #16
 800092e:	bd70      	pop	{r4, r5, r6, pc}
 8000930:	30004000 	.word	0x30004000

08000934 <__io_putchar>:
{
 8000934:	b500      	push	{lr}
 8000936:	b083      	sub	sp, #12
 8000938:	9001      	str	r0, [sp, #4]
    HAL_UART_Transmit(&huart3, (uint8_t *)&ch, 1, HAL_MAX_DELAY);
 800093a:	f04f 33ff 	mov.w	r3, #4294967295
 800093e:	2201      	movs	r2, #1
 8000940:	a901      	add	r1, sp, #4
 8000942:	4803      	ldr	r0, [pc, #12]	@ (8000950 <__io_putchar+0x1c>)
 8000944:	f005 feeb 	bl	800671e <HAL_UART_Transmit>
}
 8000948:	9801      	ldr	r0, [sp, #4]
 800094a:	b003      	add	sp, #12
 800094c:	f85d fb04 	ldr.w	pc, [sp], #4
 8000950:	24003670 	.word	0x24003670

08000954 <HAL_TIM_PeriodElapsedCallback>:
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 8000954:	b508      	push	{r3, lr}
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM1) {
 8000956:	6802      	ldr	r2, [r0, #0]
 8000958:	4b03      	ldr	r3, [pc, #12]	@ (8000968 <HAL_TIM_PeriodElapsedCallback+0x14>)
 800095a:	429a      	cmp	r2, r3
 800095c:	d000      	beq.n	8000960 <HAL_TIM_PeriodElapsedCallback+0xc>
    HAL_IncTick();
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}
 800095e:	bd08      	pop	{r3, pc}
    HAL_IncTick();
 8000960:	f000 fd3e 	bl	80013e0 <HAL_IncTick>
}
 8000964:	e7fb      	b.n	800095e <HAL_TIM_PeriodElapsedCallback+0xa>
 8000966:	bf00      	nop
 8000968:	40010000 	.word	0x40010000

0800096c <Error_Handler>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800096c:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 800096e:	e7fe      	b.n	800096e <Error_Handler+0x2>

08000970 <SystemClock_Config>:
{
 8000970:	b500      	push	{lr}
 8000972:	b09d      	sub	sp, #116	@ 0x74
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8000974:	224c      	movs	r2, #76	@ 0x4c
 8000976:	2100      	movs	r1, #0
 8000978:	a809      	add	r0, sp, #36	@ 0x24
 800097a:	f013 fc9d 	bl	80142b8 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800097e:	2220      	movs	r2, #32
 8000980:	2100      	movs	r1, #0
 8000982:	a801      	add	r0, sp, #4
 8000984:	f013 fc98 	bl	80142b8 <memset>
  HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
 8000988:	2002      	movs	r0, #2
 800098a:	f002 f941 	bl	8002c10 <HAL_PWREx_ConfigSupply>
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 800098e:	2300      	movs	r3, #0
 8000990:	9300      	str	r3, [sp, #0]
 8000992:	4b2a      	ldr	r3, [pc, #168]	@ (8000a3c <SystemClock_Config+0xcc>)
 8000994:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8000996:	f022 0201 	bic.w	r2, r2, #1
 800099a:	62da      	str	r2, [r3, #44]	@ 0x2c
 800099c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800099e:	f003 0301 	and.w	r3, r3, #1
 80009a2:	9300      	str	r3, [sp, #0]
 80009a4:	4b26      	ldr	r3, [pc, #152]	@ (8000a40 <SystemClock_Config+0xd0>)
 80009a6:	699a      	ldr	r2, [r3, #24]
 80009a8:	f442 4240 	orr.w	r2, r2, #49152	@ 0xc000
 80009ac:	619a      	str	r2, [r3, #24]
 80009ae:	699b      	ldr	r3, [r3, #24]
 80009b0:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
 80009b4:	9300      	str	r3, [sp, #0]
 80009b6:	9b00      	ldr	r3, [sp, #0]
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
 80009b8:	4b21      	ldr	r3, [pc, #132]	@ (8000a40 <SystemClock_Config+0xd0>)
 80009ba:	699b      	ldr	r3, [r3, #24]
 80009bc:	f413 5f00 	tst.w	r3, #8192	@ 0x2000
 80009c0:	d0fa      	beq.n	80009b8 <SystemClock_Config+0x48>
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_HSE;
 80009c2:	2321      	movs	r3, #33	@ 0x21
 80009c4:	9309      	str	r3, [sp, #36]	@ 0x24
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 80009c6:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 80009ca:	930a      	str	r3, [sp, #40]	@ 0x28
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
 80009cc:	2301      	movs	r3, #1
 80009ce:	930f      	str	r3, [sp, #60]	@ 0x3c
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80009d0:	2302      	movs	r3, #2
 80009d2:	9312      	str	r3, [sp, #72]	@ 0x48
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80009d4:	9313      	str	r3, [sp, #76]	@ 0x4c
  RCC_OscInitStruct.PLL.PLLM = 2;
 80009d6:	9314      	str	r3, [sp, #80]	@ 0x50
  RCC_OscInitStruct.PLL.PLLN = 80;
 80009d8:	2250      	movs	r2, #80	@ 0x50
 80009da:	9215      	str	r2, [sp, #84]	@ 0x54
  RCC_OscInitStruct.PLL.PLLP = 2;
 80009dc:	9316      	str	r3, [sp, #88]	@ 0x58
  RCC_OscInitStruct.PLL.PLLQ = 8;
 80009de:	2208      	movs	r2, #8
 80009e0:	9217      	str	r2, [sp, #92]	@ 0x5c
  RCC_OscInitStruct.PLL.PLLR = 2;
 80009e2:	9318      	str	r3, [sp, #96]	@ 0x60
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_3;
 80009e4:	230c      	movs	r3, #12
 80009e6:	9319      	str	r3, [sp, #100]	@ 0x64
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
 80009e8:	2300      	movs	r3, #0
 80009ea:	931a      	str	r3, [sp, #104]	@ 0x68
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
 80009ec:	931b      	str	r3, [sp, #108]	@ 0x6c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80009ee:	a809      	add	r0, sp, #36	@ 0x24
 80009f0:	f002 f944 	bl	8002c7c <HAL_RCC_OscConfig>
 80009f4:	b9e8      	cbnz	r0, 8000a32 <SystemClock_Config+0xc2>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80009f6:	233f      	movs	r3, #63	@ 0x3f
 80009f8:	9301      	str	r3, [sp, #4]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80009fa:	2303      	movs	r3, #3
 80009fc:	9302      	str	r3, [sp, #8]
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
 80009fe:	2300      	movs	r3, #0
 8000a00:	9303      	str	r3, [sp, #12]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
 8000a02:	2308      	movs	r3, #8
 8000a04:	9304      	str	r3, [sp, #16]
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
 8000a06:	2340      	movs	r3, #64	@ 0x40
 8000a08:	9305      	str	r3, [sp, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
 8000a0a:	9306      	str	r3, [sp, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
 8000a0c:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8000a10:	9207      	str	r2, [sp, #28]
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
 8000a12:	9308      	str	r3, [sp, #32]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 8000a14:	2102      	movs	r1, #2
 8000a16:	a801      	add	r0, sp, #4
 8000a18:	f002 ff36 	bl	8003888 <HAL_RCC_ClockConfig>
 8000a1c:	b958      	cbnz	r0, 8000a36 <SystemClock_Config+0xc6>
  HAL_RCC_MCOConfig(RCC_MCO1, RCC_MCO1SOURCE_PLL1QCLK, RCC_MCODIV_4);
 8000a1e:	f44f 1280 	mov.w	r2, #1048576	@ 0x100000
 8000a22:	f44f 0140 	mov.w	r1, #12582912	@ 0xc00000
 8000a26:	2000      	movs	r0, #0
 8000a28:	f002 fd64 	bl	80034f4 <HAL_RCC_MCOConfig>
}
 8000a2c:	b01d      	add	sp, #116	@ 0x74
 8000a2e:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 8000a32:	f7ff ff9b 	bl	800096c <Error_Handler>
    Error_Handler();
 8000a36:	f7ff ff99 	bl	800096c <Error_Handler>
 8000a3a:	bf00      	nop
 8000a3c:	58000400 	.word	0x58000400
 8000a40:	58024800 	.word	0x58024800

08000a44 <main>:
{
 8000a44:	b508      	push	{r3, lr}
  MPU_Config();
 8000a46:	f7ff ff17 	bl	8000878 <MPU_Config>
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
 8000a4a:	4b20      	ldr	r3, [pc, #128]	@ (8000acc <main+0x88>)
 8000a4c:	695b      	ldr	r3, [r3, #20]
 8000a4e:	f413 3f80 	tst.w	r3, #65536	@ 0x10000
 8000a52:	d127      	bne.n	8000aa4 <main+0x60>

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
 8000a54:	4b1d      	ldr	r3, [pc, #116]	@ (8000acc <main+0x88>)
 8000a56:	2200      	movs	r2, #0
 8000a58:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8000a5c:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
 8000a60:	f8d3 4080 	ldr.w	r4, [r3, #128]	@ 0x80

                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 8000a64:	f3c4 304e 	ubfx	r0, r4, #13, #15
 8000a68:	e000      	b.n	8000a6c <main+0x28>
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
    } while(sets-- != 0U);
 8000a6a:	4618      	mov	r0, r3
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8000a6c:	f3c4 02c9 	ubfx	r2, r4, #3, #10
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000a70:	f643 73e0 	movw	r3, #16352	@ 0x3fe0
 8000a74:	ea03 1340 	and.w	r3, r3, r0, lsl #5
 8000a78:	ea43 7382 	orr.w	r3, r3, r2, lsl #30
 8000a7c:	4913      	ldr	r1, [pc, #76]	@ (8000acc <main+0x88>)
 8000a7e:	f8c1 3260 	str.w	r3, [r1, #608]	@ 0x260
      } while (ways-- != 0U);
 8000a82:	4613      	mov	r3, r2
 8000a84:	3a01      	subs	r2, #1
 8000a86:	2b00      	cmp	r3, #0
 8000a88:	d1f2      	bne.n	8000a70 <main+0x2c>
    } while(sets-- != 0U);
 8000a8a:	1e43      	subs	r3, r0, #1
 8000a8c:	2800      	cmp	r0, #0
 8000a8e:	d1ec      	bne.n	8000a6a <main+0x26>
 8000a90:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 8000a94:	694b      	ldr	r3, [r1, #20]
 8000a96:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8000a9a:	614b      	str	r3, [r1, #20]
 8000a9c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8000aa0:	f3bf 8f6f 	isb	sy
  HAL_Init();
 8000aa4:	f000 fc6e 	bl	8001384 <HAL_Init>
  SystemClock_Config();
 8000aa8:	f7ff ff62 	bl	8000970 <SystemClock_Config>
  MX_GPIO_Init();
 8000aac:	f7ff fe70 	bl	8000790 <MX_GPIO_Init>
  MX_SPI3_Init();
 8000ab0:	f000 f850 	bl	8000b54 <MX_SPI3_Init>
  MX_USART3_UART_Init();
 8000ab4:	f000 fad4 	bl	8001060 <MX_USART3_UART_Init>
  MX_RNG_Init();
 8000ab8:	f000 f80e 	bl	8000ad8 <MX_RNG_Init>
  printf("Firmware start\n");
 8000abc:	4804      	ldr	r0, [pc, #16]	@ (8000ad0 <main+0x8c>)
 8000abe:	f013 facf 	bl	8014060 <puts>
  MX_FREERTOS_Init();
 8000ac2:	f7ff fe49 	bl	8000758 <MX_FREERTOS_Init>
  osKernelStart();
 8000ac6:	f006 f8dd 	bl	8006c84 <osKernelStart>
  while (1)
 8000aca:	e7fe      	b.n	8000aca <main+0x86>
 8000acc:	e000ed00 	.word	0xe000ed00
 8000ad0:	08015318 	.word	0x08015318

08000ad4 <assert_failed>:
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
 8000ad4:	4770      	bx	lr
	...

08000ad8 <MX_RNG_Init>:

RNG_HandleTypeDef hrng;

/* RNG init function */
void MX_RNG_Init(void)
{
 8000ad8:	b508      	push	{r3, lr}
  /* USER CODE END RNG_Init 0 */

  /* USER CODE BEGIN RNG_Init 1 */

  /* USER CODE END RNG_Init 1 */
  hrng.Instance = RNG;
 8000ada:	4806      	ldr	r0, [pc, #24]	@ (8000af4 <MX_RNG_Init+0x1c>)
 8000adc:	4b06      	ldr	r3, [pc, #24]	@ (8000af8 <MX_RNG_Init+0x20>)
 8000ade:	6003      	str	r3, [r0, #0]
  hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
 8000ae0:	2300      	movs	r3, #0
 8000ae2:	6043      	str	r3, [r0, #4]
  if (HAL_RNG_Init(&hrng) != HAL_OK)
 8000ae4:	f004 fc52 	bl	800538c <HAL_RNG_Init>
 8000ae8:	b900      	cbnz	r0, 8000aec <MX_RNG_Init+0x14>
  }
  /* USER CODE BEGIN RNG_Init 2 */

  /* USER CODE END RNG_Init 2 */

}
 8000aea:	bd08      	pop	{r3, pc}
    Error_Handler();
 8000aec:	f7ff ff3e 	bl	800096c <Error_Handler>
}
 8000af0:	e7fb      	b.n	8000aea <MX_RNG_Init+0x12>
 8000af2:	bf00      	nop
 8000af4:	24003584 	.word	0x24003584
 8000af8:	48021800 	.word	0x48021800

08000afc <HAL_RNG_MspInit>:

void HAL_RNG_MspInit(RNG_HandleTypeDef* rngHandle)
{
 8000afc:	b510      	push	{r4, lr}
 8000afe:	b0b2      	sub	sp, #200	@ 0xc8
 8000b00:	4604      	mov	r4, r0

  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8000b02:	22c0      	movs	r2, #192	@ 0xc0
 8000b04:	2100      	movs	r1, #0
 8000b06:	a802      	add	r0, sp, #8
 8000b08:	f013 fbd6 	bl	80142b8 <memset>
  if(rngHandle->Instance==RNG)
 8000b0c:	6822      	ldr	r2, [r4, #0]
 8000b0e:	4b0f      	ldr	r3, [pc, #60]	@ (8000b4c <HAL_RNG_MspInit+0x50>)
 8000b10:	429a      	cmp	r2, r3
 8000b12:	d001      	beq.n	8000b18 <HAL_RNG_MspInit+0x1c>
    __HAL_RCC_RNG_CLK_ENABLE();
  /* USER CODE BEGIN RNG_MspInit 1 */

  /* USER CODE END RNG_MspInit 1 */
  }
}
 8000b14:	b032      	add	sp, #200	@ 0xc8
 8000b16:	bd10      	pop	{r4, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RNG;
 8000b18:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
 8000b1c:	2300      	movs	r3, #0
 8000b1e:	e9cd 2302 	strd	r2, r3, [sp, #8]
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8000b22:	a802      	add	r0, sp, #8
 8000b24:	f003 fb24 	bl	8004170 <HAL_RCCEx_PeriphCLKConfig>
 8000b28:	b968      	cbnz	r0, 8000b46 <HAL_RNG_MspInit+0x4a>
    __HAL_RCC_RNG_CLK_ENABLE();
 8000b2a:	4b09      	ldr	r3, [pc, #36]	@ (8000b50 <HAL_RNG_MspInit+0x54>)
 8000b2c:	f8d3 20dc 	ldr.w	r2, [r3, #220]	@ 0xdc
 8000b30:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8000b34:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
 8000b38:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 8000b3c:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8000b40:	9301      	str	r3, [sp, #4]
 8000b42:	9b01      	ldr	r3, [sp, #4]
}
 8000b44:	e7e6      	b.n	8000b14 <HAL_RNG_MspInit+0x18>
      Error_Handler();
 8000b46:	f7ff ff11 	bl	800096c <Error_Handler>
 8000b4a:	e7ee      	b.n	8000b2a <HAL_RNG_MspInit+0x2e>
 8000b4c:	48021800 	.word	0x48021800
 8000b50:	58024400 	.word	0x58024400

08000b54 <MX_SPI3_Init>:

SPI_HandleTypeDef hspi3;

/* SPI3 init function */
void MX_SPI3_Init(void)
{
 8000b54:	b508      	push	{r3, lr}
  /* USER CODE END SPI3_Init 0 */

  /* USER CODE BEGIN SPI3_Init 1 */

  /* USER CODE END SPI3_Init 1 */
  hspi3.Instance = SPI3;
 8000b56:	4813      	ldr	r0, [pc, #76]	@ (8000ba4 <MX_SPI3_Init+0x50>)
 8000b58:	4b13      	ldr	r3, [pc, #76]	@ (8000ba8 <MX_SPI3_Init+0x54>)
 8000b5a:	6003      	str	r3, [r0, #0]
  hspi3.Init.Mode = SPI_MODE_MASTER;
 8000b5c:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
 8000b60:	6043      	str	r3, [r0, #4]
  hspi3.Init.Direction = SPI_DIRECTION_2LINES;
 8000b62:	2300      	movs	r3, #0
 8000b64:	6083      	str	r3, [r0, #8]
  hspi3.Init.DataSize = SPI_DATASIZE_4BIT;
 8000b66:	2203      	movs	r2, #3
 8000b68:	60c2      	str	r2, [r0, #12]
  hspi3.Init.CLKPolarity = SPI_POLARITY_LOW;
 8000b6a:	6103      	str	r3, [r0, #16]
  hspi3.Init.CLKPhase = SPI_PHASE_1EDGE;
 8000b6c:	6143      	str	r3, [r0, #20]
  hspi3.Init.NSS = SPI_NSS_HARD_OUTPUT;
 8000b6e:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
 8000b72:	6182      	str	r2, [r0, #24]
  hspi3.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 8000b74:	61c3      	str	r3, [r0, #28]
  hspi3.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8000b76:	6203      	str	r3, [r0, #32]
  hspi3.Init.TIMode = SPI_TIMODE_DISABLE;
 8000b78:	6243      	str	r3, [r0, #36]	@ 0x24
  hspi3.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8000b7a:	6283      	str	r3, [r0, #40]	@ 0x28
  hspi3.Init.CRCPolynomial = 0x0;
 8000b7c:	62c3      	str	r3, [r0, #44]	@ 0x2c
  hspi3.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 8000b7e:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 8000b82:	6342      	str	r2, [r0, #52]	@ 0x34
  hspi3.Init.NSSPolarity = SPI_NSS_POLARITY_LOW;
 8000b84:	6383      	str	r3, [r0, #56]	@ 0x38
  hspi3.Init.FifoThreshold = SPI_FIFO_THRESHOLD_01DATA;
 8000b86:	63c3      	str	r3, [r0, #60]	@ 0x3c
  hspi3.Init.TxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;
 8000b88:	6403      	str	r3, [r0, #64]	@ 0x40
  hspi3.Init.RxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;
 8000b8a:	6443      	str	r3, [r0, #68]	@ 0x44
  hspi3.Init.MasterSSIdleness = SPI_MASTER_SS_IDLENESS_00CYCLE;
 8000b8c:	6483      	str	r3, [r0, #72]	@ 0x48
  hspi3.Init.MasterInterDataIdleness = SPI_MASTER_INTERDATA_IDLENESS_00CYCLE;
 8000b8e:	64c3      	str	r3, [r0, #76]	@ 0x4c
  hspi3.Init.MasterReceiverAutoSusp = SPI_MASTER_RX_AUTOSUSP_DISABLE;
 8000b90:	6503      	str	r3, [r0, #80]	@ 0x50
  hspi3.Init.MasterKeepIOState = SPI_MASTER_KEEP_IO_STATE_DISABLE;
 8000b92:	6543      	str	r3, [r0, #84]	@ 0x54
  hspi3.Init.IOSwap = SPI_IO_SWAP_DISABLE;
 8000b94:	6583      	str	r3, [r0, #88]	@ 0x58
  if (HAL_SPI_Init(&hspi3) != HAL_OK)
 8000b96:	f004 fc59 	bl	800544c <HAL_SPI_Init>
 8000b9a:	b900      	cbnz	r0, 8000b9e <MX_SPI3_Init+0x4a>
  }
  /* USER CODE BEGIN SPI3_Init 2 */

  /* USER CODE END SPI3_Init 2 */

}
 8000b9c:	bd08      	pop	{r3, pc}
    Error_Handler();
 8000b9e:	f7ff fee5 	bl	800096c <Error_Handler>
}
 8000ba2:	e7fb      	b.n	8000b9c <MX_SPI3_Init+0x48>
 8000ba4:	24003598 	.word	0x24003598
 8000ba8:	40003c00 	.word	0x40003c00

08000bac <HAL_SPI_MspInit>:

void HAL_SPI_MspInit(SPI_HandleTypeDef* spiHandle)
{
 8000bac:	b570      	push	{r4, r5, r6, lr}
 8000bae:	b0ba      	sub	sp, #232	@ 0xe8
 8000bb0:	4604      	mov	r4, r0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000bb2:	2100      	movs	r1, #0
 8000bb4:	9135      	str	r1, [sp, #212]	@ 0xd4
 8000bb6:	9136      	str	r1, [sp, #216]	@ 0xd8
 8000bb8:	9137      	str	r1, [sp, #220]	@ 0xdc
 8000bba:	9138      	str	r1, [sp, #224]	@ 0xe0
 8000bbc:	9139      	str	r1, [sp, #228]	@ 0xe4
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8000bbe:	22c0      	movs	r2, #192	@ 0xc0
 8000bc0:	a804      	add	r0, sp, #16
 8000bc2:	f013 fb79 	bl	80142b8 <memset>
  if(spiHandle->Instance==SPI3)
 8000bc6:	6822      	ldr	r2, [r4, #0]
 8000bc8:	4b27      	ldr	r3, [pc, #156]	@ (8000c68 <HAL_SPI_MspInit+0xbc>)
 8000bca:	429a      	cmp	r2, r3
 8000bcc:	d001      	beq.n	8000bd2 <HAL_SPI_MspInit+0x26>

  /* USER CODE BEGIN SPI3_MspInit 1 */

  /* USER CODE END SPI3_MspInit 1 */
  }
}
 8000bce:	b03a      	add	sp, #232	@ 0xe8
 8000bd0:	bd70      	pop	{r4, r5, r6, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SPI3;
 8000bd2:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 8000bd6:	2300      	movs	r3, #0
 8000bd8:	e9cd 2304 	strd	r2, r3, [sp, #16]
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8000bdc:	a804      	add	r0, sp, #16
 8000bde:	f003 fac7 	bl	8004170 <HAL_RCCEx_PeriphCLKConfig>
 8000be2:	2800      	cmp	r0, #0
 8000be4:	d13d      	bne.n	8000c62 <HAL_SPI_MspInit+0xb6>
    __HAL_RCC_SPI3_CLK_ENABLE();
 8000be6:	4b21      	ldr	r3, [pc, #132]	@ (8000c6c <HAL_SPI_MspInit+0xc0>)
 8000be8:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
 8000bec:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 8000bf0:	f8c3 20e8 	str.w	r2, [r3, #232]	@ 0xe8
 8000bf4:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
 8000bf8:	f402 4200 	and.w	r2, r2, #32768	@ 0x8000
 8000bfc:	9201      	str	r2, [sp, #4]
 8000bfe:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000c00:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 8000c04:	f042 0201 	orr.w	r2, r2, #1
 8000c08:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
 8000c0c:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 8000c10:	f002 0201 	and.w	r2, r2, #1
 8000c14:	9202      	str	r2, [sp, #8]
 8000c16:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8000c18:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 8000c1c:	f042 0204 	orr.w	r2, r2, #4
 8000c20:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
 8000c24:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8000c28:	f003 0304 	and.w	r3, r3, #4
 8000c2c:	9303      	str	r3, [sp, #12]
 8000c2e:	9b03      	ldr	r3, [sp, #12]
    GPIO_InitStruct.Pin = GPIO_PIN_4;
 8000c30:	2310      	movs	r3, #16
 8000c32:	9335      	str	r3, [sp, #212]	@ 0xd4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000c34:	2602      	movs	r6, #2
 8000c36:	9636      	str	r6, [sp, #216]	@ 0xd8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000c38:	2400      	movs	r4, #0
 8000c3a:	9437      	str	r4, [sp, #220]	@ 0xdc
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000c3c:	9438      	str	r4, [sp, #224]	@ 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
 8000c3e:	2506      	movs	r5, #6
 8000c40:	9539      	str	r5, [sp, #228]	@ 0xe4
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000c42:	a935      	add	r1, sp, #212	@ 0xd4
 8000c44:	480a      	ldr	r0, [pc, #40]	@ (8000c70 <HAL_SPI_MspInit+0xc4>)
 8000c46:	f001 fdfd 	bl	8002844 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12;
 8000c4a:	f44f 53e0 	mov.w	r3, #7168	@ 0x1c00
 8000c4e:	9335      	str	r3, [sp, #212]	@ 0xd4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000c50:	9636      	str	r6, [sp, #216]	@ 0xd8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000c52:	9437      	str	r4, [sp, #220]	@ 0xdc
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000c54:	9438      	str	r4, [sp, #224]	@ 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
 8000c56:	9539      	str	r5, [sp, #228]	@ 0xe4
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000c58:	a935      	add	r1, sp, #212	@ 0xd4
 8000c5a:	4806      	ldr	r0, [pc, #24]	@ (8000c74 <HAL_SPI_MspInit+0xc8>)
 8000c5c:	f001 fdf2 	bl	8002844 <HAL_GPIO_Init>
}
 8000c60:	e7b5      	b.n	8000bce <HAL_SPI_MspInit+0x22>
      Error_Handler();
 8000c62:	f7ff fe83 	bl	800096c <Error_Handler>
 8000c66:	e7be      	b.n	8000be6 <HAL_SPI_MspInit+0x3a>
 8000c68:	40003c00 	.word	0x40003c00
 8000c6c:	58024400 	.word	0x58024400
 8000c70:	58020000 	.word	0x58020000
 8000c74:	58020800 	.word	0x58020800

08000c78 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8000c78:	b500      	push	{lr}
 8000c7a:	b083      	sub	sp, #12
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000c7c:	4b0a      	ldr	r3, [pc, #40]	@ (8000ca8 <HAL_MspInit+0x30>)
 8000c7e:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
 8000c82:	f042 0202 	orr.w	r2, r2, #2
 8000c86:	f8c3 20f4 	str.w	r2, [r3, #244]	@ 0xf4
 8000c8a:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8000c8e:	f003 0302 	and.w	r3, r3, #2
 8000c92:	9301      	str	r3, [sp, #4]
 8000c94:	9b01      	ldr	r3, [sp, #4]

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 8000c96:	2200      	movs	r2, #0
 8000c98:	210f      	movs	r1, #15
 8000c9a:	f06f 0001 	mvn.w	r0, #1
 8000c9e:	f000 fc41 	bl	8001524 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8000ca2:	b003      	add	sp, #12
 8000ca4:	f85d fb04 	ldr.w	pc, [sp], #4
 8000ca8:	58024400 	.word	0x58024400

08000cac <HAL_InitTick>:
  uint32_t              uwTimclock;

  uint32_t              uwPrescalerValue;
  uint32_t              pFLatency;
/*Configure the TIM1 IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8000cac:	280f      	cmp	r0, #15
 8000cae:	d901      	bls.n	8000cb4 <HAL_InitTick+0x8>
  HAL_NVIC_EnableIRQ(TIM1_UP_IRQn);
    uwTickPrio = TickPriority;
    }
  else
  {
    return HAL_ERROR;
 8000cb0:	2001      	movs	r0, #1
    return HAL_TIM_Base_Start_IT(&htim1);
  }

  /* Return function status */
  return HAL_ERROR;
}
 8000cb2:	4770      	bx	lr
{
 8000cb4:	b510      	push	{r4, lr}
 8000cb6:	b08a      	sub	sp, #40	@ 0x28
 8000cb8:	4604      	mov	r4, r0
  HAL_NVIC_SetPriority(TIM1_UP_IRQn, TickPriority ,0U);
 8000cba:	2200      	movs	r2, #0
 8000cbc:	4601      	mov	r1, r0
 8000cbe:	2019      	movs	r0, #25
 8000cc0:	f000 fc30 	bl	8001524 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TIM1_UP_IRQn);
 8000cc4:	2019      	movs	r0, #25
 8000cc6:	f000 fc51 	bl	800156c <HAL_NVIC_EnableIRQ>
    uwTickPrio = TickPriority;
 8000cca:	4b17      	ldr	r3, [pc, #92]	@ (8000d28 <HAL_InitTick+0x7c>)
 8000ccc:	601c      	str	r4, [r3, #0]
  __HAL_RCC_TIM1_CLK_ENABLE();
 8000cce:	4b17      	ldr	r3, [pc, #92]	@ (8000d2c <HAL_InitTick+0x80>)
 8000cd0:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
 8000cd4:	f042 0201 	orr.w	r2, r2, #1
 8000cd8:	f8c3 20f0 	str.w	r2, [r3, #240]	@ 0xf0
 8000cdc:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8000ce0:	f003 0301 	and.w	r3, r3, #1
 8000ce4:	9300      	str	r3, [sp, #0]
 8000ce6:	9b00      	ldr	r3, [sp, #0]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8000ce8:	a901      	add	r1, sp, #4
 8000cea:	a802      	add	r0, sp, #8
 8000cec:	f003 f856 	bl	8003d9c <HAL_RCC_GetClockConfig>
      uwTimclock = 2*HAL_RCC_GetPCLK2Freq();
 8000cf0:	f003 f842 	bl	8003d78 <HAL_RCC_GetPCLK2Freq>
 8000cf4:	0043      	lsls	r3, r0, #1
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8000cf6:	4a0e      	ldr	r2, [pc, #56]	@ (8000d30 <HAL_InitTick+0x84>)
 8000cf8:	fba2 2303 	umull	r2, r3, r2, r3
 8000cfc:	0c9b      	lsrs	r3, r3, #18
 8000cfe:	3b01      	subs	r3, #1
  htim1.Instance = TIM1;
 8000d00:	480c      	ldr	r0, [pc, #48]	@ (8000d34 <HAL_InitTick+0x88>)
 8000d02:	4a0d      	ldr	r2, [pc, #52]	@ (8000d38 <HAL_InitTick+0x8c>)
 8000d04:	6002      	str	r2, [r0, #0]
  htim1.Init.Period = (1000000U / 1000U) - 1U;
 8000d06:	f240 32e7 	movw	r2, #999	@ 0x3e7
 8000d0a:	60c2      	str	r2, [r0, #12]
  htim1.Init.Prescaler = uwPrescalerValue;
 8000d0c:	6043      	str	r3, [r0, #4]
  htim1.Init.ClockDivision = 0;
 8000d0e:	2300      	movs	r3, #0
 8000d10:	6103      	str	r3, [r0, #16]
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 8000d12:	6083      	str	r3, [r0, #8]
  if(HAL_TIM_Base_Init(&htim1) == HAL_OK)
 8000d14:	f004 ff2c 	bl	8005b70 <HAL_TIM_Base_Init>
 8000d18:	b110      	cbz	r0, 8000d20 <HAL_InitTick+0x74>
  return HAL_ERROR;
 8000d1a:	2001      	movs	r0, #1
}
 8000d1c:	b00a      	add	sp, #40	@ 0x28
 8000d1e:	bd10      	pop	{r4, pc}
    return HAL_TIM_Base_Start_IT(&htim1);
 8000d20:	4804      	ldr	r0, [pc, #16]	@ (8000d34 <HAL_InitTick+0x88>)
 8000d22:	f004 fd49 	bl	80057b8 <HAL_TIM_Base_Start_IT>
 8000d26:	e7f9      	b.n	8000d1c <HAL_InitTick+0x70>
 8000d28:	2400000c 	.word	0x2400000c
 8000d2c:	58024400 	.word	0x58024400
 8000d30:	431bde83 	.word	0x431bde83
 8000d34:	24003620 	.word	0x24003620
 8000d38:	40010000 	.word	0x40010000

08000d3c <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 8000d3c:	e7fe      	b.n	8000d3c <NMI_Handler>

08000d3e <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8000d3e:	e7fe      	b.n	8000d3e <HardFault_Handler>

08000d40 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8000d40:	e7fe      	b.n	8000d40 <MemManage_Handler>

08000d42 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8000d42:	e7fe      	b.n	8000d42 <BusFault_Handler>

08000d44 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8000d44:	e7fe      	b.n	8000d44 <UsageFault_Handler>

08000d46 <DebugMon_Handler>:

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8000d46:	4770      	bx	lr

08000d48 <TIM1_UP_IRQHandler>:

/**
  * @brief This function handles TIM1 update interrupt.
  */
void TIM1_UP_IRQHandler(void)
{
 8000d48:	b508      	push	{r3, lr}
  /* USER CODE BEGIN TIM1_UP_IRQn 0 */

  /* USER CODE END TIM1_UP_IRQn 0 */
  HAL_TIM_IRQHandler(&htim1);
 8000d4a:	4802      	ldr	r0, [pc, #8]	@ (8000d54 <TIM1_UP_IRQHandler+0xc>)
 8000d4c:	f004 fdc0 	bl	80058d0 <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM1_UP_IRQn 1 */

  /* USER CODE END TIM1_UP_IRQn 1 */
}
 8000d50:	bd08      	pop	{r3, pc}
 8000d52:	bf00      	nop
 8000d54:	24003620 	.word	0x24003620

08000d58 <ETH_IRQHandler>:

/**
  * @brief This function handles Ethernet global interrupt.
  */
void ETH_IRQHandler(void)
{
 8000d58:	b508      	push	{r3, lr}
  /* USER CODE BEGIN ETH_IRQn 0 */

  /* USER CODE END ETH_IRQn 0 */
  HAL_ETH_IRQHandler(&heth);
 8000d5a:	4802      	ldr	r0, [pc, #8]	@ (8000d64 <ETH_IRQHandler+0xc>)
 8000d5c:	f001 f9f3 	bl	8002146 <HAL_ETH_IRQHandler>
  /* USER CODE BEGIN ETH_IRQn 1 */

  /* USER CODE END ETH_IRQn 1 */
}
 8000d60:	bd08      	pop	{r3, pc}
 8000d62:	bf00      	nop
 8000d64:	240144a0 	.word	0x240144a0

08000d68 <_getpid>:
}

int _getpid(void)
{
  return 1;
}
 8000d68:	2001      	movs	r0, #1
 8000d6a:	4770      	bx	lr

08000d6c <_kill>:

int _kill(int pid, int sig)
{
 8000d6c:	b508      	push	{r3, lr}
  (void)pid;
  (void)sig;
  errno = EINVAL;
 8000d6e:	f013 fb13 	bl	8014398 <__errno>
 8000d72:	2316      	movs	r3, #22
 8000d74:	6003      	str	r3, [r0, #0]
  return -1;
}
 8000d76:	f04f 30ff 	mov.w	r0, #4294967295
 8000d7a:	bd08      	pop	{r3, pc}

08000d7c <_exit>:

void _exit (int status)
{
 8000d7c:	b508      	push	{r3, lr}
  _kill(status, -1);
 8000d7e:	f04f 31ff 	mov.w	r1, #4294967295
 8000d82:	f7ff fff3 	bl	8000d6c <_kill>
  while (1) {}    /* Make sure we hang here */
 8000d86:	e7fe      	b.n	8000d86 <_exit+0xa>

08000d88 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8000d88:	b570      	push	{r4, r5, r6, lr}
 8000d8a:	460c      	mov	r4, r1
 8000d8c:	4616      	mov	r6, r2
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8000d8e:	2500      	movs	r5, #0
 8000d90:	e006      	b.n	8000da0 <_read+0x18>
  {
    *ptr++ = __io_getchar();
 8000d92:	f3af 8000 	nop.w
 8000d96:	4621      	mov	r1, r4
 8000d98:	f801 0b01 	strb.w	r0, [r1], #1
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8000d9c:	3501      	adds	r5, #1
    *ptr++ = __io_getchar();
 8000d9e:	460c      	mov	r4, r1
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8000da0:	42b5      	cmp	r5, r6
 8000da2:	dbf6      	blt.n	8000d92 <_read+0xa>
  }

  return len;
}
 8000da4:	4630      	mov	r0, r6
 8000da6:	bd70      	pop	{r4, r5, r6, pc}

08000da8 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 8000da8:	b570      	push	{r4, r5, r6, lr}
 8000daa:	460c      	mov	r4, r1
 8000dac:	4616      	mov	r6, r2
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8000dae:	2500      	movs	r5, #0
 8000db0:	e004      	b.n	8000dbc <_write+0x14>
  {
    __io_putchar(*ptr++);
 8000db2:	f814 0b01 	ldrb.w	r0, [r4], #1
 8000db6:	f7ff fdbd 	bl	8000934 <__io_putchar>
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8000dba:	3501      	adds	r5, #1
 8000dbc:	42b5      	cmp	r5, r6
 8000dbe:	dbf8      	blt.n	8000db2 <_write+0xa>
  }
  return len;
}
 8000dc0:	4630      	mov	r0, r6
 8000dc2:	bd70      	pop	{r4, r5, r6, pc}

08000dc4 <_close>:

int _close(int file)
{
  (void)file;
  return -1;
}
 8000dc4:	f04f 30ff 	mov.w	r0, #4294967295
 8000dc8:	4770      	bx	lr

08000dca <_fstat>:


int _fstat(int file, struct stat *st)
{
  (void)file;
  st->st_mode = S_IFCHR;
 8000dca:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 8000dce:	604b      	str	r3, [r1, #4]
  return 0;
}
 8000dd0:	2000      	movs	r0, #0
 8000dd2:	4770      	bx	lr

08000dd4 <_isatty>:

int _isatty(int file)
{
  (void)file;
  return 1;
}
 8000dd4:	2001      	movs	r0, #1
 8000dd6:	4770      	bx	lr

08000dd8 <_lseek>:
{
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
}
 8000dd8:	2000      	movs	r0, #0
 8000dda:	4770      	bx	lr

08000ddc <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 8000ddc:	b510      	push	{r4, lr}
 8000dde:	4603      	mov	r3, r0
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8000de0:	4a0c      	ldr	r2, [pc, #48]	@ (8000e14 <_sbrk+0x38>)
 8000de2:	490d      	ldr	r1, [pc, #52]	@ (8000e18 <_sbrk+0x3c>)
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8000de4:	480d      	ldr	r0, [pc, #52]	@ (8000e1c <_sbrk+0x40>)
 8000de6:	6800      	ldr	r0, [r0, #0]
 8000de8:	b140      	cbz	r0, 8000dfc <_sbrk+0x20>
  {
    __sbrk_heap_end = &_end;
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8000dea:	480c      	ldr	r0, [pc, #48]	@ (8000e1c <_sbrk+0x40>)
 8000dec:	6800      	ldr	r0, [r0, #0]
 8000dee:	4403      	add	r3, r0
 8000df0:	1a52      	subs	r2, r2, r1
 8000df2:	4293      	cmp	r3, r2
 8000df4:	d806      	bhi.n	8000e04 <_sbrk+0x28>
    errno = ENOMEM;
    return (void *)-1;
  }

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;
 8000df6:	4a09      	ldr	r2, [pc, #36]	@ (8000e1c <_sbrk+0x40>)
 8000df8:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
}
 8000dfa:	bd10      	pop	{r4, pc}
    __sbrk_heap_end = &_end;
 8000dfc:	4807      	ldr	r0, [pc, #28]	@ (8000e1c <_sbrk+0x40>)
 8000dfe:	4c08      	ldr	r4, [pc, #32]	@ (8000e20 <_sbrk+0x44>)
 8000e00:	6004      	str	r4, [r0, #0]
 8000e02:	e7f2      	b.n	8000dea <_sbrk+0xe>
    errno = ENOMEM;
 8000e04:	f013 fac8 	bl	8014398 <__errno>
 8000e08:	230c      	movs	r3, #12
 8000e0a:	6003      	str	r3, [r0, #0]
    return (void *)-1;
 8000e0c:	f04f 30ff 	mov.w	r0, #4294967295
 8000e10:	e7f3      	b.n	8000dfa <_sbrk+0x1e>
 8000e12:	bf00      	nop
 8000e14:	24080000 	.word	0x24080000
 8000e18:	00001000 	.word	0x00001000
 8000e1c:	2400366c 	.word	0x2400366c
 8000e20:	240146c0 	.word	0x240146c0

08000e24 <SystemInit>:
 __IO uint32_t tmpreg;
#endif /* DATA_IN_D2_SRAM */

  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 8000e24:	4a27      	ldr	r2, [pc, #156]	@ (8000ec4 <SystemInit+0xa0>)
 8000e26:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
 8000e2a:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 8000e2e:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/

   /* Increasing the CPU frequency */
  if(FLASH_LATENCY_DEFAULT  > (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
 8000e32:	4b25      	ldr	r3, [pc, #148]	@ (8000ec8 <SystemInit+0xa4>)
 8000e34:	681b      	ldr	r3, [r3, #0]
 8000e36:	f003 030f 	and.w	r3, r3, #15
 8000e3a:	2b06      	cmp	r3, #6
 8000e3c:	d806      	bhi.n	8000e4c <SystemInit+0x28>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
 8000e3e:	4a22      	ldr	r2, [pc, #136]	@ (8000ec8 <SystemInit+0xa4>)
 8000e40:	6813      	ldr	r3, [r2, #0]
 8000e42:	f023 030f 	bic.w	r3, r3, #15
 8000e46:	f043 0307 	orr.w	r3, r3, #7
 8000e4a:	6013      	str	r3, [r2, #0]
  }

  /* Set HSION bit */
  RCC->CR |= RCC_CR_HSION;
 8000e4c:	4b1f      	ldr	r3, [pc, #124]	@ (8000ecc <SystemInit+0xa8>)
 8000e4e:	681a      	ldr	r2, [r3, #0]
 8000e50:	f042 0201 	orr.w	r2, r2, #1
 8000e54:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8000e56:	2200      	movs	r2, #0
 8000e58:	611a      	str	r2, [r3, #16]

  /* Reset HSEON, HSECSSON, CSION, HSI48ON, CSIKERON, PLL1ON, PLL2ON and PLL3ON bits */
  RCC->CR &= 0xEAF6ED7FU;
 8000e5a:	6819      	ldr	r1, [r3, #0]
 8000e5c:	4a1c      	ldr	r2, [pc, #112]	@ (8000ed0 <SystemInit+0xac>)
 8000e5e:	400a      	ands	r2, r1
 8000e60:	601a      	str	r2, [r3, #0]

   /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLASH_LATENCY_DEFAULT  < (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
 8000e62:	4b19      	ldr	r3, [pc, #100]	@ (8000ec8 <SystemInit+0xa4>)
 8000e64:	681b      	ldr	r3, [r3, #0]
 8000e66:	f013 0f08 	tst.w	r3, #8
 8000e6a:	d006      	beq.n	8000e7a <SystemInit+0x56>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
 8000e6c:	4a16      	ldr	r2, [pc, #88]	@ (8000ec8 <SystemInit+0xa4>)
 8000e6e:	6813      	ldr	r3, [r2, #0]
 8000e70:	f023 030f 	bic.w	r3, r3, #15
 8000e74:	f043 0307 	orr.w	r3, r3, #7
 8000e78:	6013      	str	r3, [r2, #0]
  }

#if defined(D3_SRAM_BASE)
  /* Reset D1CFGR register */
  RCC->D1CFGR = 0x00000000;
 8000e7a:	4b14      	ldr	r3, [pc, #80]	@ (8000ecc <SystemInit+0xa8>)
 8000e7c:	2200      	movs	r2, #0
 8000e7e:	619a      	str	r2, [r3, #24]

  /* Reset D2CFGR register */
  RCC->D2CFGR = 0x00000000;
 8000e80:	61da      	str	r2, [r3, #28]

  /* Reset D3CFGR register */
  RCC->D3CFGR = 0x00000000;
 8000e82:	621a      	str	r2, [r3, #32]

  /* Reset SRDCFGR register */
  RCC->SRDCFGR = 0x00000000;
#endif
  /* Reset PLLCKSELR register */
  RCC->PLLCKSELR = 0x02020200;
 8000e84:	4913      	ldr	r1, [pc, #76]	@ (8000ed4 <SystemInit+0xb0>)
 8000e86:	6299      	str	r1, [r3, #40]	@ 0x28

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x01FF0000;
 8000e88:	4913      	ldr	r1, [pc, #76]	@ (8000ed8 <SystemInit+0xb4>)
 8000e8a:	62d9      	str	r1, [r3, #44]	@ 0x2c
  /* Reset PLL1DIVR register */
  RCC->PLL1DIVR = 0x01010280;
 8000e8c:	4913      	ldr	r1, [pc, #76]	@ (8000edc <SystemInit+0xb8>)
 8000e8e:	6319      	str	r1, [r3, #48]	@ 0x30
  /* Reset PLL1FRACR register */
  RCC->PLL1FRACR = 0x00000000;
 8000e90:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Reset PLL2DIVR register */
  RCC->PLL2DIVR = 0x01010280;
 8000e92:	6399      	str	r1, [r3, #56]	@ 0x38

  /* Reset PLL2FRACR register */

  RCC->PLL2FRACR = 0x00000000;
 8000e94:	63da      	str	r2, [r3, #60]	@ 0x3c
  /* Reset PLL3DIVR register */
  RCC->PLL3DIVR = 0x01010280;
 8000e96:	6419      	str	r1, [r3, #64]	@ 0x40

  /* Reset PLL3FRACR register */
  RCC->PLL3FRACR = 0x00000000;
 8000e98:	645a      	str	r2, [r3, #68]	@ 0x44

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 8000e9a:	6819      	ldr	r1, [r3, #0]
 8000e9c:	f421 2180 	bic.w	r1, r1, #262144	@ 0x40000
 8000ea0:	6019      	str	r1, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
 8000ea2:	661a      	str	r2, [r3, #96]	@ 0x60

#if (STM32H7_DEV_ID == 0x450UL)
  /* dual core CM7 or single core line */
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
 8000ea4:	4b0e      	ldr	r3, [pc, #56]	@ (8000ee0 <SystemInit+0xbc>)
 8000ea6:	681b      	ldr	r3, [r3, #0]
 8000ea8:	f36f 030f 	bfc	r3, #0, #16
 8000eac:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8000eb0:	d203      	bcs.n	8000eba <SystemInit+0x96>
  {
    /* if stm32h7 revY*/
    /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
    *((__IO uint32_t*)0x51008108) = 0x000000001U;
 8000eb2:	4b0c      	ldr	r3, [pc, #48]	@ (8000ee4 <SystemInit+0xc0>)
 8000eb4:	2201      	movs	r2, #1
 8000eb6:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
  /*
   * Disable the FMC bank1 (enabled after reset).
   * This, prevents CPU speculation access on this bank which blocks the use of FMC during
   * 24us. During this time the others FMC master (such as LTDC) cannot use it!
   */
  FMC_Bank1_R->BTCR[0] = 0x000030D2;
 8000eba:	4b0b      	ldr	r3, [pc, #44]	@ (8000ee8 <SystemInit+0xc4>)
 8000ebc:	f243 02d2 	movw	r2, #12498	@ 0x30d2
 8000ec0:	601a      	str	r2, [r3, #0]
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D1 AXI-RAM or in Internal FLASH */
#endif /* USER_VECT_TAB_ADDRESS */

#endif /*DUAL_CORE && CORE_CM4*/
}
 8000ec2:	4770      	bx	lr
 8000ec4:	e000ed00 	.word	0xe000ed00
 8000ec8:	52002000 	.word	0x52002000
 8000ecc:	58024400 	.word	0x58024400
 8000ed0:	eaf6ed7f 	.word	0xeaf6ed7f
 8000ed4:	02020200 	.word	0x02020200
 8000ed8:	01ff0000 	.word	0x01ff0000
 8000edc:	01010280 	.word	0x01010280
 8000ee0:	5c001000 	.word	0x5c001000
 8000ee4:	51008000 	.word	0x51008000
 8000ee8:	52004000 	.word	0x52004000

08000eec <send_udp>:
    }
    return upcb;
}

static void send_udp(struct udp_pcb *upcb, const ip_addr_t *addr, u16_t port)
{
 8000eec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000eee:	4604      	mov	r4, r0
 8000ef0:	460d      	mov	r5, r1
 8000ef2:	4616      	mov	r6, r2
    struct pbuf *p;


    p = pbuf_alloc(PBUF_TRANSPORT, strlen(searchReply_str), PBUF_RAM);
 8000ef4:	f44f 7220 	mov.w	r2, #640	@ 0x280
 8000ef8:	21de      	movs	r1, #222	@ 0xde
 8000efa:	2036      	movs	r0, #54	@ 0x36
 8000efc:	f00a fe80 	bl	800bc00 <pbuf_alloc>

    if (!p) {
 8000f00:	b1a8      	cbz	r0, 8000f2e <send_udp+0x42>
 8000f02:	4607      	mov	r7, r0
        printf("Failed to allocate transport buffer\n");
    } else {
        memcpy(p->payload, searchReply_str, strlen(searchReply_str));
 8000f04:	22de      	movs	r2, #222	@ 0xde
 8000f06:	4910      	ldr	r1, [pc, #64]	@ (8000f48 <send_udp+0x5c>)
 8000f08:	6840      	ldr	r0, [r0, #4]
 8000f0a:	f013 fa7a 	bl	8014402 <memcpy>
        err_t err = udp_sendto(upcb, p, addr, port);
 8000f0e:	4633      	mov	r3, r6
 8000f10:	462a      	mov	r2, r5
 8000f12:	4639      	mov	r1, r7
 8000f14:	4620      	mov	r0, r4
 8000f16:	f00f fe57 	bl	8010bc8 <udp_sendto>
        if (err < 0) {
 8000f1a:	1e04      	subs	r4, r0, #0
 8000f1c:	db0b      	blt.n	8000f36 <send_udp+0x4a>
            printf("Error sending message: %s (%d)\n", lwip_strerr(err), err);
        } else {
            printf("Sent message '%s'\n", searchReply_str);
 8000f1e:	490a      	ldr	r1, [pc, #40]	@ (8000f48 <send_udp+0x5c>)
 8000f20:	480a      	ldr	r0, [pc, #40]	@ (8000f4c <send_udp+0x60>)
 8000f22:	f013 f82d 	bl	8013f80 <iprintf>
        }
        pbuf_free(p);
 8000f26:	4638      	mov	r0, r7
 8000f28:	f00a fe02 	bl	800bb30 <pbuf_free>
    }
}
 8000f2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        printf("Failed to allocate transport buffer\n");
 8000f2e:	4808      	ldr	r0, [pc, #32]	@ (8000f50 <send_udp+0x64>)
 8000f30:	f013 f896 	bl	8014060 <puts>
 8000f34:	e7fa      	b.n	8000f2c <send_udp+0x40>
            printf("Error sending message: %s (%d)\n", lwip_strerr(err), err);
 8000f36:	4620      	mov	r0, r4
 8000f38:	f009 fc6c 	bl	800a814 <lwip_strerr>
 8000f3c:	4601      	mov	r1, r0
 8000f3e:	4622      	mov	r2, r4
 8000f40:	4804      	ldr	r0, [pc, #16]	@ (8000f54 <send_udp+0x68>)
 8000f42:	f013 f81d 	bl	8013f80 <iprintf>
 8000f46:	e7ee      	b.n	8000f26 <send_udp+0x3a>
 8000f48:	08018cd4 	.word	0x08018cd4
 8000f4c:	0801536c 	.word	0x0801536c
 8000f50:	08015328 	.word	0x08015328
 8000f54:	0801534c 	.word	0x0801534c

08000f58 <receive_callback>:
  * @param addr the remote IP address from which the packet was received
  * @param port the remote port from which the packet was received
  * @retval None
  */
static void receive_callback(void *arg, struct udp_pcb *upcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
{
 8000f58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000f5a:	f8bd 7018 	ldrh.w	r7, [sp, #24]
    if (p) {
 8000f5e:	b1aa      	cbz	r2, 8000f8c <receive_callback+0x34>
 8000f60:	460c      	mov	r4, r1
 8000f62:	461d      	mov	r5, r3
 8000f64:	4616      	mov	r6, r2
        printf("Msg received port:%d len:%d\n", port, p->len);
 8000f66:	8952      	ldrh	r2, [r2, #10]
 8000f68:	4639      	mov	r1, r7
 8000f6a:	4809      	ldr	r0, [pc, #36]	@ (8000f90 <receive_callback+0x38>)
 8000f6c:	f013 f808 	bl	8013f80 <iprintf>
        uint8_t *buf = (uint8_t*) p->payload;
        printf("Msg received port:%d len:%d\nbuf: %s\n", port, p->len, buf);
 8000f70:	6873      	ldr	r3, [r6, #4]
 8000f72:	8972      	ldrh	r2, [r6, #10]
 8000f74:	4639      	mov	r1, r7
 8000f76:	4807      	ldr	r0, [pc, #28]	@ (8000f94 <receive_callback+0x3c>)
 8000f78:	f013 f802 	bl	8013f80 <iprintf>

        send_udp(upcb, addr, port);
 8000f7c:	463a      	mov	r2, r7
 8000f7e:	4629      	mov	r1, r5
 8000f80:	4620      	mov	r0, r4
 8000f82:	f7ff ffb3 	bl	8000eec <send_udp>

        pbuf_free(p);
 8000f86:	4630      	mov	r0, r6
 8000f88:	f00a fdd2 	bl	800bb30 <pbuf_free>
    }
}
 8000f8c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000f8e:	bf00      	nop
 8000f90:	08015380 	.word	0x08015380
 8000f94:	080153a0 	.word	0x080153a0

08000f98 <mcast_join_group>:
{
 8000f98:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000f9a:	b083      	sub	sp, #12
 8000f9c:	4606      	mov	r6, r0
 8000f9e:	460d      	mov	r5, r1
 8000fa0:	4617      	mov	r7, r2
    printf("Joining mcast group %s:%d\n", group_ip, group_port);
 8000fa2:	460a      	mov	r2, r1
 8000fa4:	4601      	mov	r1, r0
 8000fa6:	4820      	ldr	r0, [pc, #128]	@ (8001028 <mcast_join_group+0x90>)
 8000fa8:	f012 ffea 	bl	8013f80 <iprintf>
        upcb = udp_new();
 8000fac:	f00f fece 	bl	8010d4c <udp_new>
        if (!upcb) {
 8000fb0:	4604      	mov	r4, r0
 8000fb2:	b1d0      	cbz	r0, 8000fea <mcast_join_group+0x52>
        udp_bind(upcb, IP4_ADDR_ANY, group_port);
 8000fb4:	462a      	mov	r2, r5
 8000fb6:	491d      	ldr	r1, [pc, #116]	@ (800102c <mcast_join_group+0x94>)
 8000fb8:	f00f fc0c 	bl	80107d4 <udp_bind>
        struct netif* netif = system_get_netif();
 8000fbc:	f7ff fbe4 	bl	8000788 <system_get_netif>
        if (!netif) {
 8000fc0:	4605      	mov	r5, r0
 8000fc2:	b1e8      	cbz	r0, 8001000 <mcast_join_group+0x68>
        if (!(netif->flags & NETIF_FLAG_IGMP)) {
 8000fc4:	f890 302d 	ldrb.w	r3, [r0, #45]	@ 0x2d
 8000fc8:	f013 0f20 	tst.w	r3, #32
 8000fcc:	d01c      	beq.n	8001008 <mcast_join_group+0x70>
        ip4addr_aton(group_ip, &ipgroup);
 8000fce:	a901      	add	r1, sp, #4
 8000fd0:	4630      	mov	r0, r6
 8000fd2:	f011 fba7 	bl	8012724 <ip4addr_aton>
        err_t err = igmp_joingroup_netif(netif, &ipgroup);
 8000fd6:	a901      	add	r1, sp, #4
 8000fd8:	4628      	mov	r0, r5
 8000fda:	f011 f875 	bl	80120c8 <igmp_joingroup_netif>
        if (ERR_OK != err) {
 8000fde:	4601      	mov	r1, r0
 8000fe0:	b1c8      	cbz	r0, 8001016 <mcast_join_group+0x7e>
            printf("Failed to join multicast group: %d", err);
 8000fe2:	4813      	ldr	r0, [pc, #76]	@ (8001030 <mcast_join_group+0x98>)
 8000fe4:	f012 ffcc 	bl	8013f80 <iprintf>
            break;
 8000fe8:	e002      	b.n	8000ff0 <mcast_join_group+0x58>
            printf("Error, udp_new failed");
 8000fea:	4812      	ldr	r0, [pc, #72]	@ (8001034 <mcast_join_group+0x9c>)
 8000fec:	f012 ffc8 	bl	8013f80 <iprintf>
        if (upcb) {
 8000ff0:	b11c      	cbz	r4, 8000ffa <mcast_join_group+0x62>
            udp_remove(upcb);
 8000ff2:	4620      	mov	r0, r4
 8000ff4:	f00f fe80 	bl	8010cf8 <udp_remove>
        upcb = NULL;
 8000ff8:	2400      	movs	r4, #0
}
 8000ffa:	4620      	mov	r0, r4
 8000ffc:	b003      	add	sp, #12
 8000ffe:	bdf0      	pop	{r4, r5, r6, r7, pc}
            printf("Error, netif is null");
 8001000:	480d      	ldr	r0, [pc, #52]	@ (8001038 <mcast_join_group+0xa0>)
 8001002:	f012 ffbd 	bl	8013f80 <iprintf>
            break;
 8001006:	e7f3      	b.n	8000ff0 <mcast_join_group+0x58>
            netif->flags |= NETIF_FLAG_IGMP;
 8001008:	f043 0320 	orr.w	r3, r3, #32
 800100c:	f880 302d 	strb.w	r3, [r0, #45]	@ 0x2d
            igmp_start(netif);
 8001010:	f010 ff9e 	bl	8011f50 <igmp_start>
 8001014:	e7db      	b.n	8000fce <mcast_join_group+0x36>
        printf("Join successs\n");
 8001016:	4809      	ldr	r0, [pc, #36]	@ (800103c <mcast_join_group+0xa4>)
 8001018:	f013 f822 	bl	8014060 <puts>
        udp_recv(upcb, recv, upcb);
 800101c:	4622      	mov	r2, r4
 800101e:	4639      	mov	r1, r7
 8001020:	4620      	mov	r0, r4
 8001022:	f00f fe55 	bl	8010cd0 <udp_recv>
 8001026:	e7e8      	b.n	8000ffa <mcast_join_group+0x62>
 8001028:	080153c8 	.word	0x080153c8
 800102c:	08018fc0 	.word	0x08018fc0
 8001030:	08015414 	.word	0x08015414
 8001034:	080153e4 	.word	0x080153e4
 8001038:	080153fc 	.word	0x080153fc
 800103c:	08015438 	.word	0x08015438

08001040 <UPNP_serverInit>:
* PARAM:
* RET:
* DESC:		Initialises a UPNP server that listens on UDP port 1900
*****************************************************************************/
UPNP_RESULT_T UPNP_serverInit(void)
{
 8001040:	b508      	push	{r3, lr}
	/**** INITIALIZATION ****/
  res = UPNPERR_OK;
	/**** PARAMETER CHECK ***/
	/**** PROGRAM CODE ******/

  upcb = mcast_join_group(UPNP_MCAST_GRP, UPNP_MCAST_PORT, receive_callback);
 8001042:	4a05      	ldr	r2, [pc, #20]	@ (8001058 <UPNP_serverInit+0x18>)
 8001044:	f240 716c 	movw	r1, #1900	@ 0x76c
 8001048:	4804      	ldr	r0, [pc, #16]	@ (800105c <UPNP_serverInit+0x1c>)
 800104a:	f7ff ffa5 	bl	8000f98 <mcast_join_group>

  if(upcb != NULL)
 800104e:	b900      	cbnz	r0, 8001052 <UPNP_serverInit+0x12>
  {
    res = UPNPERR_ALLOCFAILED;
  }

  return res;
}
 8001050:	bd08      	pop	{r3, pc}
    res = UPNPERR_ALLOCFAILED;
 8001052:	f04f 30ff 	mov.w	r0, #4294967295
 8001056:	e7fb      	b.n	8001050 <UPNP_serverInit+0x10>
 8001058:	08000f59 	.word	0x08000f59
 800105c:	08015448 	.word	0x08015448

08001060 <MX_USART3_UART_Init>:
UART_HandleTypeDef huart3;

/* USART3 init function */

void MX_USART3_UART_Init(void)
{
 8001060:	b508      	push	{r3, lr}
  /* USER CODE END USART3_Init 0 */

  /* USER CODE BEGIN USART3_Init 1 */

  /* USER CODE END USART3_Init 1 */
  huart3.Instance = USART3;
 8001062:	4817      	ldr	r0, [pc, #92]	@ (80010c0 <MX_USART3_UART_Init+0x60>)
 8001064:	4b17      	ldr	r3, [pc, #92]	@ (80010c4 <MX_USART3_UART_Init+0x64>)
 8001066:	6003      	str	r3, [r0, #0]
  huart3.Init.BaudRate = 115200;
 8001068:	f44f 33e1 	mov.w	r3, #115200	@ 0x1c200
 800106c:	6043      	str	r3, [r0, #4]
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
 800106e:	2300      	movs	r3, #0
 8001070:	6083      	str	r3, [r0, #8]
  huart3.Init.StopBits = UART_STOPBITS_1;
 8001072:	60c3      	str	r3, [r0, #12]
  huart3.Init.Parity = UART_PARITY_NONE;
 8001074:	6103      	str	r3, [r0, #16]
  huart3.Init.Mode = UART_MODE_TX_RX;
 8001076:	220c      	movs	r2, #12
 8001078:	6142      	str	r2, [r0, #20]
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800107a:	6183      	str	r3, [r0, #24]
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
 800107c:	61c3      	str	r3, [r0, #28]
  huart3.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 800107e:	6203      	str	r3, [r0, #32]
  huart3.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 8001080:	6243      	str	r3, [r0, #36]	@ 0x24
  huart3.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8001082:	6283      	str	r3, [r0, #40]	@ 0x28
  if (HAL_UART_Init(&huart3) != HAL_OK)
 8001084:	f005 fc18 	bl	80068b8 <HAL_UART_Init>
 8001088:	b970      	cbnz	r0, 80010a8 <MX_USART3_UART_Init+0x48>
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart3, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 800108a:	2100      	movs	r1, #0
 800108c:	480c      	ldr	r0, [pc, #48]	@ (80010c0 <MX_USART3_UART_Init+0x60>)
 800108e:	f005 fd15 	bl	8006abc <HAL_UARTEx_SetTxFifoThreshold>
 8001092:	b960      	cbnz	r0, 80010ae <MX_USART3_UART_Init+0x4e>
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart3, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 8001094:	2100      	movs	r1, #0
 8001096:	480a      	ldr	r0, [pc, #40]	@ (80010c0 <MX_USART3_UART_Init+0x60>)
 8001098:	f005 fd7c 	bl	8006b94 <HAL_UARTEx_SetRxFifoThreshold>
 800109c:	b950      	cbnz	r0, 80010b4 <MX_USART3_UART_Init+0x54>
  {
    Error_Handler();
  }
  if (HAL_UARTEx_DisableFifoMode(&huart3) != HAL_OK)
 800109e:	4808      	ldr	r0, [pc, #32]	@ (80010c0 <MX_USART3_UART_Init+0x60>)
 80010a0:	f005 fcc2 	bl	8006a28 <HAL_UARTEx_DisableFifoMode>
 80010a4:	b948      	cbnz	r0, 80010ba <MX_USART3_UART_Init+0x5a>
  }
  /* USER CODE BEGIN USART3_Init 2 */

  /* USER CODE END USART3_Init 2 */

}
 80010a6:	bd08      	pop	{r3, pc}
    Error_Handler();
 80010a8:	f7ff fc60 	bl	800096c <Error_Handler>
 80010ac:	e7ed      	b.n	800108a <MX_USART3_UART_Init+0x2a>
    Error_Handler();
 80010ae:	f7ff fc5d 	bl	800096c <Error_Handler>
 80010b2:	e7ef      	b.n	8001094 <MX_USART3_UART_Init+0x34>
    Error_Handler();
 80010b4:	f7ff fc5a 	bl	800096c <Error_Handler>
 80010b8:	e7f1      	b.n	800109e <MX_USART3_UART_Init+0x3e>
    Error_Handler();
 80010ba:	f7ff fc57 	bl	800096c <Error_Handler>
}
 80010be:	e7f2      	b.n	80010a6 <MX_USART3_UART_Init+0x46>
 80010c0:	24003670 	.word	0x24003670
 80010c4:	40004800 	.word	0x40004800

080010c8 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 80010c8:	b510      	push	{r4, lr}
 80010ca:	b0b8      	sub	sp, #224	@ 0xe0
 80010cc:	4604      	mov	r4, r0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80010ce:	2100      	movs	r1, #0
 80010d0:	9133      	str	r1, [sp, #204]	@ 0xcc
 80010d2:	9134      	str	r1, [sp, #208]	@ 0xd0
 80010d4:	9135      	str	r1, [sp, #212]	@ 0xd4
 80010d6:	9136      	str	r1, [sp, #216]	@ 0xd8
 80010d8:	9137      	str	r1, [sp, #220]	@ 0xdc
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 80010da:	22c0      	movs	r2, #192	@ 0xc0
 80010dc:	a802      	add	r0, sp, #8
 80010de:	f013 f8eb 	bl	80142b8 <memset>
  if(uartHandle->Instance==USART3)
 80010e2:	6822      	ldr	r2, [r4, #0]
 80010e4:	4b1b      	ldr	r3, [pc, #108]	@ (8001154 <HAL_UART_MspInit+0x8c>)
 80010e6:	429a      	cmp	r2, r3
 80010e8:	d001      	beq.n	80010ee <HAL_UART_MspInit+0x26>

  /* USER CODE BEGIN USART3_MspInit 1 */

  /* USER CODE END USART3_MspInit 1 */
  }
}
 80010ea:	b038      	add	sp, #224	@ 0xe0
 80010ec:	bd10      	pop	{r4, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART3;
 80010ee:	2202      	movs	r2, #2
 80010f0:	2300      	movs	r3, #0
 80010f2:	e9cd 2302 	strd	r2, r3, [sp, #8]
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80010f6:	a802      	add	r0, sp, #8
 80010f8:	f003 f83a 	bl	8004170 <HAL_RCCEx_PeriphCLKConfig>
 80010fc:	bb38      	cbnz	r0, 800114e <HAL_UART_MspInit+0x86>
    __HAL_RCC_USART3_CLK_ENABLE();
 80010fe:	4b16      	ldr	r3, [pc, #88]	@ (8001158 <HAL_UART_MspInit+0x90>)
 8001100:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
 8001104:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 8001108:	f8c3 20e8 	str.w	r2, [r3, #232]	@ 0xe8
 800110c:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
 8001110:	f402 2280 	and.w	r2, r2, #262144	@ 0x40000
 8001114:	9200      	str	r2, [sp, #0]
 8001116:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8001118:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 800111c:	f042 0208 	orr.w	r2, r2, #8
 8001120:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
 8001124:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8001128:	f003 0308 	and.w	r3, r3, #8
 800112c:	9301      	str	r3, [sp, #4]
 800112e:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
 8001130:	f44f 7340 	mov.w	r3, #768	@ 0x300
 8001134:	9333      	str	r3, [sp, #204]	@ 0xcc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001136:	2302      	movs	r3, #2
 8001138:	9334      	str	r3, [sp, #208]	@ 0xd0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800113a:	2300      	movs	r3, #0
 800113c:	9335      	str	r3, [sp, #212]	@ 0xd4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800113e:	9336      	str	r3, [sp, #216]	@ 0xd8
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 8001140:	2307      	movs	r3, #7
 8001142:	9337      	str	r3, [sp, #220]	@ 0xdc
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8001144:	a933      	add	r1, sp, #204	@ 0xcc
 8001146:	4805      	ldr	r0, [pc, #20]	@ (800115c <HAL_UART_MspInit+0x94>)
 8001148:	f001 fb7c 	bl	8002844 <HAL_GPIO_Init>
}
 800114c:	e7cd      	b.n	80010ea <HAL_UART_MspInit+0x22>
      Error_Handler();
 800114e:	f7ff fc0d 	bl	800096c <Error_Handler>
 8001152:	e7d4      	b.n	80010fe <HAL_UART_MspInit+0x36>
 8001154:	40004800 	.word	0x40004800
 8001158:	58024400 	.word	0x58024400
 800115c:	58020c00 	.word	0x58020c00

08001160 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack      /* set stack pointer */
 8001160:	f8df d034 	ldr.w	sp, [pc, #52]	@ 8001198 <LoopFillZerobss+0xe>

/* Call the clock system initialization function.*/
  bl  SystemInit
 8001164:	f7ff fe5e 	bl	8000e24 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8001168:	480c      	ldr	r0, [pc, #48]	@ (800119c <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 800116a:	490d      	ldr	r1, [pc, #52]	@ (80011a0 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 800116c:	4a0d      	ldr	r2, [pc, #52]	@ (80011a4 <LoopFillZerobss+0x1a>)
  movs r3, #0
 800116e:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8001170:	e002      	b.n	8001178 <LoopCopyDataInit>

08001172 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8001172:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8001174:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8001176:	3304      	adds	r3, #4

08001178 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8001178:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800117a:	428c      	cmp	r4, r1
  bcc CopyDataInit
 800117c:	d3f9      	bcc.n	8001172 <CopyDataInit>
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800117e:	4a0a      	ldr	r2, [pc, #40]	@ (80011a8 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8001180:	4c0a      	ldr	r4, [pc, #40]	@ (80011ac <LoopFillZerobss+0x22>)
  movs r3, #0
 8001182:	2300      	movs	r3, #0
  b LoopFillZerobss
 8001184:	e001      	b.n	800118a <LoopFillZerobss>

08001186 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8001186:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8001188:	3204      	adds	r2, #4

0800118a <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800118a:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800118c:	d3fb      	bcc.n	8001186 <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 800118e:	f013 f909 	bl	80143a4 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8001192:	f7ff fc57 	bl	8000a44 <main>
  bx  lr
 8001196:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 8001198:	24080000 	.word	0x24080000
  ldr r0, =_sdata
 800119c:	24000000 	.word	0x24000000
  ldr r1, =_edata
 80011a0:	2400008c 	.word	0x2400008c
  ldr r2, =_sidata
 80011a4:	08019b58 	.word	0x08019b58
  ldr r2, =_sbss
 80011a8:	240032d0 	.word	0x240032d0
  ldr r4, =_ebss
 80011ac:	240146bc 	.word	0x240146bc

080011b0 <ADC3_IRQHandler>:
 * @retval None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 80011b0:	e7fe      	b.n	80011b0 <ADC3_IRQHandler>

080011b2 <LAN8742_RegisterBusIO>:
  * @retval LAN8742_STATUS_OK  if OK
  *         LAN8742_STATUS_ERROR if missing mandatory function
  */
int32_t  LAN8742_RegisterBusIO(lan8742_Object_t *pObj, lan8742_IOCtx_t *ioctx)
{
  if(!pObj || !ioctx->ReadReg || !ioctx->WriteReg || !ioctx->GetTick)
 80011b2:	b188      	cbz	r0, 80011d8 <LAN8742_RegisterBusIO+0x26>
 80011b4:	68ca      	ldr	r2, [r1, #12]
 80011b6:	b192      	cbz	r2, 80011de <LAN8742_RegisterBusIO+0x2c>
 80011b8:	688a      	ldr	r2, [r1, #8]
 80011ba:	b19a      	cbz	r2, 80011e4 <LAN8742_RegisterBusIO+0x32>
 80011bc:	690a      	ldr	r2, [r1, #16]
 80011be:	b1a2      	cbz	r2, 80011ea <LAN8742_RegisterBusIO+0x38>
  {
    return LAN8742_STATUS_ERROR;
  }
  
  pObj->IO.Init = ioctx->Init;
 80011c0:	680a      	ldr	r2, [r1, #0]
 80011c2:	6082      	str	r2, [r0, #8]
  pObj->IO.DeInit = ioctx->DeInit;
 80011c4:	684a      	ldr	r2, [r1, #4]
 80011c6:	60c2      	str	r2, [r0, #12]
  pObj->IO.ReadReg = ioctx->ReadReg;
 80011c8:	68ca      	ldr	r2, [r1, #12]
 80011ca:	6142      	str	r2, [r0, #20]
  pObj->IO.WriteReg = ioctx->WriteReg;
 80011cc:	688a      	ldr	r2, [r1, #8]
 80011ce:	6102      	str	r2, [r0, #16]
  pObj->IO.GetTick = ioctx->GetTick;
 80011d0:	690a      	ldr	r2, [r1, #16]
 80011d2:	6182      	str	r2, [r0, #24]
  
  return LAN8742_STATUS_OK;
 80011d4:	2000      	movs	r0, #0
 80011d6:	4770      	bx	lr
    return LAN8742_STATUS_ERROR;
 80011d8:	f04f 30ff 	mov.w	r0, #4294967295
 80011dc:	4770      	bx	lr
 80011de:	f04f 30ff 	mov.w	r0, #4294967295
 80011e2:	4770      	bx	lr
 80011e4:	f04f 30ff 	mov.w	r0, #4294967295
 80011e8:	4770      	bx	lr
 80011ea:	f04f 30ff 	mov.w	r0, #4294967295
}
 80011ee:	4770      	bx	lr

080011f0 <LAN8742_Init>:
  *         LAN8742_STATUS_READ_ERROR if connot read register
  *         LAN8742_STATUS_WRITE_ERROR if connot write to register
  *         LAN8742_STATUS_RESET_TIMEOUT if cannot perform a software reset
  */
 int32_t LAN8742_Init(lan8742_Object_t *pObj)
 {
 80011f0:	b570      	push	{r4, r5, r6, lr}
 80011f2:	b082      	sub	sp, #8
 80011f4:	4605      	mov	r5, r0
   uint32_t tickstart = 0, regvalue = 0, addr = 0;
 80011f6:	2300      	movs	r3, #0
 80011f8:	9301      	str	r3, [sp, #4]
   int32_t status = LAN8742_STATUS_OK;
   
   if(pObj->Is_Initialized == 0)
 80011fa:	6844      	ldr	r4, [r0, #4]
 80011fc:	2c00      	cmp	r4, #0
 80011fe:	d14a      	bne.n	8001296 <LAN8742_Init+0xa6>
   {
     if(pObj->IO.Init != 0)
 8001200:	6883      	ldr	r3, [r0, #8]
 8001202:	b103      	cbz	r3, 8001206 <LAN8742_Init+0x16>
     {
       /* GPIO and Clocks initialization */
       pObj->IO.Init();
 8001204:	4798      	blx	r3
     }
   
     /* for later check */
     pObj->DevAddr = LAN8742_MAX_DEV_ADDR + 1;
 8001206:	2320      	movs	r3, #32
 8001208:	602b      	str	r3, [r5, #0]
   int32_t status = LAN8742_STATUS_OK;
 800120a:	2600      	movs	r6, #0
   
     /* Get the device address from special mode register */  
     for(addr = 0; addr <= LAN8742_MAX_DEV_ADDR; addr ++)
 800120c:	e002      	b.n	8001214 <LAN8742_Init+0x24>
     {
       if(pObj->IO.ReadReg(addr, LAN8742_SMR, &regvalue) < 0)
       { 
         status = LAN8742_STATUS_READ_ERROR;
 800120e:	f06f 0604 	mvn.w	r6, #4
     for(addr = 0; addr <= LAN8742_MAX_DEV_ADDR; addr ++)
 8001212:	3401      	adds	r4, #1
 8001214:	2c1f      	cmp	r4, #31
 8001216:	d80d      	bhi.n	8001234 <LAN8742_Init+0x44>
       if(pObj->IO.ReadReg(addr, LAN8742_SMR, &regvalue) < 0)
 8001218:	696b      	ldr	r3, [r5, #20]
 800121a:	aa01      	add	r2, sp, #4
 800121c:	2112      	movs	r1, #18
 800121e:	4620      	mov	r0, r4
 8001220:	4798      	blx	r3
 8001222:	2800      	cmp	r0, #0
 8001224:	dbf3      	blt.n	800120e <LAN8742_Init+0x1e>
         /* Can't read from this device address 
            continue with next address */
         continue;
       }
     
       if((regvalue & LAN8742_SMR_PHY_ADDR) == addr)
 8001226:	9b01      	ldr	r3, [sp, #4]
 8001228:	f003 031f 	and.w	r3, r3, #31
 800122c:	42a3      	cmp	r3, r4
 800122e:	d1f0      	bne.n	8001212 <LAN8742_Init+0x22>
       {
         pObj->DevAddr = addr;
 8001230:	602c      	str	r4, [r5, #0]
         status = LAN8742_STATUS_OK;
 8001232:	2600      	movs	r6, #0
         break;
       }
     }
   
     if(pObj->DevAddr > LAN8742_MAX_DEV_ADDR)
 8001234:	6828      	ldr	r0, [r5, #0]
 8001236:	281f      	cmp	r0, #31
 8001238:	d826      	bhi.n	8001288 <LAN8742_Init+0x98>
     {
       status = LAN8742_STATUS_ADDRESS_ERROR;
     }
     
     /* if device address is matched */
     if(status == LAN8742_STATUS_OK)
 800123a:	2e00      	cmp	r6, #0
 800123c:	d137      	bne.n	80012ae <LAN8742_Init+0xbe>
     {
       /* set a software reset  */
       if(pObj->IO.WriteReg(pObj->DevAddr, LAN8742_BCR, LAN8742_BCR_SOFT_RESET) >= 0)
 800123e:	692b      	ldr	r3, [r5, #16]
 8001240:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
 8001244:	2100      	movs	r1, #0
 8001246:	4798      	blx	r3
 8001248:	2800      	cmp	r0, #0
 800124a:	db33      	blt.n	80012b4 <LAN8742_Init+0xc4>
       { 
         /* get software reset status */
         if(pObj->IO.ReadReg(pObj->DevAddr, LAN8742_BCR, &regvalue) >= 0)
 800124c:	696b      	ldr	r3, [r5, #20]
 800124e:	aa01      	add	r2, sp, #4
 8001250:	2100      	movs	r1, #0
 8001252:	6828      	ldr	r0, [r5, #0]
 8001254:	4798      	blx	r3
 8001256:	2800      	cmp	r0, #0
 8001258:	db2f      	blt.n	80012ba <LAN8742_Init+0xca>
         { 
           tickstart = pObj->IO.GetTick();
 800125a:	69ab      	ldr	r3, [r5, #24]
 800125c:	4798      	blx	r3
 800125e:	4604      	mov	r4, r0
           
           /* wait until software reset is done or timeout occured  */
           while(regvalue & LAN8742_BCR_SOFT_RESET)
 8001260:	9b01      	ldr	r3, [sp, #4]
 8001262:	f413 4f00 	tst.w	r3, #32768	@ 0x8000
 8001266:	d011      	beq.n	800128c <LAN8742_Init+0x9c>
           {
             if((pObj->IO.GetTick() - tickstart) <= LAN8742_SW_RESET_TO)
 8001268:	69ab      	ldr	r3, [r5, #24]
 800126a:	4798      	blx	r3
 800126c:	1b00      	subs	r0, r0, r4
 800126e:	f5b0 7ffa 	cmp.w	r0, #500	@ 0x1f4
 8001272:	d80d      	bhi.n	8001290 <LAN8742_Init+0xa0>
             {
               if(pObj->IO.ReadReg(pObj->DevAddr, LAN8742_BCR, &regvalue) < 0)
 8001274:	696b      	ldr	r3, [r5, #20]
 8001276:	aa01      	add	r2, sp, #4
 8001278:	2100      	movs	r1, #0
 800127a:	6828      	ldr	r0, [r5, #0]
 800127c:	4798      	blx	r3
 800127e:	2800      	cmp	r0, #0
 8001280:	daee      	bge.n	8001260 <LAN8742_Init+0x70>
               { 
                 status = LAN8742_STATUS_READ_ERROR;
 8001282:	f06f 0604 	mvn.w	r6, #4
 8001286:	e001      	b.n	800128c <LAN8742_Init+0x9c>
       status = LAN8742_STATUS_ADDRESS_ERROR;
 8001288:	f06f 0602 	mvn.w	r6, #2
         status = LAN8742_STATUS_WRITE_ERROR;
       }
     }
   }
      
   if(status == LAN8742_STATUS_OK)
 800128c:	b97e      	cbnz	r6, 80012ae <LAN8742_Init+0xbe>
 800128e:	e003      	b.n	8001298 <LAN8742_Init+0xa8>
               status = LAN8742_STATUS_RESET_TIMEOUT;
 8001290:	f06f 0601 	mvn.w	r6, #1
 8001294:	e7fa      	b.n	800128c <LAN8742_Init+0x9c>
   int32_t status = LAN8742_STATUS_OK;
 8001296:	2600      	movs	r6, #0
   {
     tickstart =  pObj->IO.GetTick();
 8001298:	69ab      	ldr	r3, [r5, #24]
 800129a:	4798      	blx	r3
 800129c:	4604      	mov	r4, r0
     
     /* Wait for 2s to perform initialization */
     while((pObj->IO.GetTick() - tickstart) <= LAN8742_INIT_TO)
 800129e:	69ab      	ldr	r3, [r5, #24]
 80012a0:	4798      	blx	r3
 80012a2:	1b03      	subs	r3, r0, r4
 80012a4:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 80012a8:	d9f9      	bls.n	800129e <LAN8742_Init+0xae>
     {
     }
     pObj->Is_Initialized = 1;
 80012aa:	2301      	movs	r3, #1
 80012ac:	606b      	str	r3, [r5, #4]
   }
   
   return status;
 }
 80012ae:	4630      	mov	r0, r6
 80012b0:	b002      	add	sp, #8
 80012b2:	bd70      	pop	{r4, r5, r6, pc}
         status = LAN8742_STATUS_WRITE_ERROR;
 80012b4:	f06f 0603 	mvn.w	r6, #3
 80012b8:	e7f9      	b.n	80012ae <LAN8742_Init+0xbe>
           status = LAN8742_STATUS_READ_ERROR;
 80012ba:	f06f 0604 	mvn.w	r6, #4
   return status;
 80012be:	e7f6      	b.n	80012ae <LAN8742_Init+0xbe>

080012c0 <LAN8742_GetLinkState>:
  *         LAN8742_STATUS_10MBITS_HALFDUPLEX  if 10Mb/s HD       
  *         LAN8742_STATUS_READ_ERROR if connot read register
  *         LAN8742_STATUS_WRITE_ERROR if connot write to register
  */
int32_t LAN8742_GetLinkState(lan8742_Object_t *pObj)
{
 80012c0:	b510      	push	{r4, lr}
 80012c2:	b082      	sub	sp, #8
 80012c4:	4604      	mov	r4, r0
  uint32_t readval = 0;
 80012c6:	2300      	movs	r3, #0
 80012c8:	9301      	str	r3, [sp, #4]
  
  /* Read Status register  */
  if(pObj->IO.ReadReg(pObj->DevAddr, LAN8742_BSR, &readval) < 0)
 80012ca:	6943      	ldr	r3, [r0, #20]
 80012cc:	aa01      	add	r2, sp, #4
 80012ce:	2101      	movs	r1, #1
 80012d0:	6800      	ldr	r0, [r0, #0]
 80012d2:	4798      	blx	r3
 80012d4:	2800      	cmp	r0, #0
 80012d6:	db39      	blt.n	800134c <LAN8742_GetLinkState+0x8c>
  {
    return LAN8742_STATUS_READ_ERROR;
  }
  
  /* Read Status register again */
  if(pObj->IO.ReadReg(pObj->DevAddr, LAN8742_BSR, &readval) < 0)
 80012d8:	6963      	ldr	r3, [r4, #20]
 80012da:	aa01      	add	r2, sp, #4
 80012dc:	2101      	movs	r1, #1
 80012de:	6820      	ldr	r0, [r4, #0]
 80012e0:	4798      	blx	r3
 80012e2:	2800      	cmp	r0, #0
 80012e4:	db35      	blt.n	8001352 <LAN8742_GetLinkState+0x92>
  {
    return LAN8742_STATUS_READ_ERROR;
  }
  
  if((readval & LAN8742_BSR_LINK_STATUS) == 0)
 80012e6:	9b01      	ldr	r3, [sp, #4]
 80012e8:	f013 0f04 	tst.w	r3, #4
 80012ec:	d034      	beq.n	8001358 <LAN8742_GetLinkState+0x98>
    /* Return Link Down status */
    return LAN8742_STATUS_LINK_DOWN;    
  }
  
  /* Check Auto negotiaition */
  if(pObj->IO.ReadReg(pObj->DevAddr, LAN8742_BCR, &readval) < 0)
 80012ee:	6963      	ldr	r3, [r4, #20]
 80012f0:	aa01      	add	r2, sp, #4
 80012f2:	2100      	movs	r1, #0
 80012f4:	6820      	ldr	r0, [r4, #0]
 80012f6:	4798      	blx	r3
 80012f8:	2800      	cmp	r0, #0
 80012fa:	db30      	blt.n	800135e <LAN8742_GetLinkState+0x9e>
  {
    return LAN8742_STATUS_READ_ERROR;
  }
  
  if((readval & LAN8742_BCR_AUTONEGO_EN) != LAN8742_BCR_AUTONEGO_EN)
 80012fc:	9b01      	ldr	r3, [sp, #4]
 80012fe:	f413 5f80 	tst.w	r3, #4096	@ 0x1000
 8001302:	d10c      	bne.n	800131e <LAN8742_GetLinkState+0x5e>
  {
    if(((readval & LAN8742_BCR_SPEED_SELECT) == LAN8742_BCR_SPEED_SELECT) && ((readval & LAN8742_BCR_DUPLEX_MODE) == LAN8742_BCR_DUPLEX_MODE)) 
 8001304:	f403 5204 	and.w	r2, r3, #8448	@ 0x2100
 8001308:	f5b2 5f04 	cmp.w	r2, #8448	@ 0x2100
 800130c:	d02a      	beq.n	8001364 <LAN8742_GetLinkState+0xa4>
    {
      return LAN8742_STATUS_100MBITS_FULLDUPLEX;
    }
    else if ((readval & LAN8742_BCR_SPEED_SELECT) == LAN8742_BCR_SPEED_SELECT)
 800130e:	f413 5f00 	tst.w	r3, #8192	@ 0x2000
 8001312:	d129      	bne.n	8001368 <LAN8742_GetLinkState+0xa8>
    {
      return LAN8742_STATUS_100MBITS_HALFDUPLEX;
    }        
    else if ((readval & LAN8742_BCR_DUPLEX_MODE) == LAN8742_BCR_DUPLEX_MODE)
 8001314:	f413 7f80 	tst.w	r3, #256	@ 0x100
 8001318:	d028      	beq.n	800136c <LAN8742_GetLinkState+0xac>
    {
      return LAN8742_STATUS_10MBITS_FULLDUPLEX;
 800131a:	2004      	movs	r0, #4
 800131c:	e01d      	b.n	800135a <LAN8742_GetLinkState+0x9a>
      return LAN8742_STATUS_10MBITS_HALFDUPLEX;
    }  		
  }
  else /* Auto Nego enabled */
  {
    if(pObj->IO.ReadReg(pObj->DevAddr, LAN8742_PHYSCSR, &readval) < 0)
 800131e:	6963      	ldr	r3, [r4, #20]
 8001320:	aa01      	add	r2, sp, #4
 8001322:	211f      	movs	r1, #31
 8001324:	6820      	ldr	r0, [r4, #0]
 8001326:	4798      	blx	r3
 8001328:	2800      	cmp	r0, #0
 800132a:	db21      	blt.n	8001370 <LAN8742_GetLinkState+0xb0>
    {
      return LAN8742_STATUS_READ_ERROR;
    }
    
    /* Check if auto nego not done */
    if((readval & LAN8742_PHYSCSR_AUTONEGO_DONE) == 0)
 800132c:	9b01      	ldr	r3, [sp, #4]
 800132e:	f413 5f80 	tst.w	r3, #4096	@ 0x1000
 8001332:	d020      	beq.n	8001376 <LAN8742_GetLinkState+0xb6>
    {
      return LAN8742_STATUS_AUTONEGO_NOTDONE;
    }
    
    if((readval & LAN8742_PHYSCSR_HCDSPEEDMASK) == LAN8742_PHYSCSR_100BTX_FD)
 8001334:	f003 031c 	and.w	r3, r3, #28
 8001338:	2b18      	cmp	r3, #24
 800133a:	d01e      	beq.n	800137a <LAN8742_GetLinkState+0xba>
    {
      return LAN8742_STATUS_100MBITS_FULLDUPLEX;
    }
    else if ((readval & LAN8742_PHYSCSR_HCDSPEEDMASK) == LAN8742_PHYSCSR_100BTX_HD)
 800133c:	2b08      	cmp	r3, #8
 800133e:	d01e      	beq.n	800137e <LAN8742_GetLinkState+0xbe>
    {
      return LAN8742_STATUS_100MBITS_HALFDUPLEX;
    }
    else if ((readval & LAN8742_PHYSCSR_HCDSPEEDMASK) == LAN8742_PHYSCSR_10BT_FD)
 8001340:	2b14      	cmp	r3, #20
 8001342:	d001      	beq.n	8001348 <LAN8742_GetLinkState+0x88>
    {
      return LAN8742_STATUS_10MBITS_FULLDUPLEX;
    }
    else
    {
      return LAN8742_STATUS_10MBITS_HALFDUPLEX;
 8001344:	2005      	movs	r0, #5
 8001346:	e008      	b.n	800135a <LAN8742_GetLinkState+0x9a>
      return LAN8742_STATUS_10MBITS_FULLDUPLEX;
 8001348:	2004      	movs	r0, #4
 800134a:	e006      	b.n	800135a <LAN8742_GetLinkState+0x9a>
    return LAN8742_STATUS_READ_ERROR;
 800134c:	f06f 0004 	mvn.w	r0, #4
 8001350:	e003      	b.n	800135a <LAN8742_GetLinkState+0x9a>
    return LAN8742_STATUS_READ_ERROR;
 8001352:	f06f 0004 	mvn.w	r0, #4
 8001356:	e000      	b.n	800135a <LAN8742_GetLinkState+0x9a>
    return LAN8742_STATUS_LINK_DOWN;    
 8001358:	2001      	movs	r0, #1
    }				
  }
}
 800135a:	b002      	add	sp, #8
 800135c:	bd10      	pop	{r4, pc}
    return LAN8742_STATUS_READ_ERROR;
 800135e:	f06f 0004 	mvn.w	r0, #4
 8001362:	e7fa      	b.n	800135a <LAN8742_GetLinkState+0x9a>
      return LAN8742_STATUS_100MBITS_FULLDUPLEX;
 8001364:	2002      	movs	r0, #2
 8001366:	e7f8      	b.n	800135a <LAN8742_GetLinkState+0x9a>
      return LAN8742_STATUS_100MBITS_HALFDUPLEX;
 8001368:	2003      	movs	r0, #3
 800136a:	e7f6      	b.n	800135a <LAN8742_GetLinkState+0x9a>
      return LAN8742_STATUS_10MBITS_HALFDUPLEX;
 800136c:	2005      	movs	r0, #5
 800136e:	e7f4      	b.n	800135a <LAN8742_GetLinkState+0x9a>
      return LAN8742_STATUS_READ_ERROR;
 8001370:	f06f 0004 	mvn.w	r0, #4
 8001374:	e7f1      	b.n	800135a <LAN8742_GetLinkState+0x9a>
      return LAN8742_STATUS_AUTONEGO_NOTDONE;
 8001376:	2006      	movs	r0, #6
 8001378:	e7ef      	b.n	800135a <LAN8742_GetLinkState+0x9a>
      return LAN8742_STATUS_100MBITS_FULLDUPLEX;
 800137a:	2002      	movs	r0, #2
 800137c:	e7ed      	b.n	800135a <LAN8742_GetLinkState+0x9a>
      return LAN8742_STATUS_100MBITS_HALFDUPLEX;
 800137e:	2003      	movs	r0, #3
 8001380:	e7eb      	b.n	800135a <LAN8742_GetLinkState+0x9a>
	...

08001384 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8001384:	b510      	push	{r4, lr}
   __HAL_ART_CONFIG_BASE_ADDRESS(0x08100000UL);  /* Configure the Cortex-M4 ART Base address to the Flash Bank 2 : */
   __HAL_ART_ENABLE();                           /* Enable the Cortex-M4 ART */
#endif /* DUAL_CORE &&  CORE_CM4 */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8001386:	2003      	movs	r0, #3
 8001388:	f000 f8ae 	bl	80014e8 <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 800138c:	f002 f980 	bl	8003690 <HAL_RCC_GetSysClockFreq>
 8001390:	490f      	ldr	r1, [pc, #60]	@ (80013d0 <HAL_Init+0x4c>)
 8001392:	698b      	ldr	r3, [r1, #24]
 8001394:	f3c3 2303 	ubfx	r3, r3, #8, #4
 8001398:	4a0e      	ldr	r2, [pc, #56]	@ (80013d4 <HAL_Init+0x50>)
 800139a:	5cd3      	ldrb	r3, [r2, r3]
 800139c:	f003 031f 	and.w	r3, r3, #31
 80013a0:	40d8      	lsrs	r0, r3
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

  /* Update the SystemD2Clock global variable */
#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 80013a2:	698b      	ldr	r3, [r1, #24]
 80013a4:	f003 030f 	and.w	r3, r3, #15
 80013a8:	5cd3      	ldrb	r3, [r2, r3]
 80013aa:	f003 031f 	and.w	r3, r3, #31
 80013ae:	fa20 f303 	lsr.w	r3, r0, r3
 80013b2:	4a09      	ldr	r2, [pc, #36]	@ (80013d8 <HAL_Init+0x54>)
 80013b4:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
 80013b6:	4b09      	ldr	r3, [pc, #36]	@ (80013dc <HAL_Init+0x58>)
 80013b8:	6018      	str	r0, [r3, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 80013ba:	2001      	movs	r0, #1
 80013bc:	f7ff fc76 	bl	8000cac <HAL_InitTick>
 80013c0:	b110      	cbz	r0, 80013c8 <HAL_Init+0x44>
  {
    return HAL_ERROR;
 80013c2:	2401      	movs	r4, #1
  /* Init the low level hardware */
  HAL_MspInit();

  /* Return function status */
  return HAL_OK;
}
 80013c4:	4620      	mov	r0, r4
 80013c6:	bd10      	pop	{r4, pc}
 80013c8:	4604      	mov	r4, r0
  HAL_MspInit();
 80013ca:	f7ff fc55 	bl	8000c78 <HAL_MspInit>
  return HAL_OK;
 80013ce:	e7f9      	b.n	80013c4 <HAL_Init+0x40>
 80013d0:	58024400 	.word	0x58024400
 80013d4:	08018cc4 	.word	0x08018cc4
 80013d8:	24000000 	.word	0x24000000
 80013dc:	24000004 	.word	0x24000004

080013e0 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
 80013e0:	4b03      	ldr	r3, [pc, #12]	@ (80013f0 <HAL_IncTick+0x10>)
 80013e2:	781b      	ldrb	r3, [r3, #0]
 80013e4:	4a03      	ldr	r2, [pc, #12]	@ (80013f4 <HAL_IncTick+0x14>)
 80013e6:	6811      	ldr	r1, [r2, #0]
 80013e8:	440b      	add	r3, r1
 80013ea:	6013      	str	r3, [r2, #0]
}
 80013ec:	4770      	bx	lr
 80013ee:	bf00      	nop
 80013f0:	24000008 	.word	0x24000008
 80013f4:	24003704 	.word	0x24003704

080013f8 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80013f8:	4b01      	ldr	r3, [pc, #4]	@ (8001400 <HAL_GetTick+0x8>)
 80013fa:	6818      	ldr	r0, [r3, #0]
}
 80013fc:	4770      	bx	lr
 80013fe:	bf00      	nop
 8001400:	24003704 	.word	0x24003704

08001404 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8001404:	b538      	push	{r3, r4, r5, lr}
 8001406:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8001408:	f7ff fff6 	bl	80013f8 <HAL_GetTick>
 800140c:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800140e:	f1b4 3fff 	cmp.w	r4, #4294967295
 8001412:	d002      	beq.n	800141a <HAL_Delay+0x16>
  {
    wait += (uint32_t)(uwTickFreq);
 8001414:	4b04      	ldr	r3, [pc, #16]	@ (8001428 <HAL_Delay+0x24>)
 8001416:	781b      	ldrb	r3, [r3, #0]
 8001418:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 800141a:	f7ff ffed 	bl	80013f8 <HAL_GetTick>
 800141e:	1b40      	subs	r0, r0, r5
 8001420:	42a0      	cmp	r0, r4
 8001422:	d3fa      	bcc.n	800141a <HAL_Delay+0x16>
  {
  }
}
 8001424:	bd38      	pop	{r3, r4, r5, pc}
 8001426:	bf00      	nop
 8001428:	24000008 	.word	0x24000008

0800142c <HAL_GetREVID>:
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
   return((DBGMCU->IDCODE) >> 16);
 800142c:	4b01      	ldr	r3, [pc, #4]	@ (8001434 <HAL_GetREVID+0x8>)
 800142e:	6818      	ldr	r0, [r3, #0]
}
 8001430:	0c00      	lsrs	r0, r0, #16
 8001432:	4770      	bx	lr
 8001434:	5c001000 	.word	0x5c001000

08001438 <HAL_SYSCFG_ETHInterfaceSelect>:
  *   @arg SYSCFG_ETH_MII : Select the Media Independent Interface
  *   @arg SYSCFG_ETH_RMII: Select the Reduced Media Independent Interface
  * @retval None
  */
void HAL_SYSCFG_ETHInterfaceSelect(uint32_t SYSCFG_ETHInterface)
{
 8001438:	b510      	push	{r4, lr}
  /* Check the parameter */
  assert_param(IS_SYSCFG_ETHERNET_CONFIG(SYSCFG_ETHInterface));
 800143a:	4604      	mov	r4, r0
 800143c:	2800      	cmp	r0, #0
 800143e:	bf18      	it	ne
 8001440:	f5b0 0f00 	cmpne.w	r0, #8388608	@ 0x800000
 8001444:	d106      	bne.n	8001454 <HAL_SYSCFG_ETHInterfaceSelect+0x1c>

  MODIFY_REG(SYSCFG->PMCR, SYSCFG_PMCR_EPIS_SEL, (uint32_t)(SYSCFG_ETHInterface));
 8001446:	4a06      	ldr	r2, [pc, #24]	@ (8001460 <HAL_SYSCFG_ETHInterfaceSelect+0x28>)
 8001448:	6853      	ldr	r3, [r2, #4]
 800144a:	f423 0360 	bic.w	r3, r3, #14680064	@ 0xe00000
 800144e:	4323      	orrs	r3, r4
 8001450:	6053      	str	r3, [r2, #4]
}
 8001452:	bd10      	pop	{r4, pc}
  assert_param(IS_SYSCFG_ETHERNET_CONFIG(SYSCFG_ETHInterface));
 8001454:	f240 215b 	movw	r1, #603	@ 0x25b
 8001458:	4802      	ldr	r0, [pc, #8]	@ (8001464 <HAL_SYSCFG_ETHInterfaceSelect+0x2c>)
 800145a:	f7ff fb3b 	bl	8000ad4 <assert_failed>
 800145e:	e7f2      	b.n	8001446 <HAL_SYSCFG_ETHInterfaceSelect+0xe>
 8001460:	58000400 	.word	0x58000400
 8001464:	08015458 	.word	0x08015458

08001468 <__NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8001468:	2800      	cmp	r0, #0
 800146a:	db07      	blt.n	800147c <__NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800146c:	f000 021f 	and.w	r2, r0, #31
 8001470:	0940      	lsrs	r0, r0, #5
 8001472:	2301      	movs	r3, #1
 8001474:	4093      	lsls	r3, r2
 8001476:	4a02      	ldr	r2, [pc, #8]	@ (8001480 <__NVIC_EnableIRQ+0x18>)
 8001478:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
}
 800147c:	4770      	bx	lr
 800147e:	bf00      	nop
 8001480:	e000e100 	.word	0xe000e100

08001484 <__NVIC_SetPriority>:
  if ((int32_t)(IRQn) >= 0)
 8001484:	2800      	cmp	r0, #0
 8001486:	db04      	blt.n	8001492 <__NVIC_SetPriority+0xe>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001488:	0109      	lsls	r1, r1, #4
 800148a:	b2c9      	uxtb	r1, r1
 800148c:	4b04      	ldr	r3, [pc, #16]	@ (80014a0 <__NVIC_SetPriority+0x1c>)
 800148e:	5419      	strb	r1, [r3, r0]
 8001490:	4770      	bx	lr
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001492:	f000 000f 	and.w	r0, r0, #15
 8001496:	0109      	lsls	r1, r1, #4
 8001498:	b2c9      	uxtb	r1, r1
 800149a:	4b02      	ldr	r3, [pc, #8]	@ (80014a4 <__NVIC_SetPriority+0x20>)
 800149c:	5419      	strb	r1, [r3, r0]
}
 800149e:	4770      	bx	lr
 80014a0:	e000e400 	.word	0xe000e400
 80014a4:	e000ed14 	.word	0xe000ed14

080014a8 <NVIC_EncodePriority>:
{
 80014a8:	b500      	push	{lr}
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 80014aa:	f000 0007 	and.w	r0, r0, #7
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80014ae:	f1c0 0c07 	rsb	ip, r0, #7
 80014b2:	f1bc 0f04 	cmp.w	ip, #4
 80014b6:	bf28      	it	cs
 80014b8:	f04f 0c04 	movcs.w	ip, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80014bc:	1d03      	adds	r3, r0, #4
 80014be:	2b06      	cmp	r3, #6
 80014c0:	d90f      	bls.n	80014e2 <NVIC_EncodePriority+0x3a>
 80014c2:	1ec3      	subs	r3, r0, #3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80014c4:	f04f 3eff 	mov.w	lr, #4294967295
 80014c8:	fa0e f00c 	lsl.w	r0, lr, ip
 80014cc:	ea21 0100 	bic.w	r1, r1, r0
 80014d0:	4099      	lsls	r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80014d2:	fa0e fe03 	lsl.w	lr, lr, r3
 80014d6:	ea22 020e 	bic.w	r2, r2, lr
}
 80014da:	ea41 0002 	orr.w	r0, r1, r2
 80014de:	f85d fb04 	ldr.w	pc, [sp], #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80014e2:	2300      	movs	r3, #0
 80014e4:	e7ee      	b.n	80014c4 <NVIC_EncodePriority+0x1c>
	...

080014e8 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80014e8:	b510      	push	{r4, lr}
 80014ea:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 80014ec:	1ec3      	subs	r3, r0, #3
 80014ee:	2b04      	cmp	r3, #4
 80014f0:	d80d      	bhi.n	800150e <HAL_NVIC_SetPriorityGrouping+0x26>
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80014f2:	4909      	ldr	r1, [pc, #36]	@ (8001518 <HAL_NVIC_SetPriorityGrouping+0x30>)
 80014f4:	68cb      	ldr	r3, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80014f6:	f423 63e0 	bic.w	r3, r3, #1792	@ 0x700
 80014fa:	041b      	lsls	r3, r3, #16
 80014fc:	0c1b      	lsrs	r3, r3, #16
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80014fe:	0224      	lsls	r4, r4, #8
 8001500:	f404 64e0 	and.w	r4, r4, #1792	@ 0x700
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8001504:	4323      	orrs	r3, r4
  reg_value  =  (reg_value                                   |
 8001506:	4a05      	ldr	r2, [pc, #20]	@ (800151c <HAL_NVIC_SetPriorityGrouping+0x34>)
 8001508:	431a      	orrs	r2, r3
  SCB->AIRCR =  reg_value;
 800150a:	60ca      	str	r2, [r1, #12]

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 800150c:	bd10      	pop	{r4, pc}
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 800150e:	2191      	movs	r1, #145	@ 0x91
 8001510:	4803      	ldr	r0, [pc, #12]	@ (8001520 <HAL_NVIC_SetPriorityGrouping+0x38>)
 8001512:	f7ff fadf 	bl	8000ad4 <assert_failed>
 8001516:	e7ec      	b.n	80014f2 <HAL_NVIC_SetPriorityGrouping+0xa>
 8001518:	e000ed00 	.word	0xe000ed00
 800151c:	05fa0000 	.word	0x05fa0000
 8001520:	0801548c 	.word	0x0801548c

08001524 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8001524:	b570      	push	{r4, r5, r6, lr}
 8001526:	4606      	mov	r6, r0
 8001528:	460c      	mov	r4, r1
 800152a:	4615      	mov	r5, r2
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
 800152c:	2a0f      	cmp	r2, #15
 800152e:	d80e      	bhi.n	800154e <HAL_NVIC_SetPriority+0x2a>
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
 8001530:	2c0f      	cmp	r4, #15
 8001532:	d811      	bhi.n	8001558 <HAL_NVIC_SetPriority+0x34>
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8001534:	4b0b      	ldr	r3, [pc, #44]	@ (8001564 <HAL_NVIC_SetPriority+0x40>)
 8001536:	68d8      	ldr	r0, [r3, #12]

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8001538:	462a      	mov	r2, r5
 800153a:	4621      	mov	r1, r4
 800153c:	f3c0 2002 	ubfx	r0, r0, #8, #3
 8001540:	f7ff ffb2 	bl	80014a8 <NVIC_EncodePriority>
 8001544:	4601      	mov	r1, r0
 8001546:	4630      	mov	r0, r6
 8001548:	f7ff ff9c 	bl	8001484 <__NVIC_SetPriority>
}
 800154c:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
 800154e:	21a9      	movs	r1, #169	@ 0xa9
 8001550:	4805      	ldr	r0, [pc, #20]	@ (8001568 <HAL_NVIC_SetPriority+0x44>)
 8001552:	f7ff fabf 	bl	8000ad4 <assert_failed>
 8001556:	e7eb      	b.n	8001530 <HAL_NVIC_SetPriority+0xc>
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
 8001558:	21aa      	movs	r1, #170	@ 0xaa
 800155a:	4803      	ldr	r0, [pc, #12]	@ (8001568 <HAL_NVIC_SetPriority+0x44>)
 800155c:	f7ff faba 	bl	8000ad4 <assert_failed>
 8001560:	e7e8      	b.n	8001534 <HAL_NVIC_SetPriority+0x10>
 8001562:	bf00      	nop
 8001564:	e000ed00 	.word	0xe000ed00
 8001568:	0801548c 	.word	0x0801548c

0800156c <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800156c:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
 800156e:	1e04      	subs	r4, r0, #0
 8001570:	db03      	blt.n	800157a <HAL_NVIC_EnableIRQ+0xe>

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8001572:	4620      	mov	r0, r4
 8001574:	f7ff ff78 	bl	8001468 <__NVIC_EnableIRQ>
}
 8001578:	bd10      	pop	{r4, pc}
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
 800157a:	21bd      	movs	r1, #189	@ 0xbd
 800157c:	4801      	ldr	r0, [pc, #4]	@ (8001584 <HAL_NVIC_EnableIRQ+0x18>)
 800157e:	f7ff faa9 	bl	8000ad4 <assert_failed>
 8001582:	e7f6      	b.n	8001572 <HAL_NVIC_EnableIRQ+0x6>
 8001584:	0801548c 	.word	0x0801548c

08001588 <HAL_MPU_Disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
 8001588:	f3bf 8f5f 	dmb	sy
{
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 800158c:	4b04      	ldr	r3, [pc, #16]	@ (80015a0 <HAL_MPU_Disable+0x18>)
 800158e:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8001590:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 8001594:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
 8001596:	2200      	movs	r2, #0
 8001598:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
}
 800159c:	4770      	bx	lr
 800159e:	bf00      	nop
 80015a0:	e000ed00 	.word	0xe000ed00

080015a4 <HAL_MPU_Enable>:
  * @retval None
  */
void HAL_MPU_Enable(uint32_t MPU_Control)
{
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
 80015a4:	f040 0001 	orr.w	r0, r0, #1
 80015a8:	4b05      	ldr	r3, [pc, #20]	@ (80015c0 <HAL_MPU_Enable+0x1c>)
 80015aa:	f8c3 0094 	str.w	r0, [r3, #148]	@ 0x94

  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
 80015ae:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 80015b0:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 80015b4:	625a      	str	r2, [r3, #36]	@ 0x24
  __ASM volatile ("dsb 0xF":::"memory");
 80015b6:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80015ba:	f3bf 8f6f 	isb	sy

  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
 80015be:	4770      	bx	lr
 80015c0:	e000ed00 	.word	0xe000ed00

080015c4 <HAL_MPU_ConfigRegion>:
  * @param  MPU_Init Pointer to a MPU_Region_InitTypeDef structure that contains
  *                  the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
 80015c4:	b510      	push	{r4, lr}
 80015c6:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
 80015c8:	7843      	ldrb	r3, [r0, #1]
 80015ca:	2b0f      	cmp	r3, #15
 80015cc:	d847      	bhi.n	800165e <HAL_MPU_ConfigRegion+0x9a>
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));
 80015ce:	7823      	ldrb	r3, [r4, #0]
 80015d0:	2b01      	cmp	r3, #1
 80015d2:	d84a      	bhi.n	800166a <HAL_MPU_ConfigRegion+0xa6>

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
 80015d4:	7862      	ldrb	r2, [r4, #1]
 80015d6:	4b43      	ldr	r3, [pc, #268]	@ (80016e4 <HAL_MPU_ConfigRegion+0x120>)
 80015d8:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98

  if ((MPU_Init->Enable) != 0UL)
 80015dc:	7823      	ldrb	r3, [r4, #0]
 80015de:	2b00      	cmp	r3, #0
 80015e0:	d079      	beq.n	80016d6 <HAL_MPU_ConfigRegion+0x112>
  {
    /* Check the parameters */
    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
 80015e2:	7b23      	ldrb	r3, [r4, #12]
 80015e4:	2b01      	cmp	r3, #1
 80015e6:	d846      	bhi.n	8001676 <HAL_MPU_ConfigRegion+0xb2>
    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
 80015e8:	7ae3      	ldrb	r3, [r4, #11]
 80015ea:	2b05      	cmp	r3, #5
 80015ec:	bf18      	it	ne
 80015ee:	2b03      	cmpne	r3, #3
 80015f0:	d901      	bls.n	80015f6 <HAL_MPU_ConfigRegion+0x32>
 80015f2:	2b06      	cmp	r3, #6
 80015f4:	d145      	bne.n	8001682 <HAL_MPU_ConfigRegion+0xbe>
    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
 80015f6:	7aa3      	ldrb	r3, [r4, #10]
 80015f8:	2b02      	cmp	r3, #2
 80015fa:	d848      	bhi.n	800168e <HAL_MPU_ConfigRegion+0xca>
    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
 80015fc:	7b63      	ldrb	r3, [r4, #13]
 80015fe:	2b01      	cmp	r3, #1
 8001600:	d84b      	bhi.n	800169a <HAL_MPU_ConfigRegion+0xd6>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
 8001602:	7ba3      	ldrb	r3, [r4, #14]
 8001604:	2b01      	cmp	r3, #1
 8001606:	d84e      	bhi.n	80016a6 <HAL_MPU_ConfigRegion+0xe2>
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
 8001608:	7be3      	ldrb	r3, [r4, #15]
 800160a:	2b01      	cmp	r3, #1
 800160c:	d851      	bhi.n	80016b2 <HAL_MPU_ConfigRegion+0xee>
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
 800160e:	7a63      	ldrb	r3, [r4, #9]
 8001610:	2bff      	cmp	r3, #255	@ 0xff
 8001612:	d054      	beq.n	80016be <HAL_MPU_ConfigRegion+0xfa>
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
 8001614:	7a23      	ldrb	r3, [r4, #8]
 8001616:	3b04      	subs	r3, #4
 8001618:	b2db      	uxtb	r3, r3
 800161a:	2b1b      	cmp	r3, #27
 800161c:	d855      	bhi.n	80016ca <HAL_MPU_ConfigRegion+0x106>

    MPU->RBAR = MPU_Init->BaseAddress;
 800161e:	6863      	ldr	r3, [r4, #4]
 8001620:	4a30      	ldr	r2, [pc, #192]	@ (80016e4 <HAL_MPU_ConfigRegion+0x120>)
 8001622:	f8c2 309c 	str.w	r3, [r2, #156]	@ 0x9c
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 8001626:	7b21      	ldrb	r1, [r4, #12]
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 8001628:	7ae3      	ldrb	r3, [r4, #11]
 800162a:	061b      	lsls	r3, r3, #24
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 800162c:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
 8001630:	7aa1      	ldrb	r1, [r4, #10]
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 8001632:	ea43 43c1 	orr.w	r3, r3, r1, lsl #19
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
 8001636:	7b61      	ldrb	r1, [r4, #13]
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
 8001638:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
 800163c:	7ba1      	ldrb	r1, [r4, #14]
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
 800163e:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
 8001642:	7be1      	ldrb	r1, [r4, #15]
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
 8001644:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
 8001648:	7a61      	ldrb	r1, [r4, #9]
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
 800164a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 800164e:	7a21      	ldrb	r1, [r4, #8]
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
 8001650:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
 8001654:	7821      	ldrb	r1, [r4, #0]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 8001656:	430b      	orrs	r3, r1
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 8001658:	f8c2 30a0 	str.w	r3, [r2, #160]	@ 0xa0
  else
  {
    MPU->RBAR = 0x00;
    MPU->RASR = 0x00;
  }
}
 800165c:	bd10      	pop	{r4, pc}
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
 800165e:	f44f 7196 	mov.w	r1, #300	@ 0x12c
 8001662:	4821      	ldr	r0, [pc, #132]	@ (80016e8 <HAL_MPU_ConfigRegion+0x124>)
 8001664:	f7ff fa36 	bl	8000ad4 <assert_failed>
 8001668:	e7b1      	b.n	80015ce <HAL_MPU_ConfigRegion+0xa>
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));
 800166a:	f240 112d 	movw	r1, #301	@ 0x12d
 800166e:	481e      	ldr	r0, [pc, #120]	@ (80016e8 <HAL_MPU_ConfigRegion+0x124>)
 8001670:	f7ff fa30 	bl	8000ad4 <assert_failed>
 8001674:	e7ae      	b.n	80015d4 <HAL_MPU_ConfigRegion+0x10>
    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
 8001676:	f240 1135 	movw	r1, #309	@ 0x135
 800167a:	481b      	ldr	r0, [pc, #108]	@ (80016e8 <HAL_MPU_ConfigRegion+0x124>)
 800167c:	f7ff fa2a 	bl	8000ad4 <assert_failed>
 8001680:	e7b2      	b.n	80015e8 <HAL_MPU_ConfigRegion+0x24>
    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
 8001682:	f44f 719b 	mov.w	r1, #310	@ 0x136
 8001686:	4818      	ldr	r0, [pc, #96]	@ (80016e8 <HAL_MPU_ConfigRegion+0x124>)
 8001688:	f7ff fa24 	bl	8000ad4 <assert_failed>
 800168c:	e7b3      	b.n	80015f6 <HAL_MPU_ConfigRegion+0x32>
    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
 800168e:	f240 1137 	movw	r1, #311	@ 0x137
 8001692:	4815      	ldr	r0, [pc, #84]	@ (80016e8 <HAL_MPU_ConfigRegion+0x124>)
 8001694:	f7ff fa1e 	bl	8000ad4 <assert_failed>
 8001698:	e7b0      	b.n	80015fc <HAL_MPU_ConfigRegion+0x38>
    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
 800169a:	f44f 719c 	mov.w	r1, #312	@ 0x138
 800169e:	4812      	ldr	r0, [pc, #72]	@ (80016e8 <HAL_MPU_ConfigRegion+0x124>)
 80016a0:	f7ff fa18 	bl	8000ad4 <assert_failed>
 80016a4:	e7ad      	b.n	8001602 <HAL_MPU_ConfigRegion+0x3e>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
 80016a6:	f240 1139 	movw	r1, #313	@ 0x139
 80016aa:	480f      	ldr	r0, [pc, #60]	@ (80016e8 <HAL_MPU_ConfigRegion+0x124>)
 80016ac:	f7ff fa12 	bl	8000ad4 <assert_failed>
 80016b0:	e7aa      	b.n	8001608 <HAL_MPU_ConfigRegion+0x44>
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
 80016b2:	f44f 719d 	mov.w	r1, #314	@ 0x13a
 80016b6:	480c      	ldr	r0, [pc, #48]	@ (80016e8 <HAL_MPU_ConfigRegion+0x124>)
 80016b8:	f7ff fa0c 	bl	8000ad4 <assert_failed>
 80016bc:	e7a7      	b.n	800160e <HAL_MPU_ConfigRegion+0x4a>
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
 80016be:	f240 113b 	movw	r1, #315	@ 0x13b
 80016c2:	4809      	ldr	r0, [pc, #36]	@ (80016e8 <HAL_MPU_ConfigRegion+0x124>)
 80016c4:	f7ff fa06 	bl	8000ad4 <assert_failed>
 80016c8:	e7a4      	b.n	8001614 <HAL_MPU_ConfigRegion+0x50>
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
 80016ca:	f44f 719e 	mov.w	r1, #316	@ 0x13c
 80016ce:	4806      	ldr	r0, [pc, #24]	@ (80016e8 <HAL_MPU_ConfigRegion+0x124>)
 80016d0:	f7ff fa00 	bl	8000ad4 <assert_failed>
 80016d4:	e7a3      	b.n	800161e <HAL_MPU_ConfigRegion+0x5a>
    MPU->RBAR = 0x00;
 80016d6:	4b03      	ldr	r3, [pc, #12]	@ (80016e4 <HAL_MPU_ConfigRegion+0x120>)
 80016d8:	2200      	movs	r2, #0
 80016da:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
    MPU->RASR = 0x00;
 80016de:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
}
 80016e2:	e7bb      	b.n	800165c <HAL_MPU_ConfigRegion+0x98>
 80016e4:	e000ed00 	.word	0xe000ed00
 80016e8:	0801548c 	.word	0x0801548c

080016ec <ETH_UpdateDescriptor>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  */
static void ETH_UpdateDescriptor(ETH_HandleTypeDef *heth)
{
 80016ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80016f0:	b082      	sub	sp, #8
 80016f2:	4607      	mov	r7, r0
  uint32_t descidx;
  uint32_t desccount;
  ETH_DMADescTypeDef *dmarxdesc;
  uint8_t *buff = NULL;
 80016f4:	2300      	movs	r3, #0
 80016f6:	9301      	str	r3, [sp, #4]
  uint8_t allocStatus = 1U;

  descidx = heth->RxDescList.RxBuildDescIdx;
 80016f8:	f8d0 8068 	ldr.w	r8, [r0, #104]	@ 0x68
  dmarxdesc = (ETH_DMADescTypeDef *)heth->RxDescList.RxDesc[descidx];
 80016fc:	f108 0312 	add.w	r3, r8, #18
 8001700:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
  desccount = heth->RxDescList.RxBuildDescCnt;
 8001704:	6ec5      	ldr	r5, [r0, #108]	@ 0x6c
  uint8_t allocStatus = 1U;
 8001706:	2601      	movs	r6, #1

  while ((desccount > 0U) && (allocStatus != 0U))
 8001708:	e013      	b.n	8001732 <ETH_UpdateDescriptor+0x46>
#if (USE_HAL_ETH_REGISTER_CALLBACKS == 1)
      /*Call registered Allocate callback*/
      heth->rxAllocateCallback(&buff);
#else
      /* Allocate callback */
      HAL_ETH_RxAllocateCallback(&buff);
 800170a:	a801      	add	r0, sp, #4
 800170c:	f012 f9a8 	bl	8013a60 <HAL_ETH_RxAllocateCallback>
#endif  /* USE_HAL_ETH_REGISTER_CALLBACKS */
      if (buff == NULL)
 8001710:	9b01      	ldr	r3, [sp, #4]
 8001712:	b113      	cbz	r3, 800171a <ETH_UpdateDescriptor+0x2e>
      {
        allocStatus = 0U;
      }
      else
      {
        WRITE_REG(dmarxdesc->BackupAddr0, (uint32_t)buff);
 8001714:	6123      	str	r3, [r4, #16]
        WRITE_REG(dmarxdesc->DESC0, (uint32_t)buff);
 8001716:	6023      	str	r3, [r4, #0]
 8001718:	e010      	b.n	800173c <ETH_UpdateDescriptor+0x50>
        allocStatus = 0U;
 800171a:	2600      	movs	r6, #0
 800171c:	e00e      	b.n	800173c <ETH_UpdateDescriptor+0x50>
      {
        WRITE_REG(dmarxdesc->DESC3, ETH_DMARXNDESCRF_OWN | ETH_DMARXNDESCRF_BUF1V | ETH_DMARXNDESCRF_IOC);
      }
      else
      {
        WRITE_REG(dmarxdesc->DESC3, ETH_DMARXNDESCRF_OWN | ETH_DMARXNDESCRF_BUF1V);
 800171e:	f04f 4301 	mov.w	r3, #2164260864	@ 0x81000000
 8001722:	60e3      	str	r3, [r4, #12]
 8001724:	e014      	b.n	8001750 <ETH_UpdateDescriptor+0x64>
      }

      /* Increment current rx descriptor index */
      INCR_RX_DESC_INDEX(descidx, 1U);
      /* Get current descriptor address */
      dmarxdesc = (ETH_DMADescTypeDef *)heth->RxDescList.RxDesc[descidx];
 8001726:	f103 0212 	add.w	r2, r3, #18
 800172a:	f857 4022 	ldr.w	r4, [r7, r2, lsl #2]
      desccount--;
 800172e:	3d01      	subs	r5, #1
 8001730:	4698      	mov	r8, r3
  while ((desccount > 0U) && (allocStatus != 0U))
 8001732:	b1a5      	cbz	r5, 800175e <ETH_UpdateDescriptor+0x72>
 8001734:	b19e      	cbz	r6, 800175e <ETH_UpdateDescriptor+0x72>
    if (READ_REG(dmarxdesc->BackupAddr0) == 0U)
 8001736:	6923      	ldr	r3, [r4, #16]
 8001738:	2b00      	cmp	r3, #0
 800173a:	d0e6      	beq.n	800170a <ETH_UpdateDescriptor+0x1e>
    if (allocStatus != 0U)
 800173c:	2e00      	cmp	r6, #0
 800173e:	d0f8      	beq.n	8001732 <ETH_UpdateDescriptor+0x46>
  __ASM volatile ("dmb 0xF":::"memory");
 8001740:	f3bf 8f5f 	dmb	sy
      if (heth->RxDescList.ItMode != 0U)
 8001744:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8001746:	2b00      	cmp	r3, #0
 8001748:	d0e9      	beq.n	800171e <ETH_UpdateDescriptor+0x32>
        WRITE_REG(dmarxdesc->DESC3, ETH_DMARXNDESCRF_OWN | ETH_DMARXNDESCRF_BUF1V | ETH_DMARXNDESCRF_IOC);
 800174a:	f04f 4341 	mov.w	r3, #3238002688	@ 0xc1000000
 800174e:	60e3      	str	r3, [r4, #12]
      INCR_RX_DESC_INDEX(descidx, 1U);
 8001750:	f108 0301 	add.w	r3, r8, #1
 8001754:	2b03      	cmp	r3, #3
 8001756:	d9e6      	bls.n	8001726 <ETH_UpdateDescriptor+0x3a>
 8001758:	f1a8 0303 	sub.w	r3, r8, #3
 800175c:	e7e3      	b.n	8001726 <ETH_UpdateDescriptor+0x3a>
    }
  }

  if (heth->RxDescList.RxBuildDescCnt != desccount)
 800175e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8001760:	42ab      	cmp	r3, r5
 8001762:	d008      	beq.n	8001776 <ETH_UpdateDescriptor+0x8a>
  {
    /* Set the Tail pointer address */
    WRITE_REG(heth->Instance->DMACRDTPR, 0);
 8001764:	683b      	ldr	r3, [r7, #0]
 8001766:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 800176a:	2200      	movs	r2, #0
 800176c:	f8c3 2128 	str.w	r2, [r3, #296]	@ 0x128

    heth->RxDescList.RxBuildDescIdx = descidx;
 8001770:	f8c7 8068 	str.w	r8, [r7, #104]	@ 0x68
    heth->RxDescList.RxBuildDescCnt = desccount;
 8001774:	66fd      	str	r5, [r7, #108]	@ 0x6c
  }
}
 8001776:	b002      	add	sp, #8
 8001778:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800177c <ETH_SetMACConfig>:
  * @{
  */


static void ETH_SetMACConfig(ETH_HandleTypeDef *heth,  ETH_MACConfigTypeDef *macconf)
{
 800177c:	b430      	push	{r4, r5}
  uint32_t macregval;

  /*------------------------ MACCR Configuration --------------------*/
  macregval = (macconf->InterPacketGapVal |
 800177e:	688b      	ldr	r3, [r1, #8]
               macconf->SourceAddrControl |
 8001780:	680a      	ldr	r2, [r1, #0]
  macregval = (macconf->InterPacketGapVal |
 8001782:	4313      	orrs	r3, r2
               ((uint32_t)macconf->ChecksumOffload << 27) |
 8001784:	790a      	ldrb	r2, [r1, #4]
               macconf->SourceAddrControl |
 8001786:	ea43 63c2 	orr.w	r3, r3, r2, lsl #27
               ((uint32_t)macconf->GiantPacketSizeLimitControl << 23) |
 800178a:	7b0a      	ldrb	r2, [r1, #12]
               ((uint32_t)macconf->ChecksumOffload << 27) |
 800178c:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
               ((uint32_t)macconf->Support2KPacket  << 22) |
 8001790:	7b4a      	ldrb	r2, [r1, #13]
               ((uint32_t)macconf->GiantPacketSizeLimitControl << 23) |
 8001792:	ea43 5382 	orr.w	r3, r3, r2, lsl #22
               ((uint32_t)macconf->CRCStripTypePacket << 21) |
 8001796:	7b8a      	ldrb	r2, [r1, #14]
               ((uint32_t)macconf->Support2KPacket  << 22) |
 8001798:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
               ((uint32_t)macconf->AutomaticPadCRCStrip << 20) |
 800179c:	7bca      	ldrb	r2, [r1, #15]
               ((uint32_t)macconf->CRCStripTypePacket << 21) |
 800179e:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
               ((uint32_t)((macconf->Watchdog == DISABLE) ? 1U : 0U) << 19) |
 80017a2:	7c0a      	ldrb	r2, [r1, #16]
 80017a4:	2a00      	cmp	r2, #0
 80017a6:	f040 80b0 	bne.w	800190a <ETH_SetMACConfig+0x18e>
 80017aa:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
               ((uint32_t)macconf->AutomaticPadCRCStrip << 20) |
 80017ae:	4313      	orrs	r3, r2
               ((uint32_t)((macconf->Jabber == DISABLE) ? 1U : 0U) << 17) |
 80017b0:	7c4a      	ldrb	r2, [r1, #17]
 80017b2:	2a00      	cmp	r2, #0
 80017b4:	f040 80ab 	bne.w	800190e <ETH_SetMACConfig+0x192>
 80017b8:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
               ((uint32_t)((macconf->Watchdog == DISABLE) ? 1U : 0U) << 19) |
 80017bc:	4313      	orrs	r3, r2
               ((uint32_t)macconf->JumboPacket << 16) |
 80017be:	7c8a      	ldrb	r2, [r1, #18]
               ((uint32_t)((macconf->Jabber == DISABLE) ? 1U : 0U) << 17) |
 80017c0:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
               macconf->Speed |
 80017c4:	694a      	ldr	r2, [r1, #20]
               ((uint32_t)macconf->JumboPacket << 16) |
 80017c6:	4313      	orrs	r3, r2
               macconf->DuplexMode |
 80017c8:	698a      	ldr	r2, [r1, #24]
               macconf->Speed |
 80017ca:	4313      	orrs	r3, r2
               ((uint32_t)macconf->LoopbackMode << 12) |
 80017cc:	7f0a      	ldrb	r2, [r1, #28]
               macconf->DuplexMode |
 80017ce:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
               ((uint32_t)macconf->CarrierSenseBeforeTransmit << 11) |
 80017d2:	7f4a      	ldrb	r2, [r1, #29]
               ((uint32_t)macconf->LoopbackMode << 12) |
 80017d4:	ea43 23c2 	orr.w	r3, r3, r2, lsl #11
               ((uint32_t)((macconf->ReceiveOwn == DISABLE) ? 1U : 0U) << 10) |
 80017d8:	7f8a      	ldrb	r2, [r1, #30]
 80017da:	2a00      	cmp	r2, #0
 80017dc:	f040 8099 	bne.w	8001912 <ETH_SetMACConfig+0x196>
 80017e0:	f44f 6280 	mov.w	r2, #1024	@ 0x400
               ((uint32_t)macconf->CarrierSenseBeforeTransmit << 11) |
 80017e4:	4313      	orrs	r3, r2
               ((uint32_t)macconf->CarrierSenseDuringTransmit << 9) |
 80017e6:	7fca      	ldrb	r2, [r1, #31]
               ((uint32_t)((macconf->ReceiveOwn == DISABLE) ? 1U : 0U) << 10) |
 80017e8:	ea43 2342 	orr.w	r3, r3, r2, lsl #9
               ((uint32_t)((macconf->RetryTransmission == DISABLE) ? 1U : 0U) << 8) |
 80017ec:	f891 2020 	ldrb.w	r2, [r1, #32]
 80017f0:	2a00      	cmp	r2, #0
 80017f2:	f040 8090 	bne.w	8001916 <ETH_SetMACConfig+0x19a>
 80017f6:	f44f 7280 	mov.w	r2, #256	@ 0x100
               ((uint32_t)macconf->CarrierSenseDuringTransmit << 9) |
 80017fa:	4313      	orrs	r3, r2
               macconf->BackOffLimit |
 80017fc:	6a4a      	ldr	r2, [r1, #36]	@ 0x24
               ((uint32_t)((macconf->RetryTransmission == DISABLE) ? 1U : 0U) << 8) |
 80017fe:	4313      	orrs	r3, r2
               ((uint32_t)macconf->DeferralCheck << 4) |
 8001800:	f891 2028 	ldrb.w	r2, [r1, #40]	@ 0x28
               macconf->BackOffLimit |
 8001804:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
               macconf->PreambleLength);
 8001808:	6aca      	ldr	r2, [r1, #44]	@ 0x2c
  macregval = (macconf->InterPacketGapVal |
 800180a:	4313      	orrs	r3, r2

  /* Write to MACCR */
  MODIFY_REG(heth->Instance->MACCR, ETH_MACCR_MASK, macregval);
 800180c:	6804      	ldr	r4, [r0, #0]
 800180e:	6822      	ldr	r2, [r4, #0]
 8001810:	f022 427f 	bic.w	r2, r2, #4278190080	@ 0xff000000
 8001814:	f422 027b 	bic.w	r2, r2, #16449536	@ 0xfb0000
 8001818:	f422 42fe 	bic.w	r2, r2, #32512	@ 0x7f00
 800181c:	f022 027c 	bic.w	r2, r2, #124	@ 0x7c
 8001820:	4313      	orrs	r3, r2
 8001822:	6023      	str	r3, [r4, #0]

  /*------------------------ MACECR Configuration --------------------*/
  macregval = ((macconf->ExtendedInterPacketGapVal << 25) |
 8001824:	6bca      	ldr	r2, [r1, #60]	@ 0x3c
               ((uint32_t)macconf->ExtendedInterPacketGap << 24) |
 8001826:	f891 3038 	ldrb.w	r3, [r1, #56]	@ 0x38
 800182a:	061b      	lsls	r3, r3, #24
  macregval = ((macconf->ExtendedInterPacketGapVal << 25) |
 800182c:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
               ((uint32_t)macconf->UnicastSlowProtocolPacketDetect << 18) |
 8001830:	f891 2030 	ldrb.w	r2, [r1, #48]	@ 0x30
               ((uint32_t)macconf->ExtendedInterPacketGap << 24) |
 8001834:	ea43 4382 	orr.w	r3, r3, r2, lsl #18
               ((uint32_t)macconf->SlowProtocolDetect << 17) |
 8001838:	f891 2031 	ldrb.w	r2, [r1, #49]	@ 0x31
               ((uint32_t)macconf->UnicastSlowProtocolPacketDetect << 18) |
 800183c:	ea43 4342 	orr.w	r3, r3, r2, lsl #17
               ((uint32_t)((macconf->CRCCheckingRxPackets == DISABLE) ? 1U : 0U) << 16) |
 8001840:	f891 2032 	ldrb.w	r2, [r1, #50]	@ 0x32
 8001844:	2a00      	cmp	r2, #0
 8001846:	d168      	bne.n	800191a <ETH_SetMACConfig+0x19e>
 8001848:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
               ((uint32_t)macconf->SlowProtocolDetect << 17) |
 800184c:	4313      	orrs	r3, r2
               macconf->GiantPacketSizeLimit);
 800184e:	6b4a      	ldr	r2, [r1, #52]	@ 0x34
  macregval = ((macconf->ExtendedInterPacketGapVal << 25) |
 8001850:	4313      	orrs	r3, r2

  /* Write to MACECR */
  MODIFY_REG(heth->Instance->MACECR, ETH_MACECR_MASK, macregval);
 8001852:	6804      	ldr	r4, [r0, #0]
 8001854:	6862      	ldr	r2, [r4, #4]
 8001856:	f022 527c 	bic.w	r2, r2, #1056964608	@ 0x3f000000
 800185a:	f422 22ef 	bic.w	r2, r2, #489472	@ 0x77800
 800185e:	f422 62ff 	bic.w	r2, r2, #2040	@ 0x7f8
 8001862:	f022 0207 	bic.w	r2, r2, #7
 8001866:	4313      	orrs	r3, r2
 8001868:	6063      	str	r3, [r4, #4]

  /*------------------------ MACWTR Configuration --------------------*/
  macregval = (((uint32_t)macconf->ProgrammableWatchdog << 8) |
 800186a:	f891 2040 	ldrb.w	r2, [r1, #64]	@ 0x40
               macconf->WatchdogTimeout);
 800186e:	6c4b      	ldr	r3, [r1, #68]	@ 0x44
  macregval = (((uint32_t)macconf->ProgrammableWatchdog << 8) |
 8001870:	ea43 2202 	orr.w	r2, r3, r2, lsl #8

  /* Write to MACWTR */
  MODIFY_REG(heth->Instance->MACWTR, ETH_MACWTR_MASK, macregval);
 8001874:	6804      	ldr	r4, [r0, #0]
 8001876:	68e5      	ldr	r5, [r4, #12]
 8001878:	4b2b      	ldr	r3, [pc, #172]	@ (8001928 <ETH_SetMACConfig+0x1ac>)
 800187a:	402b      	ands	r3, r5
 800187c:	4313      	orrs	r3, r2
 800187e:	60e3      	str	r3, [r4, #12]

  /*------------------------ MACTFCR Configuration --------------------*/
  macregval = (((uint32_t)macconf->TransmitFlowControl << 1) |
 8001880:	f891 2054 	ldrb.w	r2, [r1, #84]	@ 0x54
               macconf->PauseLowThreshold |
 8001884:	6d0b      	ldr	r3, [r1, #80]	@ 0x50
  macregval = (((uint32_t)macconf->TransmitFlowControl << 1) |
 8001886:	ea43 0342 	orr.w	r3, r3, r2, lsl #1
               ((uint32_t)((macconf->ZeroQuantaPause == DISABLE) ? 1U : 0U) << 7) |
 800188a:	f891 204c 	ldrb.w	r2, [r1, #76]	@ 0x4c
 800188e:	2a00      	cmp	r2, #0
 8001890:	d145      	bne.n	800191e <ETH_SetMACConfig+0x1a2>
 8001892:	2280      	movs	r2, #128	@ 0x80
               macconf->PauseLowThreshold |
 8001894:	4313      	orrs	r3, r2
               (macconf->PauseTime << 16));
 8001896:	6c8a      	ldr	r2, [r1, #72]	@ 0x48
  macregval = (((uint32_t)macconf->TransmitFlowControl << 1) |
 8001898:	ea43 4302 	orr.w	r3, r3, r2, lsl #16

  /* Write to MACTFCR */
  MODIFY_REG(heth->Instance->MACTFCR, ETH_MACTFCR_MASK, macregval);
 800189c:	6804      	ldr	r4, [r0, #0]
 800189e:	6f22      	ldr	r2, [r4, #112]	@ 0x70
 80018a0:	f022 02f2 	bic.w	r2, r2, #242	@ 0xf2
 80018a4:	0412      	lsls	r2, r2, #16
 80018a6:	0c12      	lsrs	r2, r2, #16
 80018a8:	4313      	orrs	r3, r2
 80018aa:	6723      	str	r3, [r4, #112]	@ 0x70

  /*------------------------ MACRFCR Configuration --------------------*/
  macregval = ((uint32_t)macconf->ReceiveFlowControl |
 80018ac:	f891 2056 	ldrb.w	r2, [r1, #86]	@ 0x56
               ((uint32_t)macconf->UnicastPausePacketDetect << 1));
 80018b0:	f891 3055 	ldrb.w	r3, [r1, #85]	@ 0x55
  macregval = ((uint32_t)macconf->ReceiveFlowControl |
 80018b4:	ea42 0243 	orr.w	r2, r2, r3, lsl #1

  /* Write to MACRFCR */
  MODIFY_REG(heth->Instance->MACRFCR, ETH_MACRFCR_MASK, macregval);
 80018b8:	6804      	ldr	r4, [r0, #0]
 80018ba:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 80018be:	f023 0303 	bic.w	r3, r3, #3
 80018c2:	4313      	orrs	r3, r2
 80018c4:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90

  /*------------------------ MTLTQOMR Configuration --------------------*/
  /* Write to MTLTQOMR */
  MODIFY_REG(heth->Instance->MTLTQOMR, ETH_MTLTQOMR_MASK, macconf->TransmitQueueMode);
 80018c8:	6802      	ldr	r2, [r0, #0]
 80018ca:	f8d2 3d00 	ldr.w	r3, [r2, #3328]	@ 0xd00
 80018ce:	f023 0372 	bic.w	r3, r3, #114	@ 0x72
 80018d2:	6d8c      	ldr	r4, [r1, #88]	@ 0x58
 80018d4:	4323      	orrs	r3, r4
 80018d6:	f8c2 3d00 	str.w	r3, [r2, #3328]	@ 0xd00

  /*------------------------ MTLRQOMR Configuration --------------------*/
  macregval = (macconf->ReceiveQueueMode |
 80018da:	6dcb      	ldr	r3, [r1, #92]	@ 0x5c
               ((uint32_t)((macconf->DropTCPIPChecksumErrorPacket == DISABLE) ? 1U : 0U) << 6) |
 80018dc:	f891 2060 	ldrb.w	r2, [r1, #96]	@ 0x60
 80018e0:	b9fa      	cbnz	r2, 8001922 <ETH_SetMACConfig+0x1a6>
 80018e2:	2240      	movs	r2, #64	@ 0x40
  macregval = (macconf->ReceiveQueueMode |
 80018e4:	4313      	orrs	r3, r2
               ((uint32_t)macconf->ForwardRxErrorPacket << 4) |
 80018e6:	f891 2061 	ldrb.w	r2, [r1, #97]	@ 0x61
               ((uint32_t)((macconf->DropTCPIPChecksumErrorPacket == DISABLE) ? 1U : 0U) << 6) |
 80018ea:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
               ((uint32_t)macconf->ForwardRxUndersizedGoodPacket << 3));
 80018ee:	f891 2062 	ldrb.w	r2, [r1, #98]	@ 0x62
  macregval = (macconf->ReceiveQueueMode |
 80018f2:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3

  /* Write to MTLRQOMR */
  MODIFY_REG(heth->Instance->MTLRQOMR, ETH_MTLRQOMR_MASK, macregval);
 80018f6:	6801      	ldr	r1, [r0, #0]
 80018f8:	f8d1 2d30 	ldr.w	r2, [r1, #3376]	@ 0xd30
 80018fc:	f022 027b 	bic.w	r2, r2, #123	@ 0x7b
 8001900:	4313      	orrs	r3, r2
 8001902:	f8c1 3d30 	str.w	r3, [r1, #3376]	@ 0xd30
}
 8001906:	bc30      	pop	{r4, r5}
 8001908:	4770      	bx	lr
               ((uint32_t)((macconf->Watchdog == DISABLE) ? 1U : 0U) << 19) |
 800190a:	2200      	movs	r2, #0
 800190c:	e74f      	b.n	80017ae <ETH_SetMACConfig+0x32>
               ((uint32_t)((macconf->Jabber == DISABLE) ? 1U : 0U) << 17) |
 800190e:	2200      	movs	r2, #0
 8001910:	e754      	b.n	80017bc <ETH_SetMACConfig+0x40>
               ((uint32_t)((macconf->ReceiveOwn == DISABLE) ? 1U : 0U) << 10) |
 8001912:	2200      	movs	r2, #0
 8001914:	e766      	b.n	80017e4 <ETH_SetMACConfig+0x68>
               ((uint32_t)((macconf->RetryTransmission == DISABLE) ? 1U : 0U) << 8) |
 8001916:	2200      	movs	r2, #0
 8001918:	e76f      	b.n	80017fa <ETH_SetMACConfig+0x7e>
               ((uint32_t)((macconf->CRCCheckingRxPackets == DISABLE) ? 1U : 0U) << 16) |
 800191a:	2200      	movs	r2, #0
 800191c:	e796      	b.n	800184c <ETH_SetMACConfig+0xd0>
               ((uint32_t)((macconf->ZeroQuantaPause == DISABLE) ? 1U : 0U) << 7) |
 800191e:	2200      	movs	r2, #0
 8001920:	e7b8      	b.n	8001894 <ETH_SetMACConfig+0x118>
               ((uint32_t)((macconf->DropTCPIPChecksumErrorPacket == DISABLE) ? 1U : 0U) << 6) |
 8001922:	2200      	movs	r2, #0
 8001924:	e7de      	b.n	80018e4 <ETH_SetMACConfig+0x168>
 8001926:	bf00      	nop
 8001928:	fffffef0 	.word	0xfffffef0

0800192c <ETH_SetDMAConfig>:

static void ETH_SetDMAConfig(ETH_HandleTypeDef *heth,  ETH_DMAConfigTypeDef *dmaconf)
{
 800192c:	b410      	push	{r4}
  uint32_t dmaregval;

  /*------------------------ DMAMR Configuration --------------------*/
  MODIFY_REG(heth->Instance->DMAMR, ETH_DMAMR_MASK, dmaconf->DMAArbitration);
 800192e:	6802      	ldr	r2, [r0, #0]
 8001930:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 8001934:	6814      	ldr	r4, [r2, #0]
 8001936:	4b23      	ldr	r3, [pc, #140]	@ (80019c4 <ETH_SetDMAConfig+0x98>)
 8001938:	4023      	ands	r3, r4
 800193a:	680c      	ldr	r4, [r1, #0]
 800193c:	4323      	orrs	r3, r4
 800193e:	6013      	str	r3, [r2, #0]

  /*------------------------ DMASBMR Configuration --------------------*/
  dmaregval = (((uint32_t)dmaconf->AddressAlignedBeats << 12) |
 8001940:	790a      	ldrb	r2, [r1, #4]
               dmaconf->BurstMode |
 8001942:	688b      	ldr	r3, [r1, #8]
  dmaregval = (((uint32_t)dmaconf->AddressAlignedBeats << 12) |
 8001944:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
               ((uint32_t)dmaconf->RebuildINCRxBurst << 15));
 8001948:	7b0a      	ldrb	r2, [r1, #12]
  dmaregval = (((uint32_t)dmaconf->AddressAlignedBeats << 12) |
 800194a:	ea43 32c2 	orr.w	r2, r3, r2, lsl #15

  MODIFY_REG(heth->Instance->DMASBMR, ETH_DMASBMR_MASK, dmaregval);
 800194e:	6803      	ldr	r3, [r0, #0]
 8001950:	f503 5c80 	add.w	ip, r3, #4096	@ 0x1000
 8001954:	f8dc 4004 	ldr.w	r4, [ip, #4]
 8001958:	4b1b      	ldr	r3, [pc, #108]	@ (80019c8 <ETH_SetDMAConfig+0x9c>)
 800195a:	4023      	ands	r3, r4
 800195c:	4313      	orrs	r3, r2
 800195e:	f8cc 3004 	str.w	r3, [ip, #4]

  /*------------------------ DMACCR Configuration --------------------*/
  dmaregval = (((uint32_t)dmaconf->PBLx8Mode << 16) |
 8001962:	7b4a      	ldrb	r2, [r1, #13]
               dmaconf->MaximumSegmentSize);
 8001964:	6a0b      	ldr	r3, [r1, #32]
  dmaregval = (((uint32_t)dmaconf->PBLx8Mode << 16) |
 8001966:	ea43 4c02 	orr.w	ip, r3, r2, lsl #16

  MODIFY_REG(heth->Instance->DMACCR, ETH_DMACCR_MASK, dmaregval);
 800196a:	6802      	ldr	r2, [r0, #0]
 800196c:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 8001970:	f8d2 4100 	ldr.w	r4, [r2, #256]	@ 0x100
 8001974:	4b15      	ldr	r3, [pc, #84]	@ (80019cc <ETH_SetDMAConfig+0xa0>)
 8001976:	4023      	ands	r3, r4
 8001978:	ea43 030c 	orr.w	r3, r3, ip
 800197c:	f8c2 3100 	str.w	r3, [r2, #256]	@ 0x100

  /*------------------------ DMACTCR Configuration --------------------*/
  dmaregval = (dmaconf->TxDMABurstLength |
 8001980:	690b      	ldr	r3, [r1, #16]
               ((uint32_t)dmaconf->SecondPacketOperate << 4) |
 8001982:	7d0a      	ldrb	r2, [r1, #20]
  dmaregval = (dmaconf->TxDMABurstLength |
 8001984:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
               ((uint32_t)dmaconf->TCPSegmentation << 12));
 8001988:	7f4a      	ldrb	r2, [r1, #29]
  dmaregval = (dmaconf->TxDMABurstLength |
 800198a:	ea43 3202 	orr.w	r2, r3, r2, lsl #12

  MODIFY_REG(heth->Instance->DMACTCR, ETH_DMACTCR_MASK, dmaregval);
 800198e:	6803      	ldr	r3, [r0, #0]
 8001990:	f503 5c80 	add.w	ip, r3, #4096	@ 0x1000
 8001994:	f8dc 4104 	ldr.w	r4, [ip, #260]	@ 0x104
 8001998:	4b0d      	ldr	r3, [pc, #52]	@ (80019d0 <ETH_SetDMAConfig+0xa4>)
 800199a:	4023      	ands	r3, r4
 800199c:	4313      	orrs	r3, r2
 800199e:	f8cc 3104 	str.w	r3, [ip, #260]	@ 0x104

  /*------------------------ DMACRCR Configuration --------------------*/
  dmaregval = (((uint32_t)dmaconf->FlushRxPacket  << 31) |
 80019a2:	7f0b      	ldrb	r3, [r1, #28]
               dmaconf->RxDMABurstLength);
 80019a4:	6989      	ldr	r1, [r1, #24]
  dmaregval = (((uint32_t)dmaconf->FlushRxPacket  << 31) |
 80019a6:	ea41 71c3 	orr.w	r1, r1, r3, lsl #31

  /* Write to DMACRCR */
  MODIFY_REG(heth->Instance->DMACRCR, ETH_DMACRCR_MASK, dmaregval);
 80019aa:	6802      	ldr	r2, [r0, #0]
 80019ac:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 80019b0:	f8d2 0108 	ldr.w	r0, [r2, #264]	@ 0x108
 80019b4:	4b07      	ldr	r3, [pc, #28]	@ (80019d4 <ETH_SetDMAConfig+0xa8>)
 80019b6:	4003      	ands	r3, r0
 80019b8:	430b      	orrs	r3, r1
 80019ba:	f8c2 3108 	str.w	r3, [r2, #264]	@ 0x108
}
 80019be:	f85d 4b04 	ldr.w	r4, [sp], #4
 80019c2:	4770      	bx	lr
 80019c4:	ffff87fd 	.word	0xffff87fd
 80019c8:	ffff2ffe 	.word	0xffff2ffe
 80019cc:	fffec000 	.word	0xfffec000
 80019d0:	ffc0efef 	.word	0xffc0efef
 80019d4:	7fc0ffff 	.word	0x7fc0ffff

080019d8 <ETH_MACDMAConfig>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  */
static void ETH_MACDMAConfig(ETH_HandleTypeDef *heth)
{
 80019d8:	b570      	push	{r4, r5, r6, lr}
 80019da:	b0a2      	sub	sp, #136	@ 0x88
 80019dc:	4606      	mov	r6, r0
  ETH_MACConfigTypeDef macDefaultConf;
  ETH_DMAConfigTypeDef dmaDefaultConf;

  /*--------------- ETHERNET MAC registers default Configuration --------------*/
  macDefaultConf.AutomaticPadCRCStrip = ENABLE;
 80019de:	2501      	movs	r5, #1
 80019e0:	f88d 5033 	strb.w	r5, [sp, #51]	@ 0x33
  macDefaultConf.BackOffLimit = ETH_BACKOFFLIMIT_10;
 80019e4:	2400      	movs	r4, #0
 80019e6:	9412      	str	r4, [sp, #72]	@ 0x48
  macDefaultConf.CarrierSenseBeforeTransmit = DISABLE;
 80019e8:	f88d 4041 	strb.w	r4, [sp, #65]	@ 0x41
  macDefaultConf.CarrierSenseDuringTransmit = DISABLE;
 80019ec:	f88d 4043 	strb.w	r4, [sp, #67]	@ 0x43
  macDefaultConf.ChecksumOffload = ENABLE;
 80019f0:	f88d 5028 	strb.w	r5, [sp, #40]	@ 0x28
  macDefaultConf.CRCCheckingRxPackets = ENABLE;
 80019f4:	f88d 5056 	strb.w	r5, [sp, #86]	@ 0x56
  macDefaultConf.CRCStripTypePacket = ENABLE;
 80019f8:	f88d 5032 	strb.w	r5, [sp, #50]	@ 0x32
  macDefaultConf.DeferralCheck = DISABLE;
 80019fc:	f88d 404c 	strb.w	r4, [sp, #76]	@ 0x4c
  macDefaultConf.DropTCPIPChecksumErrorPacket = ENABLE;
 8001a00:	f88d 5084 	strb.w	r5, [sp, #132]	@ 0x84
  macDefaultConf.DuplexMode = ETH_FULLDUPLEX_MODE;
 8001a04:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 8001a08:	930f      	str	r3, [sp, #60]	@ 0x3c
  macDefaultConf.ExtendedInterPacketGap = DISABLE;
 8001a0a:	f88d 405c 	strb.w	r4, [sp, #92]	@ 0x5c
  macDefaultConf.ExtendedInterPacketGapVal = 0x0;
 8001a0e:	9418      	str	r4, [sp, #96]	@ 0x60
  macDefaultConf.ForwardRxErrorPacket = DISABLE;
 8001a10:	f88d 4085 	strb.w	r4, [sp, #133]	@ 0x85
  macDefaultConf.ForwardRxUndersizedGoodPacket = DISABLE;
 8001a14:	f88d 4086 	strb.w	r4, [sp, #134]	@ 0x86
  macDefaultConf.GiantPacketSizeLimit = 0x618;
 8001a18:	f44f 63c3 	mov.w	r3, #1560	@ 0x618
 8001a1c:	9316      	str	r3, [sp, #88]	@ 0x58
  macDefaultConf.GiantPacketSizeLimitControl = DISABLE;
 8001a1e:	f88d 4030 	strb.w	r4, [sp, #48]	@ 0x30
  macDefaultConf.InterPacketGapVal = ETH_INTERPACKETGAP_96BIT;
 8001a22:	940b      	str	r4, [sp, #44]	@ 0x2c
  macDefaultConf.Jabber = ENABLE;
 8001a24:	f88d 5035 	strb.w	r5, [sp, #53]	@ 0x35
  macDefaultConf.JumboPacket = DISABLE;
 8001a28:	f88d 4036 	strb.w	r4, [sp, #54]	@ 0x36
  macDefaultConf.LoopbackMode = DISABLE;
 8001a2c:	f88d 4040 	strb.w	r4, [sp, #64]	@ 0x40
  macDefaultConf.PauseLowThreshold = ETH_PAUSELOWTHRESHOLD_MINUS_4;
 8001a30:	941d      	str	r4, [sp, #116]	@ 0x74
  macDefaultConf.PauseTime = 0x0;
 8001a32:	941b      	str	r4, [sp, #108]	@ 0x6c
  macDefaultConf.PreambleLength = ETH_PREAMBLELENGTH_7;
 8001a34:	9414      	str	r4, [sp, #80]	@ 0x50
  macDefaultConf.ProgrammableWatchdog = DISABLE;
 8001a36:	f88d 4064 	strb.w	r4, [sp, #100]	@ 0x64
  macDefaultConf.ReceiveFlowControl = DISABLE;
 8001a3a:	f88d 407a 	strb.w	r4, [sp, #122]	@ 0x7a
  macDefaultConf.ReceiveOwn = ENABLE;
 8001a3e:	f88d 5042 	strb.w	r5, [sp, #66]	@ 0x42
  macDefaultConf.ReceiveQueueMode = ETH_RECEIVESTOREFORWARD;
 8001a42:	2320      	movs	r3, #32
 8001a44:	9320      	str	r3, [sp, #128]	@ 0x80
  macDefaultConf.RetryTransmission = ENABLE;
 8001a46:	f88d 5044 	strb.w	r5, [sp, #68]	@ 0x44
  macDefaultConf.SlowProtocolDetect = DISABLE;
 8001a4a:	f88d 4055 	strb.w	r4, [sp, #85]	@ 0x55
  macDefaultConf.SourceAddrControl = ETH_SOURCEADDRESS_REPLACE_ADDR0;
 8001a4e:	f04f 5340 	mov.w	r3, #805306368	@ 0x30000000
 8001a52:	9309      	str	r3, [sp, #36]	@ 0x24
  macDefaultConf.Speed = ETH_SPEED_100M;
 8001a54:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
 8001a58:	930e      	str	r3, [sp, #56]	@ 0x38
  macDefaultConf.Support2KPacket = DISABLE;
 8001a5a:	f88d 4031 	strb.w	r4, [sp, #49]	@ 0x31
  macDefaultConf.TransmitQueueMode = ETH_TRANSMITSTOREFORWARD;
 8001a5e:	2302      	movs	r3, #2
 8001a60:	931f      	str	r3, [sp, #124]	@ 0x7c
  macDefaultConf.TransmitFlowControl = DISABLE;
 8001a62:	f88d 4078 	strb.w	r4, [sp, #120]	@ 0x78
  macDefaultConf.UnicastPausePacketDetect = DISABLE;
 8001a66:	f88d 4079 	strb.w	r4, [sp, #121]	@ 0x79
  macDefaultConf.UnicastSlowProtocolPacketDetect = DISABLE;
 8001a6a:	f88d 4054 	strb.w	r4, [sp, #84]	@ 0x54
  macDefaultConf.Watchdog = ENABLE;
 8001a6e:	f88d 5034 	strb.w	r5, [sp, #52]	@ 0x34
  macDefaultConf.WatchdogTimeout =  ETH_MACWTR_WTO_2KB;
 8001a72:	941a      	str	r4, [sp, #104]	@ 0x68
  macDefaultConf.ZeroQuantaPause = ENABLE;
 8001a74:	f88d 5070 	strb.w	r5, [sp, #112]	@ 0x70

  /* MAC default configuration */
  ETH_SetMACConfig(heth, &macDefaultConf);
 8001a78:	a909      	add	r1, sp, #36	@ 0x24
 8001a7a:	f7ff fe7f 	bl	800177c <ETH_SetMACConfig>

  /*--------------- ETHERNET DMA registers default Configuration --------------*/
  dmaDefaultConf.AddressAlignedBeats = ENABLE;
 8001a7e:	f88d 5004 	strb.w	r5, [sp, #4]
  dmaDefaultConf.BurstMode = ETH_BURSTLENGTH_FIXED;
 8001a82:	9502      	str	r5, [sp, #8]
  dmaDefaultConf.DMAArbitration = ETH_DMAARBITRATION_RX1_TX1;
 8001a84:	9400      	str	r4, [sp, #0]
  dmaDefaultConf.FlushRxPacket = DISABLE;
 8001a86:	f88d 401c 	strb.w	r4, [sp, #28]
  dmaDefaultConf.PBLx8Mode = DISABLE;
 8001a8a:	f88d 400d 	strb.w	r4, [sp, #13]
  dmaDefaultConf.RebuildINCRxBurst = DISABLE;
 8001a8e:	f88d 400c 	strb.w	r4, [sp, #12]
  dmaDefaultConf.RxDMABurstLength = ETH_RXDMABURSTLENGTH_32BEAT;
 8001a92:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8001a96:	9306      	str	r3, [sp, #24]
  dmaDefaultConf.SecondPacketOperate = DISABLE;
 8001a98:	f88d 4014 	strb.w	r4, [sp, #20]
  dmaDefaultConf.TxDMABurstLength = ETH_TXDMABURSTLENGTH_32BEAT;
 8001a9c:	9304      	str	r3, [sp, #16]
  dmaDefaultConf.TCPSegmentation = DISABLE;
 8001a9e:	f88d 401d 	strb.w	r4, [sp, #29]
  dmaDefaultConf.MaximumSegmentSize = ETH_SEGMENT_SIZE_DEFAULT;
 8001aa2:	f44f 7306 	mov.w	r3, #536	@ 0x218
 8001aa6:	9308      	str	r3, [sp, #32]

  /* DMA default configuration */
  ETH_SetDMAConfig(heth, &dmaDefaultConf);
 8001aa8:	4669      	mov	r1, sp
 8001aaa:	4630      	mov	r0, r6
 8001aac:	f7ff ff3e 	bl	800192c <ETH_SetDMAConfig>
}
 8001ab0:	b022      	add	sp, #136	@ 0x88
 8001ab2:	bd70      	pop	{r4, r5, r6, pc}

08001ab4 <ETH_DMATxDescListInit>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
static void ETH_DMATxDescListInit(ETH_HandleTypeDef *heth)
{
 8001ab4:	b410      	push	{r4}
  ETH_DMADescTypeDef *dmatxdesc;
  uint32_t i;

  /* Fill each DMATxDesc descriptor with the right values */
  for (i = 0; i < (uint32_t)ETH_TX_DESC_CNT; i++)
 8001ab6:	2200      	movs	r2, #0
 8001ab8:	e010      	b.n	8001adc <ETH_DMATxDescListInit+0x28>
  {
    dmatxdesc = heth->Init.TxDesc + i;
 8001aba:	68c4      	ldr	r4, [r0, #12]
 8001abc:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 8001ac0:	ea4f 0cc3 	mov.w	ip, r3, lsl #3
 8001ac4:	eb04 03c3 	add.w	r3, r4, r3, lsl #3

    WRITE_REG(dmatxdesc->DESC0, 0x0);
 8001ac8:	2100      	movs	r1, #0
 8001aca:	f844 100c 	str.w	r1, [r4, ip]
    WRITE_REG(dmatxdesc->DESC1, 0x0);
 8001ace:	6059      	str	r1, [r3, #4]
    WRITE_REG(dmatxdesc->DESC2, 0x0);
 8001ad0:	6099      	str	r1, [r3, #8]
    WRITE_REG(dmatxdesc->DESC3, 0x0);
 8001ad2:	60d9      	str	r1, [r3, #12]

    WRITE_REG(heth->TxDescList.TxDesc[i], (uint32_t)dmatxdesc);
 8001ad4:	1d91      	adds	r1, r2, #6
 8001ad6:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
  for (i = 0; i < (uint32_t)ETH_TX_DESC_CNT; i++)
 8001ada:	3201      	adds	r2, #1
 8001adc:	2a03      	cmp	r2, #3
 8001ade:	d9ec      	bls.n	8001aba <ETH_DMATxDescListInit+0x6>

  }

  heth->TxDescList.CurTxDesc = 0;
 8001ae0:	2300      	movs	r3, #0
 8001ae2:	6283      	str	r3, [r0, #40]	@ 0x28

  /* Set Transmit Descriptor Ring Length */
  WRITE_REG(heth->Instance->DMACTDRLR, (ETH_TX_DESC_CNT - 1U));
 8001ae4:	6803      	ldr	r3, [r0, #0]
 8001ae6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8001aea:	2203      	movs	r2, #3
 8001aec:	f8c3 212c 	str.w	r2, [r3, #300]	@ 0x12c

  /* Set Transmit Descriptor List Address */
  WRITE_REG(heth->Instance->DMACTDLAR, (uint32_t) heth->Init.TxDesc);
 8001af0:	68c2      	ldr	r2, [r0, #12]
 8001af2:	6803      	ldr	r3, [r0, #0]
 8001af4:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8001af8:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114

  /* Set Transmit Descriptor Tail pointer */
  WRITE_REG(heth->Instance->DMACTDTPR, (uint32_t) heth->Init.TxDesc);
 8001afc:	68c2      	ldr	r2, [r0, #12]
 8001afe:	6803      	ldr	r3, [r0, #0]
 8001b00:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8001b04:	f8c3 2120 	str.w	r2, [r3, #288]	@ 0x120
}
 8001b08:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001b0c:	4770      	bx	lr

08001b0e <ETH_DMARxDescListInit>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
static void ETH_DMARxDescListInit(ETH_HandleTypeDef *heth)
{
 8001b0e:	b410      	push	{r4}
  ETH_DMADescTypeDef *dmarxdesc;
  uint32_t i;

  for (i = 0; i < (uint32_t)ETH_RX_DESC_CNT; i++)
 8001b10:	2100      	movs	r1, #0
 8001b12:	e013      	b.n	8001b3c <ETH_DMARxDescListInit+0x2e>
  {
    dmarxdesc =  heth->Init.RxDesc + i;
 8001b14:	6904      	ldr	r4, [r0, #16]
 8001b16:	eb01 0341 	add.w	r3, r1, r1, lsl #1
 8001b1a:	ea4f 0cc3 	mov.w	ip, r3, lsl #3
 8001b1e:	eb04 03c3 	add.w	r3, r4, r3, lsl #3

    WRITE_REG(dmarxdesc->DESC0, 0x0);
 8001b22:	2200      	movs	r2, #0
 8001b24:	f844 200c 	str.w	r2, [r4, ip]
    WRITE_REG(dmarxdesc->DESC1, 0x0);
 8001b28:	605a      	str	r2, [r3, #4]
    WRITE_REG(dmarxdesc->DESC2, 0x0);
 8001b2a:	609a      	str	r2, [r3, #8]
    WRITE_REG(dmarxdesc->DESC3, 0x0);
 8001b2c:	60da      	str	r2, [r3, #12]
    WRITE_REG(dmarxdesc->BackupAddr0, 0x0);
 8001b2e:	611a      	str	r2, [r3, #16]
    WRITE_REG(dmarxdesc->BackupAddr1, 0x0);
 8001b30:	615a      	str	r2, [r3, #20]


    /* Set Rx descritors addresses */
    WRITE_REG(heth->RxDescList.RxDesc[i], (uint32_t)dmarxdesc);
 8001b32:	f101 0212 	add.w	r2, r1, #18
 8001b36:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
  for (i = 0; i < (uint32_t)ETH_RX_DESC_CNT; i++)
 8001b3a:	3101      	adds	r1, #1
 8001b3c:	2903      	cmp	r1, #3
 8001b3e:	d9e9      	bls.n	8001b14 <ETH_DMARxDescListInit+0x6>

  }

  WRITE_REG(heth->RxDescList.RxDescIdx, 0);
 8001b40:	2300      	movs	r3, #0
 8001b42:	65c3      	str	r3, [r0, #92]	@ 0x5c
  WRITE_REG(heth->RxDescList.RxDescCnt, 0);
 8001b44:	6603      	str	r3, [r0, #96]	@ 0x60
  WRITE_REG(heth->RxDescList.RxBuildDescIdx, 0);
 8001b46:	6683      	str	r3, [r0, #104]	@ 0x68
  WRITE_REG(heth->RxDescList.RxBuildDescCnt, 0);
 8001b48:	66c3      	str	r3, [r0, #108]	@ 0x6c
  WRITE_REG(heth->RxDescList.ItMode, 0);
 8001b4a:	6583      	str	r3, [r0, #88]	@ 0x58

  /* Set Receive Descriptor Ring Length */
  WRITE_REG(heth->Instance->DMACRDRLR, ((uint32_t)(ETH_RX_DESC_CNT - 1U)));
 8001b4c:	6803      	ldr	r3, [r0, #0]
 8001b4e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8001b52:	2203      	movs	r2, #3
 8001b54:	f8c3 2130 	str.w	r2, [r3, #304]	@ 0x130

  /* Set Receive Descriptor List Address */
  WRITE_REG(heth->Instance->DMACRDLAR, (uint32_t) heth->Init.RxDesc);
 8001b58:	6902      	ldr	r2, [r0, #16]
 8001b5a:	6803      	ldr	r3, [r0, #0]
 8001b5c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8001b60:	f8c3 211c 	str.w	r2, [r3, #284]	@ 0x11c

  /* Set Receive Descriptor Tail pointer Address */
  WRITE_REG(heth->Instance->DMACRDTPR, ((uint32_t)(heth->Init.RxDesc + (uint32_t)(ETH_RX_DESC_CNT - 1U))));
 8001b64:	6903      	ldr	r3, [r0, #16]
 8001b66:	f103 0248 	add.w	r2, r3, #72	@ 0x48
 8001b6a:	6803      	ldr	r3, [r0, #0]
 8001b6c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8001b70:	f8c3 2128 	str.w	r2, [r3, #296]	@ 0x128
}
 8001b74:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001b78:	4770      	bx	lr
	...

08001b7c <ETH_Prepare_Tx_Descriptors>:
  * @param  pTxConfig: Tx packet configuration
  * @param  ItMode: Enable or disable Tx EOT interrept
  * @retval Status
  */
static uint32_t ETH_Prepare_Tx_Descriptors(ETH_HandleTypeDef *heth, ETH_TxPacketConfig *pTxConfig, uint32_t ItMode)
{
 8001b7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001b80:	4690      	mov	r8, r2
  ETH_TxDescListTypeDef *dmatxdesclist = &heth->TxDescList;
  uint32_t descidx = dmatxdesclist->CurTxDesc;
 8001b82:	6a84      	ldr	r4, [r0, #40]	@ 0x28
  uint32_t firstdescidx = dmatxdesclist->CurTxDesc;
  uint32_t idx;
  uint32_t descnbr = 0;
  ETH_DMADescTypeDef *dmatxdesc = (ETH_DMADescTypeDef *)dmatxdesclist->TxDesc[descidx];
 8001b84:	eb00 0384 	add.w	r3, r0, r4, lsl #2
 8001b88:	699b      	ldr	r3, [r3, #24]

  ETH_BufferTypeDef  *txbuffer = pTxConfig->TxBuffer;
 8001b8a:	f8d1 c008 	ldr.w	ip, [r1, #8]
  uint32_t           bd_count = 0;

  /* Current Tx Descriptor Owned by DMA: cannot be used by the application  */
  if ((READ_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCWBF_OWN) == ETH_DMATXNDESCWBF_OWN)
 8001b8e:	68da      	ldr	r2, [r3, #12]
 8001b90:	2a00      	cmp	r2, #0
 8001b92:	f2c0 818d 	blt.w	8001eb0 <ETH_Prepare_Tx_Descriptors+0x334>
      || (dmatxdesclist->PacketAddress[descidx] != NULL))
 8001b96:	1d22      	adds	r2, r4, #4
 8001b98:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8001b9c:	69d2      	ldr	r2, [r2, #28]
 8001b9e:	2a00      	cmp	r2, #0
 8001ba0:	f040 8188 	bne.w	8001eb4 <ETH_Prepare_Tx_Descriptors+0x338>

  /***************************************************************************/
  /*****************    Context descriptor configuration (Optional) **********/
  /***************************************************************************/
  /* If VLAN tag is enabled for this packet */
  if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_VLANTAG) != (uint32_t)RESET)
 8001ba4:	680a      	ldr	r2, [r1, #0]
 8001ba6:	f012 0f04 	tst.w	r2, #4
 8001baa:	d02c      	beq.n	8001c06 <ETH_Prepare_Tx_Descriptors+0x8a>
  {
    /* Set vlan tag value */
    MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXCDESC_VT, pTxConfig->VlanTag);
 8001bac:	68da      	ldr	r2, [r3, #12]
 8001bae:	f36f 020f 	bfc	r2, #0, #16
 8001bb2:	6a4d      	ldr	r5, [r1, #36]	@ 0x24
 8001bb4:	432a      	orrs	r2, r5
 8001bb6:	60da      	str	r2, [r3, #12]
    /* Set vlan tag valid bit */
    SET_BIT(dmatxdesc->DESC3, ETH_DMATXCDESC_VLTV);
 8001bb8:	68da      	ldr	r2, [r3, #12]
 8001bba:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 8001bbe:	60da      	str	r2, [r3, #12]
    /* Set the descriptor as the vlan input source */
    SET_BIT(heth->Instance->MACVIR, ETH_MACVIR_VLTI);
 8001bc0:	6805      	ldr	r5, [r0, #0]
 8001bc2:	6e2a      	ldr	r2, [r5, #96]	@ 0x60
 8001bc4:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
 8001bc8:	662a      	str	r2, [r5, #96]	@ 0x60

    /* if inner VLAN is enabled */
    if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_INNERVLANTAG) != (uint32_t)RESET)
 8001bca:	680a      	ldr	r2, [r1, #0]
 8001bcc:	f012 0f08 	tst.w	r2, #8
 8001bd0:	d019      	beq.n	8001c06 <ETH_Prepare_Tx_Descriptors+0x8a>
    {
      /* Set inner vlan tag value */
      MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXCDESC_IVT, (pTxConfig->InnerVlanTag << 16));
 8001bd2:	689a      	ldr	r2, [r3, #8]
 8001bd4:	b292      	uxth	r2, r2
 8001bd6:	6acd      	ldr	r5, [r1, #44]	@ 0x2c
 8001bd8:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
 8001bdc:	609a      	str	r2, [r3, #8]
      /* Set inner vlan tag valid bit */
      SET_BIT(dmatxdesc->DESC3, ETH_DMATXCDESC_IVLTV);
 8001bde:	68da      	ldr	r2, [r3, #12]
 8001be0:	f442 3200 	orr.w	r2, r2, #131072	@ 0x20000
 8001be4:	60da      	str	r2, [r3, #12]

      /* Set Vlan Tag control */
      MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXCDESC_IVTIR, pTxConfig->InnerVlanCtrl);
 8001be6:	68da      	ldr	r2, [r3, #12]
 8001be8:	f422 2240 	bic.w	r2, r2, #786432	@ 0xc0000
 8001bec:	6b0d      	ldr	r5, [r1, #48]	@ 0x30
 8001bee:	432a      	orrs	r2, r5
 8001bf0:	60da      	str	r2, [r3, #12]

      /* Set the descriptor as the inner vlan input source */
      SET_BIT(heth->Instance->MACIVIR, ETH_MACIVIR_VLTI);
 8001bf2:	6805      	ldr	r5, [r0, #0]
 8001bf4:	6e6a      	ldr	r2, [r5, #100]	@ 0x64
 8001bf6:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
 8001bfa:	666a      	str	r2, [r5, #100]	@ 0x64
      /* Enable double VLAN processing */
      SET_BIT(heth->Instance->MACVTR, ETH_MACVTR_EDVLP);
 8001bfc:	6805      	ldr	r5, [r0, #0]
 8001bfe:	6d2a      	ldr	r2, [r5, #80]	@ 0x50
 8001c00:	f042 6280 	orr.w	r2, r2, #67108864	@ 0x4000000
 8001c04:	652a      	str	r2, [r5, #80]	@ 0x50
    }
  }

  /* if tcp segmentation is enabled for this packet */
  if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_TSO) != (uint32_t)RESET)
 8001c06:	680a      	ldr	r2, [r1, #0]
 8001c08:	f012 0f10 	tst.w	r2, #16
 8001c0c:	d009      	beq.n	8001c22 <ETH_Prepare_Tx_Descriptors+0xa6>
  {
    /* Set MSS value */
    MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXCDESC_MSS, pTxConfig->MaxSegmentSize);
 8001c0e:	689a      	ldr	r2, [r3, #8]
 8001c10:	f36f 020d 	bfc	r2, #0, #14
 8001c14:	698d      	ldr	r5, [r1, #24]
 8001c16:	432a      	orrs	r2, r5
 8001c18:	609a      	str	r2, [r3, #8]
    /* Set MSS valid bit */
    SET_BIT(dmatxdesc->DESC3, ETH_DMATXCDESC_TCMSSV);
 8001c1a:	68da      	ldr	r2, [r3, #12]
 8001c1c:	f042 6280 	orr.w	r2, r2, #67108864	@ 0x4000000
 8001c20:	60da      	str	r2, [r3, #12]
  }

  if ((READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_VLANTAG) != (uint32_t)RESET)
      || (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_TSO) != (uint32_t)RESET))
 8001c22:	680a      	ldr	r2, [r1, #0]
  if ((READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_VLANTAG) != (uint32_t)RESET)
 8001c24:	f012 0214 	ands.w	r2, r2, #20
 8001c28:	d020      	beq.n	8001c6c <ETH_Prepare_Tx_Descriptors+0xf0>
  {
    /* Set as context descriptor */
    SET_BIT(dmatxdesc->DESC3, ETH_DMATXCDESC_CTXT);
 8001c2a:	68da      	ldr	r2, [r3, #12]
 8001c2c:	f042 4280 	orr.w	r2, r2, #1073741824	@ 0x40000000
 8001c30:	60da      	str	r2, [r3, #12]
 8001c32:	f3bf 8f5f 	dmb	sy
    /* Ensure rest of descriptor is written to RAM before the OWN bit */
    __DMB();
    /* Set own bit */
    SET_BIT(dmatxdesc->DESC3, ETH_DMATXCDESC_OWN);
 8001c36:	68da      	ldr	r2, [r3, #12]
 8001c38:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
 8001c3c:	60da      	str	r2, [r3, #12]
    /* Increment current tx descriptor index */
    INCR_TX_DESC_INDEX(descidx, 1U);
 8001c3e:	1c66      	adds	r6, r4, #1
 8001c40:	2e03      	cmp	r6, #3
 8001c42:	d900      	bls.n	8001c46 <ETH_Prepare_Tx_Descriptors+0xca>
 8001c44:	1ee6      	subs	r6, r4, #3
    /* Get current descriptor address */
    dmatxdesc = (ETH_DMADescTypeDef *)dmatxdesclist->TxDesc[descidx];
 8001c46:	eb00 0386 	add.w	r3, r0, r6, lsl #2
 8001c4a:	699b      	ldr	r3, [r3, #24]

    descnbr += 1U;

    /* Current Tx Descriptor Owned by DMA: cannot be used by the application  */
    if (READ_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCWBF_OWN) == ETH_DMATXNDESCWBF_OWN)
 8001c4c:	68da      	ldr	r2, [r3, #12]
 8001c4e:	2a00      	cmp	r2, #0
 8001c50:	db01      	blt.n	8001c56 <ETH_Prepare_Tx_Descriptors+0xda>
    descnbr += 1U;
 8001c52:	2201      	movs	r2, #1
 8001c54:	e00b      	b.n	8001c6e <ETH_Prepare_Tx_Descriptors+0xf2>
    {
      dmatxdesc = (ETH_DMADescTypeDef *)dmatxdesclist->TxDesc[firstdescidx];
 8001c56:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 8001c5a:	69a2      	ldr	r2, [r4, #24]
 8001c5c:	f3bf 8f5f 	dmb	sy
      /* Ensure rest of descriptor is written to RAM before the OWN bit */
      __DMB();
      /* Clear own bit */
      CLEAR_BIT(dmatxdesc->DESC3, ETH_DMATXCDESC_OWN);
 8001c60:	68d3      	ldr	r3, [r2, #12]
 8001c62:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 8001c66:	60d3      	str	r3, [r2, #12]

      return HAL_ETH_ERROR_BUSY;
 8001c68:	2002      	movs	r0, #2
 8001c6a:	e124      	b.n	8001eb6 <ETH_Prepare_Tx_Descriptors+0x33a>
  uint32_t descidx = dmatxdesclist->CurTxDesc;
 8001c6c:	4626      	mov	r6, r4

  /***************************************************************************/
  /*****************    Normal descriptors configuration     *****************/
  /***************************************************************************/

  descnbr += 1U;
 8001c6e:	f102 0e01 	add.w	lr, r2, #1

  /* Set header or buffer 1 address */
  WRITE_REG(dmatxdesc->DESC0, (uint32_t)txbuffer->buffer);
 8001c72:	f8dc 2000 	ldr.w	r2, [ip]
 8001c76:	601a      	str	r2, [r3, #0]
  /* Set header or buffer 1 Length */
  MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_B1L, txbuffer->len);
 8001c78:	689a      	ldr	r2, [r3, #8]
 8001c7a:	f36f 020d 	bfc	r2, #0, #14
 8001c7e:	f8dc 5004 	ldr.w	r5, [ip, #4]
 8001c82:	432a      	orrs	r2, r5
 8001c84:	609a      	str	r2, [r3, #8]

  if (txbuffer->next != NULL)
 8001c86:	f8dc 2008 	ldr.w	r2, [ip, #8]
 8001c8a:	2a00      	cmp	r2, #0
 8001c8c:	d048      	beq.n	8001d20 <ETH_Prepare_Tx_Descriptors+0x1a4>
  {
    txbuffer = txbuffer->next;
    /* Set buffer 2 address */
    WRITE_REG(dmatxdesc->DESC1, (uint32_t)txbuffer->buffer);
 8001c8e:	6815      	ldr	r5, [r2, #0]
 8001c90:	605d      	str	r5, [r3, #4]
    /* Set buffer 2 Length */
    MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_B2L, (txbuffer->len << 16));
 8001c92:	689d      	ldr	r5, [r3, #8]
 8001c94:	f8df c224 	ldr.w	ip, [pc, #548]	@ 8001ebc <ETH_Prepare_Tx_Descriptors+0x340>
 8001c98:	ea05 0c0c 	and.w	ip, r5, ip
 8001c9c:	6855      	ldr	r5, [r2, #4]
 8001c9e:	ea4c 4505 	orr.w	r5, ip, r5, lsl #16
 8001ca2:	609d      	str	r5, [r3, #8]
    WRITE_REG(dmatxdesc->DESC1, 0x0);
    /* Set buffer 2 Length */
    MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_B2L, 0x0U);
  }

  if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_TSO) != (uint32_t)RESET)
 8001ca4:	680d      	ldr	r5, [r1, #0]
 8001ca6:	f015 0f10 	tst.w	r5, #16
 8001caa:	d041      	beq.n	8001d30 <ETH_Prepare_Tx_Descriptors+0x1b4>
  {
    /* Set TCP Header length */
    MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_THL, (pTxConfig->TCPHeaderLen << 19));
 8001cac:	68dd      	ldr	r5, [r3, #12]
 8001cae:	f425 0cf0 	bic.w	ip, r5, #7864320	@ 0x780000
 8001cb2:	6a0d      	ldr	r5, [r1, #32]
 8001cb4:	ea4c 45c5 	orr.w	r5, ip, r5, lsl #19
 8001cb8:	60dd      	str	r5, [r3, #12]
    /* Set TCP payload length */
    MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_TPL, pTxConfig->PayloadLen);
 8001cba:	68dd      	ldr	r5, [r3, #12]
 8001cbc:	f8df c200 	ldr.w	ip, [pc, #512]	@ 8001ec0 <ETH_Prepare_Tx_Descriptors+0x344>
 8001cc0:	ea05 0c0c 	and.w	ip, r5, ip
 8001cc4:	69cd      	ldr	r5, [r1, #28]
 8001cc6:	ea4c 0505 	orr.w	r5, ip, r5
 8001cca:	60dd      	str	r5, [r3, #12]
    /* Set TCP Segmentation Enabled bit */
    SET_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_TSE);
 8001ccc:	68dd      	ldr	r5, [r3, #12]
 8001cce:	f445 2580 	orr.w	r5, r5, #262144	@ 0x40000
 8001cd2:	60dd      	str	r5, [r3, #12]
    {
      MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_CPC, pTxConfig->CRCPadCtrl);
    }
  }

  if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_VLANTAG) != (uint32_t)RESET)
 8001cd4:	680d      	ldr	r5, [r1, #0]
 8001cd6:	f015 0f04 	tst.w	r5, #4
 8001cda:	d006      	beq.n	8001cea <ETH_Prepare_Tx_Descriptors+0x16e>
  {
    /* Set Vlan Tag control */
    MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_VTIR, pTxConfig->VlanCtrl);
 8001cdc:	689d      	ldr	r5, [r3, #8]
 8001cde:	f425 4c40 	bic.w	ip, r5, #49152	@ 0xc000
 8001ce2:	6a8d      	ldr	r5, [r1, #40]	@ 0x28
 8001ce4:	ea4c 0505 	orr.w	r5, ip, r5
 8001ce8:	609d      	str	r5, [r3, #8]
  }

  /* Mark it as First Descriptor */
  SET_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_FD);
 8001cea:	68dd      	ldr	r5, [r3, #12]
 8001cec:	f045 5500 	orr.w	r5, r5, #536870912	@ 0x20000000
 8001cf0:	60dd      	str	r5, [r3, #12]
  /* Mark it as NORMAL descriptor */
  CLEAR_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_CTXT);
 8001cf2:	68dd      	ldr	r5, [r3, #12]
 8001cf4:	f025 4580 	bic.w	r5, r5, #1073741824	@ 0x40000000
 8001cf8:	60dd      	str	r5, [r3, #12]
 8001cfa:	f3bf 8f5f 	dmb	sy
  /* Ensure rest of descriptor is written to RAM before the OWN bit */
  __DMB();
  /* set OWN bit of FIRST descriptor */
  SET_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_OWN);
 8001cfe:	68dd      	ldr	r5, [r3, #12]
 8001d00:	f045 4500 	orr.w	r5, r5, #2147483648	@ 0x80000000
 8001d04:	60dd      	str	r5, [r3, #12]

  /* If source address insertion/replacement is enabled for this packet */
  if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_SAIC) != (uint32_t)RESET)
 8001d06:	680d      	ldr	r5, [r1, #0]
 8001d08:	f015 0f02 	tst.w	r5, #2
 8001d0c:	d006      	beq.n	8001d1c <ETH_Prepare_Tx_Descriptors+0x1a0>
  {
    MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_SAIC, pTxConfig->SrcAddrCtrl);
 8001d0e:	68dd      	ldr	r5, [r3, #12]
 8001d10:	f025 7c60 	bic.w	ip, r5, #58720256	@ 0x3800000
 8001d14:	68cd      	ldr	r5, [r1, #12]
 8001d16:	ea4c 0505 	orr.w	r5, ip, r5
 8001d1a:	60dd      	str	r5, [r3, #12]
    }

    descnbr += 1U;

    /* Get the next Tx buffer in the list */
    txbuffer = txbuffer->next;
 8001d1c:	2500      	movs	r5, #0
 8001d1e:	e064      	b.n	8001dea <ETH_Prepare_Tx_Descriptors+0x26e>
    WRITE_REG(dmatxdesc->DESC1, 0x0);
 8001d20:	2200      	movs	r2, #0
 8001d22:	605a      	str	r2, [r3, #4]
    MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_B2L, 0x0U);
 8001d24:	689a      	ldr	r2, [r3, #8]
 8001d26:	f36f 421d 	bfc	r2, #16, #14
 8001d2a:	609a      	str	r2, [r3, #8]
  ETH_BufferTypeDef  *txbuffer = pTxConfig->TxBuffer;
 8001d2c:	4662      	mov	r2, ip
 8001d2e:	e7b9      	b.n	8001ca4 <ETH_Prepare_Tx_Descriptors+0x128>
    MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_FL, pTxConfig->Length);
 8001d30:	68dd      	ldr	r5, [r3, #12]
 8001d32:	f8df c190 	ldr.w	ip, [pc, #400]	@ 8001ec4 <ETH_Prepare_Tx_Descriptors+0x348>
 8001d36:	ea05 0c0c 	and.w	ip, r5, ip
 8001d3a:	684d      	ldr	r5, [r1, #4]
 8001d3c:	ea4c 0505 	orr.w	r5, ip, r5
 8001d40:	60dd      	str	r5, [r3, #12]
    if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_CSUM) != (uint32_t)RESET)
 8001d42:	680d      	ldr	r5, [r1, #0]
 8001d44:	f015 0f01 	tst.w	r5, #1
 8001d48:	d006      	beq.n	8001d58 <ETH_Prepare_Tx_Descriptors+0x1dc>
      MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_CIC, pTxConfig->ChecksumCtrl);
 8001d4a:	68dd      	ldr	r5, [r3, #12]
 8001d4c:	f425 3c40 	bic.w	ip, r5, #196608	@ 0x30000
 8001d50:	694d      	ldr	r5, [r1, #20]
 8001d52:	ea4c 0505 	orr.w	r5, ip, r5
 8001d56:	60dd      	str	r5, [r3, #12]
    if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_CRCPAD) != (uint32_t)RESET)
 8001d58:	680d      	ldr	r5, [r1, #0]
 8001d5a:	f015 0f20 	tst.w	r5, #32
 8001d5e:	d0b9      	beq.n	8001cd4 <ETH_Prepare_Tx_Descriptors+0x158>
      MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_CPC, pTxConfig->CRCPadCtrl);
 8001d60:	68dd      	ldr	r5, [r3, #12]
 8001d62:	f025 6c40 	bic.w	ip, r5, #201326592	@ 0xc000000
 8001d66:	690d      	ldr	r5, [r1, #16]
 8001d68:	ea4c 0505 	orr.w	r5, ip, r5
 8001d6c:	60dd      	str	r5, [r3, #12]
 8001d6e:	e7b1      	b.n	8001cd4 <ETH_Prepare_Tx_Descriptors+0x158>
      dmatxdesc = (ETH_DMADescTypeDef *)dmatxdesclist->TxDesc[descidx];
 8001d70:	eb00 0384 	add.w	r3, r0, r4, lsl #2
 8001d74:	6999      	ldr	r1, [r3, #24]
      for (idx = 0; idx < descnbr; idx ++)
 8001d76:	2200      	movs	r2, #0
 8001d78:	e004      	b.n	8001d84 <ETH_Prepare_Tx_Descriptors+0x208>
        dmatxdesc = (ETH_DMADescTypeDef *)dmatxdesclist->TxDesc[descidx];
 8001d7a:	eb00 0183 	add.w	r1, r0, r3, lsl #2
 8001d7e:	6989      	ldr	r1, [r1, #24]
      for (idx = 0; idx < descnbr; idx ++)
 8001d80:	3201      	adds	r2, #1
 8001d82:	461c      	mov	r4, r3
 8001d84:	4572      	cmp	r2, lr
 8001d86:	d20a      	bcs.n	8001d9e <ETH_Prepare_Tx_Descriptors+0x222>
 8001d88:	f3bf 8f5f 	dmb	sy
        CLEAR_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_OWN);
 8001d8c:	68cb      	ldr	r3, [r1, #12]
 8001d8e:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 8001d92:	60cb      	str	r3, [r1, #12]
        INCR_TX_DESC_INDEX(descidx, 1U);
 8001d94:	1c63      	adds	r3, r4, #1
 8001d96:	2b03      	cmp	r3, #3
 8001d98:	d9ef      	bls.n	8001d7a <ETH_Prepare_Tx_Descriptors+0x1fe>
 8001d9a:	1ee3      	subs	r3, r4, #3
 8001d9c:	e7ed      	b.n	8001d7a <ETH_Prepare_Tx_Descriptors+0x1fe>
      return HAL_ETH_ERROR_BUSY;
 8001d9e:	2002      	movs	r0, #2
 8001da0:	e089      	b.n	8001eb6 <ETH_Prepare_Tx_Descriptors+0x33a>
      /* Set buffer 2 Length */
      MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_B2L, (txbuffer->len << 16));
    }
    else
    {
      WRITE_REG(dmatxdesc->DESC1, 0x0);
 8001da2:	2200      	movs	r2, #0
 8001da4:	605a      	str	r2, [r3, #4]
      /* Set buffer 2 Length */
      MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_B2L, 0x0U);
 8001da6:	689a      	ldr	r2, [r3, #8]
 8001da8:	f36f 421d 	bfc	r2, #16, #14
 8001dac:	609a      	str	r2, [r3, #8]
    txbuffer = txbuffer->next;
 8001dae:	463a      	mov	r2, r7
 8001db0:	e051      	b.n	8001e56 <ETH_Prepare_Tx_Descriptors+0x2da>
      SET_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_TSE);
    }
    else
    {
      /* Set the packet length */
      MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_FL, pTxConfig->Length);
 8001db2:	68de      	ldr	r6, [r3, #12]
 8001db4:	f36f 060e 	bfc	r6, #0, #15
 8001db8:	684f      	ldr	r7, [r1, #4]
 8001dba:	433e      	orrs	r6, r7
 8001dbc:	60de      	str	r6, [r3, #12]

      if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_CSUM) != (uint32_t)RESET)
 8001dbe:	680e      	ldr	r6, [r1, #0]
 8001dc0:	f016 0f01 	tst.w	r6, #1
 8001dc4:	d005      	beq.n	8001dd2 <ETH_Prepare_Tx_Descriptors+0x256>
      {
        /* Checksum Insertion Control */
        MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_CIC, pTxConfig->ChecksumCtrl);
 8001dc6:	68de      	ldr	r6, [r3, #12]
 8001dc8:	f426 3640 	bic.w	r6, r6, #196608	@ 0x30000
 8001dcc:	694f      	ldr	r7, [r1, #20]
 8001dce:	433e      	orrs	r6, r7
 8001dd0:	60de      	str	r6, [r3, #12]
      }
    }

    bd_count += 1U;
 8001dd2:	3501      	adds	r5, #1
 8001dd4:	f3bf 8f5f 	dmb	sy

    /* Ensure rest of descriptor is written to RAM before the OWN bit */
    __DMB();
    /* Set Own bit */
    SET_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_OWN);
 8001dd8:	68de      	ldr	r6, [r3, #12]
 8001dda:	f046 4600 	orr.w	r6, r6, #2147483648	@ 0x80000000
 8001dde:	60de      	str	r6, [r3, #12]
    /* Mark it as NORMAL descriptor */
    CLEAR_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_CTXT);
 8001de0:	68de      	ldr	r6, [r3, #12]
 8001de2:	f026 4680 	bic.w	r6, r6, #1073741824	@ 0x40000000
 8001de6:	60de      	str	r6, [r3, #12]
 8001de8:	4666      	mov	r6, ip
  while (txbuffer->next != NULL)
 8001dea:	6897      	ldr	r7, [r2, #8]
 8001dec:	2f00      	cmp	r7, #0
 8001dee:	d041      	beq.n	8001e74 <ETH_Prepare_Tx_Descriptors+0x2f8>
    CLEAR_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_LD);
 8001df0:	68df      	ldr	r7, [r3, #12]
 8001df2:	f027 5780 	bic.w	r7, r7, #268435456	@ 0x10000000
 8001df6:	60df      	str	r7, [r3, #12]
    INCR_TX_DESC_INDEX(descidx, 1U);
 8001df8:	f106 0c01 	add.w	ip, r6, #1
 8001dfc:	f1bc 0f03 	cmp.w	ip, #3
 8001e00:	d901      	bls.n	8001e06 <ETH_Prepare_Tx_Descriptors+0x28a>
 8001e02:	f1a6 0c03 	sub.w	ip, r6, #3
    dmatxdesc = (ETH_DMADescTypeDef *)dmatxdesclist->TxDesc[descidx];
 8001e06:	eb00 038c 	add.w	r3, r0, ip, lsl #2
 8001e0a:	699b      	ldr	r3, [r3, #24]
    CLEAR_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_FD);
 8001e0c:	68de      	ldr	r6, [r3, #12]
 8001e0e:	f026 5600 	bic.w	r6, r6, #536870912	@ 0x20000000
 8001e12:	60de      	str	r6, [r3, #12]
    if ((READ_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_OWN) == ETH_DMATXNDESCRF_OWN)
 8001e14:	68de      	ldr	r6, [r3, #12]
 8001e16:	2e00      	cmp	r6, #0
 8001e18:	dbaa      	blt.n	8001d70 <ETH_Prepare_Tx_Descriptors+0x1f4>
        || (dmatxdesclist->PacketAddress[descidx] != NULL))
 8001e1a:	f10c 0604 	add.w	r6, ip, #4
 8001e1e:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 8001e22:	69f6      	ldr	r6, [r6, #28]
 8001e24:	2e00      	cmp	r6, #0
 8001e26:	d1a3      	bne.n	8001d70 <ETH_Prepare_Tx_Descriptors+0x1f4>
    descnbr += 1U;
 8001e28:	f10e 0e01 	add.w	lr, lr, #1
    txbuffer = txbuffer->next;
 8001e2c:	6897      	ldr	r7, [r2, #8]
    WRITE_REG(dmatxdesc->DESC0, (uint32_t)txbuffer->buffer);
 8001e2e:	683a      	ldr	r2, [r7, #0]
 8001e30:	601a      	str	r2, [r3, #0]
    MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_B1L, txbuffer->len);
 8001e32:	689e      	ldr	r6, [r3, #8]
 8001e34:	f36f 060d 	bfc	r6, #0, #14
 8001e38:	687a      	ldr	r2, [r7, #4]
 8001e3a:	4332      	orrs	r2, r6
 8001e3c:	609a      	str	r2, [r3, #8]
    if (txbuffer->next != NULL)
 8001e3e:	68ba      	ldr	r2, [r7, #8]
 8001e40:	2a00      	cmp	r2, #0
 8001e42:	d0ae      	beq.n	8001da2 <ETH_Prepare_Tx_Descriptors+0x226>
      WRITE_REG(dmatxdesc->DESC1, (uint32_t)txbuffer->buffer);
 8001e44:	6816      	ldr	r6, [r2, #0]
 8001e46:	605e      	str	r6, [r3, #4]
      MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_B2L, (txbuffer->len << 16));
 8001e48:	689e      	ldr	r6, [r3, #8]
 8001e4a:	f36f 461d 	bfc	r6, #16, #14
 8001e4e:	6857      	ldr	r7, [r2, #4]
 8001e50:	ea46 4607 	orr.w	r6, r6, r7, lsl #16
 8001e54:	609e      	str	r6, [r3, #8]
    if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_TSO) != (uint32_t)RESET)
 8001e56:	680e      	ldr	r6, [r1, #0]
 8001e58:	f016 0f10 	tst.w	r6, #16
 8001e5c:	d0a9      	beq.n	8001db2 <ETH_Prepare_Tx_Descriptors+0x236>
      MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_TPL, pTxConfig->PayloadLen);
 8001e5e:	68de      	ldr	r6, [r3, #12]
 8001e60:	f36f 0611 	bfc	r6, #0, #18
 8001e64:	69cf      	ldr	r7, [r1, #28]
 8001e66:	433e      	orrs	r6, r7
 8001e68:	60de      	str	r6, [r3, #12]
      SET_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_TSE);
 8001e6a:	68de      	ldr	r6, [r3, #12]
 8001e6c:	f446 2680 	orr.w	r6, r6, #262144	@ 0x40000
 8001e70:	60de      	str	r6, [r3, #12]
 8001e72:	e7ae      	b.n	8001dd2 <ETH_Prepare_Tx_Descriptors+0x256>
  }

  if (ItMode != ((uint32_t)RESET))
 8001e74:	f1b8 0f00 	cmp.w	r8, #0
 8001e78:	d015      	beq.n	8001ea6 <ETH_Prepare_Tx_Descriptors+0x32a>
  {
    /* Set Interrupt on completion bit */
    SET_BIT(dmatxdesc->DESC2, ETH_DMATXNDESCRF_IOC);
 8001e7a:	689a      	ldr	r2, [r3, #8]
 8001e7c:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
 8001e80:	609a      	str	r2, [r3, #8]
    /* Clear Interrupt on completion bit */
    CLEAR_BIT(dmatxdesc->DESC2, ETH_DMATXNDESCRF_IOC);
  }

  /* Mark it as LAST descriptor */
  SET_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_LD);
 8001e82:	68da      	ldr	r2, [r3, #12]
 8001e84:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 8001e88:	60da      	str	r2, [r3, #12]
  /* Save the current packet address to expose it to the application */
  dmatxdesclist->PacketAddress[descidx] = dmatxdesclist->CurrentPacketAddress;
 8001e8a:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
 8001e8c:	1d33      	adds	r3, r6, #4
 8001e8e:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8001e92:	61da      	str	r2, [r3, #28]

  dmatxdesclist->CurTxDesc = descidx;
 8001e94:	6286      	str	r6, [r0, #40]	@ 0x28
  __ASM volatile ("cpsid i" : : : "memory");
 8001e96:	b672      	cpsid	i

  /* disable the interrupt */
  __disable_irq();

  dmatxdesclist->BuffersInUse += bd_count + 1U;
 8001e98:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 8001e9a:	442b      	add	r3, r5
 8001e9c:	3301      	adds	r3, #1
 8001e9e:	6403      	str	r3, [r0, #64]	@ 0x40
  __ASM volatile ("cpsie i" : : : "memory");
 8001ea0:	b662      	cpsie	i
  /* Enable interrupts back */
  __enable_irq();


  /* Return function status */
  return HAL_ETH_ERROR_NONE;
 8001ea2:	2000      	movs	r0, #0
 8001ea4:	e007      	b.n	8001eb6 <ETH_Prepare_Tx_Descriptors+0x33a>
    CLEAR_BIT(dmatxdesc->DESC2, ETH_DMATXNDESCRF_IOC);
 8001ea6:	689a      	ldr	r2, [r3, #8]
 8001ea8:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
 8001eac:	609a      	str	r2, [r3, #8]
 8001eae:	e7e8      	b.n	8001e82 <ETH_Prepare_Tx_Descriptors+0x306>
    return HAL_ETH_ERROR_BUSY;
 8001eb0:	2002      	movs	r0, #2
 8001eb2:	e000      	b.n	8001eb6 <ETH_Prepare_Tx_Descriptors+0x33a>
 8001eb4:	2002      	movs	r0, #2
}
 8001eb6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001eba:	bf00      	nop
 8001ebc:	c000ffff 	.word	0xc000ffff
 8001ec0:	fffc0000 	.word	0xfffc0000
 8001ec4:	ffff8000 	.word	0xffff8000

08001ec8 <HAL_ETH_Start_IT>:
{
 8001ec8:	b538      	push	{r3, r4, r5, lr}
  if (heth->gState == HAL_ETH_STATE_READY)
 8001eca:	f8d0 3084 	ldr.w	r3, [r0, #132]	@ 0x84
 8001ece:	2b10      	cmp	r3, #16
 8001ed0:	d001      	beq.n	8001ed6 <HAL_ETH_Start_IT+0xe>
    return HAL_ERROR;
 8001ed2:	2001      	movs	r0, #1
}
 8001ed4:	bd38      	pop	{r3, r4, r5, pc}
 8001ed6:	4604      	mov	r4, r0
    heth->gState = HAL_ETH_STATE_BUSY;
 8001ed8:	2523      	movs	r5, #35	@ 0x23
 8001eda:	f8c0 5084 	str.w	r5, [r0, #132]	@ 0x84
    heth->RxDescList.ItMode = 1U;
 8001ede:	2301      	movs	r3, #1
 8001ee0:	6583      	str	r3, [r0, #88]	@ 0x58
    SET_BIT(heth->Instance->MMCRIMR, ETH_MMCRIMR_RXLPITRCIM | ETH_MMCRIMR_RXLPIUSCIM | \
 8001ee2:	6802      	ldr	r2, [r0, #0]
 8001ee4:	f8d2 170c 	ldr.w	r1, [r2, #1804]	@ 0x70c
 8001ee8:	4b24      	ldr	r3, [pc, #144]	@ (8001f7c <HAL_ETH_Start_IT+0xb4>)
 8001eea:	430b      	orrs	r3, r1
 8001eec:	f8c2 370c 	str.w	r3, [r2, #1804]	@ 0x70c
    SET_BIT(heth->Instance->MMCTIMR, ETH_MMCTIMR_TXLPITRCIM | ETH_MMCTIMR_TXLPIUSCIM | \
 8001ef0:	6802      	ldr	r2, [r0, #0]
 8001ef2:	f8d2 1710 	ldr.w	r1, [r2, #1808]	@ 0x710
 8001ef6:	4b22      	ldr	r3, [pc, #136]	@ (8001f80 <HAL_ETH_Start_IT+0xb8>)
 8001ef8:	430b      	orrs	r3, r1
 8001efa:	f8c2 3710 	str.w	r3, [r2, #1808]	@ 0x710
    heth->RxDescList.RxBuildDescCnt = ETH_RX_DESC_CNT;
 8001efe:	2304      	movs	r3, #4
 8001f00:	66c3      	str	r3, [r0, #108]	@ 0x6c
    ETH_UpdateDescriptor(heth);
 8001f02:	f7ff fbf3 	bl	80016ec <ETH_UpdateDescriptor>
    SET_BIT(heth->Instance->MACCR, ETH_MACCR_TE);
 8001f06:	6822      	ldr	r2, [r4, #0]
 8001f08:	6813      	ldr	r3, [r2, #0]
 8001f0a:	f043 0302 	orr.w	r3, r3, #2
 8001f0e:	6013      	str	r3, [r2, #0]
    SET_BIT(heth->Instance->MACCR, ETH_MACCR_RE);
 8001f10:	6822      	ldr	r2, [r4, #0]
 8001f12:	6813      	ldr	r3, [r2, #0]
 8001f14:	f043 0301 	orr.w	r3, r3, #1
 8001f18:	6013      	str	r3, [r2, #0]
    SET_BIT(heth->Instance->MTLTQOMR, ETH_MTLTQOMR_FTQ);
 8001f1a:	6822      	ldr	r2, [r4, #0]
 8001f1c:	f8d2 3d00 	ldr.w	r3, [r2, #3328]	@ 0xd00
 8001f20:	f043 0301 	orr.w	r3, r3, #1
 8001f24:	f8c2 3d00 	str.w	r3, [r2, #3328]	@ 0xd00
    SET_BIT(heth->Instance->DMACTCR, ETH_DMACTCR_ST);
 8001f28:	6823      	ldr	r3, [r4, #0]
 8001f2a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8001f2e:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
 8001f32:	f042 0201 	orr.w	r2, r2, #1
 8001f36:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
    SET_BIT(heth->Instance->DMACRCR, ETH_DMACRCR_SR);
 8001f3a:	6823      	ldr	r3, [r4, #0]
 8001f3c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8001f40:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
 8001f44:	f042 0201 	orr.w	r2, r2, #1
 8001f48:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
    heth->Instance->DMACSR |= (ETH_DMACSR_TPS | ETH_DMACSR_RPS);
 8001f4c:	6823      	ldr	r3, [r4, #0]
 8001f4e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8001f52:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
 8001f56:	f442 7281 	orr.w	r2, r2, #258	@ 0x102
 8001f5a:	f8c3 2160 	str.w	r2, [r3, #352]	@ 0x160
    __HAL_ETH_DMA_ENABLE_IT(heth, (ETH_DMACIER_NIE | ETH_DMACIER_RIE | ETH_DMACIER_TIE  |
 8001f5e:	6823      	ldr	r3, [r4, #0]
 8001f60:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8001f64:	f8d3 1134 	ldr.w	r1, [r3, #308]	@ 0x134
 8001f68:	f24d 02c1 	movw	r2, #53441	@ 0xd0c1
 8001f6c:	430a      	orrs	r2, r1
 8001f6e:	f8c3 2134 	str.w	r2, [r3, #308]	@ 0x134
    heth->gState = HAL_ETH_STATE_STARTED;
 8001f72:	f8c4 5084 	str.w	r5, [r4, #132]	@ 0x84
    return HAL_OK;
 8001f76:	2000      	movs	r0, #0
 8001f78:	e7ac      	b.n	8001ed4 <HAL_ETH_Start_IT+0xc>
 8001f7a:	bf00      	nop
 8001f7c:	0c020060 	.word	0x0c020060
 8001f80:	0c20c000 	.word	0x0c20c000

08001f84 <HAL_ETH_Transmit_IT>:
{
 8001f84:	b510      	push	{r4, lr}
 8001f86:	4604      	mov	r4, r0
  if (pTxConfig == NULL)
 8001f88:	b129      	cbz	r1, 8001f96 <HAL_ETH_Transmit_IT+0x12>
  if (heth->gState == HAL_ETH_STATE_STARTED)
 8001f8a:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
 8001f8e:	2b23      	cmp	r3, #35	@ 0x23
 8001f90:	d009      	beq.n	8001fa6 <HAL_ETH_Transmit_IT+0x22>
    return HAL_ERROR;
 8001f92:	2001      	movs	r0, #1
}
 8001f94:	bd10      	pop	{r4, pc}
    heth->ErrorCode |= HAL_ETH_ERROR_PARAM;
 8001f96:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
 8001f9a:	f043 0301 	orr.w	r3, r3, #1
 8001f9e:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
    return HAL_ERROR;
 8001fa2:	2001      	movs	r0, #1
 8001fa4:	e7f6      	b.n	8001f94 <HAL_ETH_Transmit_IT+0x10>
    heth->TxDescList.CurrentPacketAddress = (uint32_t *)pTxConfig->pData;
 8001fa6:	6b4b      	ldr	r3, [r1, #52]	@ 0x34
 8001fa8:	63e3      	str	r3, [r4, #60]	@ 0x3c
    if (ETH_Prepare_Tx_Descriptors(heth, pTxConfig, 1) != HAL_ETH_ERROR_NONE)
 8001faa:	2201      	movs	r2, #1
 8001fac:	4620      	mov	r0, r4
 8001fae:	f7ff fde5 	bl	8001b7c <ETH_Prepare_Tx_Descriptors>
 8001fb2:	b138      	cbz	r0, 8001fc4 <HAL_ETH_Transmit_IT+0x40>
      heth->ErrorCode |= HAL_ETH_ERROR_BUSY;
 8001fb4:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
 8001fb8:	f043 0302 	orr.w	r3, r3, #2
 8001fbc:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
      return HAL_ERROR;
 8001fc0:	2001      	movs	r0, #1
 8001fc2:	e7e7      	b.n	8001f94 <HAL_ETH_Transmit_IT+0x10>
  __ASM volatile ("dsb 0xF":::"memory");
 8001fc4:	f3bf 8f4f 	dsb	sy
    INCR_TX_DESC_INDEX(heth->TxDescList.CurTxDesc, 1U);
 8001fc8:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 8001fca:	1c5a      	adds	r2, r3, #1
 8001fcc:	62a2      	str	r2, [r4, #40]	@ 0x28
 8001fce:	2a03      	cmp	r2, #3
 8001fd0:	d901      	bls.n	8001fd6 <HAL_ETH_Transmit_IT+0x52>
 8001fd2:	3b03      	subs	r3, #3
 8001fd4:	62a3      	str	r3, [r4, #40]	@ 0x28
    WRITE_REG(heth->Instance->DMACTDTPR, (uint32_t)(heth->TxDescList.TxDesc[heth->TxDescList.CurTxDesc]));
 8001fd6:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 8001fd8:	6823      	ldr	r3, [r4, #0]
 8001fda:	3206      	adds	r2, #6
 8001fdc:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 8001fe0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8001fe4:	f8c3 2120 	str.w	r2, [r3, #288]	@ 0x120
    return HAL_OK;
 8001fe8:	2000      	movs	r0, #0
 8001fea:	e7d3      	b.n	8001f94 <HAL_ETH_Transmit_IT+0x10>

08001fec <HAL_ETH_ReadData>:
{
 8001fec:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001ff0:	4604      	mov	r4, r0
  if (pAppBuff == NULL)
 8001ff2:	b189      	cbz	r1, 8002018 <HAL_ETH_ReadData+0x2c>
 8001ff4:	468b      	mov	fp, r1
  if (heth->gState != HAL_ETH_STATE_STARTED)
 8001ff6:	f8d0 3084 	ldr.w	r3, [r0, #132]	@ 0x84
 8001ffa:	2b23      	cmp	r3, #35	@ 0x23
 8001ffc:	d172      	bne.n	80020e4 <HAL_ETH_ReadData+0xf8>
  descidx = heth->RxDescList.RxDescIdx;
 8001ffe:	f8d0 805c 	ldr.w	r8, [r0, #92]	@ 0x5c
  dmarxdesc = (ETH_DMADescTypeDef *)heth->RxDescList.RxDesc[descidx];
 8002002:	f108 0312 	add.w	r3, r8, #18
 8002006:	f850 5023 	ldr.w	r5, [r0, r3, lsl #2]
  desccntmax = ETH_RX_DESC_CNT - heth->RxDescList.RxBuildDescCnt;
 800200a:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
 800200c:	f1c3 0a04 	rsb	sl, r3, #4
  uint8_t rxdataready = 0U;
 8002010:	f04f 0900 	mov.w	r9, #0
  uint32_t desccnt = 0U;
 8002014:	464f      	mov	r7, r9
  while ((READ_BIT(dmarxdesc->DESC3, ETH_DMARXNDESCWBF_OWN) == (uint32_t)RESET) && (desccnt < desccntmax)
 8002016:	e038      	b.n	800208a <HAL_ETH_ReadData+0x9e>
    heth->ErrorCode |= HAL_ETH_ERROR_PARAM;
 8002018:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
 800201c:	f043 0301 	orr.w	r3, r3, #1
 8002020:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
    return HAL_ERROR;
 8002024:	2001      	movs	r0, #1
 8002026:	e05e      	b.n	80020e6 <HAL_ETH_ReadData+0xfa>
      if (READ_BIT(dmarxdesc->DESC3, ETH_DMARXNDESCWBF_FD) != (uint32_t)RESET)
 8002028:	68eb      	ldr	r3, [r5, #12]
 800202a:	f013 5f00 	tst.w	r3, #536870912	@ 0x20000000
 800202e:	d002      	beq.n	8002036 <HAL_ETH_ReadData+0x4a>
        heth->RxDescList.RxDescCnt = 0;
 8002030:	2300      	movs	r3, #0
 8002032:	6623      	str	r3, [r4, #96]	@ 0x60
        heth->RxDescList.RxDataLength = 0;
 8002034:	6663      	str	r3, [r4, #100]	@ 0x64
      bufflength = heth->Init.RxBuffLen;
 8002036:	6966      	ldr	r6, [r4, #20]
      if (READ_BIT(dmarxdesc->DESC3, ETH_DMARXNDESCWBF_LD) != (uint32_t)RESET)
 8002038:	68eb      	ldr	r3, [r5, #12]
 800203a:	f013 5f80 	tst.w	r3, #268435456	@ 0x10000000
 800203e:	d008      	beq.n	8002052 <HAL_ETH_ReadData+0x66>
        bufflength = READ_BIT(dmarxdesc->DESC3, ETH_DMARXNDESCWBF_PL) - heth->RxDescList.RxDataLength;
 8002040:	68ee      	ldr	r6, [r5, #12]
 8002042:	f3c6 060e 	ubfx	r6, r6, #0, #15
 8002046:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8002048:	1af6      	subs	r6, r6, r3
        heth->RxDescList.pRxLastRxDesc = dmarxdesc->DESC3;
 800204a:	68eb      	ldr	r3, [r5, #12]
 800204c:	6723      	str	r3, [r4, #112]	@ 0x70
        rxdataready = 1;
 800204e:	f04f 0901 	mov.w	r9, #1
      HAL_ETH_RxLinkCallback(&heth->RxDescList.pRxStart, &heth->RxDescList.pRxEnd,
 8002052:	b2b3      	uxth	r3, r6
 8002054:	692a      	ldr	r2, [r5, #16]
 8002056:	f104 0180 	add.w	r1, r4, #128	@ 0x80
 800205a:	f104 007c 	add.w	r0, r4, #124	@ 0x7c
 800205e:	f011 fd25 	bl	8013aac <HAL_ETH_RxLinkCallback>
      heth->RxDescList.RxDescCnt++;
 8002062:	6e23      	ldr	r3, [r4, #96]	@ 0x60
 8002064:	3301      	adds	r3, #1
 8002066:	6623      	str	r3, [r4, #96]	@ 0x60
      heth->RxDescList.RxDataLength += bufflength;
 8002068:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 800206a:	4433      	add	r3, r6
 800206c:	6663      	str	r3, [r4, #100]	@ 0x64
      dmarxdesc->BackupAddr0 = 0;
 800206e:	2300      	movs	r3, #0
 8002070:	612b      	str	r3, [r5, #16]
    INCR_RX_DESC_INDEX(descidx, 1U);
 8002072:	f108 0301 	add.w	r3, r8, #1
 8002076:	2b03      	cmp	r3, #3
 8002078:	d901      	bls.n	800207e <HAL_ETH_ReadData+0x92>
 800207a:	f1a8 0303 	sub.w	r3, r8, #3
    dmarxdesc = (ETH_DMADescTypeDef *)heth->RxDescList.RxDesc[descidx];
 800207e:	f103 0212 	add.w	r2, r3, #18
 8002082:	f854 5022 	ldr.w	r5, [r4, r2, lsl #2]
    desccnt++;
 8002086:	3701      	adds	r7, #1
 8002088:	4698      	mov	r8, r3
  while ((READ_BIT(dmarxdesc->DESC3, ETH_DMARXNDESCWBF_OWN) == (uint32_t)RESET) && (desccnt < desccntmax)
 800208a:	68eb      	ldr	r3, [r5, #12]
         && (rxdataready == 0U))
 800208c:	2b00      	cmp	r3, #0
 800208e:	db14      	blt.n	80020ba <HAL_ETH_ReadData+0xce>
 8002090:	f089 0301 	eor.w	r3, r9, #1
 8002094:	4557      	cmp	r7, sl
 8002096:	d210      	bcs.n	80020ba <HAL_ETH_ReadData+0xce>
 8002098:	b17b      	cbz	r3, 80020ba <HAL_ETH_ReadData+0xce>
    if (READ_BIT(dmarxdesc->DESC3,  ETH_DMARXNDESCWBF_CTXT)  != (uint32_t)RESET)
 800209a:	68eb      	ldr	r3, [r5, #12]
 800209c:	f013 4f80 	tst.w	r3, #1073741824	@ 0x40000000
 80020a0:	d003      	beq.n	80020aa <HAL_ETH_ReadData+0xbe>
      heth->RxDescList.TimeStamp.TimeStampHigh = dmarxdesc->DESC1;
 80020a2:	686b      	ldr	r3, [r5, #4]
 80020a4:	67a3      	str	r3, [r4, #120]	@ 0x78
      heth->RxDescList.TimeStamp.TimeStampLow  = dmarxdesc->DESC0;
 80020a6:	682b      	ldr	r3, [r5, #0]
 80020a8:	6763      	str	r3, [r4, #116]	@ 0x74
    if ((READ_BIT(dmarxdesc->DESC3, ETH_DMARXNDESCWBF_FD) != (uint32_t)RESET) || (heth->RxDescList.pRxStart != NULL))
 80020aa:	68eb      	ldr	r3, [r5, #12]
 80020ac:	f013 5f00 	tst.w	r3, #536870912	@ 0x20000000
 80020b0:	d1ba      	bne.n	8002028 <HAL_ETH_ReadData+0x3c>
 80020b2:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
 80020b4:	2b00      	cmp	r3, #0
 80020b6:	d1b7      	bne.n	8002028 <HAL_ETH_ReadData+0x3c>
 80020b8:	e7db      	b.n	8002072 <HAL_ETH_ReadData+0x86>
  heth->RxDescList.RxBuildDescCnt += desccnt;
 80020ba:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
 80020bc:	443b      	add	r3, r7
 80020be:	66e3      	str	r3, [r4, #108]	@ 0x6c
  if ((heth->RxDescList.RxBuildDescCnt) != 0U)
 80020c0:	b933      	cbnz	r3, 80020d0 <HAL_ETH_ReadData+0xe4>
  heth->RxDescList.RxDescIdx = descidx;
 80020c2:	f8c4 805c 	str.w	r8, [r4, #92]	@ 0x5c
  if (rxdataready == 1U)
 80020c6:	f1b9 0f00 	cmp.w	r9, #0
 80020ca:	d105      	bne.n	80020d8 <HAL_ETH_ReadData+0xec>
  return HAL_ERROR;
 80020cc:	2001      	movs	r0, #1
 80020ce:	e00a      	b.n	80020e6 <HAL_ETH_ReadData+0xfa>
    ETH_UpdateDescriptor(heth);
 80020d0:	4620      	mov	r0, r4
 80020d2:	f7ff fb0b 	bl	80016ec <ETH_UpdateDescriptor>
 80020d6:	e7f4      	b.n	80020c2 <HAL_ETH_ReadData+0xd6>
    *pAppBuff = heth->RxDescList.pRxStart;
 80020d8:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
 80020da:	f8cb 3000 	str.w	r3, [fp]
    heth->RxDescList.pRxStart = NULL;
 80020de:	2000      	movs	r0, #0
 80020e0:	67e0      	str	r0, [r4, #124]	@ 0x7c
    return HAL_OK;
 80020e2:	e000      	b.n	80020e6 <HAL_ETH_ReadData+0xfa>
    return HAL_ERROR;
 80020e4:	2001      	movs	r0, #1
}
 80020e6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

080020ea <HAL_ETH_ReleaseTxPacket>:
{
 80020ea:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80020ec:	4606      	mov	r6, r0
  uint32_t numOfBuf =  dmatxdesclist->BuffersInUse;
 80020ee:	6c05      	ldr	r5, [r0, #64]	@ 0x40
  uint32_t idx =       dmatxdesclist->releaseIndex;
 80020f0:	6c44      	ldr	r4, [r0, #68]	@ 0x44
  uint8_t pktTxStatus = 1U;
 80020f2:	2701      	movs	r7, #1
  while ((numOfBuf != 0U) && (pktTxStatus != 0U))
 80020f4:	e002      	b.n	80020fc <HAL_ETH_ReleaseTxPacket+0x12>
      idx = (idx + 1U) & (ETH_TX_DESC_CNT - 1U);
 80020f6:	3401      	adds	r4, #1
 80020f8:	f004 0403 	and.w	r4, r4, #3
  while ((numOfBuf != 0U) && (pktTxStatus != 0U))
 80020fc:	b1f5      	cbz	r5, 800213c <HAL_ETH_ReleaseTxPacket+0x52>
 80020fe:	b1ef      	cbz	r7, 800213c <HAL_ETH_ReleaseTxPacket+0x52>
    numOfBuf--;
 8002100:	3d01      	subs	r5, #1
    if (dmatxdesclist->PacketAddress[idx] == NULL)
 8002102:	1d23      	adds	r3, r4, #4
 8002104:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8002108:	69d8      	ldr	r0, [r3, #28]
 800210a:	2800      	cmp	r0, #0
 800210c:	d0f3      	beq.n	80020f6 <HAL_ETH_ReleaseTxPacket+0xc>
      if ((heth->Init.TxDesc[idx].DESC3 & ETH_DMATXNDESCRF_OWN) == 0U)
 800210e:	68f3      	ldr	r3, [r6, #12]
 8002110:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 8002114:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8002118:	68db      	ldr	r3, [r3, #12]
 800211a:	2b00      	cmp	r3, #0
 800211c:	da01      	bge.n	8002122 <HAL_ETH_ReleaseTxPacket+0x38>
        pktTxStatus = 0U;
 800211e:	2700      	movs	r7, #0
 8002120:	e7ec      	b.n	80020fc <HAL_ETH_ReleaseTxPacket+0x12>
        HAL_ETH_TxFreeCallback(dmatxdesclist->PacketAddress[idx]);
 8002122:	f011 fcf3 	bl	8013b0c <HAL_ETH_TxFreeCallback>
        dmatxdesclist->PacketAddress[idx] = NULL;
 8002126:	1d23      	adds	r3, r4, #4
 8002128:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 800212c:	2200      	movs	r2, #0
 800212e:	61da      	str	r2, [r3, #28]
        idx = (idx + 1U) & (ETH_TX_DESC_CNT - 1U);
 8002130:	3401      	adds	r4, #1
 8002132:	f004 0403 	and.w	r4, r4, #3
        dmatxdesclist->BuffersInUse = numOfBuf;
 8002136:	6435      	str	r5, [r6, #64]	@ 0x40
        dmatxdesclist->releaseIndex = idx;
 8002138:	6474      	str	r4, [r6, #68]	@ 0x44
 800213a:	e7df      	b.n	80020fc <HAL_ETH_ReleaseTxPacket+0x12>
}
 800213c:	2000      	movs	r0, #0
 800213e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08002140 <HAL_ETH_PMTCallback>:
}
 8002140:	4770      	bx	lr

08002142 <HAL_ETH_EEECallback>:
}
 8002142:	4770      	bx	lr

08002144 <HAL_ETH_WakeUpCallback>:
}
 8002144:	4770      	bx	lr

08002146 <HAL_ETH_IRQHandler>:
{
 8002146:	b510      	push	{r4, lr}
 8002148:	4604      	mov	r4, r0
  if (__HAL_ETH_DMA_GET_IT(heth, ETH_DMACSR_RI))
 800214a:	6803      	ldr	r3, [r0, #0]
 800214c:	f503 5280 	add.w	r2, r3, #4096	@ 0x1000
 8002150:	f8d2 2160 	ldr.w	r2, [r2, #352]	@ 0x160
 8002154:	f012 0f40 	tst.w	r2, #64	@ 0x40
 8002158:	d006      	beq.n	8002168 <HAL_ETH_IRQHandler+0x22>
    if (__HAL_ETH_DMA_GET_IT_SOURCE(heth, ETH_DMACIER_RIE))
 800215a:	f503 5280 	add.w	r2, r3, #4096	@ 0x1000
 800215e:	f8d2 2134 	ldr.w	r2, [r2, #308]	@ 0x134
 8002162:	f012 0f40 	tst.w	r2, #64	@ 0x40
 8002166:	d15c      	bne.n	8002222 <HAL_ETH_IRQHandler+0xdc>
  if (__HAL_ETH_DMA_GET_IT(heth, ETH_DMACSR_TI))
 8002168:	6823      	ldr	r3, [r4, #0]
 800216a:	f503 5280 	add.w	r2, r3, #4096	@ 0x1000
 800216e:	f8d2 2160 	ldr.w	r2, [r2, #352]	@ 0x160
 8002172:	f012 0f01 	tst.w	r2, #1
 8002176:	d006      	beq.n	8002186 <HAL_ETH_IRQHandler+0x40>
    if (__HAL_ETH_DMA_GET_IT_SOURCE(heth, ETH_DMACIER_TIE))
 8002178:	f503 5280 	add.w	r2, r3, #4096	@ 0x1000
 800217c:	f8d2 2134 	ldr.w	r2, [r2, #308]	@ 0x134
 8002180:	f012 0f01 	tst.w	r2, #1
 8002184:	d156      	bne.n	8002234 <HAL_ETH_IRQHandler+0xee>
  if (__HAL_ETH_DMA_GET_IT(heth, ETH_DMACSR_AIS))
 8002186:	6823      	ldr	r3, [r4, #0]
 8002188:	f503 5280 	add.w	r2, r3, #4096	@ 0x1000
 800218c:	f8d2 2160 	ldr.w	r2, [r2, #352]	@ 0x160
 8002190:	f412 4f80 	tst.w	r2, #16384	@ 0x4000
 8002194:	d02b      	beq.n	80021ee <HAL_ETH_IRQHandler+0xa8>
    if (__HAL_ETH_DMA_GET_IT_SOURCE(heth, ETH_DMACIER_AIE))
 8002196:	f503 5280 	add.w	r2, r3, #4096	@ 0x1000
 800219a:	f8d2 2134 	ldr.w	r2, [r2, #308]	@ 0x134
 800219e:	f412 4f80 	tst.w	r2, #16384	@ 0x4000
 80021a2:	d024      	beq.n	80021ee <HAL_ETH_IRQHandler+0xa8>
      heth->ErrorCode |= HAL_ETH_ERROR_DMA;
 80021a4:	f8d4 2088 	ldr.w	r2, [r4, #136]	@ 0x88
 80021a8:	f042 0208 	orr.w	r2, r2, #8
 80021ac:	f8c4 2088 	str.w	r2, [r4, #136]	@ 0x88
      if (__HAL_ETH_DMA_GET_IT(heth, ETH_DMACSR_FBE))
 80021b0:	f503 5280 	add.w	r2, r3, #4096	@ 0x1000
 80021b4:	f8d2 2160 	ldr.w	r2, [r2, #352]	@ 0x160
 80021b8:	f412 5f80 	tst.w	r2, #4096	@ 0x1000
 80021bc:	d044      	beq.n	8002248 <HAL_ETH_IRQHandler+0x102>
        heth->DMAErrorCode = READ_BIT(heth->Instance->DMACSR, (ETH_DMACSR_FBE | ETH_DMACSR_TPS | ETH_DMACSR_RPS));
 80021be:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80021c2:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
 80021c6:	f422 626f 	bic.w	r2, r2, #3824	@ 0xef0
 80021ca:	f022 020d 	bic.w	r2, r2, #13
 80021ce:	04d2      	lsls	r2, r2, #19
 80021d0:	0cd2      	lsrs	r2, r2, #19
 80021d2:	f8c4 208c 	str.w	r2, [r4, #140]	@ 0x8c
        __HAL_ETH_DMA_DISABLE_IT(heth, ETH_DMACIER_NIE | ETH_DMACIER_AIE);
 80021d6:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
 80021da:	f422 4240 	bic.w	r2, r2, #49152	@ 0xc000
 80021de:	f8c3 2134 	str.w	r2, [r3, #308]	@ 0x134
        heth->gState = HAL_ETH_STATE_ERROR;
 80021e2:	23e0      	movs	r3, #224	@ 0xe0
 80021e4:	f8c4 3084 	str.w	r3, [r4, #132]	@ 0x84
      HAL_ETH_ErrorCallback(heth);
 80021e8:	4620      	mov	r0, r4
 80021ea:	f011 fc1d 	bl	8013a28 <HAL_ETH_ErrorCallback>
  macirqenable = heth->Instance->MACIER;
 80021ee:	6823      	ldr	r3, [r4, #0]
 80021f0:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
  if (((macirqenable & ETH_MACIER_RXSTSIE) == ETH_MACIER_RXSTSIE) || \
 80021f4:	f412 4fc0 	tst.w	r2, #24576	@ 0x6000
 80021f8:	d133      	bne.n	8002262 <HAL_ETH_IRQHandler+0x11c>
  if (__HAL_ETH_MAC_GET_IT(heth, ETH_MAC_PMT_IT))
 80021fa:	6823      	ldr	r3, [r4, #0]
 80021fc:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
 8002200:	f012 0f10 	tst.w	r2, #16
 8002204:	d141      	bne.n	800228a <HAL_ETH_IRQHandler+0x144>
  if (__HAL_ETH_MAC_GET_IT(heth, ETH_MAC_LPI_IT))
 8002206:	6823      	ldr	r3, [r4, #0]
 8002208:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
 800220c:	f012 0f20 	tst.w	r2, #32
 8002210:	d148      	bne.n	80022a4 <HAL_ETH_IRQHandler+0x15e>
  if (__HAL_ETH_WAKEUP_EXTI_GET_FLAG(ETH_WAKEUP_EXTI_LINE) != (uint32_t)RESET)
 8002212:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8002216:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 800221a:	f413 0f80 	tst.w	r3, #4194304	@ 0x400000
 800221e:	d14e      	bne.n	80022be <HAL_ETH_IRQHandler+0x178>
}
 8002220:	bd10      	pop	{r4, pc}
      __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMACSR_RI | ETH_DMACSR_NIS);
 8002222:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8002226:	f248 0240 	movw	r2, #32832	@ 0x8040
 800222a:	f8c3 2160 	str.w	r2, [r3, #352]	@ 0x160
      HAL_ETH_RxCpltCallback(heth);
 800222e:	f011 fbeb 	bl	8013a08 <HAL_ETH_RxCpltCallback>
 8002232:	e799      	b.n	8002168 <HAL_ETH_IRQHandler+0x22>
      __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMACSR_TI | ETH_DMACSR_NIS);
 8002234:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8002238:	f248 0201 	movw	r2, #32769	@ 0x8001
 800223c:	f8c3 2160 	str.w	r2, [r3, #352]	@ 0x160
      HAL_ETH_TxCpltCallback(heth);
 8002240:	4620      	mov	r0, r4
 8002242:	f011 fbe9 	bl	8013a18 <HAL_ETH_TxCpltCallback>
 8002246:	e79e      	b.n	8002186 <HAL_ETH_IRQHandler+0x40>
        heth->DMAErrorCode = READ_BIT(heth->Instance->DMACSR, (ETH_DMACSR_CDE | ETH_DMACSR_ETI | ETH_DMACSR_RWT |
 8002248:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 800224c:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
 8002250:	f402 42cd 	and.w	r2, r2, #26240	@ 0x6680
 8002254:	f8c4 208c 	str.w	r2, [r4, #140]	@ 0x8c
        __HAL_ETH_DMA_CLEAR_IT(heth, (ETH_DMACSR_CDE | ETH_DMACSR_ETI | ETH_DMACSR_RWT |
 8002258:	f44f 42cd 	mov.w	r2, #26240	@ 0x6680
 800225c:	f8c3 2160 	str.w	r2, [r3, #352]	@ 0x160
 8002260:	e7c2      	b.n	80021e8 <HAL_ETH_IRQHandler+0xa2>
    heth->ErrorCode |= HAL_ETH_ERROR_MAC;
 8002262:	f8d4 2088 	ldr.w	r2, [r4, #136]	@ 0x88
 8002266:	f042 0210 	orr.w	r2, r2, #16
 800226a:	f8c4 2088 	str.w	r2, [r4, #136]	@ 0x88
    heth->MACErrorCode = READ_REG(heth->Instance->MACRXTXSR);
 800226e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
 8002272:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
    heth->gState = HAL_ETH_STATE_ERROR;
 8002276:	23e0      	movs	r3, #224	@ 0xe0
 8002278:	f8c4 3084 	str.w	r3, [r4, #132]	@ 0x84
    HAL_ETH_ErrorCallback(heth);
 800227c:	4620      	mov	r0, r4
 800227e:	f011 fbd3 	bl	8013a28 <HAL_ETH_ErrorCallback>
    heth->MACErrorCode = (uint32_t)(0x0U);
 8002282:	2300      	movs	r3, #0
 8002284:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
 8002288:	e7b7      	b.n	80021fa <HAL_ETH_IRQHandler+0xb4>
    heth->MACWakeUpEvent = READ_BIT(heth->Instance->MACPCSR, (ETH_MACPCSR_RWKPRCVD | ETH_MACPCSR_MGKPRCVD));
 800228a:	f8d3 30c0 	ldr.w	r3, [r3, #192]	@ 0xc0
 800228e:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 8002292:	f8c4 3094 	str.w	r3, [r4, #148]	@ 0x94
    HAL_ETH_PMTCallback(heth);
 8002296:	4620      	mov	r0, r4
 8002298:	f7ff ff52 	bl	8002140 <HAL_ETH_PMTCallback>
    heth->MACWakeUpEvent = (uint32_t)(0x0U);
 800229c:	2300      	movs	r3, #0
 800229e:	f8c4 3094 	str.w	r3, [r4, #148]	@ 0x94
 80022a2:	e7b0      	b.n	8002206 <HAL_ETH_IRQHandler+0xc0>
    heth->MACLPIEvent = READ_BIT(heth->Instance->MACPCSR, 0x0000000FU);
 80022a4:	f8d3 30c0 	ldr.w	r3, [r3, #192]	@ 0xc0
 80022a8:	f003 030f 	and.w	r3, r3, #15
 80022ac:	f8c4 3098 	str.w	r3, [r4, #152]	@ 0x98
    HAL_ETH_EEECallback(heth);
 80022b0:	4620      	mov	r0, r4
 80022b2:	f7ff ff46 	bl	8002142 <HAL_ETH_EEECallback>
    heth->MACLPIEvent = (uint32_t)(0x0U);
 80022b6:	2300      	movs	r3, #0
 80022b8:	f8c4 3098 	str.w	r3, [r4, #152]	@ 0x98
 80022bc:	e7a9      	b.n	8002212 <HAL_ETH_IRQHandler+0xcc>
    __HAL_ETH_WAKEUP_EXTI_CLEAR_FLAG(ETH_WAKEUP_EXTI_LINE);
 80022be:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80022c2:	f44f 0280 	mov.w	r2, #4194304	@ 0x400000
 80022c6:	f8c3 20a8 	str.w	r2, [r3, #168]	@ 0xa8
    HAL_ETH_WakeUpCallback(heth);
 80022ca:	4620      	mov	r0, r4
 80022cc:	f7ff ff3a 	bl	8002144 <HAL_ETH_WakeUpCallback>
}
 80022d0:	e7a6      	b.n	8002220 <HAL_ETH_IRQHandler+0xda>

080022d2 <HAL_ETH_ReadPHYRegister>:
{
 80022d2:	b570      	push	{r4, r5, r6, lr}
 80022d4:	4604      	mov	r4, r0
 80022d6:	461d      	mov	r5, r3
  if (READ_BIT(heth->Instance->MACMDIOAR, ETH_MACMDIOAR_MB) != (uint32_t)RESET)
 80022d8:	6800      	ldr	r0, [r0, #0]
 80022da:	f8d0 3200 	ldr.w	r3, [r0, #512]	@ 0x200
 80022de:	f013 0f01 	tst.w	r3, #1
 80022e2:	d001      	beq.n	80022e8 <HAL_ETH_ReadPHYRegister+0x16>
    return HAL_ERROR;
 80022e4:	2001      	movs	r0, #1
}
 80022e6:	bd70      	pop	{r4, r5, r6, pc}
  WRITE_REG(tmpreg, heth->Instance->MACMDIOAR);
 80022e8:	f8d0 3200 	ldr.w	r3, [r0, #512]	@ 0x200
  MODIFY_REG(tmpreg, ETH_MACMDIOAR_PA, (PHYAddr << 21));
 80022ec:	f023 7378 	bic.w	r3, r3, #65011712	@ 0x3e00000
 80022f0:	ea43 5141 	orr.w	r1, r3, r1, lsl #21
  MODIFY_REG(tmpreg, ETH_MACMDIOAR_RDA, (PHYReg << 16));
 80022f4:	f421 13f8 	bic.w	r3, r1, #2031616	@ 0x1f0000
 80022f8:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
  SET_BIT(tmpreg, ETH_MACMDIOAR_MB);
 80022fc:	f042 020d 	orr.w	r2, r2, #13
  WRITE_REG(heth->Instance->MACMDIOAR, tmpreg);
 8002300:	f8c0 2200 	str.w	r2, [r0, #512]	@ 0x200
  tickstart = HAL_GetTick();
 8002304:	f7ff f878 	bl	80013f8 <HAL_GetTick>
 8002308:	4606      	mov	r6, r0
  while (READ_BIT(heth->Instance->MACMDIOAR, ETH_MACMDIOAR_MB) > 0U)
 800230a:	6822      	ldr	r2, [r4, #0]
 800230c:	f8d2 1200 	ldr.w	r1, [r2, #512]	@ 0x200
 8002310:	f011 0f01 	tst.w	r1, #1
 8002314:	d007      	beq.n	8002326 <HAL_ETH_ReadPHYRegister+0x54>
    if (((HAL_GetTick() - tickstart) > ETH_MDIO_BUS_TIMEOUT))
 8002316:	f7ff f86f 	bl	80013f8 <HAL_GetTick>
 800231a:	1b82      	subs	r2, r0, r6
 800231c:	f5b2 7f7a 	cmp.w	r2, #1000	@ 0x3e8
 8002320:	d9f3      	bls.n	800230a <HAL_ETH_ReadPHYRegister+0x38>
      return HAL_ERROR;
 8002322:	2001      	movs	r0, #1
 8002324:	e7df      	b.n	80022e6 <HAL_ETH_ReadPHYRegister+0x14>
  WRITE_REG(*pRegValue, (uint16_t)heth->Instance->MACMDIODR);
 8002326:	f8d2 3204 	ldr.w	r3, [r2, #516]	@ 0x204
 800232a:	b29b      	uxth	r3, r3
 800232c:	602b      	str	r3, [r5, #0]
  return HAL_OK;
 800232e:	2000      	movs	r0, #0
 8002330:	e7d9      	b.n	80022e6 <HAL_ETH_ReadPHYRegister+0x14>
	...

08002334 <HAL_ETH_WritePHYRegister>:
{
 8002334:	b538      	push	{r3, r4, r5, lr}
 8002336:	4604      	mov	r4, r0
  if (READ_BIT(heth->Instance->MACMDIOAR, ETH_MACMDIOAR_MB) != (uint32_t)RESET)
 8002338:	6800      	ldr	r0, [r0, #0]
 800233a:	f8d0 5200 	ldr.w	r5, [r0, #512]	@ 0x200
 800233e:	f015 0f01 	tst.w	r5, #1
 8002342:	d001      	beq.n	8002348 <HAL_ETH_WritePHYRegister+0x14>
    return HAL_ERROR;
 8002344:	2001      	movs	r0, #1
}
 8002346:	bd38      	pop	{r3, r4, r5, pc}
  WRITE_REG(tmpreg, heth->Instance->MACMDIOAR);
 8002348:	f8d0 0200 	ldr.w	r0, [r0, #512]	@ 0x200
  MODIFY_REG(tmpreg, ETH_MACMDIOAR_PA, (PHYAddr << 21));
 800234c:	f020 7078 	bic.w	r0, r0, #65011712	@ 0x3e00000
 8002350:	ea40 5141 	orr.w	r1, r0, r1, lsl #21
  MODIFY_REG(tmpreg, ETH_MACMDIOAR_RDA, (PHYReg << 16));
 8002354:	f421 11f8 	bic.w	r1, r1, #2031616	@ 0x1f0000
 8002358:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
  MODIFY_REG(tmpreg, ETH_MACMDIOAR_MOC, ETH_MACMDIOAR_MOC_WR);
 800235c:	f022 020c 	bic.w	r2, r2, #12
  SET_BIT(tmpreg, ETH_MACMDIOAR_MB);
 8002360:	f042 0205 	orr.w	r2, r2, #5
  WRITE_REG(ETH->MACMDIODR, (uint16_t)RegValue);
 8002364:	b29b      	uxth	r3, r3
 8002366:	490c      	ldr	r1, [pc, #48]	@ (8002398 <HAL_ETH_WritePHYRegister+0x64>)
 8002368:	f8c1 3204 	str.w	r3, [r1, #516]	@ 0x204
  WRITE_REG(ETH->MACMDIOAR, tmpreg);
 800236c:	f8c1 2200 	str.w	r2, [r1, #512]	@ 0x200
  tickstart = HAL_GetTick();
 8002370:	f7ff f842 	bl	80013f8 <HAL_GetTick>
 8002374:	4605      	mov	r5, r0
  while (READ_BIT(heth->Instance->MACMDIOAR, ETH_MACMDIOAR_MB) > 0U)
 8002376:	6823      	ldr	r3, [r4, #0]
 8002378:	f8d3 3200 	ldr.w	r3, [r3, #512]	@ 0x200
 800237c:	f013 0f01 	tst.w	r3, #1
 8002380:	d007      	beq.n	8002392 <HAL_ETH_WritePHYRegister+0x5e>
    if (((HAL_GetTick() - tickstart) > ETH_MDIO_BUS_TIMEOUT))
 8002382:	f7ff f839 	bl	80013f8 <HAL_GetTick>
 8002386:	1b43      	subs	r3, r0, r5
 8002388:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 800238c:	d9f3      	bls.n	8002376 <HAL_ETH_WritePHYRegister+0x42>
      return HAL_ERROR;
 800238e:	2001      	movs	r0, #1
 8002390:	e7d9      	b.n	8002346 <HAL_ETH_WritePHYRegister+0x12>
  return HAL_OK;
 8002392:	2000      	movs	r0, #0
 8002394:	e7d7      	b.n	8002346 <HAL_ETH_WritePHYRegister+0x12>
 8002396:	bf00      	nop
 8002398:	40028000 	.word	0x40028000

0800239c <HAL_ETH_GetMACConfig>:
  if (macconf == NULL)
 800239c:	2900      	cmp	r1, #0
 800239e:	f000 80ee 	beq.w	800257e <HAL_ETH_GetMACConfig+0x1e2>
  macconf->PreambleLength = READ_BIT(heth->Instance->MACCR, ETH_MACCR_PRELEN);
 80023a2:	6802      	ldr	r2, [r0, #0]
 80023a4:	6812      	ldr	r2, [r2, #0]
 80023a6:	f002 020c 	and.w	r2, r2, #12
 80023aa:	62ca      	str	r2, [r1, #44]	@ 0x2c
  macconf->DeferralCheck = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_DC) >> 4) > 0U) ? ENABLE : DISABLE;
 80023ac:	6802      	ldr	r2, [r0, #0]
 80023ae:	6812      	ldr	r2, [r2, #0]
 80023b0:	f3c2 1200 	ubfx	r2, r2, #4, #1
 80023b4:	f881 2028 	strb.w	r2, [r1, #40]	@ 0x28
  macconf->BackOffLimit = READ_BIT(heth->Instance->MACCR, ETH_MACCR_BL);
 80023b8:	6802      	ldr	r2, [r0, #0]
 80023ba:	6812      	ldr	r2, [r2, #0]
 80023bc:	f002 0260 	and.w	r2, r2, #96	@ 0x60
 80023c0:	624a      	str	r2, [r1, #36]	@ 0x24
  macconf->RetryTransmission = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_DR) >> 8) == 0U) ? ENABLE : DISABLE;
 80023c2:	6802      	ldr	r2, [r0, #0]
 80023c4:	6812      	ldr	r2, [r2, #0]
 80023c6:	f412 7f80 	tst.w	r2, #256	@ 0x100
 80023ca:	bf0c      	ite	eq
 80023cc:	2201      	moveq	r2, #1
 80023ce:	2200      	movne	r2, #0
 80023d0:	f881 2020 	strb.w	r2, [r1, #32]
  macconf->CarrierSenseDuringTransmit = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_DCRS) >> 9) > 0U)
 80023d4:	6802      	ldr	r2, [r0, #0]
 80023d6:	6812      	ldr	r2, [r2, #0]
                                        ? ENABLE : DISABLE;
 80023d8:	f3c2 2240 	ubfx	r2, r2, #9, #1
  macconf->CarrierSenseDuringTransmit = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_DCRS) >> 9) > 0U)
 80023dc:	77ca      	strb	r2, [r1, #31]
  macconf->ReceiveOwn = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_DO) >> 10) == 0U) ? ENABLE : DISABLE;
 80023de:	6802      	ldr	r2, [r0, #0]
 80023e0:	6812      	ldr	r2, [r2, #0]
 80023e2:	f412 6f80 	tst.w	r2, #1024	@ 0x400
 80023e6:	bf0c      	ite	eq
 80023e8:	2201      	moveq	r2, #1
 80023ea:	2200      	movne	r2, #0
 80023ec:	778a      	strb	r2, [r1, #30]
  macconf->CarrierSenseBeforeTransmit = ((READ_BIT(heth->Instance->MACCR,
 80023ee:	6802      	ldr	r2, [r0, #0]
 80023f0:	6812      	ldr	r2, [r2, #0]
                                                   ETH_MACCR_ECRSFD) >> 11) > 0U) ? ENABLE : DISABLE;
 80023f2:	f3c2 22c0 	ubfx	r2, r2, #11, #1
  macconf->CarrierSenseBeforeTransmit = ((READ_BIT(heth->Instance->MACCR,
 80023f6:	774a      	strb	r2, [r1, #29]
  macconf->LoopbackMode = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_LM) >> 12) > 0U) ? ENABLE : DISABLE;
 80023f8:	6802      	ldr	r2, [r0, #0]
 80023fa:	6812      	ldr	r2, [r2, #0]
 80023fc:	f3c2 3200 	ubfx	r2, r2, #12, #1
 8002400:	770a      	strb	r2, [r1, #28]
  macconf->DuplexMode = READ_BIT(heth->Instance->MACCR, ETH_MACCR_DM);
 8002402:	6802      	ldr	r2, [r0, #0]
 8002404:	6812      	ldr	r2, [r2, #0]
 8002406:	f402 5200 	and.w	r2, r2, #8192	@ 0x2000
 800240a:	618a      	str	r2, [r1, #24]
  macconf->Speed = READ_BIT(heth->Instance->MACCR, ETH_MACCR_FES);
 800240c:	6802      	ldr	r2, [r0, #0]
 800240e:	6812      	ldr	r2, [r2, #0]
 8002410:	f402 4280 	and.w	r2, r2, #16384	@ 0x4000
 8002414:	614a      	str	r2, [r1, #20]
  macconf->JumboPacket = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_JE) >> 16) > 0U) ? ENABLE : DISABLE;
 8002416:	6802      	ldr	r2, [r0, #0]
 8002418:	6812      	ldr	r2, [r2, #0]
 800241a:	f3c2 4200 	ubfx	r2, r2, #16, #1
 800241e:	748a      	strb	r2, [r1, #18]
  macconf->Jabber = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_JD) >> 17) == 0U) ? ENABLE : DISABLE;
 8002420:	6802      	ldr	r2, [r0, #0]
 8002422:	6812      	ldr	r2, [r2, #0]
 8002424:	f412 3f00 	tst.w	r2, #131072	@ 0x20000
 8002428:	bf0c      	ite	eq
 800242a:	2201      	moveq	r2, #1
 800242c:	2200      	movne	r2, #0
 800242e:	744a      	strb	r2, [r1, #17]
  macconf->Watchdog = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_WD) >> 19) == 0U) ? ENABLE : DISABLE;
 8002430:	6802      	ldr	r2, [r0, #0]
 8002432:	6812      	ldr	r2, [r2, #0]
 8002434:	f412 2f00 	tst.w	r2, #524288	@ 0x80000
 8002438:	bf0c      	ite	eq
 800243a:	2201      	moveq	r2, #1
 800243c:	2200      	movne	r2, #0
 800243e:	740a      	strb	r2, [r1, #16]
  macconf->AutomaticPadCRCStrip = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_ACS) >> 20) > 0U) ? ENABLE : DISABLE;
 8002440:	6802      	ldr	r2, [r0, #0]
 8002442:	6812      	ldr	r2, [r2, #0]
 8002444:	f3c2 5200 	ubfx	r2, r2, #20, #1
 8002448:	73ca      	strb	r2, [r1, #15]
  macconf->CRCStripTypePacket = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_CST) >> 21) > 0U) ? ENABLE : DISABLE;
 800244a:	6802      	ldr	r2, [r0, #0]
 800244c:	6812      	ldr	r2, [r2, #0]
 800244e:	f3c2 5240 	ubfx	r2, r2, #21, #1
 8002452:	738a      	strb	r2, [r1, #14]
  macconf->Support2KPacket = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_S2KP) >> 22) > 0U) ? ENABLE : DISABLE;
 8002454:	6802      	ldr	r2, [r0, #0]
 8002456:	6812      	ldr	r2, [r2, #0]
 8002458:	f3c2 5280 	ubfx	r2, r2, #22, #1
 800245c:	734a      	strb	r2, [r1, #13]
  macconf->GiantPacketSizeLimitControl = ((READ_BIT(heth->Instance->MACCR,
 800245e:	6802      	ldr	r2, [r0, #0]
 8002460:	6812      	ldr	r2, [r2, #0]
                                                    ETH_MACCR_GPSLCE) >> 23) > 0U) ? ENABLE : DISABLE;
 8002462:	f3c2 52c0 	ubfx	r2, r2, #23, #1
  macconf->GiantPacketSizeLimitControl = ((READ_BIT(heth->Instance->MACCR,
 8002466:	730a      	strb	r2, [r1, #12]
  macconf->InterPacketGapVal = READ_BIT(heth->Instance->MACCR, ETH_MACCR_IPG);
 8002468:	6802      	ldr	r2, [r0, #0]
 800246a:	6812      	ldr	r2, [r2, #0]
 800246c:	f002 62e0 	and.w	r2, r2, #117440512	@ 0x7000000
 8002470:	608a      	str	r2, [r1, #8]
  macconf->ChecksumOffload = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_IPC) >> 27) > 0U) ? ENABLE : DISABLE;
 8002472:	6802      	ldr	r2, [r0, #0]
 8002474:	6812      	ldr	r2, [r2, #0]
 8002476:	f3c2 62c0 	ubfx	r2, r2, #27, #1
 800247a:	710a      	strb	r2, [r1, #4]
  macconf->SourceAddrControl = READ_BIT(heth->Instance->MACCR, ETH_MACCR_SARC);
 800247c:	6802      	ldr	r2, [r0, #0]
 800247e:	6812      	ldr	r2, [r2, #0]
 8002480:	f002 42e0 	and.w	r2, r2, #1879048192	@ 0x70000000
 8002484:	600a      	str	r2, [r1, #0]
  macconf->GiantPacketSizeLimit = READ_BIT(heth->Instance->MACECR, ETH_MACECR_GPSL);
 8002486:	6802      	ldr	r2, [r0, #0]
 8002488:	6852      	ldr	r2, [r2, #4]
 800248a:	f3c2 020d 	ubfx	r2, r2, #0, #14
 800248e:	634a      	str	r2, [r1, #52]	@ 0x34
  macconf->CRCCheckingRxPackets = ((READ_BIT(heth->Instance->MACECR, ETH_MACECR_DCRCC) >> 16) == 0U) ? ENABLE : DISABLE;
 8002490:	6802      	ldr	r2, [r0, #0]
 8002492:	6852      	ldr	r2, [r2, #4]
 8002494:	f412 3f80 	tst.w	r2, #65536	@ 0x10000
 8002498:	bf0c      	ite	eq
 800249a:	2201      	moveq	r2, #1
 800249c:	2200      	movne	r2, #0
 800249e:	f881 2032 	strb.w	r2, [r1, #50]	@ 0x32
  macconf->SlowProtocolDetect = ((READ_BIT(heth->Instance->MACECR, ETH_MACECR_SPEN) >> 17) > 0U) ? ENABLE : DISABLE;
 80024a2:	6802      	ldr	r2, [r0, #0]
 80024a4:	6852      	ldr	r2, [r2, #4]
 80024a6:	f3c2 4240 	ubfx	r2, r2, #17, #1
 80024aa:	f881 2031 	strb.w	r2, [r1, #49]	@ 0x31
  macconf->UnicastSlowProtocolPacketDetect = ((READ_BIT(heth->Instance->MACECR,
 80024ae:	6802      	ldr	r2, [r0, #0]
 80024b0:	6852      	ldr	r2, [r2, #4]
                                                        ETH_MACECR_USP) >> 18) > 0U) ? ENABLE : DISABLE;
 80024b2:	f3c2 4280 	ubfx	r2, r2, #18, #1
  macconf->UnicastSlowProtocolPacketDetect = ((READ_BIT(heth->Instance->MACECR,
 80024b6:	f881 2030 	strb.w	r2, [r1, #48]	@ 0x30
  macconf->ExtendedInterPacketGap = ((READ_BIT(heth->Instance->MACECR, ETH_MACECR_EIPGEN) >> 24) > 0U)
 80024ba:	6802      	ldr	r2, [r0, #0]
 80024bc:	6852      	ldr	r2, [r2, #4]
                                    ? ENABLE : DISABLE;
 80024be:	f3c2 6200 	ubfx	r2, r2, #24, #1
  macconf->ExtendedInterPacketGap = ((READ_BIT(heth->Instance->MACECR, ETH_MACECR_EIPGEN) >> 24) > 0U)
 80024c2:	f881 2038 	strb.w	r2, [r1, #56]	@ 0x38
  macconf->ExtendedInterPacketGapVal = READ_BIT(heth->Instance->MACECR, ETH_MACECR_EIPG) >> 25;
 80024c6:	6802      	ldr	r2, [r0, #0]
 80024c8:	6852      	ldr	r2, [r2, #4]
 80024ca:	f3c2 6244 	ubfx	r2, r2, #25, #5
 80024ce:	63ca      	str	r2, [r1, #60]	@ 0x3c
  macconf->ProgrammableWatchdog = ((READ_BIT(heth->Instance->MACWTR, ETH_MACWTR_PWE) >> 8) > 0U) ? ENABLE : DISABLE;
 80024d0:	6802      	ldr	r2, [r0, #0]
 80024d2:	68d2      	ldr	r2, [r2, #12]
 80024d4:	f3c2 2200 	ubfx	r2, r2, #8, #1
 80024d8:	f881 2040 	strb.w	r2, [r1, #64]	@ 0x40
  macconf->WatchdogTimeout = READ_BIT(heth->Instance->MACWTR, ETH_MACWTR_WTO);
 80024dc:	6802      	ldr	r2, [r0, #0]
 80024de:	68d2      	ldr	r2, [r2, #12]
 80024e0:	f002 020f 	and.w	r2, r2, #15
 80024e4:	644a      	str	r2, [r1, #68]	@ 0x44
  macconf->TransmitFlowControl = ((READ_BIT(heth->Instance->MACTFCR, ETH_MACTFCR_TFE) >> 1) > 0U) ? ENABLE : DISABLE;
 80024e6:	6802      	ldr	r2, [r0, #0]
 80024e8:	6f12      	ldr	r2, [r2, #112]	@ 0x70
 80024ea:	f3c2 0240 	ubfx	r2, r2, #1, #1
 80024ee:	f881 2054 	strb.w	r2, [r1, #84]	@ 0x54
  macconf->ZeroQuantaPause = ((READ_BIT(heth->Instance->MACTFCR, ETH_MACTFCR_DZPQ) >> 7) == 0U) ? ENABLE : DISABLE;
 80024f2:	6802      	ldr	r2, [r0, #0]
 80024f4:	6f12      	ldr	r2, [r2, #112]	@ 0x70
 80024f6:	f012 0f80 	tst.w	r2, #128	@ 0x80
 80024fa:	bf0c      	ite	eq
 80024fc:	2201      	moveq	r2, #1
 80024fe:	2200      	movne	r2, #0
 8002500:	f881 204c 	strb.w	r2, [r1, #76]	@ 0x4c
  macconf->PauseLowThreshold = READ_BIT(heth->Instance->MACTFCR, ETH_MACTFCR_PLT);
 8002504:	6802      	ldr	r2, [r0, #0]
 8002506:	6f12      	ldr	r2, [r2, #112]	@ 0x70
 8002508:	f002 0270 	and.w	r2, r2, #112	@ 0x70
 800250c:	650a      	str	r2, [r1, #80]	@ 0x50
  macconf->PauseTime = (READ_BIT(heth->Instance->MACTFCR, ETH_MACTFCR_PT) >> 16);
 800250e:	6802      	ldr	r2, [r0, #0]
 8002510:	6f12      	ldr	r2, [r2, #112]	@ 0x70
 8002512:	0c12      	lsrs	r2, r2, #16
 8002514:	648a      	str	r2, [r1, #72]	@ 0x48
  macconf->ReceiveFlowControl = (READ_BIT(heth->Instance->MACRFCR, ETH_MACRFCR_RFE) > 0U) ? ENABLE : DISABLE;
 8002516:	6802      	ldr	r2, [r0, #0]
 8002518:	f8d2 2090 	ldr.w	r2, [r2, #144]	@ 0x90
 800251c:	f002 0201 	and.w	r2, r2, #1
 8002520:	f881 2056 	strb.w	r2, [r1, #86]	@ 0x56
  macconf->UnicastPausePacketDetect = ((READ_BIT(heth->Instance->MACRFCR, ETH_MACRFCR_UP) >> 1) > 0U)
 8002524:	6802      	ldr	r2, [r0, #0]
 8002526:	f8d2 2090 	ldr.w	r2, [r2, #144]	@ 0x90
                                      ? ENABLE : DISABLE;
 800252a:	f3c2 0240 	ubfx	r2, r2, #1, #1
  macconf->UnicastPausePacketDetect = ((READ_BIT(heth->Instance->MACRFCR, ETH_MACRFCR_UP) >> 1) > 0U)
 800252e:	f881 2055 	strb.w	r2, [r1, #85]	@ 0x55
  macconf->TransmitQueueMode = READ_BIT(heth->Instance->MTLTQOMR, (ETH_MTLTQOMR_TTC | ETH_MTLTQOMR_TSF));
 8002532:	6802      	ldr	r2, [r0, #0]
 8002534:	f8d2 2d00 	ldr.w	r2, [r2, #3328]	@ 0xd00
 8002538:	f002 0272 	and.w	r2, r2, #114	@ 0x72
 800253c:	658a      	str	r2, [r1, #88]	@ 0x58
  macconf->ReceiveQueueMode = READ_BIT(heth->Instance->MTLRQOMR, (ETH_MTLRQOMR_RTC | ETH_MTLRQOMR_RSF));
 800253e:	6802      	ldr	r2, [r0, #0]
 8002540:	f8d2 2d30 	ldr.w	r2, [r2, #3376]	@ 0xd30
 8002544:	f002 0223 	and.w	r2, r2, #35	@ 0x23
 8002548:	65ca      	str	r2, [r1, #92]	@ 0x5c
  macconf->ForwardRxUndersizedGoodPacket = ((READ_BIT(heth->Instance->MTLRQOMR,
 800254a:	6802      	ldr	r2, [r0, #0]
 800254c:	f8d2 2d30 	ldr.w	r2, [r2, #3376]	@ 0xd30
                                                      ETH_MTLRQOMR_FUP) >> 3) > 0U) ? ENABLE : DISABLE;
 8002550:	f3c2 02c0 	ubfx	r2, r2, #3, #1
  macconf->ForwardRxUndersizedGoodPacket = ((READ_BIT(heth->Instance->MTLRQOMR,
 8002554:	f881 2062 	strb.w	r2, [r1, #98]	@ 0x62
  macconf->ForwardRxErrorPacket = ((READ_BIT(heth->Instance->MTLRQOMR, ETH_MTLRQOMR_FEP) >> 4) > 0U) ? ENABLE : DISABLE;
 8002558:	6802      	ldr	r2, [r0, #0]
 800255a:	f8d2 2d30 	ldr.w	r2, [r2, #3376]	@ 0xd30
 800255e:	f3c2 1200 	ubfx	r2, r2, #4, #1
 8002562:	f881 2061 	strb.w	r2, [r1, #97]	@ 0x61
  macconf->DropTCPIPChecksumErrorPacket = ((READ_BIT(heth->Instance->MTLRQOMR,
 8002566:	6802      	ldr	r2, [r0, #0]
 8002568:	f8d2 2d30 	ldr.w	r2, [r2, #3376]	@ 0xd30
                                                     ETH_MTLRQOMR_DISTCPEF) >> 6) == 0U) ? ENABLE : DISABLE;
 800256c:	f012 0f40 	tst.w	r2, #64	@ 0x40
 8002570:	bf0c      	ite	eq
 8002572:	2201      	moveq	r2, #1
 8002574:	2200      	movne	r2, #0
  macconf->DropTCPIPChecksumErrorPacket = ((READ_BIT(heth->Instance->MTLRQOMR,
 8002576:	f881 2060 	strb.w	r2, [r1, #96]	@ 0x60
  return HAL_OK;
 800257a:	2000      	movs	r0, #0
 800257c:	4770      	bx	lr
    return HAL_ERROR;
 800257e:	2001      	movs	r0, #1
}
 8002580:	4770      	bx	lr

08002582 <HAL_ETH_SetMACConfig>:
  if (macconf == NULL)
 8002582:	b151      	cbz	r1, 800259a <HAL_ETH_SetMACConfig+0x18>
{
 8002584:	b508      	push	{r3, lr}
  if (heth->gState == HAL_ETH_STATE_READY)
 8002586:	f8d0 3084 	ldr.w	r3, [r0, #132]	@ 0x84
 800258a:	2b10      	cmp	r3, #16
 800258c:	d001      	beq.n	8002592 <HAL_ETH_SetMACConfig+0x10>
    return HAL_ERROR;
 800258e:	2001      	movs	r0, #1
}
 8002590:	bd08      	pop	{r3, pc}
    ETH_SetMACConfig(heth, macconf);
 8002592:	f7ff f8f3 	bl	800177c <ETH_SetMACConfig>
    return HAL_OK;
 8002596:	2000      	movs	r0, #0
 8002598:	e7fa      	b.n	8002590 <HAL_ETH_SetMACConfig+0xe>
    return HAL_ERROR;
 800259a:	2001      	movs	r0, #1
}
 800259c:	4770      	bx	lr
	...

080025a0 <HAL_ETH_SetMDIOClockRange>:
{
 80025a0:	b538      	push	{r3, r4, r5, lr}
 80025a2:	4605      	mov	r5, r0
  tmpreg = (heth->Instance)->MACMDIOAR;
 80025a4:	6803      	ldr	r3, [r0, #0]
 80025a6:	f8d3 4200 	ldr.w	r4, [r3, #512]	@ 0x200
  tmpreg &= ~ETH_MACMDIOAR_CR;
 80025aa:	f424 6470 	bic.w	r4, r4, #3840	@ 0xf00
  hclk = HAL_RCC_GetHCLKFreq();
 80025ae:	f001 fbaf 	bl	8003d10 <HAL_RCC_GetHCLKFreq>
  if ((hclk >= 20000000U) && (hclk < 35000000U))
 80025b2:	4b11      	ldr	r3, [pc, #68]	@ (80025f8 <HAL_ETH_SetMDIOClockRange+0x58>)
 80025b4:	4403      	add	r3, r0
 80025b6:	4a11      	ldr	r2, [pc, #68]	@ (80025fc <HAL_ETH_SetMDIOClockRange+0x5c>)
 80025b8:	4293      	cmp	r3, r2
 80025ba:	d205      	bcs.n	80025c8 <HAL_ETH_SetMDIOClockRange+0x28>
    tmpreg |= (uint32_t)ETH_MACMDIOAR_CR_DIV16;
 80025bc:	f444 7400 	orr.w	r4, r4, #512	@ 0x200
  (heth->Instance)->MACMDIOAR = (uint32_t)tmpreg;
 80025c0:	682b      	ldr	r3, [r5, #0]
 80025c2:	f8c3 4200 	str.w	r4, [r3, #512]	@ 0x200
}
 80025c6:	bd38      	pop	{r3, r4, r5, pc}
  else if ((hclk >= 35000000U) && (hclk < 60000000U))
 80025c8:	4b0d      	ldr	r3, [pc, #52]	@ (8002600 <HAL_ETH_SetMDIOClockRange+0x60>)
 80025ca:	4403      	add	r3, r0
 80025cc:	4a0d      	ldr	r2, [pc, #52]	@ (8002604 <HAL_ETH_SetMDIOClockRange+0x64>)
 80025ce:	4293      	cmp	r3, r2
 80025d0:	d802      	bhi.n	80025d8 <HAL_ETH_SetMDIOClockRange+0x38>
    tmpreg |= (uint32_t)ETH_MACMDIOAR_CR_DIV26;
 80025d2:	f444 7440 	orr.w	r4, r4, #768	@ 0x300
 80025d6:	e7f3      	b.n	80025c0 <HAL_ETH_SetMDIOClockRange+0x20>
  else if ((hclk >= 60000000U) && (hclk < 100000000U))
 80025d8:	4b0b      	ldr	r3, [pc, #44]	@ (8002608 <HAL_ETH_SetMDIOClockRange+0x68>)
 80025da:	4403      	add	r3, r0
 80025dc:	4a0b      	ldr	r2, [pc, #44]	@ (800260c <HAL_ETH_SetMDIOClockRange+0x6c>)
 80025de:	4293      	cmp	r3, r2
 80025e0:	d3ee      	bcc.n	80025c0 <HAL_ETH_SetMDIOClockRange+0x20>
  else if ((hclk >= 100000000U) && (hclk < 150000000U))
 80025e2:	4b0b      	ldr	r3, [pc, #44]	@ (8002610 <HAL_ETH_SetMDIOClockRange+0x70>)
 80025e4:	4403      	add	r3, r0
 80025e6:	4a0b      	ldr	r2, [pc, #44]	@ (8002614 <HAL_ETH_SetMDIOClockRange+0x74>)
 80025e8:	4293      	cmp	r3, r2
 80025ea:	d802      	bhi.n	80025f2 <HAL_ETH_SetMDIOClockRange+0x52>
    tmpreg |= (uint32_t)ETH_MACMDIOAR_CR_DIV62;
 80025ec:	f444 7480 	orr.w	r4, r4, #256	@ 0x100
 80025f0:	e7e6      	b.n	80025c0 <HAL_ETH_SetMDIOClockRange+0x20>
    tmpreg |= (uint32_t)ETH_MACMDIOAR_CR_DIV102;
 80025f2:	f444 6480 	orr.w	r4, r4, #1024	@ 0x400
 80025f6:	e7e3      	b.n	80025c0 <HAL_ETH_SetMDIOClockRange+0x20>
 80025f8:	feced300 	.word	0xfeced300
 80025fc:	00e4e1c0 	.word	0x00e4e1c0
 8002600:	fde9f140 	.word	0xfde9f140
 8002604:	017d783f 	.word	0x017d783f
 8002608:	fc6c7900 	.word	0xfc6c7900
 800260c:	02625a00 	.word	0x02625a00
 8002610:	fa0a1f00 	.word	0xfa0a1f00
 8002614:	02faf07f 	.word	0x02faf07f

08002618 <HAL_ETH_Init>:
  if (heth == NULL)
 8002618:	2800      	cmp	r0, #0
 800261a:	f000 8099 	beq.w	8002750 <HAL_ETH_Init+0x138>
{
 800261e:	b530      	push	{r4, r5, lr}
 8002620:	b083      	sub	sp, #12
 8002622:	4604      	mov	r4, r0
  if (heth->gState == HAL_ETH_STATE_RESET)
 8002624:	f8d0 3084 	ldr.w	r3, [r0, #132]	@ 0x84
 8002628:	b39b      	cbz	r3, 8002692 <HAL_ETH_Init+0x7a>
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 800262a:	4b4a      	ldr	r3, [pc, #296]	@ (8002754 <HAL_ETH_Init+0x13c>)
 800262c:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
 8002630:	f042 0202 	orr.w	r2, r2, #2
 8002634:	f8c3 20f4 	str.w	r2, [r3, #244]	@ 0xf4
 8002638:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 800263c:	f003 0302 	and.w	r3, r3, #2
 8002640:	9301      	str	r3, [sp, #4]
 8002642:	9b01      	ldr	r3, [sp, #4]
  if (heth->Init.MediaInterface == HAL_ETH_MII_MODE)
 8002644:	7a23      	ldrb	r3, [r4, #8]
 8002646:	bb53      	cbnz	r3, 800269e <HAL_ETH_Init+0x86>
    HAL_SYSCFG_ETHInterfaceSelect(SYSCFG_ETH_MII);
 8002648:	2000      	movs	r0, #0
 800264a:	f7fe fef5 	bl	8001438 <HAL_SYSCFG_ETHInterfaceSelect>
  (void)SYSCFG->PMCR;
 800264e:	4b42      	ldr	r3, [pc, #264]	@ (8002758 <HAL_ETH_Init+0x140>)
 8002650:	685b      	ldr	r3, [r3, #4]
  SET_BIT(heth->Instance->DMAMR, ETH_DMAMR_SWR);
 8002652:	6823      	ldr	r3, [r4, #0]
 8002654:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8002658:	681a      	ldr	r2, [r3, #0]
 800265a:	f042 0201 	orr.w	r2, r2, #1
 800265e:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
 8002660:	f7fe feca 	bl	80013f8 <HAL_GetTick>
 8002664:	4605      	mov	r5, r0
  while (READ_BIT(heth->Instance->DMAMR, ETH_DMAMR_SWR) > 0U)
 8002666:	6823      	ldr	r3, [r4, #0]
 8002668:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 800266c:	681b      	ldr	r3, [r3, #0]
 800266e:	f013 0f01 	tst.w	r3, #1
 8002672:	d019      	beq.n	80026a8 <HAL_ETH_Init+0x90>
    if (((HAL_GetTick() - tickstart) > ETH_SWRESET_TIMEOUT))
 8002674:	f7fe fec0 	bl	80013f8 <HAL_GetTick>
 8002678:	1b40      	subs	r0, r0, r5
 800267a:	f5b0 7ffa 	cmp.w	r0, #500	@ 0x1f4
 800267e:	d9f2      	bls.n	8002666 <HAL_ETH_Init+0x4e>
      heth->ErrorCode = HAL_ETH_ERROR_TIMEOUT;
 8002680:	2304      	movs	r3, #4
 8002682:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
      heth->gState = HAL_ETH_STATE_ERROR;
 8002686:	23e0      	movs	r3, #224	@ 0xe0
 8002688:	f8c4 3084 	str.w	r3, [r4, #132]	@ 0x84
      return HAL_ERROR;
 800268c:	2001      	movs	r0, #1
}
 800268e:	b003      	add	sp, #12
 8002690:	bd30      	pop	{r4, r5, pc}
    heth->gState = HAL_ETH_STATE_BUSY;
 8002692:	2323      	movs	r3, #35	@ 0x23
 8002694:	f8c0 3084 	str.w	r3, [r0, #132]	@ 0x84
    HAL_ETH_MspInit(heth);
 8002698:	f011 f92e 	bl	80138f8 <HAL_ETH_MspInit>
 800269c:	e7c5      	b.n	800262a <HAL_ETH_Init+0x12>
    HAL_SYSCFG_ETHInterfaceSelect(SYSCFG_ETH_RMII);
 800269e:	f44f 0000 	mov.w	r0, #8388608	@ 0x800000
 80026a2:	f7fe fec9 	bl	8001438 <HAL_SYSCFG_ETHInterfaceSelect>
 80026a6:	e7d2      	b.n	800264e <HAL_ETH_Init+0x36>
  HAL_ETH_SetMDIOClockRange(heth);
 80026a8:	4620      	mov	r0, r4
 80026aa:	f7ff ff79 	bl	80025a0 <HAL_ETH_SetMDIOClockRange>
  WRITE_REG(heth->Instance->MAC1USTCR, (((uint32_t)HAL_RCC_GetHCLKFreq() / ETH_MAC_US_TICK) - 1U));
 80026ae:	f001 fb2f 	bl	8003d10 <HAL_RCC_GetHCLKFreq>
 80026b2:	4b2a      	ldr	r3, [pc, #168]	@ (800275c <HAL_ETH_Init+0x144>)
 80026b4:	fba3 2300 	umull	r2, r3, r3, r0
 80026b8:	0c9b      	lsrs	r3, r3, #18
 80026ba:	6822      	ldr	r2, [r4, #0]
 80026bc:	3b01      	subs	r3, #1
 80026be:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  ETH_MACDMAConfig(heth);
 80026c2:	4620      	mov	r0, r4
 80026c4:	f7ff f988 	bl	80019d8 <ETH_MACDMAConfig>
  MODIFY_REG(heth->Instance->DMACCR, ETH_DMACCR_DSL, ETH_DMACCR_DSL_64BIT);
 80026c8:	6822      	ldr	r2, [r4, #0]
 80026ca:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 80026ce:	f8d2 3100 	ldr.w	r3, [r2, #256]	@ 0x100
 80026d2:	f423 13e0 	bic.w	r3, r3, #1835008	@ 0x1c0000
 80026d6:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 80026da:	f8c2 3100 	str.w	r3, [r2, #256]	@ 0x100
  if ((heth->Init.RxBuffLen % 0x4U) != 0x0U)
 80026de:	6962      	ldr	r2, [r4, #20]
 80026e0:	f012 0f03 	tst.w	r2, #3
 80026e4:	d006      	beq.n	80026f4 <HAL_ETH_Init+0xdc>
    heth->ErrorCode = HAL_ETH_ERROR_PARAM;
 80026e6:	2001      	movs	r0, #1
 80026e8:	f8c4 0088 	str.w	r0, [r4, #136]	@ 0x88
    heth->gState = HAL_ETH_STATE_ERROR;
 80026ec:	23e0      	movs	r3, #224	@ 0xe0
 80026ee:	f8c4 3084 	str.w	r3, [r4, #132]	@ 0x84
    return HAL_ERROR;
 80026f2:	e7cc      	b.n	800268e <HAL_ETH_Init+0x76>
    MODIFY_REG(heth->Instance->DMACRCR, ETH_DMACRCR_RBSZ, ((heth->Init.RxBuffLen) << 1));
 80026f4:	6821      	ldr	r1, [r4, #0]
 80026f6:	f501 5180 	add.w	r1, r1, #4096	@ 0x1000
 80026fa:	f8d1 3108 	ldr.w	r3, [r1, #264]	@ 0x108
 80026fe:	f36f 034e 	bfc	r3, #1, #14
 8002702:	ea43 0342 	orr.w	r3, r3, r2, lsl #1
 8002706:	f8c1 3108 	str.w	r3, [r1, #264]	@ 0x108
  ETH_DMATxDescListInit(heth);
 800270a:	4620      	mov	r0, r4
 800270c:	f7ff f9d2 	bl	8001ab4 <ETH_DMATxDescListInit>
  ETH_DMARxDescListInit(heth);
 8002710:	4620      	mov	r0, r4
 8002712:	f7ff f9fc 	bl	8001b0e <ETH_DMARxDescListInit>
  heth->Instance->MACA0HR = (((uint32_t)(heth->Init.MACAddr[5]) << 8) | (uint32_t)heth->Init.MACAddr[4]);
 8002716:	6863      	ldr	r3, [r4, #4]
 8002718:	7959      	ldrb	r1, [r3, #5]
 800271a:	791b      	ldrb	r3, [r3, #4]
 800271c:	6822      	ldr	r2, [r4, #0]
 800271e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8002722:	f8c2 3300 	str.w	r3, [r2, #768]	@ 0x300
  heth->Instance->MACA0LR = (((uint32_t)(heth->Init.MACAddr[3]) << 24) | ((uint32_t)(heth->Init.MACAddr[2]) << 16) |
 8002726:	6862      	ldr	r2, [r4, #4]
 8002728:	78d1      	ldrb	r1, [r2, #3]
 800272a:	7893      	ldrb	r3, [r2, #2]
 800272c:	041b      	lsls	r3, r3, #16
 800272e:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
                             ((uint32_t)(heth->Init.MACAddr[1]) << 8) | (uint32_t)heth->Init.MACAddr[0]);
 8002732:	7851      	ldrb	r1, [r2, #1]
  heth->Instance->MACA0LR = (((uint32_t)(heth->Init.MACAddr[3]) << 24) | ((uint32_t)(heth->Init.MACAddr[2]) << 16) |
 8002734:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
                             ((uint32_t)(heth->Init.MACAddr[1]) << 8) | (uint32_t)heth->Init.MACAddr[0]);
 8002738:	7811      	ldrb	r1, [r2, #0]
  heth->Instance->MACA0LR = (((uint32_t)(heth->Init.MACAddr[3]) << 24) | ((uint32_t)(heth->Init.MACAddr[2]) << 16) |
 800273a:	6822      	ldr	r2, [r4, #0]
                             ((uint32_t)(heth->Init.MACAddr[1]) << 8) | (uint32_t)heth->Init.MACAddr[0]);
 800273c:	430b      	orrs	r3, r1
  heth->Instance->MACA0LR = (((uint32_t)(heth->Init.MACAddr[3]) << 24) | ((uint32_t)(heth->Init.MACAddr[2]) << 16) |
 800273e:	f8c2 3304 	str.w	r3, [r2, #772]	@ 0x304
  heth->ErrorCode = HAL_ETH_ERROR_NONE;
 8002742:	2000      	movs	r0, #0
 8002744:	f8c4 0088 	str.w	r0, [r4, #136]	@ 0x88
  heth->gState = HAL_ETH_STATE_READY;
 8002748:	2310      	movs	r3, #16
 800274a:	f8c4 3084 	str.w	r3, [r4, #132]	@ 0x84
  return HAL_OK;
 800274e:	e79e      	b.n	800268e <HAL_ETH_Init+0x76>
    return HAL_ERROR;
 8002750:	2001      	movs	r0, #1
}
 8002752:	4770      	bx	lr
 8002754:	58024400 	.word	0x58024400
 8002758:	58000400 	.word	0x58000400
 800275c:	431bde83 	.word	0x431bde83

08002760 <HAL_ETH_SetMACFilterConfig>:
  if (pFilterConfig == NULL)
 8002760:	460a      	mov	r2, r1
 8002762:	b341      	cbz	r1, 80027b6 <HAL_ETH_SetMACFilterConfig+0x56>
  filterconfig = ((uint32_t)pFilterConfig->PromiscuousMode |
 8002764:	780b      	ldrb	r3, [r1, #0]
                  ((uint32_t)pFilterConfig->HashUnicast << 1) |
 8002766:	78c9      	ldrb	r1, [r1, #3]
  filterconfig = ((uint32_t)pFilterConfig->PromiscuousMode |
 8002768:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
                  ((uint32_t)pFilterConfig->HashMulticast << 2)  |
 800276c:	7911      	ldrb	r1, [r2, #4]
                  ((uint32_t)pFilterConfig->HashUnicast << 1) |
 800276e:	ea43 0381 	orr.w	r3, r3, r1, lsl #2
                  ((uint32_t)pFilterConfig->DestAddrInverseFiltering << 3) |
 8002772:	7a11      	ldrb	r1, [r2, #8]
                  ((uint32_t)pFilterConfig->HashMulticast << 2)  |
 8002774:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
                  ((uint32_t)pFilterConfig->PassAllMulticast << 4) |
 8002778:	7951      	ldrb	r1, [r2, #5]
                  ((uint32_t)pFilterConfig->DestAddrInverseFiltering << 3) |
 800277a:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
                  ((uint32_t)((pFilterConfig->BroadcastFilter == DISABLE) ? 1U : 0U) << 5) |
 800277e:	7a51      	ldrb	r1, [r2, #9]
 8002780:	b9b9      	cbnz	r1, 80027b2 <HAL_ETH_SetMACFilterConfig+0x52>
 8002782:	2120      	movs	r1, #32
                  ((uint32_t)pFilterConfig->PassAllMulticast << 4) |
 8002784:	430b      	orrs	r3, r1
                  ((uint32_t)pFilterConfig->SrcAddrInverseFiltering << 8) |
 8002786:	79d1      	ldrb	r1, [r2, #7]
                  ((uint32_t)((pFilterConfig->BroadcastFilter == DISABLE) ? 1U : 0U) << 5) |
 8002788:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
                  ((uint32_t)pFilterConfig->SrcAddrFiltering << 9) |
 800278c:	7991      	ldrb	r1, [r2, #6]
                  ((uint32_t)pFilterConfig->SrcAddrInverseFiltering << 8) |
 800278e:	ea43 2341 	orr.w	r3, r3, r1, lsl #9
                  ((uint32_t)pFilterConfig->HachOrPerfectFilter << 10) |
 8002792:	7891      	ldrb	r1, [r2, #2]
                  ((uint32_t)pFilterConfig->SrcAddrFiltering << 9) |
 8002794:	ea43 2381 	orr.w	r3, r3, r1, lsl #10
                  ((uint32_t)pFilterConfig->ReceiveAllMode << 31) |
 8002798:	7851      	ldrb	r1, [r2, #1]
                  ((uint32_t)pFilterConfig->HachOrPerfectFilter << 10) |
 800279a:	ea43 73c1 	orr.w	r3, r3, r1, lsl #31
                  pFilterConfig->ControlPacketsFilter);
 800279e:	68d2      	ldr	r2, [r2, #12]
  filterconfig = ((uint32_t)pFilterConfig->PromiscuousMode |
 80027a0:	4313      	orrs	r3, r2
  MODIFY_REG(heth->Instance->MACPFR, ETH_MACPFR_MASK, filterconfig);
 80027a2:	6801      	ldr	r1, [r0, #0]
 80027a4:	6888      	ldr	r0, [r1, #8]
 80027a6:	4a05      	ldr	r2, [pc, #20]	@ (80027bc <HAL_ETH_SetMACFilterConfig+0x5c>)
 80027a8:	4002      	ands	r2, r0
 80027aa:	431a      	orrs	r2, r3
 80027ac:	608a      	str	r2, [r1, #8]
  return HAL_OK;
 80027ae:	2000      	movs	r0, #0
 80027b0:	4770      	bx	lr
                  ((uint32_t)((pFilterConfig->BroadcastFilter == DISABLE) ? 1U : 0U) << 5) |
 80027b2:	2100      	movs	r1, #0
 80027b4:	e7e6      	b.n	8002784 <HAL_ETH_SetMACFilterConfig+0x24>
    return HAL_ERROR;
 80027b6:	2001      	movs	r0, #1
}
 80027b8:	4770      	bx	lr
 80027ba:	bf00      	nop
 80027bc:	7ffff800 	.word	0x7ffff800

080027c0 <HAL_ETH_GetMACFilterConfig>:
  if (pFilterConfig == NULL)
 80027c0:	2900      	cmp	r1, #0
 80027c2:	d03a      	beq.n	800283a <HAL_ETH_GetMACFilterConfig+0x7a>
  pFilterConfig->PromiscuousMode = ((READ_BIT(heth->Instance->MACPFR, ETH_MACPFR_PR)) > 0U) ? ENABLE : DISABLE;
 80027c4:	6802      	ldr	r2, [r0, #0]
 80027c6:	6892      	ldr	r2, [r2, #8]
 80027c8:	f002 0201 	and.w	r2, r2, #1
 80027cc:	700a      	strb	r2, [r1, #0]
  pFilterConfig->HashUnicast = ((READ_BIT(heth->Instance->MACPFR, ETH_MACPFR_HUC) >> 1) > 0U) ? ENABLE : DISABLE;
 80027ce:	6802      	ldr	r2, [r0, #0]
 80027d0:	6892      	ldr	r2, [r2, #8]
 80027d2:	f3c2 0240 	ubfx	r2, r2, #1, #1
 80027d6:	70ca      	strb	r2, [r1, #3]
  pFilterConfig->HashMulticast = ((READ_BIT(heth->Instance->MACPFR, ETH_MACPFR_HMC) >> 2) > 0U) ? ENABLE : DISABLE;
 80027d8:	6802      	ldr	r2, [r0, #0]
 80027da:	6892      	ldr	r2, [r2, #8]
 80027dc:	f3c2 0280 	ubfx	r2, r2, #2, #1
 80027e0:	710a      	strb	r2, [r1, #4]
  pFilterConfig->DestAddrInverseFiltering = ((READ_BIT(heth->Instance->MACPFR,
 80027e2:	6802      	ldr	r2, [r0, #0]
 80027e4:	6892      	ldr	r2, [r2, #8]
                                                       ETH_MACPFR_DAIF) >> 3) > 0U) ? ENABLE : DISABLE;
 80027e6:	f3c2 02c0 	ubfx	r2, r2, #3, #1
  pFilterConfig->DestAddrInverseFiltering = ((READ_BIT(heth->Instance->MACPFR,
 80027ea:	720a      	strb	r2, [r1, #8]
  pFilterConfig->PassAllMulticast = ((READ_BIT(heth->Instance->MACPFR, ETH_MACPFR_PM) >> 4) > 0U) ? ENABLE : DISABLE;
 80027ec:	6802      	ldr	r2, [r0, #0]
 80027ee:	6892      	ldr	r2, [r2, #8]
 80027f0:	f3c2 1200 	ubfx	r2, r2, #4, #1
 80027f4:	714a      	strb	r2, [r1, #5]
  pFilterConfig->BroadcastFilter = ((READ_BIT(heth->Instance->MACPFR, ETH_MACPFR_DBF) >> 5) == 0U) ? ENABLE : DISABLE;
 80027f6:	6802      	ldr	r2, [r0, #0]
 80027f8:	6892      	ldr	r2, [r2, #8]
 80027fa:	f012 0f20 	tst.w	r2, #32
 80027fe:	bf0c      	ite	eq
 8002800:	2201      	moveq	r2, #1
 8002802:	2200      	movne	r2, #0
 8002804:	724a      	strb	r2, [r1, #9]
  pFilterConfig->ControlPacketsFilter = READ_BIT(heth->Instance->MACPFR, ETH_MACPFR_PCF);
 8002806:	6802      	ldr	r2, [r0, #0]
 8002808:	6892      	ldr	r2, [r2, #8]
 800280a:	f002 02c0 	and.w	r2, r2, #192	@ 0xc0
 800280e:	60ca      	str	r2, [r1, #12]
  pFilterConfig->SrcAddrInverseFiltering = ((READ_BIT(heth->Instance->MACPFR,
 8002810:	6802      	ldr	r2, [r0, #0]
 8002812:	6892      	ldr	r2, [r2, #8]
                                                      ETH_MACPFR_SAIF) >> 8) > 0U) ? ENABLE : DISABLE;
 8002814:	f3c2 2200 	ubfx	r2, r2, #8, #1
  pFilterConfig->SrcAddrInverseFiltering = ((READ_BIT(heth->Instance->MACPFR,
 8002818:	71ca      	strb	r2, [r1, #7]
  pFilterConfig->SrcAddrFiltering = ((READ_BIT(heth->Instance->MACPFR, ETH_MACPFR_SAF) >> 9) > 0U) ? ENABLE : DISABLE;
 800281a:	6802      	ldr	r2, [r0, #0]
 800281c:	6892      	ldr	r2, [r2, #8]
 800281e:	f3c2 2240 	ubfx	r2, r2, #9, #1
 8002822:	718a      	strb	r2, [r1, #6]
  pFilterConfig->HachOrPerfectFilter = ((READ_BIT(heth->Instance->MACPFR, ETH_MACPFR_HPF) >> 10) > 0U)
 8002824:	6802      	ldr	r2, [r0, #0]
 8002826:	6892      	ldr	r2, [r2, #8]
                                       ? ENABLE : DISABLE;
 8002828:	f3c2 2280 	ubfx	r2, r2, #10, #1
  pFilterConfig->HachOrPerfectFilter = ((READ_BIT(heth->Instance->MACPFR, ETH_MACPFR_HPF) >> 10) > 0U)
 800282c:	708a      	strb	r2, [r1, #2]
  pFilterConfig->ReceiveAllMode = ((READ_BIT(heth->Instance->MACPFR, ETH_MACPFR_RA) >> 31) > 0U) ? ENABLE : DISABLE;
 800282e:	6802      	ldr	r2, [r0, #0]
 8002830:	6892      	ldr	r2, [r2, #8]
 8002832:	0fd2      	lsrs	r2, r2, #31
 8002834:	704a      	strb	r2, [r1, #1]
  return HAL_OK;
 8002836:	2000      	movs	r0, #0
 8002838:	4770      	bx	lr
    return HAL_ERROR;
 800283a:	2001      	movs	r0, #1
}
 800283c:	4770      	bx	lr

0800283e <HAL_ETH_GetDMAError>:
  return heth->DMAErrorCode;
 800283e:	f8d0 008c 	ldr.w	r0, [r0, #140]	@ 0x8c
}
 8002842:	4770      	bx	lr

08002844 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8002844:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002848:	b083      	sub	sp, #12
 800284a:	4680      	mov	r8, r0
 800284c:	460c      	mov	r4, r1
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
#endif

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 800284e:	4a6d      	ldr	r2, [pc, #436]	@ (8002a04 <HAL_GPIO_Init+0x1c0>)
 8002850:	4b6d      	ldr	r3, [pc, #436]	@ (8002a08 <HAL_GPIO_Init+0x1c4>)
 8002852:	4290      	cmp	r0, r2
 8002854:	bf18      	it	ne
 8002856:	4298      	cmpne	r0, r3
 8002858:	bf14      	ite	ne
 800285a:	f04f 0901 	movne.w	r9, #1
 800285e:	f04f 0900 	moveq.w	r9, #0
 8002862:	d02b      	beq.n	80028bc <HAL_GPIO_Init+0x78>
 8002864:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8002868:	1ac3      	subs	r3, r0, r3
 800286a:	bf18      	it	ne
 800286c:	2301      	movne	r3, #1
 800286e:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8002872:	4290      	cmp	r0, r2
 8002874:	d022      	beq.n	80028bc <HAL_GPIO_Init+0x78>
 8002876:	b30b      	cbz	r3, 80028bc <HAL_GPIO_Init+0x78>
 8002878:	4b64      	ldr	r3, [pc, #400]	@ (8002a0c <HAL_GPIO_Init+0x1c8>)
 800287a:	1ac3      	subs	r3, r0, r3
 800287c:	bf18      	it	ne
 800287e:	2301      	movne	r3, #1
 8002880:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8002884:	4290      	cmp	r0, r2
 8002886:	d019      	beq.n	80028bc <HAL_GPIO_Init+0x78>
 8002888:	b1c3      	cbz	r3, 80028bc <HAL_GPIO_Init+0x78>
 800288a:	4b61      	ldr	r3, [pc, #388]	@ (8002a10 <HAL_GPIO_Init+0x1cc>)
 800288c:	1ac3      	subs	r3, r0, r3
 800288e:	bf18      	it	ne
 8002890:	2301      	movne	r3, #1
 8002892:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8002896:	4290      	cmp	r0, r2
 8002898:	d010      	beq.n	80028bc <HAL_GPIO_Init+0x78>
 800289a:	b17b      	cbz	r3, 80028bc <HAL_GPIO_Init+0x78>
 800289c:	4b5d      	ldr	r3, [pc, #372]	@ (8002a14 <HAL_GPIO_Init+0x1d0>)
 800289e:	1ac3      	subs	r3, r0, r3
 80028a0:	bf18      	it	ne
 80028a2:	2301      	movne	r3, #1
 80028a4:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80028a8:	4290      	cmp	r0, r2
 80028aa:	d007      	beq.n	80028bc <HAL_GPIO_Init+0x78>
 80028ac:	b133      	cbz	r3, 80028bc <HAL_GPIO_Init+0x78>
 80028ae:	4b5a      	ldr	r3, [pc, #360]	@ (8002a18 <HAL_GPIO_Init+0x1d4>)
 80028b0:	4298      	cmp	r0, r3
 80028b2:	d003      	beq.n	80028bc <HAL_GPIO_Init+0x78>
 80028b4:	21b3      	movs	r1, #179	@ 0xb3
 80028b6:	4859      	ldr	r0, [pc, #356]	@ (8002a1c <HAL_GPIO_Init+0x1d8>)
 80028b8:	f7fe f90c 	bl	8000ad4 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
 80028bc:	6823      	ldr	r3, [r4, #0]
 80028be:	b29a      	uxth	r2, r3
 80028c0:	b112      	cbz	r2, 80028c8 <HAL_GPIO_Init+0x84>
 80028c2:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 80028c6:	d303      	bcc.n	80028d0 <HAL_GPIO_Init+0x8c>
 80028c8:	21b4      	movs	r1, #180	@ 0xb4
 80028ca:	4854      	ldr	r0, [pc, #336]	@ (8002a1c <HAL_GPIO_Init+0x1d8>)
 80028cc:	f7fe f902 	bl	8000ad4 <assert_failed>
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
 80028d0:	6863      	ldr	r3, [r4, #4]
 80028d2:	2b11      	cmp	r3, #17
 80028d4:	bf18      	it	ne
 80028d6:	2b01      	cmpne	r3, #1
 80028d8:	d920      	bls.n	800291c <HAL_GPIO_Init+0xd8>
 80028da:	f5b3 1f04 	cmp.w	r3, #2162688	@ 0x210000
 80028de:	d01d      	beq.n	800291c <HAL_GPIO_Init+0xd8>
 80028e0:	d80f      	bhi.n	8002902 <HAL_GPIO_Init+0xbe>
 80028e2:	f5b3 1f88 	cmp.w	r3, #1114112	@ 0x110000
 80028e6:	d019      	beq.n	800291c <HAL_GPIO_Init+0xd8>
 80028e8:	d807      	bhi.n	80028fa <HAL_GPIO_Init+0xb6>
 80028ea:	2b03      	cmp	r3, #3
 80028ec:	d802      	bhi.n	80028f4 <HAL_GPIO_Init+0xb0>
 80028ee:	2b02      	cmp	r3, #2
 80028f0:	d214      	bcs.n	800291c <HAL_GPIO_Init+0xd8>
 80028f2:	e00f      	b.n	8002914 <HAL_GPIO_Init+0xd0>
 80028f4:	2b12      	cmp	r3, #18
 80028f6:	d011      	beq.n	800291c <HAL_GPIO_Init+0xd8>
 80028f8:	e00c      	b.n	8002914 <HAL_GPIO_Init+0xd0>
 80028fa:	f5b3 1f90 	cmp.w	r3, #1179648	@ 0x120000
 80028fe:	d00d      	beq.n	800291c <HAL_GPIO_Init+0xd8>
 8002900:	e008      	b.n	8002914 <HAL_GPIO_Init+0xd0>
 8002902:	f5b3 1f44 	cmp.w	r3, #3211264	@ 0x310000
 8002906:	d009      	beq.n	800291c <HAL_GPIO_Init+0xd8>
 8002908:	f5b3 1f48 	cmp.w	r3, #3276800	@ 0x320000
 800290c:	d006      	beq.n	800291c <HAL_GPIO_Init+0xd8>
 800290e:	f5b3 1f08 	cmp.w	r3, #2228224	@ 0x220000
 8002912:	d003      	beq.n	800291c <HAL_GPIO_Init+0xd8>
 8002914:	21b5      	movs	r1, #181	@ 0xb5
 8002916:	4841      	ldr	r0, [pc, #260]	@ (8002a1c <HAL_GPIO_Init+0x1d8>)
 8002918:	f7fe f8dc 	bl	8000ad4 <assert_failed>
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 800291c:	2500      	movs	r5, #0
 800291e:	e0c1      	b.n	8002aa4 <HAL_GPIO_Init+0x260>
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
 8002920:	68e3      	ldr	r3, [r4, #12]
 8002922:	2b03      	cmp	r3, #3
 8002924:	d817      	bhi.n	8002956 <HAL_GPIO_Init+0x112>
        temp = GPIOx->OSPEEDR;
 8002926:	f8d8 2008 	ldr.w	r2, [r8, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800292a:	0069      	lsls	r1, r5, #1
 800292c:	2303      	movs	r3, #3
 800292e:	408b      	lsls	r3, r1
 8002930:	ea22 0203 	bic.w	r2, r2, r3
        temp |= (GPIO_Init->Speed << (position * 2U));
 8002934:	68e3      	ldr	r3, [r4, #12]
 8002936:	408b      	lsls	r3, r1
 8002938:	4313      	orrs	r3, r2
        GPIOx->OSPEEDR = temp;
 800293a:	f8c8 3008 	str.w	r3, [r8, #8]
        temp = GPIOx->OTYPER;
 800293e:	f8d8 2004 	ldr.w	r2, [r8, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8002942:	ea22 0207 	bic.w	r2, r2, r7
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8002946:	6863      	ldr	r3, [r4, #4]
 8002948:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800294c:	40ab      	lsls	r3, r5
 800294e:	4313      	orrs	r3, r2
        GPIOx->OTYPER = temp;
 8002950:	f8c8 3004 	str.w	r3, [r8, #4]
 8002954:	e0b6      	b.n	8002ac4 <HAL_GPIO_Init+0x280>
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
 8002956:	21c4      	movs	r1, #196	@ 0xc4
 8002958:	4830      	ldr	r0, [pc, #192]	@ (8002a1c <HAL_GPIO_Init+0x1d8>)
 800295a:	f7fe f8bb 	bl	8000ad4 <assert_failed>
 800295e:	e7e2      	b.n	8002926 <HAL_GPIO_Init+0xe2>
       assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
 8002960:	21d6      	movs	r1, #214	@ 0xd6
 8002962:	482e      	ldr	r0, [pc, #184]	@ (8002a1c <HAL_GPIO_Init+0x1d8>)
 8002964:	f7fe f8b6 	bl	8000ad4 <assert_failed>
 8002968:	e0b5      	b.n	8002ad6 <HAL_GPIO_Init+0x292>
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
 800296a:	f1b9 0f00 	cmp.w	r9, #0
 800296e:	d02d      	beq.n	80029cc <HAL_GPIO_Init+0x188>
 8002970:	4b2b      	ldr	r3, [pc, #172]	@ (8002a20 <HAL_GPIO_Init+0x1dc>)
 8002972:	ebb8 0303 	subs.w	r3, r8, r3
 8002976:	bf18      	it	ne
 8002978:	2301      	movne	r3, #1
 800297a:	4a2a      	ldr	r2, [pc, #168]	@ (8002a24 <HAL_GPIO_Init+0x1e0>)
 800297c:	4590      	cmp	r8, r2
 800297e:	d025      	beq.n	80029cc <HAL_GPIO_Init+0x188>
 8002980:	b323      	cbz	r3, 80029cc <HAL_GPIO_Init+0x188>
 8002982:	4b22      	ldr	r3, [pc, #136]	@ (8002a0c <HAL_GPIO_Init+0x1c8>)
 8002984:	ebb8 0303 	subs.w	r3, r8, r3
 8002988:	bf18      	it	ne
 800298a:	2301      	movne	r3, #1
 800298c:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8002990:	4590      	cmp	r8, r2
 8002992:	d01b      	beq.n	80029cc <HAL_GPIO_Init+0x188>
 8002994:	b1d3      	cbz	r3, 80029cc <HAL_GPIO_Init+0x188>
 8002996:	4b1e      	ldr	r3, [pc, #120]	@ (8002a10 <HAL_GPIO_Init+0x1cc>)
 8002998:	ebb8 0303 	subs.w	r3, r8, r3
 800299c:	bf18      	it	ne
 800299e:	2301      	movne	r3, #1
 80029a0:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80029a4:	4590      	cmp	r8, r2
 80029a6:	d011      	beq.n	80029cc <HAL_GPIO_Init+0x188>
 80029a8:	b183      	cbz	r3, 80029cc <HAL_GPIO_Init+0x188>
 80029aa:	4b1a      	ldr	r3, [pc, #104]	@ (8002a14 <HAL_GPIO_Init+0x1d0>)
 80029ac:	ebb8 0303 	subs.w	r3, r8, r3
 80029b0:	bf18      	it	ne
 80029b2:	2301      	movne	r3, #1
 80029b4:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80029b8:	4590      	cmp	r8, r2
 80029ba:	d007      	beq.n	80029cc <HAL_GPIO_Init+0x188>
 80029bc:	b133      	cbz	r3, 80029cc <HAL_GPIO_Init+0x188>
 80029be:	4b16      	ldr	r3, [pc, #88]	@ (8002a18 <HAL_GPIO_Init+0x1d4>)
 80029c0:	4598      	cmp	r8, r3
 80029c2:	d003      	beq.n	80029cc <HAL_GPIO_Init+0x188>
 80029c4:	21e3      	movs	r1, #227	@ 0xe3
 80029c6:	4815      	ldr	r0, [pc, #84]	@ (8002a1c <HAL_GPIO_Init+0x1d8>)
 80029c8:	f7fe f884 	bl	8000ad4 <assert_failed>
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
 80029cc:	6923      	ldr	r3, [r4, #16]
 80029ce:	2b0f      	cmp	r3, #15
 80029d0:	d810      	bhi.n	80029f4 <HAL_GPIO_Init+0x1b0>
        temp = GPIOx->AFR[position >> 3U];
 80029d2:	08ea      	lsrs	r2, r5, #3
 80029d4:	3208      	adds	r2, #8
 80029d6:	f858 0022 	ldr.w	r0, [r8, r2, lsl #2]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 80029da:	f005 0107 	and.w	r1, r5, #7
 80029de:	0089      	lsls	r1, r1, #2
 80029e0:	230f      	movs	r3, #15
 80029e2:	408b      	lsls	r3, r1
 80029e4:	ea20 0003 	bic.w	r0, r0, r3
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 80029e8:	6923      	ldr	r3, [r4, #16]
 80029ea:	408b      	lsls	r3, r1
 80029ec:	4303      	orrs	r3, r0
        GPIOx->AFR[position >> 3U] = temp;
 80029ee:	f848 3022 	str.w	r3, [r8, r2, lsl #2]
 80029f2:	e082      	b.n	8002afa <HAL_GPIO_Init+0x2b6>
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
 80029f4:	21e4      	movs	r1, #228	@ 0xe4
 80029f6:	4809      	ldr	r0, [pc, #36]	@ (8002a1c <HAL_GPIO_Init+0x1d8>)
 80029f8:	f7fe f86c 	bl	8000ad4 <assert_failed>
 80029fc:	e7e9      	b.n	80029d2 <HAL_GPIO_Init+0x18e>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80029fe:	2309      	movs	r3, #9
 8002a00:	e013      	b.n	8002a2a <HAL_GPIO_Init+0x1e6>
 8002a02:	bf00      	nop
 8002a04:	58020000 	.word	0x58020000
 8002a08:	58020400 	.word	0x58020400
 8002a0c:	58021400 	.word	0x58021400
 8002a10:	58021c00 	.word	0x58021c00
 8002a14:	58022400 	.word	0x58022400
 8002a18:	58022800 	.word	0x58022800
 8002a1c:	080154c8 	.word	0x080154c8
 8002a20:	58020c00 	.word	0x58020c00
 8002a24:	58020800 	.word	0x58020800
 8002a28:	2300      	movs	r3, #0
 8002a2a:	408b      	lsls	r3, r1
 8002a2c:	4303      	orrs	r3, r0
        SYSCFG->EXTICR[position >> 2U] = temp;
 8002a2e:	3202      	adds	r2, #2
 8002a30:	4966      	ldr	r1, [pc, #408]	@ (8002bcc <HAL_GPIO_Init+0x388>)
 8002a32:	f841 3022 	str.w	r3, [r1, r2, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8002a36:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8002a3a:	681a      	ldr	r2, [r3, #0]
        temp &= ~(iocurrent);
 8002a3c:	43f3      	mvns	r3, r6
 8002a3e:	ea22 0106 	bic.w	r1, r2, r6
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 8002a42:	6860      	ldr	r0, [r4, #4]
 8002a44:	f410 1f80 	tst.w	r0, #1048576	@ 0x100000
 8002a48:	d001      	beq.n	8002a4e <HAL_GPIO_Init+0x20a>
        {
          temp |= iocurrent;
 8002a4a:	ea46 0102 	orr.w	r1, r6, r2
        }
        EXTI->RTSR1 = temp;
 8002a4e:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8002a52:	6011      	str	r1, [r2, #0]

        temp = EXTI->FTSR1;
 8002a54:	6852      	ldr	r2, [r2, #4]
        temp &= ~(iocurrent);
 8002a56:	ea03 0102 	and.w	r1, r3, r2
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8002a5a:	6860      	ldr	r0, [r4, #4]
 8002a5c:	f410 1f00 	tst.w	r0, #2097152	@ 0x200000
 8002a60:	d001      	beq.n	8002a66 <HAL_GPIO_Init+0x222>
        {
          temp |= iocurrent;
 8002a62:	ea46 0102 	orr.w	r1, r6, r2
        }
        EXTI->FTSR1 = temp;
 8002a66:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8002a6a:	6051      	str	r1, [r2, #4]

        temp = EXTI_CurrentCPU->EMR1;
 8002a6c:	f8d2 2084 	ldr.w	r2, [r2, #132]	@ 0x84
        temp &= ~(iocurrent);
 8002a70:	ea03 0102 	and.w	r1, r3, r2
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 8002a74:	6860      	ldr	r0, [r4, #4]
 8002a76:	f410 3f00 	tst.w	r0, #131072	@ 0x20000
 8002a7a:	d001      	beq.n	8002a80 <HAL_GPIO_Init+0x23c>
        {
          temp |= iocurrent;
 8002a7c:	ea46 0102 	orr.w	r1, r6, r2
        }
        EXTI_CurrentCPU->EMR1 = temp;
 8002a80:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8002a84:	f8c2 1084 	str.w	r1, [r2, #132]	@ 0x84

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
 8002a88:	f8d2 2080 	ldr.w	r2, [r2, #128]	@ 0x80
        temp &= ~(iocurrent);
 8002a8c:	4013      	ands	r3, r2
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 8002a8e:	6861      	ldr	r1, [r4, #4]
 8002a90:	f411 3f80 	tst.w	r1, #65536	@ 0x10000
 8002a94:	d001      	beq.n	8002a9a <HAL_GPIO_Init+0x256>
        {
          temp |= iocurrent;
 8002a96:	ea46 0302 	orr.w	r3, r6, r2
        }
        EXTI_CurrentCPU->IMR1 = temp;
 8002a9a:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8002a9e:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
      }
    }

    position++;
 8002aa2:	3501      	adds	r5, #1
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 8002aa4:	6826      	ldr	r6, [r4, #0]
 8002aa6:	fa36 f205 	lsrs.w	r2, r6, r5
 8002aaa:	f000 808c 	beq.w	8002bc6 <HAL_GPIO_Init+0x382>
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 8002aae:	2701      	movs	r7, #1
 8002ab0:	40af      	lsls	r7, r5
    if (iocurrent != 0x00U)
 8002ab2:	403e      	ands	r6, r7
 8002ab4:	d0f5      	beq.n	8002aa2 <HAL_GPIO_Init+0x25e>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8002ab6:	6863      	ldr	r3, [r4, #4]
 8002ab8:	f003 0303 	and.w	r3, r3, #3
 8002abc:	3b01      	subs	r3, #1
 8002abe:	2b01      	cmp	r3, #1
 8002ac0:	f67f af2e 	bls.w	8002920 <HAL_GPIO_Init+0xdc>
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8002ac4:	6863      	ldr	r3, [r4, #4]
 8002ac6:	f003 0303 	and.w	r3, r3, #3
 8002aca:	2b03      	cmp	r3, #3
 8002acc:	d00f      	beq.n	8002aee <HAL_GPIO_Init+0x2aa>
       assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
 8002ace:	68a3      	ldr	r3, [r4, #8]
 8002ad0:	2b02      	cmp	r3, #2
 8002ad2:	f63f af45 	bhi.w	8002960 <HAL_GPIO_Init+0x11c>
      temp = GPIOx->PUPDR;
 8002ad6:	f8d8 200c 	ldr.w	r2, [r8, #12]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8002ada:	0069      	lsls	r1, r5, #1
 8002adc:	2303      	movs	r3, #3
 8002ade:	408b      	lsls	r3, r1
 8002ae0:	ea22 0203 	bic.w	r2, r2, r3
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8002ae4:	68a3      	ldr	r3, [r4, #8]
 8002ae6:	408b      	lsls	r3, r1
 8002ae8:	4313      	orrs	r3, r2
      GPIOx->PUPDR = temp;
 8002aea:	f8c8 300c 	str.w	r3, [r8, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8002aee:	6863      	ldr	r3, [r4, #4]
 8002af0:	f003 0303 	and.w	r3, r3, #3
 8002af4:	2b02      	cmp	r3, #2
 8002af6:	f43f af38 	beq.w	800296a <HAL_GPIO_Init+0x126>
      temp = GPIOx->MODER;
 8002afa:	f8d8 2000 	ldr.w	r2, [r8]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8002afe:	0069      	lsls	r1, r5, #1
 8002b00:	2303      	movs	r3, #3
 8002b02:	408b      	lsls	r3, r1
 8002b04:	ea22 0203 	bic.w	r2, r2, r3
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8002b08:	6863      	ldr	r3, [r4, #4]
 8002b0a:	f003 0303 	and.w	r3, r3, #3
 8002b0e:	408b      	lsls	r3, r1
 8002b10:	4313      	orrs	r3, r2
      GPIOx->MODER = temp;
 8002b12:	f8c8 3000 	str.w	r3, [r8]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 8002b16:	6863      	ldr	r3, [r4, #4]
 8002b18:	f413 3f40 	tst.w	r3, #196608	@ 0x30000
 8002b1c:	d0c1      	beq.n	8002aa2 <HAL_GPIO_Init+0x25e>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8002b1e:	4b2c      	ldr	r3, [pc, #176]	@ (8002bd0 <HAL_GPIO_Init+0x38c>)
 8002b20:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
 8002b24:	f042 0202 	orr.w	r2, r2, #2
 8002b28:	f8c3 20f4 	str.w	r2, [r3, #244]	@ 0xf4
 8002b2c:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8002b30:	f003 0302 	and.w	r3, r3, #2
 8002b34:	9301      	str	r3, [sp, #4]
 8002b36:	9b01      	ldr	r3, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2U];
 8002b38:	08aa      	lsrs	r2, r5, #2
 8002b3a:	1c91      	adds	r1, r2, #2
 8002b3c:	4b23      	ldr	r3, [pc, #140]	@ (8002bcc <HAL_GPIO_Init+0x388>)
 8002b3e:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8002b42:	f005 0103 	and.w	r1, r5, #3
 8002b46:	0089      	lsls	r1, r1, #2
 8002b48:	230f      	movs	r3, #15
 8002b4a:	408b      	lsls	r3, r1
 8002b4c:	ea20 0003 	bic.w	r0, r0, r3
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8002b50:	4b20      	ldr	r3, [pc, #128]	@ (8002bd4 <HAL_GPIO_Init+0x390>)
 8002b52:	4598      	cmp	r8, r3
 8002b54:	f43f af68 	beq.w	8002a28 <HAL_GPIO_Init+0x1e4>
 8002b58:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8002b5c:	4598      	cmp	r8, r3
 8002b5e:	d022      	beq.n	8002ba6 <HAL_GPIO_Init+0x362>
 8002b60:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8002b64:	4598      	cmp	r8, r3
 8002b66:	d020      	beq.n	8002baa <HAL_GPIO_Init+0x366>
 8002b68:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8002b6c:	4598      	cmp	r8, r3
 8002b6e:	d01e      	beq.n	8002bae <HAL_GPIO_Init+0x36a>
 8002b70:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8002b74:	4598      	cmp	r8, r3
 8002b76:	d01c      	beq.n	8002bb2 <HAL_GPIO_Init+0x36e>
 8002b78:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8002b7c:	4598      	cmp	r8, r3
 8002b7e:	d01a      	beq.n	8002bb6 <HAL_GPIO_Init+0x372>
 8002b80:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8002b84:	4598      	cmp	r8, r3
 8002b86:	d018      	beq.n	8002bba <HAL_GPIO_Init+0x376>
 8002b88:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8002b8c:	4598      	cmp	r8, r3
 8002b8e:	d016      	beq.n	8002bbe <HAL_GPIO_Init+0x37a>
 8002b90:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8002b94:	4598      	cmp	r8, r3
 8002b96:	d014      	beq.n	8002bc2 <HAL_GPIO_Init+0x37e>
 8002b98:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8002b9c:	4598      	cmp	r8, r3
 8002b9e:	f43f af2e 	beq.w	80029fe <HAL_GPIO_Init+0x1ba>
 8002ba2:	230a      	movs	r3, #10
 8002ba4:	e741      	b.n	8002a2a <HAL_GPIO_Init+0x1e6>
 8002ba6:	2301      	movs	r3, #1
 8002ba8:	e73f      	b.n	8002a2a <HAL_GPIO_Init+0x1e6>
 8002baa:	2302      	movs	r3, #2
 8002bac:	e73d      	b.n	8002a2a <HAL_GPIO_Init+0x1e6>
 8002bae:	2303      	movs	r3, #3
 8002bb0:	e73b      	b.n	8002a2a <HAL_GPIO_Init+0x1e6>
 8002bb2:	2304      	movs	r3, #4
 8002bb4:	e739      	b.n	8002a2a <HAL_GPIO_Init+0x1e6>
 8002bb6:	2305      	movs	r3, #5
 8002bb8:	e737      	b.n	8002a2a <HAL_GPIO_Init+0x1e6>
 8002bba:	2306      	movs	r3, #6
 8002bbc:	e735      	b.n	8002a2a <HAL_GPIO_Init+0x1e6>
 8002bbe:	2307      	movs	r3, #7
 8002bc0:	e733      	b.n	8002a2a <HAL_GPIO_Init+0x1e6>
 8002bc2:	2308      	movs	r3, #8
 8002bc4:	e731      	b.n	8002a2a <HAL_GPIO_Init+0x1e6>
  }
}
 8002bc6:	b003      	add	sp, #12
 8002bc8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8002bcc:	58000400 	.word	0x58000400
 8002bd0:	58024400 	.word	0x58024400
 8002bd4:	58020000 	.word	0x58020000

08002bd8 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8002bd8:	b570      	push	{r4, r5, r6, lr}
 8002bda:	4605      	mov	r5, r0
 8002bdc:	4614      	mov	r4, r2
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
 8002bde:	460e      	mov	r6, r1
 8002be0:	b121      	cbz	r1, 8002bec <HAL_GPIO_WritePin+0x14>
  assert_param(IS_GPIO_PIN_ACTION(PinState));
 8002be2:	2c01      	cmp	r4, #1
 8002be4:	d808      	bhi.n	8002bf8 <HAL_GPIO_WritePin+0x20>

  if (PinState != GPIO_PIN_RESET)
 8002be6:	b16c      	cbz	r4, 8002c04 <HAL_GPIO_WritePin+0x2c>
  {
    GPIOx->BSRR = GPIO_Pin;
 8002be8:	61ae      	str	r6, [r5, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
  }
}
 8002bea:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_GPIO_PIN(GPIO_Pin));
 8002bec:	f44f 71d5 	mov.w	r1, #426	@ 0x1aa
 8002bf0:	4806      	ldr	r0, [pc, #24]	@ (8002c0c <HAL_GPIO_WritePin+0x34>)
 8002bf2:	f7fd ff6f 	bl	8000ad4 <assert_failed>
 8002bf6:	e7f4      	b.n	8002be2 <HAL_GPIO_WritePin+0xa>
  assert_param(IS_GPIO_PIN_ACTION(PinState));
 8002bf8:	f240 11ab 	movw	r1, #427	@ 0x1ab
 8002bfc:	4803      	ldr	r0, [pc, #12]	@ (8002c0c <HAL_GPIO_WritePin+0x34>)
 8002bfe:	f7fd ff69 	bl	8000ad4 <assert_failed>
 8002c02:	e7f0      	b.n	8002be6 <HAL_GPIO_WritePin+0xe>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 8002c04:	0436      	lsls	r6, r6, #16
 8002c06:	61ae      	str	r6, [r5, #24]
}
 8002c08:	e7ef      	b.n	8002bea <HAL_GPIO_WritePin+0x12>
 8002c0a:	bf00      	nop
 8002c0c:	080154c8 	.word	0x080154c8

08002c10 <HAL_PWREx_ConfigSupply>:
  *         PWR_SMPS_2V5_SUPPLIES_EXT are used only for lines that supports SMPS
  *         regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply (uint32_t SupplySource)
{
 8002c10:	b510      	push	{r4, lr}
 8002c12:	4604      	mov	r4, r0
  uint32_t tickstart;

  /* Check the parameters */
  assert_param (IS_PWR_SUPPLY (SupplySource));
 8002c14:	1e43      	subs	r3, r0, #1
 8002c16:	2b01      	cmp	r3, #1
 8002c18:	d80c      	bhi.n	8002c34 <HAL_PWREx_ConfigSupply+0x24>

  /* Check if supply source was configured */
#if defined (PWR_FLAG_SCUEN)
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
 8002c1a:	4b16      	ldr	r3, [pc, #88]	@ (8002c74 <HAL_PWREx_ConfigSupply+0x64>)
 8002c1c:	68db      	ldr	r3, [r3, #12]
 8002c1e:	f013 0f04 	tst.w	r3, #4
 8002c22:	d10d      	bne.n	8002c40 <HAL_PWREx_ConfigSupply+0x30>
#else
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
#endif /* defined (PWR_FLAG_SCUEN) */
  {
    /* Check supply configuration */
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
 8002c24:	4b13      	ldr	r3, [pc, #76]	@ (8002c74 <HAL_PWREx_ConfigSupply+0x64>)
 8002c26:	68db      	ldr	r3, [r3, #12]
 8002c28:	f003 0307 	and.w	r3, r3, #7
 8002c2c:	42a3      	cmp	r3, r4
 8002c2e:	d01f      	beq.n	8002c70 <HAL_PWREx_ConfigSupply+0x60>
    {
      /* Supply configuration update locked, can't apply a new supply config */
      return HAL_ERROR;
 8002c30:	2001      	movs	r0, #1
    }
  }
#endif /* defined (SMPS) */

  return HAL_OK;
}
 8002c32:	bd10      	pop	{r4, pc}
  assert_param (IS_PWR_SUPPLY (SupplySource));
 8002c34:	f44f 719f 	mov.w	r1, #318	@ 0x13e
 8002c38:	480f      	ldr	r0, [pc, #60]	@ (8002c78 <HAL_PWREx_ConfigSupply+0x68>)
 8002c3a:	f7fd ff4b 	bl	8000ad4 <assert_failed>
 8002c3e:	e7ec      	b.n	8002c1a <HAL_PWREx_ConfigSupply+0xa>
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
 8002c40:	4a0c      	ldr	r2, [pc, #48]	@ (8002c74 <HAL_PWREx_ConfigSupply+0x64>)
 8002c42:	68d3      	ldr	r3, [r2, #12]
 8002c44:	f023 0307 	bic.w	r3, r3, #7
 8002c48:	4323      	orrs	r3, r4
 8002c4a:	60d3      	str	r3, [r2, #12]
  tickstart = HAL_GetTick ();
 8002c4c:	f7fe fbd4 	bl	80013f8 <HAL_GetTick>
 8002c50:	4604      	mov	r4, r0
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
 8002c52:	4b08      	ldr	r3, [pc, #32]	@ (8002c74 <HAL_PWREx_ConfigSupply+0x64>)
 8002c54:	685b      	ldr	r3, [r3, #4]
 8002c56:	f413 5f00 	tst.w	r3, #8192	@ 0x2000
 8002c5a:	d107      	bne.n	8002c6c <HAL_PWREx_ConfigSupply+0x5c>
    if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
 8002c5c:	f7fe fbcc 	bl	80013f8 <HAL_GetTick>
 8002c60:	1b00      	subs	r0, r0, r4
 8002c62:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
 8002c66:	d9f4      	bls.n	8002c52 <HAL_PWREx_ConfigSupply+0x42>
      return HAL_ERROR;
 8002c68:	2001      	movs	r0, #1
 8002c6a:	e7e2      	b.n	8002c32 <HAL_PWREx_ConfigSupply+0x22>
  return HAL_OK;
 8002c6c:	2000      	movs	r0, #0
 8002c6e:	e7e0      	b.n	8002c32 <HAL_PWREx_ConfigSupply+0x22>
      return HAL_OK;
 8002c70:	2000      	movs	r0, #0
 8002c72:	e7de      	b.n	8002c32 <HAL_PWREx_ConfigSupply+0x22>
 8002c74:	58024800 	.word	0x58024800
 8002c78:	08015504 	.word	0x08015504

08002c7c <HAL_RCC_OscConfig>:
{
  uint32_t tickstart;
  uint32_t temp1_pllckcfg, temp2_pllckcfg;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 8002c7c:	2800      	cmp	r0, #0
 8002c7e:	f000 841a 	beq.w	80034b6 <HAL_RCC_OscConfig+0x83a>
{
 8002c82:	b538      	push	{r3, r4, r5, lr}
 8002c84:	4604      	mov	r4, r0
  {
    return HAL_ERROR;
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
 8002c86:	6803      	ldr	r3, [r0, #0]
 8002c88:	b113      	cbz	r3, 8002c90 <HAL_RCC_OscConfig+0x14>
 8002c8a:	f013 0f3f 	tst.w	r3, #63	@ 0x3f
 8002c8e:	d025      	beq.n	8002cdc <HAL_RCC_OscConfig+0x60>
  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8002c90:	6823      	ldr	r3, [r4, #0]
 8002c92:	f013 0f01 	tst.w	r3, #1
 8002c96:	d03a      	beq.n	8002d0e <HAL_RCC_OscConfig+0x92>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
 8002c98:	6863      	ldr	r3, [r4, #4]
 8002c9a:	2b00      	cmp	r3, #0
 8002c9c:	bf18      	it	ne
 8002c9e:	f5b3 3f80 	cmpne.w	r3, #65536	@ 0x10000
 8002ca2:	d002      	beq.n	8002caa <HAL_RCC_OscConfig+0x2e>
 8002ca4:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 8002ca8:	d11e      	bne.n	8002ce8 <HAL_RCC_OscConfig+0x6c>

    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8002caa:	4aa0      	ldr	r2, [pc, #640]	@ (8002f2c <HAL_RCC_OscConfig+0x2b0>)
 8002cac:	6913      	ldr	r3, [r2, #16]
 8002cae:	f003 0338 	and.w	r3, r3, #56	@ 0x38
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 8002cb2:	6a92      	ldr	r2, [r2, #40]	@ 0x28
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if ((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
 8002cb4:	2b10      	cmp	r3, #16
 8002cb6:	d021      	beq.n	8002cfc <HAL_RCC_OscConfig+0x80>
 8002cb8:	2b18      	cmp	r3, #24
 8002cba:	d01b      	beq.n	8002cf4 <HAL_RCC_OscConfig+0x78>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002cbc:	6863      	ldr	r3, [r4, #4]
 8002cbe:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8002cc2:	d057      	beq.n	8002d74 <HAL_RCC_OscConfig+0xf8>
 8002cc4:	2b00      	cmp	r3, #0
 8002cc6:	d16b      	bne.n	8002da0 <HAL_RCC_OscConfig+0x124>
 8002cc8:	4b98      	ldr	r3, [pc, #608]	@ (8002f2c <HAL_RCC_OscConfig+0x2b0>)
 8002cca:	681a      	ldr	r2, [r3, #0]
 8002ccc:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 8002cd0:	601a      	str	r2, [r3, #0]
 8002cd2:	681a      	ldr	r2, [r3, #0]
 8002cd4:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 8002cd8:	601a      	str	r2, [r3, #0]
 8002cda:	e050      	b.n	8002d7e <HAL_RCC_OscConfig+0x102>
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
 8002cdc:	f240 11a1 	movw	r1, #417	@ 0x1a1
 8002ce0:	4893      	ldr	r0, [pc, #588]	@ (8002f30 <HAL_RCC_OscConfig+0x2b4>)
 8002ce2:	f7fd fef7 	bl	8000ad4 <assert_failed>
 8002ce6:	e7d3      	b.n	8002c90 <HAL_RCC_OscConfig+0x14>
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
 8002ce8:	f44f 71d3 	mov.w	r1, #422	@ 0x1a6
 8002cec:	4890      	ldr	r0, [pc, #576]	@ (8002f30 <HAL_RCC_OscConfig+0x2b4>)
 8002cee:	f7fd fef1 	bl	8000ad4 <assert_failed>
 8002cf2:	e7da      	b.n	8002caa <HAL_RCC_OscConfig+0x2e>
    if ((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
 8002cf4:	f002 0203 	and.w	r2, r2, #3
 8002cf8:	2a02      	cmp	r2, #2
 8002cfa:	d1df      	bne.n	8002cbc <HAL_RCC_OscConfig+0x40>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8002cfc:	4b8b      	ldr	r3, [pc, #556]	@ (8002f2c <HAL_RCC_OscConfig+0x2b0>)
 8002cfe:	681b      	ldr	r3, [r3, #0]
 8002d00:	f413 3f00 	tst.w	r3, #131072	@ 0x20000
 8002d04:	d003      	beq.n	8002d0e <HAL_RCC_OscConfig+0x92>
 8002d06:	6863      	ldr	r3, [r4, #4]
 8002d08:	2b00      	cmp	r3, #0
 8002d0a:	f000 83d6 	beq.w	80034ba <HAL_RCC_OscConfig+0x83e>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8002d0e:	6823      	ldr	r3, [r4, #0]
 8002d10:	f013 0f02 	tst.w	r3, #2
 8002d14:	f000 80b9 	beq.w	8002e8a <HAL_RCC_OscConfig+0x20e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
 8002d18:	68e3      	ldr	r3, [r4, #12]
 8002d1a:	2b09      	cmp	r3, #9
 8002d1c:	bf18      	it	ne
 8002d1e:	2b01      	cmpne	r3, #1
 8002d20:	d903      	bls.n	8002d2a <HAL_RCC_OscConfig+0xae>
 8002d22:	2b11      	cmp	r3, #17
 8002d24:	d001      	beq.n	8002d2a <HAL_RCC_OscConfig+0xae>
 8002d26:	2b19      	cmp	r3, #25
 8002d28:	d160      	bne.n	8002dec <HAL_RCC_OscConfig+0x170>
    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
 8002d2a:	6923      	ldr	r3, [r4, #16]
 8002d2c:	2b7f      	cmp	r3, #127	@ 0x7f
 8002d2e:	d863      	bhi.n	8002df8 <HAL_RCC_OscConfig+0x17c>

    /* When the HSI is used as system clock it will not be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8002d30:	4a7e      	ldr	r2, [pc, #504]	@ (8002f2c <HAL_RCC_OscConfig+0x2b0>)
 8002d32:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 8002d34:	6a92      	ldr	r2, [r2, #40]	@ 0x28
    if ((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
 8002d36:	f013 0338 	ands.w	r3, r3, #56	@ 0x38
 8002d3a:	d066      	beq.n	8002e0a <HAL_RCC_OscConfig+0x18e>
 8002d3c:	2b18      	cmp	r3, #24
 8002d3e:	d061      	beq.n	8002e04 <HAL_RCC_OscConfig+0x188>
    }

    else
    {
      /* Check the HSI State */
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
 8002d40:	68e3      	ldr	r3, [r4, #12]
 8002d42:	2b00      	cmp	r3, #0
 8002d44:	f000 80f6 	beq.w	8002f34 <HAL_RCC_OscConfig+0x2b8>
      {
        /* Enable the Internal High Speed oscillator (HSI, HSIDIV2,HSIDIV4, or HSIDIV8) */
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 8002d48:	4978      	ldr	r1, [pc, #480]	@ (8002f2c <HAL_RCC_OscConfig+0x2b0>)
 8002d4a:	680a      	ldr	r2, [r1, #0]
 8002d4c:	f022 0219 	bic.w	r2, r2, #25
 8002d50:	4313      	orrs	r3, r2
 8002d52:	600b      	str	r3, [r1, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002d54:	f7fe fb50 	bl	80013f8 <HAL_GetTick>
 8002d58:	4605      	mov	r5, r0

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8002d5a:	4b74      	ldr	r3, [pc, #464]	@ (8002f2c <HAL_RCC_OscConfig+0x2b0>)
 8002d5c:	681b      	ldr	r3, [r3, #0]
 8002d5e:	f013 0f04 	tst.w	r3, #4
 8002d62:	f040 80c1 	bne.w	8002ee8 <HAL_RCC_OscConfig+0x26c>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8002d66:	f7fe fb47 	bl	80013f8 <HAL_GetTick>
 8002d6a:	1b40      	subs	r0, r0, r5
 8002d6c:	2802      	cmp	r0, #2
 8002d6e:	d9f4      	bls.n	8002d5a <HAL_RCC_OscConfig+0xde>
          {
            return HAL_TIMEOUT;
 8002d70:	2003      	movs	r0, #3
 8002d72:	e068      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002d74:	4a6d      	ldr	r2, [pc, #436]	@ (8002f2c <HAL_RCC_OscConfig+0x2b0>)
 8002d76:	6813      	ldr	r3, [r2, #0]
 8002d78:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8002d7c:	6013      	str	r3, [r2, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8002d7e:	6863      	ldr	r3, [r4, #4]
 8002d80:	b32b      	cbz	r3, 8002dce <HAL_RCC_OscConfig+0x152>
        tickstart = HAL_GetTick();
 8002d82:	f7fe fb39 	bl	80013f8 <HAL_GetTick>
 8002d86:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8002d88:	4b68      	ldr	r3, [pc, #416]	@ (8002f2c <HAL_RCC_OscConfig+0x2b0>)
 8002d8a:	681b      	ldr	r3, [r3, #0]
 8002d8c:	f413 3f00 	tst.w	r3, #131072	@ 0x20000
 8002d90:	d1bd      	bne.n	8002d0e <HAL_RCC_OscConfig+0x92>
          if ((uint32_t)(HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8002d92:	f7fe fb31 	bl	80013f8 <HAL_GetTick>
 8002d96:	1b40      	subs	r0, r0, r5
 8002d98:	2864      	cmp	r0, #100	@ 0x64
 8002d9a:	d9f5      	bls.n	8002d88 <HAL_RCC_OscConfig+0x10c>
            return HAL_TIMEOUT;
 8002d9c:	2003      	movs	r0, #3
 8002d9e:	e052      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002da0:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 8002da4:	d009      	beq.n	8002dba <HAL_RCC_OscConfig+0x13e>
 8002da6:	4b61      	ldr	r3, [pc, #388]	@ (8002f2c <HAL_RCC_OscConfig+0x2b0>)
 8002da8:	681a      	ldr	r2, [r3, #0]
 8002daa:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 8002dae:	601a      	str	r2, [r3, #0]
 8002db0:	681a      	ldr	r2, [r3, #0]
 8002db2:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 8002db6:	601a      	str	r2, [r3, #0]
 8002db8:	e7e1      	b.n	8002d7e <HAL_RCC_OscConfig+0x102>
 8002dba:	4b5c      	ldr	r3, [pc, #368]	@ (8002f2c <HAL_RCC_OscConfig+0x2b0>)
 8002dbc:	681a      	ldr	r2, [r3, #0]
 8002dbe:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 8002dc2:	601a      	str	r2, [r3, #0]
 8002dc4:	681a      	ldr	r2, [r3, #0]
 8002dc6:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 8002dca:	601a      	str	r2, [r3, #0]
 8002dcc:	e7d7      	b.n	8002d7e <HAL_RCC_OscConfig+0x102>
        tickstart = HAL_GetTick();
 8002dce:	f7fe fb13 	bl	80013f8 <HAL_GetTick>
 8002dd2:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 8002dd4:	4b55      	ldr	r3, [pc, #340]	@ (8002f2c <HAL_RCC_OscConfig+0x2b0>)
 8002dd6:	681b      	ldr	r3, [r3, #0]
 8002dd8:	f413 3f00 	tst.w	r3, #131072	@ 0x20000
 8002ddc:	d097      	beq.n	8002d0e <HAL_RCC_OscConfig+0x92>
          if ((uint32_t)(HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8002dde:	f7fe fb0b 	bl	80013f8 <HAL_GetTick>
 8002de2:	1b40      	subs	r0, r0, r5
 8002de4:	2864      	cmp	r0, #100	@ 0x64
 8002de6:	d9f5      	bls.n	8002dd4 <HAL_RCC_OscConfig+0x158>
            return HAL_TIMEOUT;
 8002de8:	2003      	movs	r0, #3
 8002dea:	e02c      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
 8002dec:	f44f 71ed 	mov.w	r1, #474	@ 0x1da
 8002df0:	484f      	ldr	r0, [pc, #316]	@ (8002f30 <HAL_RCC_OscConfig+0x2b4>)
 8002df2:	f7fd fe6f 	bl	8000ad4 <assert_failed>
 8002df6:	e798      	b.n	8002d2a <HAL_RCC_OscConfig+0xae>
    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
 8002df8:	f240 11db 	movw	r1, #475	@ 0x1db
 8002dfc:	484c      	ldr	r0, [pc, #304]	@ (8002f30 <HAL_RCC_OscConfig+0x2b4>)
 8002dfe:	f7fd fe69 	bl	8000ad4 <assert_failed>
 8002e02:	e795      	b.n	8002d30 <HAL_RCC_OscConfig+0xb4>
    if ((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
 8002e04:	f012 0f03 	tst.w	r2, #3
 8002e08:	d19a      	bne.n	8002d40 <HAL_RCC_OscConfig+0xc4>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8002e0a:	4b48      	ldr	r3, [pc, #288]	@ (8002f2c <HAL_RCC_OscConfig+0x2b0>)
 8002e0c:	681b      	ldr	r3, [r3, #0]
 8002e0e:	f013 0f04 	tst.w	r3, #4
 8002e12:	d003      	beq.n	8002e1c <HAL_RCC_OscConfig+0x1a0>
 8002e14:	68e3      	ldr	r3, [r4, #12]
 8002e16:	2b00      	cmp	r3, #0
 8002e18:	f000 8351 	beq.w	80034be <HAL_RCC_OscConfig+0x842>
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 8002e1c:	4a43      	ldr	r2, [pc, #268]	@ (8002f2c <HAL_RCC_OscConfig+0x2b0>)
 8002e1e:	6813      	ldr	r3, [r2, #0]
 8002e20:	f023 0319 	bic.w	r3, r3, #25
 8002e24:	68e1      	ldr	r1, [r4, #12]
 8002e26:	430b      	orrs	r3, r1
 8002e28:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8002e2a:	f7fe fae5 	bl	80013f8 <HAL_GetTick>
 8002e2e:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8002e30:	4b3e      	ldr	r3, [pc, #248]	@ (8002f2c <HAL_RCC_OscConfig+0x2b0>)
 8002e32:	681b      	ldr	r3, [r3, #0]
 8002e34:	f013 0f04 	tst.w	r3, #4
 8002e38:	d106      	bne.n	8002e48 <HAL_RCC_OscConfig+0x1cc>
          if ((uint32_t)(HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8002e3a:	f7fe fadd 	bl	80013f8 <HAL_GetTick>
 8002e3e:	1b40      	subs	r0, r0, r5
 8002e40:	2802      	cmp	r0, #2
 8002e42:	d9f5      	bls.n	8002e30 <HAL_RCC_OscConfig+0x1b4>
            return HAL_TIMEOUT;
 8002e44:	2003      	movs	r0, #3
        }
      }
    }
  }
  return HAL_OK;
}
 8002e46:	bd38      	pop	{r3, r4, r5, pc}
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002e48:	f7fe faf0 	bl	800142c <HAL_GetREVID>
 8002e4c:	f241 0303 	movw	r3, #4099	@ 0x1003
 8002e50:	4298      	cmp	r0, r3
 8002e52:	d812      	bhi.n	8002e7a <HAL_RCC_OscConfig+0x1fe>
 8002e54:	6922      	ldr	r2, [r4, #16]
 8002e56:	2a40      	cmp	r2, #64	@ 0x40
 8002e58:	d007      	beq.n	8002e6a <HAL_RCC_OscConfig+0x1ee>
 8002e5a:	4934      	ldr	r1, [pc, #208]	@ (8002f2c <HAL_RCC_OscConfig+0x2b0>)
 8002e5c:	684b      	ldr	r3, [r1, #4]
 8002e5e:	f423 337c 	bic.w	r3, r3, #258048	@ 0x3f000
 8002e62:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
 8002e66:	604b      	str	r3, [r1, #4]
 8002e68:	e00f      	b.n	8002e8a <HAL_RCC_OscConfig+0x20e>
 8002e6a:	4a30      	ldr	r2, [pc, #192]	@ (8002f2c <HAL_RCC_OscConfig+0x2b0>)
 8002e6c:	6853      	ldr	r3, [r2, #4]
 8002e6e:	f423 337c 	bic.w	r3, r3, #258048	@ 0x3f000
 8002e72:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8002e76:	6053      	str	r3, [r2, #4]
 8002e78:	e007      	b.n	8002e8a <HAL_RCC_OscConfig+0x20e>
 8002e7a:	4a2c      	ldr	r2, [pc, #176]	@ (8002f2c <HAL_RCC_OscConfig+0x2b0>)
 8002e7c:	6853      	ldr	r3, [r2, #4]
 8002e7e:	f023 43fe 	bic.w	r3, r3, #2130706432	@ 0x7f000000
 8002e82:	6921      	ldr	r1, [r4, #16]
 8002e84:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8002e88:	6053      	str	r3, [r2, #4]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
 8002e8a:	6823      	ldr	r3, [r4, #0]
 8002e8c:	f013 0f10 	tst.w	r3, #16
 8002e90:	f000 809e 	beq.w	8002fd0 <HAL_RCC_OscConfig+0x354>
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
 8002e94:	69e3      	ldr	r3, [r4, #28]
 8002e96:	2b00      	cmp	r3, #0
 8002e98:	bf18      	it	ne
 8002e9a:	2b80      	cmpne	r3, #128	@ 0x80
 8002e9c:	d15e      	bne.n	8002f5c <HAL_RCC_OscConfig+0x2e0>
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));
 8002e9e:	6a23      	ldr	r3, [r4, #32]
 8002ea0:	2b3f      	cmp	r3, #63	@ 0x3f
 8002ea2:	d861      	bhi.n	8002f68 <HAL_RCC_OscConfig+0x2ec>
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8002ea4:	4a21      	ldr	r2, [pc, #132]	@ (8002f2c <HAL_RCC_OscConfig+0x2b0>)
 8002ea6:	6913      	ldr	r3, [r2, #16]
 8002ea8:	f003 0338 	and.w	r3, r3, #56	@ 0x38
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 8002eac:	6a92      	ldr	r2, [r2, #40]	@ 0x28
    if ((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
 8002eae:	2b08      	cmp	r3, #8
 8002eb0:	d064      	beq.n	8002f7c <HAL_RCC_OscConfig+0x300>
 8002eb2:	2b18      	cmp	r3, #24
 8002eb4:	d05e      	beq.n	8002f74 <HAL_RCC_OscConfig+0x2f8>
      if ((RCC_OscInitStruct->CSIState) != RCC_CSI_OFF)
 8002eb6:	69e3      	ldr	r3, [r4, #28]
 8002eb8:	2b00      	cmp	r3, #0
 8002eba:	f000 80c9 	beq.w	8003050 <HAL_RCC_OscConfig+0x3d4>
        __HAL_RCC_CSI_ENABLE();
 8002ebe:	4a1b      	ldr	r2, [pc, #108]	@ (8002f2c <HAL_RCC_OscConfig+0x2b0>)
 8002ec0:	6813      	ldr	r3, [r2, #0]
 8002ec2:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8002ec6:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8002ec8:	f7fe fa96 	bl	80013f8 <HAL_GetTick>
 8002ecc:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 8002ece:	4b17      	ldr	r3, [pc, #92]	@ (8002f2c <HAL_RCC_OscConfig+0x2b0>)
 8002ed0:	681b      	ldr	r3, [r3, #0]
 8002ed2:	f413 7f80 	tst.w	r3, #256	@ 0x100
 8002ed6:	f040 8099 	bne.w	800300c <HAL_RCC_OscConfig+0x390>
          if ((HAL_GetTick() - tickstart) > CSI_TIMEOUT_VALUE)
 8002eda:	f7fe fa8d 	bl	80013f8 <HAL_GetTick>
 8002ede:	1b40      	subs	r0, r0, r5
 8002ee0:	2802      	cmp	r0, #2
 8002ee2:	d9f4      	bls.n	8002ece <HAL_RCC_OscConfig+0x252>
            return HAL_TIMEOUT;
 8002ee4:	2003      	movs	r0, #3
 8002ee6:	e7ae      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002ee8:	f7fe faa0 	bl	800142c <HAL_GetREVID>
 8002eec:	f241 0303 	movw	r3, #4099	@ 0x1003
 8002ef0:	4298      	cmp	r0, r3
 8002ef2:	d812      	bhi.n	8002f1a <HAL_RCC_OscConfig+0x29e>
 8002ef4:	6922      	ldr	r2, [r4, #16]
 8002ef6:	2a40      	cmp	r2, #64	@ 0x40
 8002ef8:	d007      	beq.n	8002f0a <HAL_RCC_OscConfig+0x28e>
 8002efa:	490c      	ldr	r1, [pc, #48]	@ (8002f2c <HAL_RCC_OscConfig+0x2b0>)
 8002efc:	684b      	ldr	r3, [r1, #4]
 8002efe:	f423 337c 	bic.w	r3, r3, #258048	@ 0x3f000
 8002f02:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
 8002f06:	604b      	str	r3, [r1, #4]
 8002f08:	e7bf      	b.n	8002e8a <HAL_RCC_OscConfig+0x20e>
 8002f0a:	4a08      	ldr	r2, [pc, #32]	@ (8002f2c <HAL_RCC_OscConfig+0x2b0>)
 8002f0c:	6853      	ldr	r3, [r2, #4]
 8002f0e:	f423 337c 	bic.w	r3, r3, #258048	@ 0x3f000
 8002f12:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8002f16:	6053      	str	r3, [r2, #4]
 8002f18:	e7b7      	b.n	8002e8a <HAL_RCC_OscConfig+0x20e>
 8002f1a:	4a04      	ldr	r2, [pc, #16]	@ (8002f2c <HAL_RCC_OscConfig+0x2b0>)
 8002f1c:	6853      	ldr	r3, [r2, #4]
 8002f1e:	f023 43fe 	bic.w	r3, r3, #2130706432	@ 0x7f000000
 8002f22:	6921      	ldr	r1, [r4, #16]
 8002f24:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8002f28:	6053      	str	r3, [r2, #4]
 8002f2a:	e7ae      	b.n	8002e8a <HAL_RCC_OscConfig+0x20e>
 8002f2c:	58024400 	.word	0x58024400
 8002f30:	08015540 	.word	0x08015540
        __HAL_RCC_HSI_DISABLE();
 8002f34:	4a9d      	ldr	r2, [pc, #628]	@ (80031ac <HAL_RCC_OscConfig+0x530>)
 8002f36:	6813      	ldr	r3, [r2, #0]
 8002f38:	f023 0301 	bic.w	r3, r3, #1
 8002f3c:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8002f3e:	f7fe fa5b 	bl	80013f8 <HAL_GetTick>
 8002f42:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 8002f44:	4b99      	ldr	r3, [pc, #612]	@ (80031ac <HAL_RCC_OscConfig+0x530>)
 8002f46:	681b      	ldr	r3, [r3, #0]
 8002f48:	f013 0f04 	tst.w	r3, #4
 8002f4c:	d09d      	beq.n	8002e8a <HAL_RCC_OscConfig+0x20e>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8002f4e:	f7fe fa53 	bl	80013f8 <HAL_GetTick>
 8002f52:	1b40      	subs	r0, r0, r5
 8002f54:	2802      	cmp	r0, #2
 8002f56:	d9f5      	bls.n	8002f44 <HAL_RCC_OscConfig+0x2c8>
            return HAL_TIMEOUT;
 8002f58:	2003      	movs	r0, #3
 8002f5a:	e774      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
 8002f5c:	f240 212b 	movw	r1, #555	@ 0x22b
 8002f60:	4893      	ldr	r0, [pc, #588]	@ (80031b0 <HAL_RCC_OscConfig+0x534>)
 8002f62:	f7fd fdb7 	bl	8000ad4 <assert_failed>
 8002f66:	e79a      	b.n	8002e9e <HAL_RCC_OscConfig+0x222>
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));
 8002f68:	f44f 710b 	mov.w	r1, #556	@ 0x22c
 8002f6c:	4890      	ldr	r0, [pc, #576]	@ (80031b0 <HAL_RCC_OscConfig+0x534>)
 8002f6e:	f7fd fdb1 	bl	8000ad4 <assert_failed>
 8002f72:	e797      	b.n	8002ea4 <HAL_RCC_OscConfig+0x228>
    if ((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
 8002f74:	f002 0203 	and.w	r2, r2, #3
 8002f78:	2a01      	cmp	r2, #1
 8002f7a:	d19c      	bne.n	8002eb6 <HAL_RCC_OscConfig+0x23a>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
 8002f7c:	4b8b      	ldr	r3, [pc, #556]	@ (80031ac <HAL_RCC_OscConfig+0x530>)
 8002f7e:	681b      	ldr	r3, [r3, #0]
 8002f80:	f413 7f80 	tst.w	r3, #256	@ 0x100
 8002f84:	d003      	beq.n	8002f8e <HAL_RCC_OscConfig+0x312>
 8002f86:	69e3      	ldr	r3, [r4, #28]
 8002f88:	2b80      	cmp	r3, #128	@ 0x80
 8002f8a:	f040 829a 	bne.w	80034c2 <HAL_RCC_OscConfig+0x846>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 8002f8e:	f7fe fa4d 	bl	800142c <HAL_GetREVID>
 8002f92:	f241 0303 	movw	r3, #4099	@ 0x1003
 8002f96:	4298      	cmp	r0, r3
 8002f98:	d812      	bhi.n	8002fc0 <HAL_RCC_OscConfig+0x344>
 8002f9a:	6a22      	ldr	r2, [r4, #32]
 8002f9c:	2a20      	cmp	r2, #32
 8002f9e:	d007      	beq.n	8002fb0 <HAL_RCC_OscConfig+0x334>
 8002fa0:	4982      	ldr	r1, [pc, #520]	@ (80031ac <HAL_RCC_OscConfig+0x530>)
 8002fa2:	684b      	ldr	r3, [r1, #4]
 8002fa4:	f023 43f8 	bic.w	r3, r3, #2080374784	@ 0x7c000000
 8002fa8:	ea43 6382 	orr.w	r3, r3, r2, lsl #26
 8002fac:	604b      	str	r3, [r1, #4]
 8002fae:	e00f      	b.n	8002fd0 <HAL_RCC_OscConfig+0x354>
 8002fb0:	4a7e      	ldr	r2, [pc, #504]	@ (80031ac <HAL_RCC_OscConfig+0x530>)
 8002fb2:	6853      	ldr	r3, [r2, #4]
 8002fb4:	f023 43f8 	bic.w	r3, r3, #2080374784	@ 0x7c000000
 8002fb8:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8002fbc:	6053      	str	r3, [r2, #4]
 8002fbe:	e007      	b.n	8002fd0 <HAL_RCC_OscConfig+0x354>
 8002fc0:	4a7a      	ldr	r2, [pc, #488]	@ (80031ac <HAL_RCC_OscConfig+0x530>)
 8002fc2:	68d3      	ldr	r3, [r2, #12]
 8002fc4:	f023 537c 	bic.w	r3, r3, #1056964608	@ 0x3f000000
 8002fc8:	6a21      	ldr	r1, [r4, #32]
 8002fca:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8002fce:	60d3      	str	r3, [r2, #12]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8002fd0:	6823      	ldr	r3, [r4, #0]
 8002fd2:	f013 0f08 	tst.w	r3, #8
 8002fd6:	d069      	beq.n	80030ac <HAL_RCC_OscConfig+0x430>
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
 8002fd8:	6963      	ldr	r3, [r4, #20]
 8002fda:	2b01      	cmp	r3, #1
 8002fdc:	d84c      	bhi.n	8003078 <HAL_RCC_OscConfig+0x3fc>
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
 8002fde:	6963      	ldr	r3, [r4, #20]
 8002fe0:	2b00      	cmp	r3, #0
 8002fe2:	d04f      	beq.n	8003084 <HAL_RCC_OscConfig+0x408>
      __HAL_RCC_LSI_ENABLE();
 8002fe4:	4a71      	ldr	r2, [pc, #452]	@ (80031ac <HAL_RCC_OscConfig+0x530>)
 8002fe6:	6f53      	ldr	r3, [r2, #116]	@ 0x74
 8002fe8:	f043 0301 	orr.w	r3, r3, #1
 8002fec:	6753      	str	r3, [r2, #116]	@ 0x74
      tickstart = HAL_GetTick();
 8002fee:	f7fe fa03 	bl	80013f8 <HAL_GetTick>
 8002ff2:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8002ff4:	4b6d      	ldr	r3, [pc, #436]	@ (80031ac <HAL_RCC_OscConfig+0x530>)
 8002ff6:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8002ff8:	f013 0f02 	tst.w	r3, #2
 8002ffc:	d156      	bne.n	80030ac <HAL_RCC_OscConfig+0x430>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8002ffe:	f7fe f9fb 	bl	80013f8 <HAL_GetTick>
 8003002:	1b40      	subs	r0, r0, r5
 8003004:	2802      	cmp	r0, #2
 8003006:	d9f5      	bls.n	8002ff4 <HAL_RCC_OscConfig+0x378>
          return HAL_TIMEOUT;
 8003008:	2003      	movs	r0, #3
 800300a:	e71c      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 800300c:	f7fe fa0e 	bl	800142c <HAL_GetREVID>
 8003010:	f241 0303 	movw	r3, #4099	@ 0x1003
 8003014:	4298      	cmp	r0, r3
 8003016:	d812      	bhi.n	800303e <HAL_RCC_OscConfig+0x3c2>
 8003018:	6a22      	ldr	r2, [r4, #32]
 800301a:	2a20      	cmp	r2, #32
 800301c:	d007      	beq.n	800302e <HAL_RCC_OscConfig+0x3b2>
 800301e:	4963      	ldr	r1, [pc, #396]	@ (80031ac <HAL_RCC_OscConfig+0x530>)
 8003020:	684b      	ldr	r3, [r1, #4]
 8003022:	f023 43f8 	bic.w	r3, r3, #2080374784	@ 0x7c000000
 8003026:	ea43 6382 	orr.w	r3, r3, r2, lsl #26
 800302a:	604b      	str	r3, [r1, #4]
 800302c:	e7d0      	b.n	8002fd0 <HAL_RCC_OscConfig+0x354>
 800302e:	4a5f      	ldr	r2, [pc, #380]	@ (80031ac <HAL_RCC_OscConfig+0x530>)
 8003030:	6853      	ldr	r3, [r2, #4]
 8003032:	f023 43f8 	bic.w	r3, r3, #2080374784	@ 0x7c000000
 8003036:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 800303a:	6053      	str	r3, [r2, #4]
 800303c:	e7c8      	b.n	8002fd0 <HAL_RCC_OscConfig+0x354>
 800303e:	4a5b      	ldr	r2, [pc, #364]	@ (80031ac <HAL_RCC_OscConfig+0x530>)
 8003040:	68d3      	ldr	r3, [r2, #12]
 8003042:	f023 537c 	bic.w	r3, r3, #1056964608	@ 0x3f000000
 8003046:	6a21      	ldr	r1, [r4, #32]
 8003048:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 800304c:	60d3      	str	r3, [r2, #12]
 800304e:	e7bf      	b.n	8002fd0 <HAL_RCC_OscConfig+0x354>
        __HAL_RCC_CSI_DISABLE();
 8003050:	4a56      	ldr	r2, [pc, #344]	@ (80031ac <HAL_RCC_OscConfig+0x530>)
 8003052:	6813      	ldr	r3, [r2, #0]
 8003054:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8003058:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 800305a:	f7fe f9cd 	bl	80013f8 <HAL_GetTick>
 800305e:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
 8003060:	4b52      	ldr	r3, [pc, #328]	@ (80031ac <HAL_RCC_OscConfig+0x530>)
 8003062:	681b      	ldr	r3, [r3, #0]
 8003064:	f413 7f80 	tst.w	r3, #256	@ 0x100
 8003068:	d0b2      	beq.n	8002fd0 <HAL_RCC_OscConfig+0x354>
          if ((HAL_GetTick() - tickstart) > CSI_TIMEOUT_VALUE)
 800306a:	f7fe f9c5 	bl	80013f8 <HAL_GetTick>
 800306e:	1b40      	subs	r0, r0, r5
 8003070:	2802      	cmp	r0, #2
 8003072:	d9f5      	bls.n	8003060 <HAL_RCC_OscConfig+0x3e4>
            return HAL_TIMEOUT;
 8003074:	2003      	movs	r0, #3
 8003076:	e6e6      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
 8003078:	f240 216d 	movw	r1, #621	@ 0x26d
 800307c:	484c      	ldr	r0, [pc, #304]	@ (80031b0 <HAL_RCC_OscConfig+0x534>)
 800307e:	f7fd fd29 	bl	8000ad4 <assert_failed>
 8003082:	e7ac      	b.n	8002fde <HAL_RCC_OscConfig+0x362>
      __HAL_RCC_LSI_DISABLE();
 8003084:	4a49      	ldr	r2, [pc, #292]	@ (80031ac <HAL_RCC_OscConfig+0x530>)
 8003086:	6f53      	ldr	r3, [r2, #116]	@ 0x74
 8003088:	f023 0301 	bic.w	r3, r3, #1
 800308c:	6753      	str	r3, [r2, #116]	@ 0x74
      tickstart = HAL_GetTick();
 800308e:	f7fe f9b3 	bl	80013f8 <HAL_GetTick>
 8003092:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 8003094:	4b45      	ldr	r3, [pc, #276]	@ (80031ac <HAL_RCC_OscConfig+0x530>)
 8003096:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8003098:	f013 0f02 	tst.w	r3, #2
 800309c:	d006      	beq.n	80030ac <HAL_RCC_OscConfig+0x430>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800309e:	f7fe f9ab 	bl	80013f8 <HAL_GetTick>
 80030a2:	1b40      	subs	r0, r0, r5
 80030a4:	2802      	cmp	r0, #2
 80030a6:	d9f5      	bls.n	8003094 <HAL_RCC_OscConfig+0x418>
          return HAL_TIMEOUT;
 80030a8:	2003      	movs	r0, #3
 80030aa:	e6cc      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 80030ac:	6823      	ldr	r3, [r4, #0]
 80030ae:	f013 0f20 	tst.w	r3, #32
 80030b2:	d032      	beq.n	800311a <HAL_RCC_OscConfig+0x49e>
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));
 80030b4:	69a3      	ldr	r3, [r4, #24]
 80030b6:	2b01      	cmp	r3, #1
 80030b8:	d815      	bhi.n	80030e6 <HAL_RCC_OscConfig+0x46a>
    if ((RCC_OscInitStruct->HSI48State) != RCC_HSI48_OFF)
 80030ba:	69a3      	ldr	r3, [r4, #24]
 80030bc:	b1cb      	cbz	r3, 80030f2 <HAL_RCC_OscConfig+0x476>
      __HAL_RCC_HSI48_ENABLE();
 80030be:	4a3b      	ldr	r2, [pc, #236]	@ (80031ac <HAL_RCC_OscConfig+0x530>)
 80030c0:	6813      	ldr	r3, [r2, #0]
 80030c2:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 80030c6:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 80030c8:	f7fe f996 	bl	80013f8 <HAL_GetTick>
 80030cc:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 80030ce:	4b37      	ldr	r3, [pc, #220]	@ (80031ac <HAL_RCC_OscConfig+0x530>)
 80030d0:	681b      	ldr	r3, [r3, #0]
 80030d2:	f413 5f00 	tst.w	r3, #8192	@ 0x2000
 80030d6:	d120      	bne.n	800311a <HAL_RCC_OscConfig+0x49e>
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 80030d8:	f7fe f98e 	bl	80013f8 <HAL_GetTick>
 80030dc:	1b40      	subs	r0, r0, r5
 80030de:	2802      	cmp	r0, #2
 80030e0:	d9f5      	bls.n	80030ce <HAL_RCC_OscConfig+0x452>
          return HAL_TIMEOUT;
 80030e2:	2003      	movs	r0, #3
 80030e4:	e6af      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));
 80030e6:	f44f 7126 	mov.w	r1, #664	@ 0x298
 80030ea:	4831      	ldr	r0, [pc, #196]	@ (80031b0 <HAL_RCC_OscConfig+0x534>)
 80030ec:	f7fd fcf2 	bl	8000ad4 <assert_failed>
 80030f0:	e7e3      	b.n	80030ba <HAL_RCC_OscConfig+0x43e>
      __HAL_RCC_HSI48_DISABLE();
 80030f2:	4a2e      	ldr	r2, [pc, #184]	@ (80031ac <HAL_RCC_OscConfig+0x530>)
 80030f4:	6813      	ldr	r3, [r2, #0]
 80030f6:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 80030fa:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 80030fc:	f7fe f97c 	bl	80013f8 <HAL_GetTick>
 8003100:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 8003102:	4b2a      	ldr	r3, [pc, #168]	@ (80031ac <HAL_RCC_OscConfig+0x530>)
 8003104:	681b      	ldr	r3, [r3, #0]
 8003106:	f413 5f00 	tst.w	r3, #8192	@ 0x2000
 800310a:	d006      	beq.n	800311a <HAL_RCC_OscConfig+0x49e>
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800310c:	f7fe f974 	bl	80013f8 <HAL_GetTick>
 8003110:	1b40      	subs	r0, r0, r5
 8003112:	2802      	cmp	r0, #2
 8003114:	d9f5      	bls.n	8003102 <HAL_RCC_OscConfig+0x486>
          return HAL_TIMEOUT;
 8003116:	2003      	movs	r0, #3
 8003118:	e695      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800311a:	6823      	ldr	r3, [r4, #0]
 800311c:	f013 0f04 	tst.w	r3, #4
 8003120:	d071      	beq.n	8003206 <HAL_RCC_OscConfig+0x58a>
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
 8003122:	68a3      	ldr	r3, [r4, #8]
 8003124:	2b05      	cmp	r3, #5
 8003126:	bf18      	it	ne
 8003128:	2b01      	cmpne	r3, #1
 800312a:	d813      	bhi.n	8003154 <HAL_RCC_OscConfig+0x4d8>
    PWR->CR1 |= PWR_CR1_DBP;
 800312c:	4a21      	ldr	r2, [pc, #132]	@ (80031b4 <HAL_RCC_OscConfig+0x538>)
 800312e:	6813      	ldr	r3, [r2, #0]
 8003130:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8003134:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 8003136:	f7fe f95f 	bl	80013f8 <HAL_GetTick>
 800313a:	4605      	mov	r5, r0
    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 800313c:	4b1d      	ldr	r3, [pc, #116]	@ (80031b4 <HAL_RCC_OscConfig+0x538>)
 800313e:	681b      	ldr	r3, [r3, #0]
 8003140:	f413 7f80 	tst.w	r3, #256	@ 0x100
 8003144:	d10c      	bne.n	8003160 <HAL_RCC_OscConfig+0x4e4>
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8003146:	f7fe f957 	bl	80013f8 <HAL_GetTick>
 800314a:	1b40      	subs	r0, r0, r5
 800314c:	2864      	cmp	r0, #100	@ 0x64
 800314e:	d9f5      	bls.n	800313c <HAL_RCC_OscConfig+0x4c0>
        return HAL_TIMEOUT;
 8003150:	2003      	movs	r0, #3
 8003152:	e678      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
 8003154:	f240 21c2 	movw	r1, #706	@ 0x2c2
 8003158:	4815      	ldr	r0, [pc, #84]	@ (80031b0 <HAL_RCC_OscConfig+0x534>)
 800315a:	f7fd fcbb 	bl	8000ad4 <assert_failed>
 800315e:	e7e5      	b.n	800312c <HAL_RCC_OscConfig+0x4b0>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8003160:	68a3      	ldr	r3, [r4, #8]
 8003162:	2b01      	cmp	r3, #1
 8003164:	d00a      	beq.n	800317c <HAL_RCC_OscConfig+0x500>
 8003166:	bb3b      	cbnz	r3, 80031b8 <HAL_RCC_OscConfig+0x53c>
 8003168:	4b10      	ldr	r3, [pc, #64]	@ (80031ac <HAL_RCC_OscConfig+0x530>)
 800316a:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 800316c:	f022 0201 	bic.w	r2, r2, #1
 8003170:	671a      	str	r2, [r3, #112]	@ 0x70
 8003172:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 8003174:	f022 0204 	bic.w	r2, r2, #4
 8003178:	671a      	str	r2, [r3, #112]	@ 0x70
 800317a:	e004      	b.n	8003186 <HAL_RCC_OscConfig+0x50a>
 800317c:	4a0b      	ldr	r2, [pc, #44]	@ (80031ac <HAL_RCC_OscConfig+0x530>)
 800317e:	6f13      	ldr	r3, [r2, #112]	@ 0x70
 8003180:	f043 0301 	orr.w	r3, r3, #1
 8003184:	6713      	str	r3, [r2, #112]	@ 0x70
    if ((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8003186:	68a3      	ldr	r3, [r4, #8]
 8003188:	b363      	cbz	r3, 80031e4 <HAL_RCC_OscConfig+0x568>
      tickstart = HAL_GetTick();
 800318a:	f7fe f935 	bl	80013f8 <HAL_GetTick>
 800318e:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8003190:	4b06      	ldr	r3, [pc, #24]	@ (80031ac <HAL_RCC_OscConfig+0x530>)
 8003192:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8003194:	f013 0f02 	tst.w	r3, #2
 8003198:	d135      	bne.n	8003206 <HAL_RCC_OscConfig+0x58a>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800319a:	f7fe f92d 	bl	80013f8 <HAL_GetTick>
 800319e:	1b40      	subs	r0, r0, r5
 80031a0:	f241 3388 	movw	r3, #5000	@ 0x1388
 80031a4:	4298      	cmp	r0, r3
 80031a6:	d9f3      	bls.n	8003190 <HAL_RCC_OscConfig+0x514>
          return HAL_TIMEOUT;
 80031a8:	2003      	movs	r0, #3
 80031aa:	e64c      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
 80031ac:	58024400 	.word	0x58024400
 80031b0:	08015540 	.word	0x08015540
 80031b4:	58024800 	.word	0x58024800
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80031b8:	2b05      	cmp	r3, #5
 80031ba:	d009      	beq.n	80031d0 <HAL_RCC_OscConfig+0x554>
 80031bc:	4b92      	ldr	r3, [pc, #584]	@ (8003408 <HAL_RCC_OscConfig+0x78c>)
 80031be:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 80031c0:	f022 0201 	bic.w	r2, r2, #1
 80031c4:	671a      	str	r2, [r3, #112]	@ 0x70
 80031c6:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 80031c8:	f022 0204 	bic.w	r2, r2, #4
 80031cc:	671a      	str	r2, [r3, #112]	@ 0x70
 80031ce:	e7da      	b.n	8003186 <HAL_RCC_OscConfig+0x50a>
 80031d0:	4b8d      	ldr	r3, [pc, #564]	@ (8003408 <HAL_RCC_OscConfig+0x78c>)
 80031d2:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 80031d4:	f042 0204 	orr.w	r2, r2, #4
 80031d8:	671a      	str	r2, [r3, #112]	@ 0x70
 80031da:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 80031dc:	f042 0201 	orr.w	r2, r2, #1
 80031e0:	671a      	str	r2, [r3, #112]	@ 0x70
 80031e2:	e7d0      	b.n	8003186 <HAL_RCC_OscConfig+0x50a>
      tickstart = HAL_GetTick();
 80031e4:	f7fe f908 	bl	80013f8 <HAL_GetTick>
 80031e8:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 80031ea:	4b87      	ldr	r3, [pc, #540]	@ (8003408 <HAL_RCC_OscConfig+0x78c>)
 80031ec:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80031ee:	f013 0f02 	tst.w	r3, #2
 80031f2:	d008      	beq.n	8003206 <HAL_RCC_OscConfig+0x58a>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80031f4:	f7fe f900 	bl	80013f8 <HAL_GetTick>
 80031f8:	1b40      	subs	r0, r0, r5
 80031fa:	f241 3388 	movw	r3, #5000	@ 0x1388
 80031fe:	4298      	cmp	r0, r3
 8003200:	d9f3      	bls.n	80031ea <HAL_RCC_OscConfig+0x56e>
          return HAL_TIMEOUT;
 8003202:	2003      	movs	r0, #3
 8003204:	e61f      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
 8003206:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8003208:	2b02      	cmp	r3, #2
 800320a:	d84f      	bhi.n	80032ac <HAL_RCC_OscConfig+0x630>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800320c:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 800320e:	2b00      	cmp	r3, #0
 8003210:	f000 8159 	beq.w	80034c6 <HAL_RCC_OscConfig+0x84a>
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)
 8003214:	4a7c      	ldr	r2, [pc, #496]	@ (8003408 <HAL_RCC_OscConfig+0x78c>)
 8003216:	6912      	ldr	r2, [r2, #16]
 8003218:	f002 0238 	and.w	r2, r2, #56	@ 0x38
 800321c:	2a18      	cmp	r2, #24
 800321e:	f000 80f9 	beq.w	8003414 <HAL_RCC_OscConfig+0x798>
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8003222:	2b02      	cmp	r3, #2
 8003224:	f040 80da 	bne.w	80033dc <HAL_RCC_OscConfig+0x760>
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
 8003228:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 800322a:	2b03      	cmp	r3, #3
 800322c:	bf18      	it	ne
 800322e:	2b01      	cmpne	r3, #1
 8003230:	d901      	bls.n	8003236 <HAL_RCC_OscConfig+0x5ba>
 8003232:	2b02      	cmp	r3, #2
 8003234:	d140      	bne.n	80032b8 <HAL_RCC_OscConfig+0x63c>
        assert_param(IS_RCC_PLLRGE_VALUE(RCC_OscInitStruct->PLL.PLLRGE));
 8003236:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 8003238:	2b00      	cmp	r3, #0
 800323a:	bf18      	it	ne
 800323c:	2b04      	cmpne	r3, #4
 800323e:	d003      	beq.n	8003248 <HAL_RCC_OscConfig+0x5cc>
 8003240:	2b08      	cmp	r3, #8
 8003242:	d001      	beq.n	8003248 <HAL_RCC_OscConfig+0x5cc>
 8003244:	2b0c      	cmp	r3, #12
 8003246:	d13d      	bne.n	80032c4 <HAL_RCC_OscConfig+0x648>
        assert_param(IS_RCC_PLLVCO_VALUE(RCC_OscInitStruct->PLL.PLLVCOSEL));
 8003248:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 800324a:	2b00      	cmp	r3, #0
 800324c:	bf18      	it	ne
 800324e:	2b02      	cmpne	r3, #2
 8003250:	d13e      	bne.n	80032d0 <HAL_RCC_OscConfig+0x654>
        assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
 8003252:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 8003254:	3b01      	subs	r3, #1
 8003256:	2b3e      	cmp	r3, #62	@ 0x3e
 8003258:	d840      	bhi.n	80032dc <HAL_RCC_OscConfig+0x660>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
 800325a:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 800325c:	3b04      	subs	r3, #4
 800325e:	f5b3 7ffe 	cmp.w	r3, #508	@ 0x1fc
 8003262:	d841      	bhi.n	80032e8 <HAL_RCC_OscConfig+0x66c>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
 8003264:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 8003266:	3b01      	subs	r3, #1
 8003268:	2b7f      	cmp	r3, #127	@ 0x7f
 800326a:	d843      	bhi.n	80032f4 <HAL_RCC_OscConfig+0x678>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
 800326c:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 800326e:	3b01      	subs	r3, #1
 8003270:	2b7f      	cmp	r3, #127	@ 0x7f
 8003272:	d845      	bhi.n	8003300 <HAL_RCC_OscConfig+0x684>
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
 8003274:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8003276:	3b01      	subs	r3, #1
 8003278:	2b7f      	cmp	r3, #127	@ 0x7f
 800327a:	d847      	bhi.n	800330c <HAL_RCC_OscConfig+0x690>
        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));
 800327c:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 800327e:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8003282:	d249      	bcs.n	8003318 <HAL_RCC_OscConfig+0x69c>
        __HAL_RCC_PLL_DISABLE();
 8003284:	4a60      	ldr	r2, [pc, #384]	@ (8003408 <HAL_RCC_OscConfig+0x78c>)
 8003286:	6813      	ldr	r3, [r2, #0]
 8003288:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 800328c:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 800328e:	f7fe f8b3 	bl	80013f8 <HAL_GetTick>
 8003292:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 8003294:	4b5c      	ldr	r3, [pc, #368]	@ (8003408 <HAL_RCC_OscConfig+0x78c>)
 8003296:	681b      	ldr	r3, [r3, #0]
 8003298:	f013 7f00 	tst.w	r3, #33554432	@ 0x2000000
 800329c:	d042      	beq.n	8003324 <HAL_RCC_OscConfig+0x6a8>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800329e:	f7fe f8ab 	bl	80013f8 <HAL_GetTick>
 80032a2:	1b40      	subs	r0, r0, r5
 80032a4:	2802      	cmp	r0, #2
 80032a6:	d9f5      	bls.n	8003294 <HAL_RCC_OscConfig+0x618>
            return HAL_TIMEOUT;
 80032a8:	2003      	movs	r0, #3
 80032aa:	e5cc      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
 80032ac:	f44f 713d 	mov.w	r1, #756	@ 0x2f4
 80032b0:	4856      	ldr	r0, [pc, #344]	@ (800340c <HAL_RCC_OscConfig+0x790>)
 80032b2:	f7fd fc0f 	bl	8000ad4 <assert_failed>
 80032b6:	e7a9      	b.n	800320c <HAL_RCC_OscConfig+0x590>
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
 80032b8:	f240 21fd 	movw	r1, #765	@ 0x2fd
 80032bc:	4853      	ldr	r0, [pc, #332]	@ (800340c <HAL_RCC_OscConfig+0x790>)
 80032be:	f7fd fc09 	bl	8000ad4 <assert_failed>
 80032c2:	e7b8      	b.n	8003236 <HAL_RCC_OscConfig+0x5ba>
        assert_param(IS_RCC_PLLRGE_VALUE(RCC_OscInitStruct->PLL.PLLRGE));
 80032c4:	f240 21fe 	movw	r1, #766	@ 0x2fe
 80032c8:	4850      	ldr	r0, [pc, #320]	@ (800340c <HAL_RCC_OscConfig+0x790>)
 80032ca:	f7fd fc03 	bl	8000ad4 <assert_failed>
 80032ce:	e7bb      	b.n	8003248 <HAL_RCC_OscConfig+0x5cc>
        assert_param(IS_RCC_PLLVCO_VALUE(RCC_OscInitStruct->PLL.PLLVCOSEL));
 80032d0:	f240 21ff 	movw	r1, #767	@ 0x2ff
 80032d4:	484d      	ldr	r0, [pc, #308]	@ (800340c <HAL_RCC_OscConfig+0x790>)
 80032d6:	f7fd fbfd 	bl	8000ad4 <assert_failed>
 80032da:	e7ba      	b.n	8003252 <HAL_RCC_OscConfig+0x5d6>
        assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
 80032dc:	f44f 7140 	mov.w	r1, #768	@ 0x300
 80032e0:	484a      	ldr	r0, [pc, #296]	@ (800340c <HAL_RCC_OscConfig+0x790>)
 80032e2:	f7fd fbf7 	bl	8000ad4 <assert_failed>
 80032e6:	e7b8      	b.n	800325a <HAL_RCC_OscConfig+0x5de>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
 80032e8:	f240 3101 	movw	r1, #769	@ 0x301
 80032ec:	4847      	ldr	r0, [pc, #284]	@ (800340c <HAL_RCC_OscConfig+0x790>)
 80032ee:	f7fd fbf1 	bl	8000ad4 <assert_failed>
 80032f2:	e7b7      	b.n	8003264 <HAL_RCC_OscConfig+0x5e8>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
 80032f4:	f240 3102 	movw	r1, #770	@ 0x302
 80032f8:	4844      	ldr	r0, [pc, #272]	@ (800340c <HAL_RCC_OscConfig+0x790>)
 80032fa:	f7fd fbeb 	bl	8000ad4 <assert_failed>
 80032fe:	e7b5      	b.n	800326c <HAL_RCC_OscConfig+0x5f0>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
 8003300:	f240 3103 	movw	r1, #771	@ 0x303
 8003304:	4841      	ldr	r0, [pc, #260]	@ (800340c <HAL_RCC_OscConfig+0x790>)
 8003306:	f7fd fbe5 	bl	8000ad4 <assert_failed>
 800330a:	e7b3      	b.n	8003274 <HAL_RCC_OscConfig+0x5f8>
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
 800330c:	f44f 7141 	mov.w	r1, #772	@ 0x304
 8003310:	483e      	ldr	r0, [pc, #248]	@ (800340c <HAL_RCC_OscConfig+0x790>)
 8003312:	f7fd fbdf 	bl	8000ad4 <assert_failed>
 8003316:	e7b1      	b.n	800327c <HAL_RCC_OscConfig+0x600>
        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));
 8003318:	f240 3105 	movw	r1, #773	@ 0x305
 800331c:	483b      	ldr	r0, [pc, #236]	@ (800340c <HAL_RCC_OscConfig+0x790>)
 800331e:	f7fd fbd9 	bl	8000ad4 <assert_failed>
 8003322:	e7af      	b.n	8003284 <HAL_RCC_OscConfig+0x608>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8003324:	4b38      	ldr	r3, [pc, #224]	@ (8003408 <HAL_RCC_OscConfig+0x78c>)
 8003326:	6a99      	ldr	r1, [r3, #40]	@ 0x28
 8003328:	4a39      	ldr	r2, [pc, #228]	@ (8003410 <HAL_RCC_OscConfig+0x794>)
 800332a:	400a      	ands	r2, r1
 800332c:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 800332e:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 8003330:	ea41 1100 	orr.w	r1, r1, r0, lsl #4
 8003334:	430a      	orrs	r2, r1
 8003336:	629a      	str	r2, [r3, #40]	@ 0x28
 8003338:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 800333a:	3a01      	subs	r2, #1
 800333c:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8003340:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 8003342:	3901      	subs	r1, #1
 8003344:	0249      	lsls	r1, r1, #9
 8003346:	b289      	uxth	r1, r1
 8003348:	430a      	orrs	r2, r1
 800334a:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 800334c:	3901      	subs	r1, #1
 800334e:	0409      	lsls	r1, r1, #16
 8003350:	f401 01fe 	and.w	r1, r1, #8323072	@ 0x7f0000
 8003354:	430a      	orrs	r2, r1
 8003356:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
 8003358:	3901      	subs	r1, #1
 800335a:	0609      	lsls	r1, r1, #24
 800335c:	f001 41fe 	and.w	r1, r1, #2130706432	@ 0x7f000000
 8003360:	430a      	orrs	r2, r1
 8003362:	631a      	str	r2, [r3, #48]	@ 0x30
        __HAL_RCC_PLLFRACN_DISABLE();
 8003364:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8003366:	f022 0201 	bic.w	r2, r2, #1
 800336a:	62da      	str	r2, [r3, #44]	@ 0x2c
        __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
 800336c:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 800336e:	f36f 02cf 	bfc	r2, #3, #13
 8003372:	6ca1      	ldr	r1, [r4, #72]	@ 0x48
 8003374:	ea42 02c1 	orr.w	r2, r2, r1, lsl #3
 8003378:	635a      	str	r2, [r3, #52]	@ 0x34
        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;
 800337a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800337c:	f022 020c 	bic.w	r2, r2, #12
 8003380:	6c21      	ldr	r1, [r4, #64]	@ 0x40
 8003382:	430a      	orrs	r2, r1
 8003384:	62da      	str	r2, [r3, #44]	@ 0x2c
        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;
 8003386:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8003388:	f022 0202 	bic.w	r2, r2, #2
 800338c:	6c61      	ldr	r1, [r4, #68]	@ 0x44
 800338e:	430a      	orrs	r2, r1
 8003390:	62da      	str	r2, [r3, #44]	@ 0x2c
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 8003392:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8003394:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 8003398:	62da      	str	r2, [r3, #44]	@ 0x2c
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800339a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800339c:	f442 3200 	orr.w	r2, r2, #131072	@ 0x20000
 80033a0:	62da      	str	r2, [r3, #44]	@ 0x2c
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
 80033a2:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 80033a4:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 80033a8:	62da      	str	r2, [r3, #44]	@ 0x2c
        __HAL_RCC_PLLFRACN_ENABLE();
 80033aa:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 80033ac:	f042 0201 	orr.w	r2, r2, #1
 80033b0:	62da      	str	r2, [r3, #44]	@ 0x2c
        __HAL_RCC_PLL_ENABLE();
 80033b2:	681a      	ldr	r2, [r3, #0]
 80033b4:	f042 7280 	orr.w	r2, r2, #16777216	@ 0x1000000
 80033b8:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80033ba:	f7fe f81d 	bl	80013f8 <HAL_GetTick>
 80033be:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 80033c0:	4b11      	ldr	r3, [pc, #68]	@ (8003408 <HAL_RCC_OscConfig+0x78c>)
 80033c2:	681b      	ldr	r3, [r3, #0]
 80033c4:	f013 7f00 	tst.w	r3, #33554432	@ 0x2000000
 80033c8:	d106      	bne.n	80033d8 <HAL_RCC_OscConfig+0x75c>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80033ca:	f7fe f815 	bl	80013f8 <HAL_GetTick>
 80033ce:	1b00      	subs	r0, r0, r4
 80033d0:	2802      	cmp	r0, #2
 80033d2:	d9f5      	bls.n	80033c0 <HAL_RCC_OscConfig+0x744>
            return HAL_TIMEOUT;
 80033d4:	2003      	movs	r0, #3
 80033d6:	e536      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
  return HAL_OK;
 80033d8:	2000      	movs	r0, #0
 80033da:	e534      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
        __HAL_RCC_PLL_DISABLE();
 80033dc:	4a0a      	ldr	r2, [pc, #40]	@ (8003408 <HAL_RCC_OscConfig+0x78c>)
 80033de:	6813      	ldr	r3, [r2, #0]
 80033e0:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 80033e4:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 80033e6:	f7fe f807 	bl	80013f8 <HAL_GetTick>
 80033ea:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 80033ec:	4b06      	ldr	r3, [pc, #24]	@ (8003408 <HAL_RCC_OscConfig+0x78c>)
 80033ee:	681b      	ldr	r3, [r3, #0]
 80033f0:	f013 7f00 	tst.w	r3, #33554432	@ 0x2000000
 80033f4:	d006      	beq.n	8003404 <HAL_RCC_OscConfig+0x788>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80033f6:	f7fd ffff 	bl	80013f8 <HAL_GetTick>
 80033fa:	1b00      	subs	r0, r0, r4
 80033fc:	2802      	cmp	r0, #2
 80033fe:	d9f5      	bls.n	80033ec <HAL_RCC_OscConfig+0x770>
            return HAL_TIMEOUT;
 8003400:	2003      	movs	r0, #3
 8003402:	e520      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
  return HAL_OK;
 8003404:	2000      	movs	r0, #0
 8003406:	e51e      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
 8003408:	58024400 	.word	0x58024400
 800340c:	08015540 	.word	0x08015540
 8003410:	fffffc0c 	.word	0xfffffc0c
      temp1_pllckcfg = RCC->PLLCKSELR;
 8003414:	4a35      	ldr	r2, [pc, #212]	@ (80034ec <HAL_RCC_OscConfig+0x870>)
 8003416:	6a91      	ldr	r1, [r2, #40]	@ 0x28
      temp2_pllckcfg = RCC->PLL1DIVR;
 8003418:	6b10      	ldr	r0, [r2, #48]	@ 0x30
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800341a:	2b01      	cmp	r3, #1
 800341c:	d055      	beq.n	80034ca <HAL_RCC_OscConfig+0x84e>
          (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800341e:	f001 0303 	and.w	r3, r1, #3
 8003422:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8003424:	4293      	cmp	r3, r2
 8003426:	d152      	bne.n	80034ce <HAL_RCC_OscConfig+0x852>
          ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
 8003428:	f3c1 1105 	ubfx	r1, r1, #4, #6
 800342c:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
          (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800342e:	4299      	cmp	r1, r3
 8003430:	d14f      	bne.n	80034d2 <HAL_RCC_OscConfig+0x856>
          (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
 8003432:	f3c0 0208 	ubfx	r2, r0, #0, #9
 8003436:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 8003438:	3b01      	subs	r3, #1
          ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
 800343a:	429a      	cmp	r2, r3
 800343c:	d14b      	bne.n	80034d6 <HAL_RCC_OscConfig+0x85a>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
 800343e:	f3c0 2246 	ubfx	r2, r0, #9, #7
 8003442:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 8003444:	3b01      	subs	r3, #1
          (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
 8003446:	429a      	cmp	r2, r3
 8003448:	d147      	bne.n	80034da <HAL_RCC_OscConfig+0x85e>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 800344a:	f3c0 4206 	ubfx	r2, r0, #16, #7
 800344e:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8003450:	3b01      	subs	r3, #1
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
 8003452:	429a      	cmp	r2, r3
 8003454:	d143      	bne.n	80034de <HAL_RCC_OscConfig+0x862>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
 8003456:	f3c0 6006 	ubfx	r0, r0, #24, #7
 800345a:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 800345c:	3b01      	subs	r3, #1
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 800345e:	4298      	cmp	r0, r3
 8003460:	d13f      	bne.n	80034e2 <HAL_RCC_OscConfig+0x866>
        temp1_pllckcfg = ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> RCC_PLL1FRACR_FRACN1_Pos);
 8003462:	4b22      	ldr	r3, [pc, #136]	@ (80034ec <HAL_RCC_OscConfig+0x870>)
 8003464:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8003466:	f3c3 03cc 	ubfx	r3, r3, #3, #13
        if (RCC_OscInitStruct->PLL.PLLFRACN != temp1_pllckcfg)
 800346a:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
 800346c:	429a      	cmp	r2, r3
 800346e:	d03a      	beq.n	80034e6 <HAL_RCC_OscConfig+0x86a>
          assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));
 8003470:	f5b2 5f00 	cmp.w	r2, #8192	@ 0x2000
 8003474:	d219      	bcs.n	80034aa <HAL_RCC_OscConfig+0x82e>
          __HAL_RCC_PLLFRACN_DISABLE();
 8003476:	4a1d      	ldr	r2, [pc, #116]	@ (80034ec <HAL_RCC_OscConfig+0x870>)
 8003478:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 800347a:	f023 0301 	bic.w	r3, r3, #1
 800347e:	62d3      	str	r3, [r2, #44]	@ 0x2c
          tickstart = HAL_GetTick();
 8003480:	f7fd ffba 	bl	80013f8 <HAL_GetTick>
 8003484:	4605      	mov	r5, r0
          while ((HAL_GetTick() - tickstart) < PLL_FRAC_TIMEOUT_VALUE)
 8003486:	f7fd ffb7 	bl	80013f8 <HAL_GetTick>
 800348a:	42a8      	cmp	r0, r5
 800348c:	d0fb      	beq.n	8003486 <HAL_RCC_OscConfig+0x80a>
          __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
 800348e:	4a17      	ldr	r2, [pc, #92]	@ (80034ec <HAL_RCC_OscConfig+0x870>)
 8003490:	6b53      	ldr	r3, [r2, #52]	@ 0x34
 8003492:	f36f 03cf 	bfc	r3, #3, #13
 8003496:	6ca1      	ldr	r1, [r4, #72]	@ 0x48
 8003498:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 800349c:	6353      	str	r3, [r2, #52]	@ 0x34
          __HAL_RCC_PLLFRACN_ENABLE();
 800349e:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 80034a0:	f043 0301 	orr.w	r3, r3, #1
 80034a4:	62d3      	str	r3, [r2, #44]	@ 0x2c
  return HAL_OK;
 80034a6:	2000      	movs	r0, #0
 80034a8:	e4cd      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
          assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));
 80034aa:	f44f 715b 	mov.w	r1, #876	@ 0x36c
 80034ae:	4810      	ldr	r0, [pc, #64]	@ (80034f0 <HAL_RCC_OscConfig+0x874>)
 80034b0:	f7fd fb10 	bl	8000ad4 <assert_failed>
 80034b4:	e7df      	b.n	8003476 <HAL_RCC_OscConfig+0x7fa>
    return HAL_ERROR;
 80034b6:	2001      	movs	r0, #1
}
 80034b8:	4770      	bx	lr
        return HAL_ERROR;
 80034ba:	2001      	movs	r0, #1
 80034bc:	e4c3      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
        return HAL_ERROR;
 80034be:	2001      	movs	r0, #1
 80034c0:	e4c1      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
        return HAL_ERROR;
 80034c2:	2001      	movs	r0, #1
 80034c4:	e4bf      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
  return HAL_OK;
 80034c6:	2000      	movs	r0, #0
 80034c8:	e4bd      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
        return HAL_ERROR;
 80034ca:	2001      	movs	r0, #1
 80034cc:	e4bb      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
 80034ce:	2001      	movs	r0, #1
 80034d0:	e4b9      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
 80034d2:	2001      	movs	r0, #1
 80034d4:	e4b7      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
 80034d6:	2001      	movs	r0, #1
 80034d8:	e4b5      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
 80034da:	2001      	movs	r0, #1
 80034dc:	e4b3      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
 80034de:	2001      	movs	r0, #1
 80034e0:	e4b1      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
 80034e2:	2001      	movs	r0, #1
 80034e4:	e4af      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
  return HAL_OK;
 80034e6:	2000      	movs	r0, #0
 80034e8:	e4ad      	b.n	8002e46 <HAL_RCC_OscConfig+0x1ca>
 80034ea:	bf00      	nop
 80034ec:	58024400 	.word	0x58024400
 80034f0:	08015540 	.word	0x08015540

080034f4 <HAL_RCC_MCOConfig>:
  *          This parameter can be one of the following values:
  *            @arg RCC_MCODIV_1 up to RCC_MCODIV_15  : divider applied to MCOx clock
  * @retval None
  */
void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 80034f4:	b570      	push	{r4, r5, r6, lr}
 80034f6:	b088      	sub	sp, #32
 80034f8:	4606      	mov	r6, r0
 80034fa:	460d      	mov	r5, r1
 80034fc:	4614      	mov	r4, r2
  GPIO_InitTypeDef GPIO_InitStruct;
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCOx));
 80034fe:	2801      	cmp	r0, #1
 8003500:	d86d      	bhi.n	80035de <HAL_RCC_MCOConfig+0xea>
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
 8003502:	f5b4 2f80 	cmp.w	r4, #262144	@ 0x40000
 8003506:	bf18      	it	ne
 8003508:	f5b4 2f00 	cmpne.w	r4, #524288	@ 0x80000
 800350c:	d032      	beq.n	8003574 <HAL_RCC_MCOConfig+0x80>
 800350e:	f5b4 1380 	subs.w	r3, r4, #1048576	@ 0x100000
 8003512:	bf18      	it	ne
 8003514:	2301      	movne	r3, #1
 8003516:	f5b4 2f40 	cmp.w	r4, #786432	@ 0xc0000
 800351a:	d02b      	beq.n	8003574 <HAL_RCC_MCOConfig+0x80>
 800351c:	b353      	cbz	r3, 8003574 <HAL_RCC_MCOConfig+0x80>
 800351e:	f5b4 13c0 	subs.w	r3, r4, #1572864	@ 0x180000
 8003522:	bf18      	it	ne
 8003524:	2301      	movne	r3, #1
 8003526:	f5b4 1fa0 	cmp.w	r4, #1310720	@ 0x140000
 800352a:	d023      	beq.n	8003574 <HAL_RCC_MCOConfig+0x80>
 800352c:	b313      	cbz	r3, 8003574 <HAL_RCC_MCOConfig+0x80>
 800352e:	f5b4 1300 	subs.w	r3, r4, #2097152	@ 0x200000
 8003532:	bf18      	it	ne
 8003534:	2301      	movne	r3, #1
 8003536:	f5b4 1fe0 	cmp.w	r4, #1835008	@ 0x1c0000
 800353a:	d01b      	beq.n	8003574 <HAL_RCC_MCOConfig+0x80>
 800353c:	b1d3      	cbz	r3, 8003574 <HAL_RCC_MCOConfig+0x80>
 800353e:	f5b4 1320 	subs.w	r3, r4, #2621440	@ 0x280000
 8003542:	bf18      	it	ne
 8003544:	2301      	movne	r3, #1
 8003546:	f5b4 1f10 	cmp.w	r4, #2359296	@ 0x240000
 800354a:	d013      	beq.n	8003574 <HAL_RCC_MCOConfig+0x80>
 800354c:	b193      	cbz	r3, 8003574 <HAL_RCC_MCOConfig+0x80>
 800354e:	f5b4 1340 	subs.w	r3, r4, #3145728	@ 0x300000
 8003552:	bf18      	it	ne
 8003554:	2301      	movne	r3, #1
 8003556:	f5b4 1f30 	cmp.w	r4, #2883584	@ 0x2c0000
 800355a:	d00b      	beq.n	8003574 <HAL_RCC_MCOConfig+0x80>
 800355c:	b153      	cbz	r3, 8003574 <HAL_RCC_MCOConfig+0x80>
 800355e:	f5b4 1360 	subs.w	r3, r4, #3670016	@ 0x380000
 8003562:	bf18      	it	ne
 8003564:	2301      	movne	r3, #1
 8003566:	f5b4 1f50 	cmp.w	r4, #3407872	@ 0x340000
 800356a:	d003      	beq.n	8003574 <HAL_RCC_MCOConfig+0x80>
 800356c:	b113      	cbz	r3, 8003574 <HAL_RCC_MCOConfig+0x80>
 800356e:	f5b4 1f70 	cmp.w	r4, #3932160	@ 0x3c0000
 8003572:	d13a      	bne.n	80035ea <HAL_RCC_MCOConfig+0xf6>
  /* RCC_MCO1 */
  if (RCC_MCOx == RCC_MCO1)
 8003574:	2e00      	cmp	r6, #0
 8003576:	d144      	bne.n	8003602 <HAL_RCC_MCOConfig+0x10e>
  {
    assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
 8003578:	2d00      	cmp	r5, #0
 800357a:	bf18      	it	ne
 800357c:	f5b5 0f80 	cmpne.w	r5, #4194304	@ 0x400000
 8003580:	d00a      	beq.n	8003598 <HAL_RCC_MCOConfig+0xa4>
 8003582:	f5b5 0340 	subs.w	r3, r5, #12582912	@ 0xc00000
 8003586:	bf18      	it	ne
 8003588:	2301      	movne	r3, #1
 800358a:	f5b5 0f00 	cmp.w	r5, #8388608	@ 0x800000
 800358e:	d003      	beq.n	8003598 <HAL_RCC_MCOConfig+0xa4>
 8003590:	b113      	cbz	r3, 8003598 <HAL_RCC_MCOConfig+0xa4>
 8003592:	f1b5 7f80 	cmp.w	r5, #16777216	@ 0x1000000
 8003596:	d12e      	bne.n	80035f6 <HAL_RCC_MCOConfig+0x102>

    /* MCO1 Clock Enable */
    MCO1_CLK_ENABLE();
 8003598:	4e39      	ldr	r6, [pc, #228]	@ (8003680 <HAL_RCC_MCOConfig+0x18c>)
 800359a:	f8d6 30e0 	ldr.w	r3, [r6, #224]	@ 0xe0
 800359e:	f043 0301 	orr.w	r3, r3, #1
 80035a2:	f8c6 30e0 	str.w	r3, [r6, #224]	@ 0xe0
 80035a6:	f8d6 30e0 	ldr.w	r3, [r6, #224]	@ 0xe0
 80035aa:	f003 0301 	and.w	r3, r3, #1
 80035ae:	9301      	str	r3, [sp, #4]
 80035b0:	9b01      	ldr	r3, [sp, #4]

    /* Configure the MCO1 pin in alternate function mode */
    GPIO_InitStruct.Pin = MCO1_PIN;
 80035b2:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80035b6:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80035b8:	2302      	movs	r3, #2
 80035ba:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80035bc:	2303      	movs	r3, #3
 80035be:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80035c0:	2300      	movs	r3, #0
 80035c2:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 80035c4:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
 80035c6:	a903      	add	r1, sp, #12
 80035c8:	482e      	ldr	r0, [pc, #184]	@ (8003684 <HAL_RCC_MCOConfig+0x190>)
 80035ca:	f7ff f93b 	bl	8002844 <HAL_GPIO_Init>

    /* Mask MCO1 and MCO1PRE[3:0] bits then Select MCO1 clock source and pre-scaler */
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
 80035ce:	6933      	ldr	r3, [r6, #16]
 80035d0:	f023 73fe 	bic.w	r3, r3, #33292288	@ 0x1fc0000
 80035d4:	432c      	orrs	r4, r5
 80035d6:	431c      	orrs	r4, r3
 80035d8:	6134      	str	r4, [r6, #16]
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);

    /* Mask MCO2 and MCO2PRE[3:0] bits then Select MCO2 clock source and pre-scaler */
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 7U)));
  }
}
 80035da:	b008      	add	sp, #32
 80035dc:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_RCC_MCO(RCC_MCOx));
 80035de:	f240 510a 	movw	r1, #1290	@ 0x50a
 80035e2:	4829      	ldr	r0, [pc, #164]	@ (8003688 <HAL_RCC_MCOConfig+0x194>)
 80035e4:	f7fd fa76 	bl	8000ad4 <assert_failed>
 80035e8:	e78b      	b.n	8003502 <HAL_RCC_MCOConfig+0xe>
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
 80035ea:	f240 510b 	movw	r1, #1291	@ 0x50b
 80035ee:	4826      	ldr	r0, [pc, #152]	@ (8003688 <HAL_RCC_MCOConfig+0x194>)
 80035f0:	f7fd fa70 	bl	8000ad4 <assert_failed>
 80035f4:	e7be      	b.n	8003574 <HAL_RCC_MCOConfig+0x80>
    assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
 80035f6:	f240 510f 	movw	r1, #1295	@ 0x50f
 80035fa:	4823      	ldr	r0, [pc, #140]	@ (8003688 <HAL_RCC_MCOConfig+0x194>)
 80035fc:	f7fd fa6a 	bl	8000ad4 <assert_failed>
 8003600:	e7ca      	b.n	8003598 <HAL_RCC_MCOConfig+0xa4>
    assert_param(IS_RCC_MCO2SOURCE(RCC_MCOSource));
 8003602:	2d00      	cmp	r5, #0
 8003604:	bf18      	it	ne
 8003606:	f1b5 5f00 	cmpne.w	r5, #536870912	@ 0x20000000
 800360a:	d00f      	beq.n	800362c <HAL_RCC_MCOConfig+0x138>
 800360c:	f1b5 43c0 	subs.w	r3, r5, #1610612736	@ 0x60000000
 8003610:	bf18      	it	ne
 8003612:	2301      	movne	r3, #1
 8003614:	f1b5 4f80 	cmp.w	r5, #1073741824	@ 0x40000000
 8003618:	d008      	beq.n	800362c <HAL_RCC_MCOConfig+0x138>
 800361a:	b13b      	cbz	r3, 800362c <HAL_RCC_MCOConfig+0x138>
 800361c:	f1b5 4320 	subs.w	r3, r5, #2684354560	@ 0xa0000000
 8003620:	bf18      	it	ne
 8003622:	2301      	movne	r3, #1
 8003624:	f1b5 4f00 	cmp.w	r5, #2147483648	@ 0x80000000
 8003628:	d000      	beq.n	800362c <HAL_RCC_MCOConfig+0x138>
 800362a:	bb13      	cbnz	r3, 8003672 <HAL_RCC_MCOConfig+0x17e>
    MCO2_CLK_ENABLE();
 800362c:	4e14      	ldr	r6, [pc, #80]	@ (8003680 <HAL_RCC_MCOConfig+0x18c>)
 800362e:	f8d6 30e0 	ldr.w	r3, [r6, #224]	@ 0xe0
 8003632:	f043 0304 	orr.w	r3, r3, #4
 8003636:	f8c6 30e0 	str.w	r3, [r6, #224]	@ 0xe0
 800363a:	f8d6 30e0 	ldr.w	r3, [r6, #224]	@ 0xe0
 800363e:	f003 0304 	and.w	r3, r3, #4
 8003642:	9302      	str	r3, [sp, #8]
 8003644:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = MCO2_PIN;
 8003646:	f44f 7300 	mov.w	r3, #512	@ 0x200
 800364a:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800364c:	2302      	movs	r3, #2
 800364e:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8003650:	2303      	movs	r3, #3
 8003652:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8003654:	2300      	movs	r3, #0
 8003656:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 8003658:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
 800365a:	a903      	add	r1, sp, #12
 800365c:	480b      	ldr	r0, [pc, #44]	@ (800368c <HAL_RCC_MCOConfig+0x198>)
 800365e:	f7ff f8f1 	bl	8002844 <HAL_GPIO_Init>
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 7U)));
 8003662:	6933      	ldr	r3, [r6, #16]
 8003664:	f023 437e 	bic.w	r3, r3, #4261412864	@ 0xfe000000
 8003668:	ea45 15c4 	orr.w	r5, r5, r4, lsl #7
 800366c:	432b      	orrs	r3, r5
 800366e:	6133      	str	r3, [r6, #16]
}
 8003670:	e7b3      	b.n	80035da <HAL_RCC_MCOConfig+0xe6>
    assert_param(IS_RCC_MCO2SOURCE(RCC_MCOSource));
 8003672:	f240 5121 	movw	r1, #1313	@ 0x521
 8003676:	4804      	ldr	r0, [pc, #16]	@ (8003688 <HAL_RCC_MCOConfig+0x194>)
 8003678:	f7fd fa2c 	bl	8000ad4 <assert_failed>
 800367c:	e7d6      	b.n	800362c <HAL_RCC_MCOConfig+0x138>
 800367e:	bf00      	nop
 8003680:	58024400 	.word	0x58024400
 8003684:	58020000 	.word	0x58020000
 8003688:	08015540 	.word	0x08015540
 800368c:	58020800 	.word	0x58020800

08003690 <HAL_RCC_GetSysClockFreq>:
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
 8003690:	4b75      	ldr	r3, [pc, #468]	@ (8003868 <HAL_RCC_GetSysClockFreq+0x1d8>)
 8003692:	691b      	ldr	r3, [r3, #16]
 8003694:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 8003698:	2b10      	cmp	r3, #16
 800369a:	f000 80de 	beq.w	800385a <HAL_RCC_GetSysClockFreq+0x1ca>
 800369e:	2b18      	cmp	r3, #24
 80036a0:	d00f      	beq.n	80036c2 <HAL_RCC_GetSysClockFreq+0x32>
 80036a2:	2b00      	cmp	r3, #0
 80036a4:	f040 80db 	bne.w	800385e <HAL_RCC_GetSysClockFreq+0x1ce>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 80036a8:	4b6f      	ldr	r3, [pc, #444]	@ (8003868 <HAL_RCC_GetSysClockFreq+0x1d8>)
 80036aa:	681b      	ldr	r3, [r3, #0]
 80036ac:	f013 0f20 	tst.w	r3, #32
 80036b0:	f000 80d7 	beq.w	8003862 <HAL_RCC_GetSysClockFreq+0x1d2>
      {
        sysclockfreq = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 80036b4:	4b6c      	ldr	r3, [pc, #432]	@ (8003868 <HAL_RCC_GetSysClockFreq+0x1d8>)
 80036b6:	681b      	ldr	r3, [r3, #0]
 80036b8:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 80036bc:	486b      	ldr	r0, [pc, #428]	@ (800386c <HAL_RCC_GetSysClockFreq+0x1dc>)
 80036be:	40d8      	lsrs	r0, r3
 80036c0:	4770      	bx	lr
{
 80036c2:	b410      	push	{r4}
    case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLR
      */
      pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 80036c4:	4b68      	ldr	r3, [pc, #416]	@ (8003868 <HAL_RCC_GetSysClockFreq+0x1d8>)
 80036c6:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 80036c8:	f002 0203 	and.w	r2, r2, #3
      pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> 4)  ;
 80036cc:	6a9c      	ldr	r4, [r3, #40]	@ 0x28
 80036ce:	f3c4 1005 	ubfx	r0, r4, #4, #6
      pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN) >> RCC_PLLCFGR_PLL1FRACEN_Pos);
 80036d2:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 80036d4:	f001 0101 	and.w	r1, r1, #1
      fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));
 80036d8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80036da:	f3c3 03cc 	ubfx	r3, r3, #3, #13
 80036de:	fb01 f303 	mul.w	r3, r1, r3
 80036e2:	ee07 3a90 	vmov	s15, r3
 80036e6:	eef8 7a67 	vcvt.f32.u32	s15, s15

      if (pllm != 0U)
 80036ea:	f414 7f7c 	tst.w	r4, #1008	@ 0x3f0
 80036ee:	d077      	beq.n	80037e0 <HAL_RCC_GetSysClockFreq+0x150>
      {
        switch (pllsource)
 80036f0:	2a01      	cmp	r2, #1
 80036f2:	d04a      	beq.n	800378a <HAL_RCC_GetSysClockFreq+0xfa>
 80036f4:	2a02      	cmp	r2, #2
 80036f6:	d076      	beq.n	80037e6 <HAL_RCC_GetSysClockFreq+0x156>
 80036f8:	2a00      	cmp	r2, #0
 80036fa:	f040 8091 	bne.w	8003820 <HAL_RCC_GetSysClockFreq+0x190>
        {
          case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

            if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 80036fe:	4b5a      	ldr	r3, [pc, #360]	@ (8003868 <HAL_RCC_GetSysClockFreq+0x1d8>)
 8003700:	681b      	ldr	r3, [r3, #0]
 8003702:	f013 0f20 	tst.w	r3, #32
 8003706:	d023      	beq.n	8003750 <HAL_RCC_GetSysClockFreq+0xc0>
            {
              hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8003708:	4957      	ldr	r1, [pc, #348]	@ (8003868 <HAL_RCC_GetSysClockFreq+0x1d8>)
 800370a:	680a      	ldr	r2, [r1, #0]
 800370c:	f3c2 02c1 	ubfx	r2, r2, #3, #2
 8003710:	4b56      	ldr	r3, [pc, #344]	@ (800386c <HAL_RCC_GetSysClockFreq+0x1dc>)
 8003712:	40d3      	lsrs	r3, r2
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8003714:	ee07 3a10 	vmov	s14, r3
 8003718:	eef8 6a47 	vcvt.f32.u32	s13, s14
 800371c:	ee07 0a10 	vmov	s14, r0
 8003720:	eeb8 6a47 	vcvt.f32.u32	s12, s14
 8003724:	ee86 7a86 	vdiv.f32	s14, s13, s12
 8003728:	6b0b      	ldr	r3, [r1, #48]	@ 0x30
 800372a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800372e:	ee06 3a90 	vmov	s13, r3
 8003732:	eef8 6a66 	vcvt.f32.u32	s13, s13
 8003736:	ed9f 6a4e 	vldr	s12, [pc, #312]	@ 8003870 <HAL_RCC_GetSysClockFreq+0x1e0>
 800373a:	ee67 7a86 	vmul.f32	s15, s15, s12
 800373e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8003742:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8003746:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800374a:	ee27 7a27 	vmul.f32	s14, s14, s15
 800374e:	e038      	b.n	80037c2 <HAL_RCC_GetSysClockFreq+0x132>
            }
            else
            {
              pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8003750:	ee07 0a10 	vmov	s14, r0
 8003754:	eef8 6a47 	vcvt.f32.u32	s13, s14
 8003758:	ed9f 6a46 	vldr	s12, [pc, #280]	@ 8003874 <HAL_RCC_GetSysClockFreq+0x1e4>
 800375c:	ee86 7a26 	vdiv.f32	s14, s12, s13
 8003760:	4b41      	ldr	r3, [pc, #260]	@ (8003868 <HAL_RCC_GetSysClockFreq+0x1d8>)
 8003762:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8003764:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8003768:	ee06 3a90 	vmov	s13, r3
 800376c:	eef8 6a66 	vcvt.f32.u32	s13, s13
 8003770:	ed9f 6a3f 	vldr	s12, [pc, #252]	@ 8003870 <HAL_RCC_GetSysClockFreq+0x1e0>
 8003774:	ee67 7a86 	vmul.f32	s15, s15, s12
 8003778:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800377c:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8003780:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8003784:	ee27 7a27 	vmul.f32	s14, s14, s15
 8003788:	e01b      	b.n	80037c2 <HAL_RCC_GetSysClockFreq+0x132>
            }
            break;

          case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800378a:	ee07 0a10 	vmov	s14, r0
 800378e:	eef8 6a47 	vcvt.f32.u32	s13, s14
 8003792:	ed9f 6a39 	vldr	s12, [pc, #228]	@ 8003878 <HAL_RCC_GetSysClockFreq+0x1e8>
 8003796:	ee86 7a26 	vdiv.f32	s14, s12, s13
 800379a:	4b33      	ldr	r3, [pc, #204]	@ (8003868 <HAL_RCC_GetSysClockFreq+0x1d8>)
 800379c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800379e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80037a2:	ee06 3a90 	vmov	s13, r3
 80037a6:	eef8 6a66 	vcvt.f32.u32	s13, s13
 80037aa:	ed9f 6a31 	vldr	s12, [pc, #196]	@ 8003870 <HAL_RCC_GetSysClockFreq+0x1e0>
 80037ae:	ee67 7a86 	vmul.f32	s15, s15, s12
 80037b2:	ee76 7aa7 	vadd.f32	s15, s13, s15
 80037b6:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 80037ba:	ee77 7aa6 	vadd.f32	s15, s15, s13
 80037be:	ee27 7a27 	vmul.f32	s14, s14, s15

          default:
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
            break;
        }
        pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> 9) + 1U) ;
 80037c2:	4b29      	ldr	r3, [pc, #164]	@ (8003868 <HAL_RCC_GetSysClockFreq+0x1d8>)
 80037c4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80037c6:	f3c3 2346 	ubfx	r3, r3, #9, #7
 80037ca:	3301      	adds	r3, #1
        sysclockfreq = (uint32_t)(float_t)(pllvco / (float_t)pllp);
 80037cc:	ee07 3a90 	vmov	s15, r3
 80037d0:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80037d4:	eec7 6a27 	vdiv.f32	s13, s14, s15
 80037d8:	eefc 7ae6 	vcvt.u32.f32	s15, s13
 80037dc:	ee17 0a90 	vmov	r0, s15
      sysclockfreq = CSI_VALUE;
      break;
  }

  return sysclockfreq;
}
 80037e0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80037e4:	4770      	bx	lr
            pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 80037e6:	ee07 0a10 	vmov	s14, r0
 80037ea:	eef8 6a47 	vcvt.f32.u32	s13, s14
 80037ee:	ed9f 6a23 	vldr	s12, [pc, #140]	@ 800387c <HAL_RCC_GetSysClockFreq+0x1ec>
 80037f2:	ee86 7a26 	vdiv.f32	s14, s12, s13
 80037f6:	4b1c      	ldr	r3, [pc, #112]	@ (8003868 <HAL_RCC_GetSysClockFreq+0x1d8>)
 80037f8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80037fa:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80037fe:	ee06 3a90 	vmov	s13, r3
 8003802:	eef8 6a66 	vcvt.f32.u32	s13, s13
 8003806:	ed9f 6a1a 	vldr	s12, [pc, #104]	@ 8003870 <HAL_RCC_GetSysClockFreq+0x1e0>
 800380a:	ee67 7a86 	vmul.f32	s15, s15, s12
 800380e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8003812:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8003816:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800381a:	ee27 7a27 	vmul.f32	s14, s14, s15
            break;
 800381e:	e7d0      	b.n	80037c2 <HAL_RCC_GetSysClockFreq+0x132>
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8003820:	ee07 0a10 	vmov	s14, r0
 8003824:	eef8 6a47 	vcvt.f32.u32	s13, s14
 8003828:	ed9f 6a13 	vldr	s12, [pc, #76]	@ 8003878 <HAL_RCC_GetSysClockFreq+0x1e8>
 800382c:	ee86 7a26 	vdiv.f32	s14, s12, s13
 8003830:	4b0d      	ldr	r3, [pc, #52]	@ (8003868 <HAL_RCC_GetSysClockFreq+0x1d8>)
 8003832:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8003834:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8003838:	ee06 3a90 	vmov	s13, r3
 800383c:	eef8 6a66 	vcvt.f32.u32	s13, s13
 8003840:	ed9f 6a0b 	vldr	s12, [pc, #44]	@ 8003870 <HAL_RCC_GetSysClockFreq+0x1e0>
 8003844:	ee67 7a86 	vmul.f32	s15, s15, s12
 8003848:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800384c:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8003850:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8003854:	ee27 7a27 	vmul.f32	s14, s14, s15
            break;
 8003858:	e7b3      	b.n	80037c2 <HAL_RCC_GetSysClockFreq+0x132>
      sysclockfreq = HSE_VALUE;
 800385a:	4809      	ldr	r0, [pc, #36]	@ (8003880 <HAL_RCC_GetSysClockFreq+0x1f0>)
 800385c:	4770      	bx	lr
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800385e:	4809      	ldr	r0, [pc, #36]	@ (8003884 <HAL_RCC_GetSysClockFreq+0x1f4>)
 8003860:	4770      	bx	lr
        sysclockfreq = (uint32_t) HSI_VALUE;
 8003862:	4802      	ldr	r0, [pc, #8]	@ (800386c <HAL_RCC_GetSysClockFreq+0x1dc>)
}
 8003864:	4770      	bx	lr
 8003866:	bf00      	nop
 8003868:	58024400 	.word	0x58024400
 800386c:	03d09000 	.word	0x03d09000
 8003870:	39000000 	.word	0x39000000
 8003874:	4c742400 	.word	0x4c742400
 8003878:	4a742400 	.word	0x4a742400
 800387c:	4b989680 	.word	0x4b989680
 8003880:	01312d00 	.word	0x01312d00
 8003884:	003d0900 	.word	0x003d0900

08003888 <HAL_RCC_ClockConfig>:
  if (RCC_ClkInitStruct == NULL)
 8003888:	2800      	cmp	r0, #0
 800388a:	f000 822a 	beq.w	8003ce2 <HAL_RCC_ClockConfig+0x45a>
{
 800388e:	b570      	push	{r4, r5, r6, lr}
 8003890:	460d      	mov	r5, r1
 8003892:	4604      	mov	r4, r0
  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
 8003894:	6803      	ldr	r3, [r0, #0]
 8003896:	3b01      	subs	r3, #1
 8003898:	2b3e      	cmp	r3, #62	@ 0x3e
 800389a:	f200 80dd 	bhi.w	8003a58 <HAL_RCC_ClockConfig+0x1d0>
  assert_param(IS_FLASH_LATENCY(FLatency));
 800389e:	2d0f      	cmp	r5, #15
 80038a0:	f200 80e0 	bhi.w	8003a64 <HAL_RCC_ClockConfig+0x1dc>
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 80038a4:	4b9e      	ldr	r3, [pc, #632]	@ (8003b20 <HAL_RCC_ClockConfig+0x298>)
 80038a6:	681b      	ldr	r3, [r3, #0]
 80038a8:	f003 030f 	and.w	r3, r3, #15
 80038ac:	42ab      	cmp	r3, r5
 80038ae:	d20b      	bcs.n	80038c8 <HAL_RCC_ClockConfig+0x40>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80038b0:	4a9b      	ldr	r2, [pc, #620]	@ (8003b20 <HAL_RCC_ClockConfig+0x298>)
 80038b2:	6813      	ldr	r3, [r2, #0]
 80038b4:	f023 030f 	bic.w	r3, r3, #15
 80038b8:	432b      	orrs	r3, r5
 80038ba:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 80038bc:	6813      	ldr	r3, [r2, #0]
 80038be:	f003 030f 	and.w	r3, r3, #15
 80038c2:	42ab      	cmp	r3, r5
 80038c4:	f040 820f 	bne.w	8003ce6 <HAL_RCC_ClockConfig+0x45e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
 80038c8:	6823      	ldr	r3, [r4, #0]
 80038ca:	f013 0f04 	tst.w	r3, #4
 80038ce:	d018      	beq.n	8003902 <HAL_RCC_ClockConfig+0x7a>
    if ((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
 80038d0:	6922      	ldr	r2, [r4, #16]
 80038d2:	4b94      	ldr	r3, [pc, #592]	@ (8003b24 <HAL_RCC_ClockConfig+0x29c>)
 80038d4:	699b      	ldr	r3, [r3, #24]
 80038d6:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 80038da:	429a      	cmp	r2, r3
 80038dc:	d911      	bls.n	8003902 <HAL_RCC_ClockConfig+0x7a>
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
 80038de:	2a00      	cmp	r2, #0
 80038e0:	bf18      	it	ne
 80038e2:	2a40      	cmpne	r2, #64	@ 0x40
 80038e4:	d006      	beq.n	80038f4 <HAL_RCC_ClockConfig+0x6c>
 80038e6:	2a50      	cmp	r2, #80	@ 0x50
 80038e8:	d004      	beq.n	80038f4 <HAL_RCC_ClockConfig+0x6c>
 80038ea:	2a60      	cmp	r2, #96	@ 0x60
 80038ec:	d002      	beq.n	80038f4 <HAL_RCC_ClockConfig+0x6c>
 80038ee:	2a70      	cmp	r2, #112	@ 0x70
 80038f0:	f040 80be 	bne.w	8003a70 <HAL_RCC_ClockConfig+0x1e8>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
 80038f4:	4a8b      	ldr	r2, [pc, #556]	@ (8003b24 <HAL_RCC_ClockConfig+0x29c>)
 80038f6:	6993      	ldr	r3, [r2, #24]
 80038f8:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 80038fc:	6921      	ldr	r1, [r4, #16]
 80038fe:	430b      	orrs	r3, r1
 8003900:	6193      	str	r3, [r2, #24]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8003902:	6823      	ldr	r3, [r4, #0]
 8003904:	f013 0f08 	tst.w	r3, #8
 8003908:	d018      	beq.n	800393c <HAL_RCC_ClockConfig+0xb4>
    if ((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
 800390a:	6962      	ldr	r2, [r4, #20]
 800390c:	4b85      	ldr	r3, [pc, #532]	@ (8003b24 <HAL_RCC_ClockConfig+0x29c>)
 800390e:	69db      	ldr	r3, [r3, #28]
 8003910:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 8003914:	429a      	cmp	r2, r3
 8003916:	d911      	bls.n	800393c <HAL_RCC_ClockConfig+0xb4>
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
 8003918:	2a00      	cmp	r2, #0
 800391a:	bf18      	it	ne
 800391c:	2a40      	cmpne	r2, #64	@ 0x40
 800391e:	d006      	beq.n	800392e <HAL_RCC_ClockConfig+0xa6>
 8003920:	2a50      	cmp	r2, #80	@ 0x50
 8003922:	d004      	beq.n	800392e <HAL_RCC_ClockConfig+0xa6>
 8003924:	2a60      	cmp	r2, #96	@ 0x60
 8003926:	d002      	beq.n	800392e <HAL_RCC_ClockConfig+0xa6>
 8003928:	2a70      	cmp	r2, #112	@ 0x70
 800392a:	f040 80a7 	bne.w	8003a7c <HAL_RCC_ClockConfig+0x1f4>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
 800392e:	4a7d      	ldr	r2, [pc, #500]	@ (8003b24 <HAL_RCC_ClockConfig+0x29c>)
 8003930:	69d3      	ldr	r3, [r2, #28]
 8003932:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8003936:	6961      	ldr	r1, [r4, #20]
 8003938:	430b      	orrs	r3, r1
 800393a:	61d3      	str	r3, [r2, #28]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800393c:	6823      	ldr	r3, [r4, #0]
 800393e:	f013 0f10 	tst.w	r3, #16
 8003942:	d01c      	beq.n	800397e <HAL_RCC_ClockConfig+0xf6>
    if ((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
 8003944:	69a2      	ldr	r2, [r4, #24]
 8003946:	4b77      	ldr	r3, [pc, #476]	@ (8003b24 <HAL_RCC_ClockConfig+0x29c>)
 8003948:	69db      	ldr	r3, [r3, #28]
 800394a:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
 800394e:	429a      	cmp	r2, r3
 8003950:	d915      	bls.n	800397e <HAL_RCC_ClockConfig+0xf6>
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
 8003952:	2a00      	cmp	r2, #0
 8003954:	bf18      	it	ne
 8003956:	f5b2 6f80 	cmpne.w	r2, #1024	@ 0x400
 800395a:	d009      	beq.n	8003970 <HAL_RCC_ClockConfig+0xe8>
 800395c:	f5b2 6fa0 	cmp.w	r2, #1280	@ 0x500
 8003960:	d006      	beq.n	8003970 <HAL_RCC_ClockConfig+0xe8>
 8003962:	f5b2 6fc0 	cmp.w	r2, #1536	@ 0x600
 8003966:	d003      	beq.n	8003970 <HAL_RCC_ClockConfig+0xe8>
 8003968:	f5b2 6fe0 	cmp.w	r2, #1792	@ 0x700
 800396c:	f040 808c 	bne.w	8003a88 <HAL_RCC_ClockConfig+0x200>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
 8003970:	4a6c      	ldr	r2, [pc, #432]	@ (8003b24 <HAL_RCC_ClockConfig+0x29c>)
 8003972:	69d3      	ldr	r3, [r2, #28]
 8003974:	f423 63e0 	bic.w	r3, r3, #1792	@ 0x700
 8003978:	69a1      	ldr	r1, [r4, #24]
 800397a:	430b      	orrs	r3, r1
 800397c:	61d3      	str	r3, [r2, #28]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
 800397e:	6823      	ldr	r3, [r4, #0]
 8003980:	f013 0f20 	tst.w	r3, #32
 8003984:	d017      	beq.n	80039b6 <HAL_RCC_ClockConfig+0x12e>
    if ((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
 8003986:	69e2      	ldr	r2, [r4, #28]
 8003988:	4b66      	ldr	r3, [pc, #408]	@ (8003b24 <HAL_RCC_ClockConfig+0x29c>)
 800398a:	6a1b      	ldr	r3, [r3, #32]
 800398c:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 8003990:	429a      	cmp	r2, r3
 8003992:	d910      	bls.n	80039b6 <HAL_RCC_ClockConfig+0x12e>
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
 8003994:	2a00      	cmp	r2, #0
 8003996:	bf18      	it	ne
 8003998:	2a40      	cmpne	r2, #64	@ 0x40
 800399a:	d005      	beq.n	80039a8 <HAL_RCC_ClockConfig+0x120>
 800399c:	2a50      	cmp	r2, #80	@ 0x50
 800399e:	d003      	beq.n	80039a8 <HAL_RCC_ClockConfig+0x120>
 80039a0:	2a60      	cmp	r2, #96	@ 0x60
 80039a2:	d001      	beq.n	80039a8 <HAL_RCC_ClockConfig+0x120>
 80039a4:	2a70      	cmp	r2, #112	@ 0x70
 80039a6:	d175      	bne.n	8003a94 <HAL_RCC_ClockConfig+0x20c>
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider));
 80039a8:	4a5e      	ldr	r2, [pc, #376]	@ (8003b24 <HAL_RCC_ClockConfig+0x29c>)
 80039aa:	6a13      	ldr	r3, [r2, #32]
 80039ac:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 80039b0:	69e1      	ldr	r1, [r4, #28]
 80039b2:	430b      	orrs	r3, r1
 80039b4:	6213      	str	r3, [r2, #32]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80039b6:	6823      	ldr	r3, [r4, #0]
 80039b8:	f013 0f02 	tst.w	r3, #2
 80039bc:	d014      	beq.n	80039e8 <HAL_RCC_ClockConfig+0x160>
    if ((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))
 80039be:	68e2      	ldr	r2, [r4, #12]
 80039c0:	4b58      	ldr	r3, [pc, #352]	@ (8003b24 <HAL_RCC_ClockConfig+0x29c>)
 80039c2:	699b      	ldr	r3, [r3, #24]
 80039c4:	f003 030f 	and.w	r3, r3, #15
 80039c8:	429a      	cmp	r2, r3
 80039ca:	d90d      	bls.n	80039e8 <HAL_RCC_ClockConfig+0x160>
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
 80039cc:	2a00      	cmp	r2, #0
 80039ce:	bf18      	it	ne
 80039d0:	2a08      	cmpne	r2, #8
 80039d2:	d002      	beq.n	80039da <HAL_RCC_ClockConfig+0x152>
 80039d4:	3a09      	subs	r2, #9
 80039d6:	2a06      	cmp	r2, #6
 80039d8:	d862      	bhi.n	8003aa0 <HAL_RCC_ClockConfig+0x218>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80039da:	4a52      	ldr	r2, [pc, #328]	@ (8003b24 <HAL_RCC_ClockConfig+0x29c>)
 80039dc:	6993      	ldr	r3, [r2, #24]
 80039de:	f023 030f 	bic.w	r3, r3, #15
 80039e2:	68e1      	ldr	r1, [r4, #12]
 80039e4:	430b      	orrs	r3, r1
 80039e6:	6193      	str	r3, [r2, #24]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80039e8:	6823      	ldr	r3, [r4, #0]
 80039ea:	f013 0f01 	tst.w	r3, #1
 80039ee:	f000 809d 	beq.w	8003b2c <HAL_RCC_ClockConfig+0x2a4>
    assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));
 80039f2:	68a3      	ldr	r3, [r4, #8]
 80039f4:	2b00      	cmp	r3, #0
 80039f6:	bf18      	it	ne
 80039f8:	f5b3 6f00 	cmpne.w	r3, #2048	@ 0x800
 80039fc:	d014      	beq.n	8003a28 <HAL_RCC_ClockConfig+0x1a0>
 80039fe:	f5b3 6f10 	cmp.w	r3, #2304	@ 0x900
 8003a02:	d011      	beq.n	8003a28 <HAL_RCC_ClockConfig+0x1a0>
 8003a04:	f5b3 6f20 	cmp.w	r3, #2560	@ 0xa00
 8003a08:	d00e      	beq.n	8003a28 <HAL_RCC_ClockConfig+0x1a0>
 8003a0a:	f5b3 6f30 	cmp.w	r3, #2816	@ 0xb00
 8003a0e:	d00b      	beq.n	8003a28 <HAL_RCC_ClockConfig+0x1a0>
 8003a10:	f5b3 6f40 	cmp.w	r3, #3072	@ 0xc00
 8003a14:	d008      	beq.n	8003a28 <HAL_RCC_ClockConfig+0x1a0>
 8003a16:	f5b3 6f50 	cmp.w	r3, #3328	@ 0xd00
 8003a1a:	d005      	beq.n	8003a28 <HAL_RCC_ClockConfig+0x1a0>
 8003a1c:	f5b3 6f60 	cmp.w	r3, #3584	@ 0xe00
 8003a20:	d002      	beq.n	8003a28 <HAL_RCC_ClockConfig+0x1a0>
 8003a22:	f5b3 6f70 	cmp.w	r3, #3840	@ 0xf00
 8003a26:	d141      	bne.n	8003aac <HAL_RCC_ClockConfig+0x224>
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
 8003a28:	6863      	ldr	r3, [r4, #4]
 8003a2a:	2b03      	cmp	r3, #3
 8003a2c:	d844      	bhi.n	8003ab8 <HAL_RCC_ClockConfig+0x230>
    MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);
 8003a2e:	4a3d      	ldr	r2, [pc, #244]	@ (8003b24 <HAL_RCC_ClockConfig+0x29c>)
 8003a30:	6993      	ldr	r3, [r2, #24]
 8003a32:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
 8003a36:	68a1      	ldr	r1, [r4, #8]
 8003a38:	430b      	orrs	r3, r1
 8003a3a:	6193      	str	r3, [r2, #24]
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8003a3c:	6863      	ldr	r3, [r4, #4]
 8003a3e:	2b02      	cmp	r3, #2
 8003a40:	d040      	beq.n	8003ac4 <HAL_RCC_ClockConfig+0x23c>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8003a42:	2b03      	cmp	r3, #3
 8003a44:	d05d      	beq.n	8003b02 <HAL_RCC_ClockConfig+0x27a>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
 8003a46:	2b01      	cmp	r3, #1
 8003a48:	d062      	beq.n	8003b10 <HAL_RCC_ClockConfig+0x288>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8003a4a:	4a36      	ldr	r2, [pc, #216]	@ (8003b24 <HAL_RCC_ClockConfig+0x29c>)
 8003a4c:	6812      	ldr	r2, [r2, #0]
 8003a4e:	f012 0f04 	tst.w	r2, #4
 8003a52:	d13c      	bne.n	8003ace <HAL_RCC_ClockConfig+0x246>
        return HAL_ERROR;
 8003a54:	2001      	movs	r0, #1
 8003a56:	e125      	b.n	8003ca4 <HAL_RCC_ClockConfig+0x41c>
  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
 8003a58:	f240 31a7 	movw	r1, #935	@ 0x3a7
 8003a5c:	4832      	ldr	r0, [pc, #200]	@ (8003b28 <HAL_RCC_ClockConfig+0x2a0>)
 8003a5e:	f7fd f839 	bl	8000ad4 <assert_failed>
 8003a62:	e71c      	b.n	800389e <HAL_RCC_ClockConfig+0x16>
  assert_param(IS_FLASH_LATENCY(FLatency));
 8003a64:	f44f 716a 	mov.w	r1, #936	@ 0x3a8
 8003a68:	482f      	ldr	r0, [pc, #188]	@ (8003b28 <HAL_RCC_ClockConfig+0x2a0>)
 8003a6a:	f7fd f833 	bl	8000ad4 <assert_failed>
 8003a6e:	e719      	b.n	80038a4 <HAL_RCC_ClockConfig+0x1c>
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
 8003a70:	f44f 7171 	mov.w	r1, #964	@ 0x3c4
 8003a74:	482c      	ldr	r0, [pc, #176]	@ (8003b28 <HAL_RCC_ClockConfig+0x2a0>)
 8003a76:	f7fd f82d 	bl	8000ad4 <assert_failed>
 8003a7a:	e73b      	b.n	80038f4 <HAL_RCC_ClockConfig+0x6c>
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
 8003a7c:	f240 31d6 	movw	r1, #982	@ 0x3d6
 8003a80:	4829      	ldr	r0, [pc, #164]	@ (8003b28 <HAL_RCC_ClockConfig+0x2a0>)
 8003a82:	f7fd f827 	bl	8000ad4 <assert_failed>
 8003a86:	e752      	b.n	800392e <HAL_RCC_ClockConfig+0xa6>
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
 8003a88:	f240 31e7 	movw	r1, #999	@ 0x3e7
 8003a8c:	4826      	ldr	r0, [pc, #152]	@ (8003b28 <HAL_RCC_ClockConfig+0x2a0>)
 8003a8e:	f7fd f821 	bl	8000ad4 <assert_failed>
 8003a92:	e76d      	b.n	8003970 <HAL_RCC_ClockConfig+0xe8>
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
 8003a94:	f240 31f9 	movw	r1, #1017	@ 0x3f9
 8003a98:	4823      	ldr	r0, [pc, #140]	@ (8003b28 <HAL_RCC_ClockConfig+0x2a0>)
 8003a9a:	f7fd f81b 	bl	8000ad4 <assert_failed>
 8003a9e:	e783      	b.n	80039a8 <HAL_RCC_ClockConfig+0x120>
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
 8003aa0:	f240 410c 	movw	r1, #1036	@ 0x40c
 8003aa4:	4820      	ldr	r0, [pc, #128]	@ (8003b28 <HAL_RCC_ClockConfig+0x2a0>)
 8003aa6:	f7fd f815 	bl	8000ad4 <assert_failed>
 8003aaa:	e796      	b.n	80039da <HAL_RCC_ClockConfig+0x152>
    assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));
 8003aac:	f240 411c 	movw	r1, #1052	@ 0x41c
 8003ab0:	481d      	ldr	r0, [pc, #116]	@ (8003b28 <HAL_RCC_ClockConfig+0x2a0>)
 8003ab2:	f7fd f80f 	bl	8000ad4 <assert_failed>
 8003ab6:	e7b7      	b.n	8003a28 <HAL_RCC_ClockConfig+0x1a0>
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
 8003ab8:	f240 411d 	movw	r1, #1053	@ 0x41d
 8003abc:	481a      	ldr	r0, [pc, #104]	@ (8003b28 <HAL_RCC_ClockConfig+0x2a0>)
 8003abe:	f7fd f809 	bl	8000ad4 <assert_failed>
 8003ac2:	e7b4      	b.n	8003a2e <HAL_RCC_ClockConfig+0x1a6>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8003ac4:	6812      	ldr	r2, [r2, #0]
 8003ac6:	f412 3f00 	tst.w	r2, #131072	@ 0x20000
 8003aca:	f000 810e 	beq.w	8003cea <HAL_RCC_ClockConfig+0x462>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8003ace:	4915      	ldr	r1, [pc, #84]	@ (8003b24 <HAL_RCC_ClockConfig+0x29c>)
 8003ad0:	690a      	ldr	r2, [r1, #16]
 8003ad2:	f022 0207 	bic.w	r2, r2, #7
 8003ad6:	4313      	orrs	r3, r2
 8003ad8:	610b      	str	r3, [r1, #16]
    tickstart = HAL_GetTick();
 8003ada:	f7fd fc8d 	bl	80013f8 <HAL_GetTick>
 8003ade:	4606      	mov	r6, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8003ae0:	4b10      	ldr	r3, [pc, #64]	@ (8003b24 <HAL_RCC_ClockConfig+0x29c>)
 8003ae2:	691b      	ldr	r3, [r3, #16]
 8003ae4:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 8003ae8:	6862      	ldr	r2, [r4, #4]
 8003aea:	ebb3 0fc2 	cmp.w	r3, r2, lsl #3
 8003aee:	d01d      	beq.n	8003b2c <HAL_RCC_ClockConfig+0x2a4>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003af0:	f7fd fc82 	bl	80013f8 <HAL_GetTick>
 8003af4:	1b80      	subs	r0, r0, r6
 8003af6:	f241 3388 	movw	r3, #5000	@ 0x1388
 8003afa:	4298      	cmp	r0, r3
 8003afc:	d9f0      	bls.n	8003ae0 <HAL_RCC_ClockConfig+0x258>
        return HAL_TIMEOUT;
 8003afe:	2003      	movs	r0, #3
 8003b00:	e0d0      	b.n	8003ca4 <HAL_RCC_ClockConfig+0x41c>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 8003b02:	4a08      	ldr	r2, [pc, #32]	@ (8003b24 <HAL_RCC_ClockConfig+0x29c>)
 8003b04:	6812      	ldr	r2, [r2, #0]
 8003b06:	f012 7f00 	tst.w	r2, #33554432	@ 0x2000000
 8003b0a:	d1e0      	bne.n	8003ace <HAL_RCC_ClockConfig+0x246>
        return HAL_ERROR;
 8003b0c:	2001      	movs	r0, #1
 8003b0e:	e0c9      	b.n	8003ca4 <HAL_RCC_ClockConfig+0x41c>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 8003b10:	4a04      	ldr	r2, [pc, #16]	@ (8003b24 <HAL_RCC_ClockConfig+0x29c>)
 8003b12:	6812      	ldr	r2, [r2, #0]
 8003b14:	f412 7f80 	tst.w	r2, #256	@ 0x100
 8003b18:	d1d9      	bne.n	8003ace <HAL_RCC_ClockConfig+0x246>
        return HAL_ERROR;
 8003b1a:	2001      	movs	r0, #1
 8003b1c:	e0c2      	b.n	8003ca4 <HAL_RCC_ClockConfig+0x41c>
 8003b1e:	bf00      	nop
 8003b20:	52002000 	.word	0x52002000
 8003b24:	58024400 	.word	0x58024400
 8003b28:	08015540 	.word	0x08015540
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8003b2c:	6823      	ldr	r3, [r4, #0]
 8003b2e:	f013 0f02 	tst.w	r3, #2
 8003b32:	d015      	beq.n	8003b60 <HAL_RCC_ClockConfig+0x2d8>
    if ((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))
 8003b34:	68e2      	ldr	r2, [r4, #12]
 8003b36:	4b6f      	ldr	r3, [pc, #444]	@ (8003cf4 <HAL_RCC_ClockConfig+0x46c>)
 8003b38:	699b      	ldr	r3, [r3, #24]
 8003b3a:	f003 030f 	and.w	r3, r3, #15
 8003b3e:	429a      	cmp	r2, r3
 8003b40:	d20e      	bcs.n	8003b60 <HAL_RCC_ClockConfig+0x2d8>
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
 8003b42:	2a00      	cmp	r2, #0
 8003b44:	bf18      	it	ne
 8003b46:	2a08      	cmpne	r2, #8
 8003b48:	d003      	beq.n	8003b52 <HAL_RCC_ClockConfig+0x2ca>
 8003b4a:	3a09      	subs	r2, #9
 8003b4c:	2a06      	cmp	r2, #6
 8003b4e:	f200 80aa 	bhi.w	8003ca6 <HAL_RCC_ClockConfig+0x41e>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8003b52:	4a68      	ldr	r2, [pc, #416]	@ (8003cf4 <HAL_RCC_ClockConfig+0x46c>)
 8003b54:	6993      	ldr	r3, [r2, #24]
 8003b56:	f023 030f 	bic.w	r3, r3, #15
 8003b5a:	68e1      	ldr	r1, [r4, #12]
 8003b5c:	430b      	orrs	r3, r1
 8003b5e:	6193      	str	r3, [r2, #24]
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8003b60:	4b65      	ldr	r3, [pc, #404]	@ (8003cf8 <HAL_RCC_ClockConfig+0x470>)
 8003b62:	681b      	ldr	r3, [r3, #0]
 8003b64:	f003 030f 	and.w	r3, r3, #15
 8003b68:	42ab      	cmp	r3, r5
 8003b6a:	d90b      	bls.n	8003b84 <HAL_RCC_ClockConfig+0x2fc>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8003b6c:	4a62      	ldr	r2, [pc, #392]	@ (8003cf8 <HAL_RCC_ClockConfig+0x470>)
 8003b6e:	6813      	ldr	r3, [r2, #0]
 8003b70:	f023 030f 	bic.w	r3, r3, #15
 8003b74:	432b      	orrs	r3, r5
 8003b76:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8003b78:	6813      	ldr	r3, [r2, #0]
 8003b7a:	f003 030f 	and.w	r3, r3, #15
 8003b7e:	42ab      	cmp	r3, r5
 8003b80:	f040 80b5 	bne.w	8003cee <HAL_RCC_ClockConfig+0x466>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
 8003b84:	6823      	ldr	r3, [r4, #0]
 8003b86:	f013 0f04 	tst.w	r3, #4
 8003b8a:	d018      	beq.n	8003bbe <HAL_RCC_ClockConfig+0x336>
    if ((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
 8003b8c:	6922      	ldr	r2, [r4, #16]
 8003b8e:	4b59      	ldr	r3, [pc, #356]	@ (8003cf4 <HAL_RCC_ClockConfig+0x46c>)
 8003b90:	699b      	ldr	r3, [r3, #24]
 8003b92:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 8003b96:	429a      	cmp	r2, r3
 8003b98:	d211      	bcs.n	8003bbe <HAL_RCC_ClockConfig+0x336>
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
 8003b9a:	2a00      	cmp	r2, #0
 8003b9c:	bf18      	it	ne
 8003b9e:	2a40      	cmpne	r2, #64	@ 0x40
 8003ba0:	d006      	beq.n	8003bb0 <HAL_RCC_ClockConfig+0x328>
 8003ba2:	2a50      	cmp	r2, #80	@ 0x50
 8003ba4:	d004      	beq.n	8003bb0 <HAL_RCC_ClockConfig+0x328>
 8003ba6:	2a60      	cmp	r2, #96	@ 0x60
 8003ba8:	d002      	beq.n	8003bb0 <HAL_RCC_ClockConfig+0x328>
 8003baa:	2a70      	cmp	r2, #112	@ 0x70
 8003bac:	f040 8081 	bne.w	8003cb2 <HAL_RCC_ClockConfig+0x42a>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
 8003bb0:	4a50      	ldr	r2, [pc, #320]	@ (8003cf4 <HAL_RCC_ClockConfig+0x46c>)
 8003bb2:	6993      	ldr	r3, [r2, #24]
 8003bb4:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8003bb8:	6921      	ldr	r1, [r4, #16]
 8003bba:	430b      	orrs	r3, r1
 8003bbc:	6193      	str	r3, [r2, #24]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8003bbe:	6823      	ldr	r3, [r4, #0]
 8003bc0:	f013 0f08 	tst.w	r3, #8
 8003bc4:	d017      	beq.n	8003bf6 <HAL_RCC_ClockConfig+0x36e>
    if ((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
 8003bc6:	6962      	ldr	r2, [r4, #20]
 8003bc8:	4b4a      	ldr	r3, [pc, #296]	@ (8003cf4 <HAL_RCC_ClockConfig+0x46c>)
 8003bca:	69db      	ldr	r3, [r3, #28]
 8003bcc:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 8003bd0:	429a      	cmp	r2, r3
 8003bd2:	d210      	bcs.n	8003bf6 <HAL_RCC_ClockConfig+0x36e>
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
 8003bd4:	2a00      	cmp	r2, #0
 8003bd6:	bf18      	it	ne
 8003bd8:	2a40      	cmpne	r2, #64	@ 0x40
 8003bda:	d005      	beq.n	8003be8 <HAL_RCC_ClockConfig+0x360>
 8003bdc:	2a50      	cmp	r2, #80	@ 0x50
 8003bde:	d003      	beq.n	8003be8 <HAL_RCC_ClockConfig+0x360>
 8003be0:	2a60      	cmp	r2, #96	@ 0x60
 8003be2:	d001      	beq.n	8003be8 <HAL_RCC_ClockConfig+0x360>
 8003be4:	2a70      	cmp	r2, #112	@ 0x70
 8003be6:	d16a      	bne.n	8003cbe <HAL_RCC_ClockConfig+0x436>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
 8003be8:	4a42      	ldr	r2, [pc, #264]	@ (8003cf4 <HAL_RCC_ClockConfig+0x46c>)
 8003bea:	69d3      	ldr	r3, [r2, #28]
 8003bec:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8003bf0:	6961      	ldr	r1, [r4, #20]
 8003bf2:	430b      	orrs	r3, r1
 8003bf4:	61d3      	str	r3, [r2, #28]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8003bf6:	6823      	ldr	r3, [r4, #0]
 8003bf8:	f013 0f10 	tst.w	r3, #16
 8003bfc:	d01b      	beq.n	8003c36 <HAL_RCC_ClockConfig+0x3ae>
    if ((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
 8003bfe:	69a2      	ldr	r2, [r4, #24]
 8003c00:	4b3c      	ldr	r3, [pc, #240]	@ (8003cf4 <HAL_RCC_ClockConfig+0x46c>)
 8003c02:	69db      	ldr	r3, [r3, #28]
 8003c04:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
 8003c08:	429a      	cmp	r2, r3
 8003c0a:	d214      	bcs.n	8003c36 <HAL_RCC_ClockConfig+0x3ae>
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
 8003c0c:	2a00      	cmp	r2, #0
 8003c0e:	bf18      	it	ne
 8003c10:	f5b2 6f80 	cmpne.w	r2, #1024	@ 0x400
 8003c14:	d008      	beq.n	8003c28 <HAL_RCC_ClockConfig+0x3a0>
 8003c16:	f5b2 6fa0 	cmp.w	r2, #1280	@ 0x500
 8003c1a:	d005      	beq.n	8003c28 <HAL_RCC_ClockConfig+0x3a0>
 8003c1c:	f5b2 6fc0 	cmp.w	r2, #1536	@ 0x600
 8003c20:	d002      	beq.n	8003c28 <HAL_RCC_ClockConfig+0x3a0>
 8003c22:	f5b2 6fe0 	cmp.w	r2, #1792	@ 0x700
 8003c26:	d150      	bne.n	8003cca <HAL_RCC_ClockConfig+0x442>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
 8003c28:	4a32      	ldr	r2, [pc, #200]	@ (8003cf4 <HAL_RCC_ClockConfig+0x46c>)
 8003c2a:	69d3      	ldr	r3, [r2, #28]
 8003c2c:	f423 63e0 	bic.w	r3, r3, #1792	@ 0x700
 8003c30:	69a1      	ldr	r1, [r4, #24]
 8003c32:	430b      	orrs	r3, r1
 8003c34:	61d3      	str	r3, [r2, #28]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
 8003c36:	6823      	ldr	r3, [r4, #0]
 8003c38:	f013 0f20 	tst.w	r3, #32
 8003c3c:	d017      	beq.n	8003c6e <HAL_RCC_ClockConfig+0x3e6>
    if ((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
 8003c3e:	69e2      	ldr	r2, [r4, #28]
 8003c40:	4b2c      	ldr	r3, [pc, #176]	@ (8003cf4 <HAL_RCC_ClockConfig+0x46c>)
 8003c42:	6a1b      	ldr	r3, [r3, #32]
 8003c44:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 8003c48:	429a      	cmp	r2, r3
 8003c4a:	d210      	bcs.n	8003c6e <HAL_RCC_ClockConfig+0x3e6>
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
 8003c4c:	2a00      	cmp	r2, #0
 8003c4e:	bf18      	it	ne
 8003c50:	2a40      	cmpne	r2, #64	@ 0x40
 8003c52:	d005      	beq.n	8003c60 <HAL_RCC_ClockConfig+0x3d8>
 8003c54:	2a50      	cmp	r2, #80	@ 0x50
 8003c56:	d003      	beq.n	8003c60 <HAL_RCC_ClockConfig+0x3d8>
 8003c58:	2a60      	cmp	r2, #96	@ 0x60
 8003c5a:	d001      	beq.n	8003c60 <HAL_RCC_ClockConfig+0x3d8>
 8003c5c:	2a70      	cmp	r2, #112	@ 0x70
 8003c5e:	d13a      	bne.n	8003cd6 <HAL_RCC_ClockConfig+0x44e>
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider));
 8003c60:	4a24      	ldr	r2, [pc, #144]	@ (8003cf4 <HAL_RCC_ClockConfig+0x46c>)
 8003c62:	6a13      	ldr	r3, [r2, #32]
 8003c64:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8003c68:	69e1      	ldr	r1, [r4, #28]
 8003c6a:	430b      	orrs	r3, r1
 8003c6c:	6213      	str	r3, [r2, #32]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8003c6e:	f7ff fd0f 	bl	8003690 <HAL_RCC_GetSysClockFreq>
 8003c72:	4920      	ldr	r1, [pc, #128]	@ (8003cf4 <HAL_RCC_ClockConfig+0x46c>)
 8003c74:	698b      	ldr	r3, [r1, #24]
 8003c76:	f3c3 2303 	ubfx	r3, r3, #8, #4
 8003c7a:	4a20      	ldr	r2, [pc, #128]	@ (8003cfc <HAL_RCC_ClockConfig+0x474>)
 8003c7c:	5cd3      	ldrb	r3, [r2, r3]
 8003c7e:	f003 031f 	and.w	r3, r3, #31
 8003c82:	40d8      	lsrs	r0, r3
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8003c84:	698b      	ldr	r3, [r1, #24]
 8003c86:	f003 030f 	and.w	r3, r3, #15
 8003c8a:	5cd3      	ldrb	r3, [r2, r3]
 8003c8c:	f003 031f 	and.w	r3, r3, #31
 8003c90:	fa20 f303 	lsr.w	r3, r0, r3
 8003c94:	4a1a      	ldr	r2, [pc, #104]	@ (8003d00 <HAL_RCC_ClockConfig+0x478>)
 8003c96:	6013      	str	r3, [r2, #0]
  SystemCoreClock = common_system_clock;
 8003c98:	4b1a      	ldr	r3, [pc, #104]	@ (8003d04 <HAL_RCC_ClockConfig+0x47c>)
 8003c9a:	6018      	str	r0, [r3, #0]
  halstatus = HAL_InitTick(uwTickPrio);
 8003c9c:	4b1a      	ldr	r3, [pc, #104]	@ (8003d08 <HAL_RCC_ClockConfig+0x480>)
 8003c9e:	6818      	ldr	r0, [r3, #0]
 8003ca0:	f7fd f804 	bl	8000cac <HAL_InitTick>
}
 8003ca4:	bd70      	pop	{r4, r5, r6, pc}
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
 8003ca6:	f240 415e 	movw	r1, #1118	@ 0x45e
 8003caa:	4818      	ldr	r0, [pc, #96]	@ (8003d0c <HAL_RCC_ClockConfig+0x484>)
 8003cac:	f7fc ff12 	bl	8000ad4 <assert_failed>
 8003cb0:	e74f      	b.n	8003b52 <HAL_RCC_ClockConfig+0x2ca>
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
 8003cb2:	f240 417f 	movw	r1, #1151	@ 0x47f
 8003cb6:	4815      	ldr	r0, [pc, #84]	@ (8003d0c <HAL_RCC_ClockConfig+0x484>)
 8003cb8:	f7fc ff0c 	bl	8000ad4 <assert_failed>
 8003cbc:	e778      	b.n	8003bb0 <HAL_RCC_ClockConfig+0x328>
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
 8003cbe:	f240 4191 	movw	r1, #1169	@ 0x491
 8003cc2:	4812      	ldr	r0, [pc, #72]	@ (8003d0c <HAL_RCC_ClockConfig+0x484>)
 8003cc4:	f7fc ff06 	bl	8000ad4 <assert_failed>
 8003cc8:	e78e      	b.n	8003be8 <HAL_RCC_ClockConfig+0x360>
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
 8003cca:	f240 41a3 	movw	r1, #1187	@ 0x4a3
 8003cce:	480f      	ldr	r0, [pc, #60]	@ (8003d0c <HAL_RCC_ClockConfig+0x484>)
 8003cd0:	f7fc ff00 	bl	8000ad4 <assert_failed>
 8003cd4:	e7a8      	b.n	8003c28 <HAL_RCC_ClockConfig+0x3a0>
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
 8003cd6:	f240 41b5 	movw	r1, #1205	@ 0x4b5
 8003cda:	480c      	ldr	r0, [pc, #48]	@ (8003d0c <HAL_RCC_ClockConfig+0x484>)
 8003cdc:	f7fc fefa 	bl	8000ad4 <assert_failed>
 8003ce0:	e7be      	b.n	8003c60 <HAL_RCC_ClockConfig+0x3d8>
    return HAL_ERROR;
 8003ce2:	2001      	movs	r0, #1
}
 8003ce4:	4770      	bx	lr
      return HAL_ERROR;
 8003ce6:	2001      	movs	r0, #1
 8003ce8:	e7dc      	b.n	8003ca4 <HAL_RCC_ClockConfig+0x41c>
        return HAL_ERROR;
 8003cea:	2001      	movs	r0, #1
 8003cec:	e7da      	b.n	8003ca4 <HAL_RCC_ClockConfig+0x41c>
      return HAL_ERROR;
 8003cee:	2001      	movs	r0, #1
 8003cf0:	e7d8      	b.n	8003ca4 <HAL_RCC_ClockConfig+0x41c>
 8003cf2:	bf00      	nop
 8003cf4:	58024400 	.word	0x58024400
 8003cf8:	52002000 	.word	0x52002000
 8003cfc:	08018cc4 	.word	0x08018cc4
 8003d00:	24000000 	.word	0x24000000
 8003d04:	24000004 	.word	0x24000004
 8003d08:	2400000c 	.word	0x2400000c
 8003d0c:	08015540 	.word	0x08015540

08003d10 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8003d10:	b508      	push	{r3, lr}
  uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 8003d12:	f7ff fcbd 	bl	8003690 <HAL_RCC_GetSysClockFreq>
 8003d16:	4a0b      	ldr	r2, [pc, #44]	@ (8003d44 <HAL_RCC_GetHCLKFreq+0x34>)
 8003d18:	6993      	ldr	r3, [r2, #24]
 8003d1a:	f3c3 2303 	ubfx	r3, r3, #8, #4
 8003d1e:	490a      	ldr	r1, [pc, #40]	@ (8003d48 <HAL_RCC_GetHCLKFreq+0x38>)
 8003d20:	5ccb      	ldrb	r3, [r1, r3]
 8003d22:	f003 031f 	and.w	r3, r3, #31
 8003d26:	fa20 f303 	lsr.w	r3, r0, r3
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE) >> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8003d2a:	6992      	ldr	r2, [r2, #24]
 8003d2c:	f002 020f 	and.w	r2, r2, #15
 8003d30:	5c88      	ldrb	r0, [r1, r2]
 8003d32:	f000 001f 	and.w	r0, r0, #31
 8003d36:	fa23 f000 	lsr.w	r0, r3, r0
 8003d3a:	4a04      	ldr	r2, [pc, #16]	@ (8003d4c <HAL_RCC_GetHCLKFreq+0x3c>)
 8003d3c:	6010      	str	r0, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
 8003d3e:	4a04      	ldr	r2, [pc, #16]	@ (8003d50 <HAL_RCC_GetHCLKFreq+0x40>)
 8003d40:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
}
 8003d42:	bd08      	pop	{r3, pc}
 8003d44:	58024400 	.word	0x58024400
 8003d48:	08018cc4 	.word	0x08018cc4
 8003d4c:	24000000 	.word	0x24000000
 8003d50:	24000004 	.word	0x24000004

08003d54 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8003d54:	b508      	push	{r3, lr}
#if defined (RCC_D2CFGR_D2PPRE1)
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1) >> RCC_D2CFGR_D2PPRE1_Pos]) & 0x1FU));
 8003d56:	f7ff ffdb 	bl	8003d10 <HAL_RCC_GetHCLKFreq>
 8003d5a:	4b05      	ldr	r3, [pc, #20]	@ (8003d70 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8003d5c:	69db      	ldr	r3, [r3, #28]
 8003d5e:	f3c3 1302 	ubfx	r3, r3, #4, #3
 8003d62:	4a04      	ldr	r2, [pc, #16]	@ (8003d74 <HAL_RCC_GetPCLK1Freq+0x20>)
 8003d64:	5cd3      	ldrb	r3, [r2, r3]
 8003d66:	f003 031f 	and.w	r3, r3, #31
#else
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1) >> RCC_CDCFGR2_CDPPRE1_Pos]) & 0x1FU));
#endif
}
 8003d6a:	40d8      	lsrs	r0, r3
 8003d6c:	bd08      	pop	{r3, pc}
 8003d6e:	bf00      	nop
 8003d70:	58024400 	.word	0x58024400
 8003d74:	08018cc4 	.word	0x08018cc4

08003d78 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 8003d78:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
#if defined(RCC_D2CFGR_D2PPRE2)
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2) >> RCC_D2CFGR_D2PPRE2_Pos]) & 0x1FU));
 8003d7a:	f7ff ffc9 	bl	8003d10 <HAL_RCC_GetHCLKFreq>
 8003d7e:	4b05      	ldr	r3, [pc, #20]	@ (8003d94 <HAL_RCC_GetPCLK2Freq+0x1c>)
 8003d80:	69db      	ldr	r3, [r3, #28]
 8003d82:	f3c3 2302 	ubfx	r3, r3, #8, #3
 8003d86:	4a04      	ldr	r2, [pc, #16]	@ (8003d98 <HAL_RCC_GetPCLK2Freq+0x20>)
 8003d88:	5cd3      	ldrb	r3, [r2, r3]
 8003d8a:	f003 031f 	and.w	r3, r3, #31
#else
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2) >> RCC_CDCFGR2_CDPPRE2_Pos]) & 0x1FU));
#endif
}
 8003d8e:	40d8      	lsrs	r0, r3
 8003d90:	bd08      	pop	{r3, pc}
 8003d92:	bf00      	nop
 8003d94:	58024400 	.word	0x58024400
 8003d98:	08018cc4 	.word	0x08018cc4

08003d9c <HAL_RCC_GetClockConfig>:
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 |
 8003d9c:	233f      	movs	r3, #63	@ 0x3f
 8003d9e:	6003      	str	r3, [r0, #0]
                                 RCC_CLOCKTYPE_PCLK2 |  RCC_CLOCKTYPE_D3PCLK1  ;

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8003da0:	4b11      	ldr	r3, [pc, #68]	@ (8003de8 <HAL_RCC_GetClockConfig+0x4c>)
 8003da2:	691a      	ldr	r2, [r3, #16]
 8003da4:	f002 0207 	and.w	r2, r2, #7
 8003da8:	6042      	str	r2, [r0, #4]

#if defined(RCC_D1CFGR_D1CPRE)
  /* Get the SYSCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1CPRE);
 8003daa:	699a      	ldr	r2, [r3, #24]
 8003dac:	f402 6270 	and.w	r2, r2, #3840	@ 0xf00
 8003db0:	6082      	str	r2, [r0, #8]

  /* Get the D1HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_HPRE);
 8003db2:	699a      	ldr	r2, [r3, #24]
 8003db4:	f002 020f 	and.w	r2, r2, #15
 8003db8:	60c2      	str	r2, [r0, #12]

  /* Get the APB3 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB3CLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1PPRE);
 8003dba:	699a      	ldr	r2, [r3, #24]
 8003dbc:	f002 0270 	and.w	r2, r2, #112	@ 0x70
 8003dc0:	6102      	str	r2, [r0, #16]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1);
 8003dc2:	69da      	ldr	r2, [r3, #28]
 8003dc4:	f002 0270 	and.w	r2, r2, #112	@ 0x70
 8003dc8:	6142      	str	r2, [r0, #20]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2);
 8003dca:	69da      	ldr	r2, [r3, #28]
 8003dcc:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
 8003dd0:	6182      	str	r2, [r0, #24]

  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->D3CFGR & RCC_D3CFGR_D3PPRE);
 8003dd2:	6a1b      	ldr	r3, [r3, #32]
 8003dd4:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 8003dd8:	61c3      	str	r3, [r0, #28]
  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE);
#endif

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8003dda:	4b04      	ldr	r3, [pc, #16]	@ (8003dec <HAL_RCC_GetClockConfig+0x50>)
 8003ddc:	681b      	ldr	r3, [r3, #0]
 8003dde:	f003 030f 	and.w	r3, r3, #15
 8003de2:	600b      	str	r3, [r1, #0]
}
 8003de4:	4770      	bx	lr
 8003de6:	bf00      	nop
 8003de8:	58024400 	.word	0x58024400
 8003dec:	52002000 	.word	0x52002000

08003df0 <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(RCC_PLL2InitTypeDef *pll2, uint32_t Divider)
{
 8003df0:	b570      	push	{r4, r5, r6, lr}
 8003df2:	4604      	mov	r4, r0
 8003df4:	460e      	mov	r6, r1

  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
  assert_param(IS_RCC_PLL2M_VALUE(pll2->PLL2M));
 8003df6:	6803      	ldr	r3, [r0, #0]
 8003df8:	3b01      	subs	r3, #1
 8003dfa:	2b3e      	cmp	r3, #62	@ 0x3e
 8003dfc:	d83d      	bhi.n	8003e7a <RCCEx_PLL2_Config+0x8a>
  assert_param(IS_RCC_PLL2N_VALUE(pll2->PLL2N));
 8003dfe:	6863      	ldr	r3, [r4, #4]
 8003e00:	3b04      	subs	r3, #4
 8003e02:	f5b3 7ffe 	cmp.w	r3, #508	@ 0x1fc
 8003e06:	d83e      	bhi.n	8003e86 <RCCEx_PLL2_Config+0x96>
  assert_param(IS_RCC_PLL2P_VALUE(pll2->PLL2P));
 8003e08:	68a3      	ldr	r3, [r4, #8]
 8003e0a:	3b01      	subs	r3, #1
 8003e0c:	2b7f      	cmp	r3, #127	@ 0x7f
 8003e0e:	d840      	bhi.n	8003e92 <RCCEx_PLL2_Config+0xa2>
  assert_param(IS_RCC_PLL2R_VALUE(pll2->PLL2R));
 8003e10:	6923      	ldr	r3, [r4, #16]
 8003e12:	3b01      	subs	r3, #1
 8003e14:	2b7f      	cmp	r3, #127	@ 0x7f
 8003e16:	d842      	bhi.n	8003e9e <RCCEx_PLL2_Config+0xae>
  assert_param(IS_RCC_PLL2Q_VALUE(pll2->PLL2Q));
 8003e18:	68e3      	ldr	r3, [r4, #12]
 8003e1a:	3b01      	subs	r3, #1
 8003e1c:	2b7f      	cmp	r3, #127	@ 0x7f
 8003e1e:	d844      	bhi.n	8003eaa <RCCEx_PLL2_Config+0xba>
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
 8003e20:	6963      	ldr	r3, [r4, #20]
 8003e22:	2b00      	cmp	r3, #0
 8003e24:	bf18      	it	ne
 8003e26:	2b40      	cmpne	r3, #64	@ 0x40
 8003e28:	d003      	beq.n	8003e32 <RCCEx_PLL2_Config+0x42>
 8003e2a:	2b80      	cmp	r3, #128	@ 0x80
 8003e2c:	d001      	beq.n	8003e32 <RCCEx_PLL2_Config+0x42>
 8003e2e:	2bc0      	cmp	r3, #192	@ 0xc0
 8003e30:	d141      	bne.n	8003eb6 <RCCEx_PLL2_Config+0xc6>
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
 8003e32:	69a3      	ldr	r3, [r4, #24]
 8003e34:	2b00      	cmp	r3, #0
 8003e36:	bf18      	it	ne
 8003e38:	2b20      	cmpne	r3, #32
 8003e3a:	d142      	bne.n	8003ec2 <RCCEx_PLL2_Config+0xd2>
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));
 8003e3c:	69e3      	ldr	r3, [r4, #28]
 8003e3e:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8003e42:	d244      	bcs.n	8003ece <RCCEx_PLL2_Config+0xde>

  /* Check that PLL2 OSC clock source is already set */
  if (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
 8003e44:	4b57      	ldr	r3, [pc, #348]	@ (8003fa4 <RCCEx_PLL2_Config+0x1b4>)
 8003e46:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8003e48:	f003 0303 	and.w	r3, r3, #3
 8003e4c:	2b03      	cmp	r3, #3
 8003e4e:	f000 80a7 	beq.w	8003fa0 <RCCEx_PLL2_Config+0x1b0>


  else
  {
    /* Disable  PLL2. */
    __HAL_RCC_PLL2_DISABLE();
 8003e52:	4a54      	ldr	r2, [pc, #336]	@ (8003fa4 <RCCEx_PLL2_Config+0x1b4>)
 8003e54:	6813      	ldr	r3, [r2, #0]
 8003e56:	f023 6380 	bic.w	r3, r3, #67108864	@ 0x4000000
 8003e5a:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8003e5c:	f7fd facc 	bl	80013f8 <HAL_GetTick>
 8003e60:	4605      	mov	r5, r0

    /* Wait till PLL is disabled */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 8003e62:	4b50      	ldr	r3, [pc, #320]	@ (8003fa4 <RCCEx_PLL2_Config+0x1b4>)
 8003e64:	681b      	ldr	r3, [r3, #0]
 8003e66:	f013 6f00 	tst.w	r3, #134217728	@ 0x8000000
 8003e6a:	d036      	beq.n	8003eda <RCCEx_PLL2_Config+0xea>
    {
      if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
 8003e6c:	f7fd fac4 	bl	80013f8 <HAL_GetTick>
 8003e70:	1b43      	subs	r3, r0, r5
 8003e72:	2b02      	cmp	r3, #2
 8003e74:	d9f5      	bls.n	8003e62 <RCCEx_PLL2_Config+0x72>
      {
        return HAL_TIMEOUT;
 8003e76:	2003      	movs	r0, #3
 8003e78:	e093      	b.n	8003fa2 <RCCEx_PLL2_Config+0x1b2>
  assert_param(IS_RCC_PLL2M_VALUE(pll2->PLL2M));
 8003e7a:	f640 6172 	movw	r1, #3698	@ 0xe72
 8003e7e:	484a      	ldr	r0, [pc, #296]	@ (8003fa8 <RCCEx_PLL2_Config+0x1b8>)
 8003e80:	f7fc fe28 	bl	8000ad4 <assert_failed>
 8003e84:	e7bb      	b.n	8003dfe <RCCEx_PLL2_Config+0xe>
  assert_param(IS_RCC_PLL2N_VALUE(pll2->PLL2N));
 8003e86:	f640 6173 	movw	r1, #3699	@ 0xe73
 8003e8a:	4847      	ldr	r0, [pc, #284]	@ (8003fa8 <RCCEx_PLL2_Config+0x1b8>)
 8003e8c:	f7fc fe22 	bl	8000ad4 <assert_failed>
 8003e90:	e7ba      	b.n	8003e08 <RCCEx_PLL2_Config+0x18>
  assert_param(IS_RCC_PLL2P_VALUE(pll2->PLL2P));
 8003e92:	f640 6174 	movw	r1, #3700	@ 0xe74
 8003e96:	4844      	ldr	r0, [pc, #272]	@ (8003fa8 <RCCEx_PLL2_Config+0x1b8>)
 8003e98:	f7fc fe1c 	bl	8000ad4 <assert_failed>
 8003e9c:	e7b8      	b.n	8003e10 <RCCEx_PLL2_Config+0x20>
  assert_param(IS_RCC_PLL2R_VALUE(pll2->PLL2R));
 8003e9e:	f640 6175 	movw	r1, #3701	@ 0xe75
 8003ea2:	4841      	ldr	r0, [pc, #260]	@ (8003fa8 <RCCEx_PLL2_Config+0x1b8>)
 8003ea4:	f7fc fe16 	bl	8000ad4 <assert_failed>
 8003ea8:	e7b6      	b.n	8003e18 <RCCEx_PLL2_Config+0x28>
  assert_param(IS_RCC_PLL2Q_VALUE(pll2->PLL2Q));
 8003eaa:	f640 6176 	movw	r1, #3702	@ 0xe76
 8003eae:	483e      	ldr	r0, [pc, #248]	@ (8003fa8 <RCCEx_PLL2_Config+0x1b8>)
 8003eb0:	f7fc fe10 	bl	8000ad4 <assert_failed>
 8003eb4:	e7b4      	b.n	8003e20 <RCCEx_PLL2_Config+0x30>
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
 8003eb6:	f640 6177 	movw	r1, #3703	@ 0xe77
 8003eba:	483b      	ldr	r0, [pc, #236]	@ (8003fa8 <RCCEx_PLL2_Config+0x1b8>)
 8003ebc:	f7fc fe0a 	bl	8000ad4 <assert_failed>
 8003ec0:	e7b7      	b.n	8003e32 <RCCEx_PLL2_Config+0x42>
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
 8003ec2:	f640 6178 	movw	r1, #3704	@ 0xe78
 8003ec6:	4838      	ldr	r0, [pc, #224]	@ (8003fa8 <RCCEx_PLL2_Config+0x1b8>)
 8003ec8:	f7fc fe04 	bl	8000ad4 <assert_failed>
 8003ecc:	e7b6      	b.n	8003e3c <RCCEx_PLL2_Config+0x4c>
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));
 8003ece:	f640 6179 	movw	r1, #3705	@ 0xe79
 8003ed2:	4835      	ldr	r0, [pc, #212]	@ (8003fa8 <RCCEx_PLL2_Config+0x1b8>)
 8003ed4:	f7fc fdfe 	bl	8000ad4 <assert_failed>
 8003ed8:	e7b4      	b.n	8003e44 <RCCEx_PLL2_Config+0x54>
      }
    }

    /* Configure PLL2 multiplication and division factors. */
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
 8003eda:	4b32      	ldr	r3, [pc, #200]	@ (8003fa4 <RCCEx_PLL2_Config+0x1b4>)
 8003edc:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8003ede:	f422 327c 	bic.w	r2, r2, #258048	@ 0x3f000
 8003ee2:	6821      	ldr	r1, [r4, #0]
 8003ee4:	ea42 3201 	orr.w	r2, r2, r1, lsl #12
 8003ee8:	629a      	str	r2, [r3, #40]	@ 0x28
 8003eea:	6862      	ldr	r2, [r4, #4]
 8003eec:	3a01      	subs	r2, #1
 8003eee:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8003ef2:	68a1      	ldr	r1, [r4, #8]
 8003ef4:	3901      	subs	r1, #1
 8003ef6:	0249      	lsls	r1, r1, #9
 8003ef8:	b289      	uxth	r1, r1
 8003efa:	430a      	orrs	r2, r1
 8003efc:	68e1      	ldr	r1, [r4, #12]
 8003efe:	3901      	subs	r1, #1
 8003f00:	0409      	lsls	r1, r1, #16
 8003f02:	f401 01fe 	and.w	r1, r1, #8323072	@ 0x7f0000
 8003f06:	430a      	orrs	r2, r1
 8003f08:	6921      	ldr	r1, [r4, #16]
 8003f0a:	3901      	subs	r1, #1
 8003f0c:	0609      	lsls	r1, r1, #24
 8003f0e:	f001 41fe 	and.w	r1, r1, #2130706432	@ 0x7f000000
 8003f12:	430a      	orrs	r2, r1
 8003f14:	639a      	str	r2, [r3, #56]	@ 0x38
                          pll2->PLL2P,
                          pll2->PLL2Q,
                          pll2->PLL2R);

    /* Select PLL2 input reference frequency range: VCI */
    __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE) ;
 8003f16:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8003f18:	f022 02c0 	bic.w	r2, r2, #192	@ 0xc0
 8003f1c:	6961      	ldr	r1, [r4, #20]
 8003f1e:	430a      	orrs	r2, r1
 8003f20:	62da      	str	r2, [r3, #44]	@ 0x2c

    /* Select PLL2 output frequency range : VCO */
    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;
 8003f22:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8003f24:	f022 0220 	bic.w	r2, r2, #32
 8003f28:	69a1      	ldr	r1, [r4, #24]
 8003f2a:	430a      	orrs	r2, r1
 8003f2c:	62da      	str	r2, [r3, #44]	@ 0x2c

    /* Disable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_DISABLE();
 8003f2e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8003f30:	f022 0210 	bic.w	r2, r2, #16
 8003f34:	62da      	str	r2, [r3, #44]	@ 0x2c

    /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
 8003f36:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8003f38:	f36f 02cf 	bfc	r2, #3, #13
 8003f3c:	69e1      	ldr	r1, [r4, #28]
 8003f3e:	ea42 02c1 	orr.w	r2, r2, r1, lsl #3
 8003f42:	63da      	str	r2, [r3, #60]	@ 0x3c

    /* Enable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_ENABLE();
 8003f44:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8003f46:	f042 0210 	orr.w	r2, r2, #16
 8003f4a:	62da      	str	r2, [r3, #44]	@ 0x2c

    /* Enable the PLL2 clock output */
    if (Divider == DIVIDER_P_UPDATE)
 8003f4c:	b9c6      	cbnz	r6, 8003f80 <RCCEx_PLL2_Config+0x190>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
 8003f4e:	461a      	mov	r2, r3
 8003f50:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8003f52:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8003f56:	62d3      	str	r3, [r2, #44]	@ 0x2c
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
    }

    /* Enable  PLL2. */
    __HAL_RCC_PLL2_ENABLE();
 8003f58:	4a12      	ldr	r2, [pc, #72]	@ (8003fa4 <RCCEx_PLL2_Config+0x1b4>)
 8003f5a:	6813      	ldr	r3, [r2, #0]
 8003f5c:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
 8003f60:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8003f62:	f7fd fa49 	bl	80013f8 <HAL_GetTick>
 8003f66:	4604      	mov	r4, r0

    /* Wait till PLL2 is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 8003f68:	4b0e      	ldr	r3, [pc, #56]	@ (8003fa4 <RCCEx_PLL2_Config+0x1b4>)
 8003f6a:	681b      	ldr	r3, [r3, #0]
 8003f6c:	f013 6f00 	tst.w	r3, #134217728	@ 0x8000000
 8003f70:	d114      	bne.n	8003f9c <RCCEx_PLL2_Config+0x1ac>
    {
      if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
 8003f72:	f7fd fa41 	bl	80013f8 <HAL_GetTick>
 8003f76:	1b00      	subs	r0, r0, r4
 8003f78:	2802      	cmp	r0, #2
 8003f7a:	d9f5      	bls.n	8003f68 <RCCEx_PLL2_Config+0x178>
      {
        return HAL_TIMEOUT;
 8003f7c:	2003      	movs	r0, #3
 8003f7e:	e010      	b.n	8003fa2 <RCCEx_PLL2_Config+0x1b2>
    else if (Divider == DIVIDER_Q_UPDATE)
 8003f80:	2e01      	cmp	r6, #1
 8003f82:	d005      	beq.n	8003f90 <RCCEx_PLL2_Config+0x1a0>
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
 8003f84:	4a07      	ldr	r2, [pc, #28]	@ (8003fa4 <RCCEx_PLL2_Config+0x1b4>)
 8003f86:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 8003f88:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8003f8c:	62d3      	str	r3, [r2, #44]	@ 0x2c
 8003f8e:	e7e3      	b.n	8003f58 <RCCEx_PLL2_Config+0x168>
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
 8003f90:	4a04      	ldr	r2, [pc, #16]	@ (8003fa4 <RCCEx_PLL2_Config+0x1b4>)
 8003f92:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 8003f94:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 8003f98:	62d3      	str	r3, [r2, #44]	@ 0x2c
 8003f9a:	e7dd      	b.n	8003f58 <RCCEx_PLL2_Config+0x168>
    }

  }


  return status;
 8003f9c:	2000      	movs	r0, #0
 8003f9e:	e000      	b.n	8003fa2 <RCCEx_PLL2_Config+0x1b2>
    return HAL_ERROR;
 8003fa0:	2001      	movs	r0, #1
}
 8003fa2:	bd70      	pop	{r4, r5, r6, pc}
 8003fa4:	58024400 	.word	0x58024400
 8003fa8:	08015578 	.word	0x08015578

08003fac <RCCEx_PLL3_Config>:
  * @note   PLL3 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(RCC_PLL3InitTypeDef *pll3, uint32_t Divider)
{
 8003fac:	b570      	push	{r4, r5, r6, lr}
 8003fae:	4604      	mov	r4, r0
 8003fb0:	460e      	mov	r6, r1
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
  assert_param(IS_RCC_PLL3M_VALUE(pll3->PLL3M));
 8003fb2:	6803      	ldr	r3, [r0, #0]
 8003fb4:	3b01      	subs	r3, #1
 8003fb6:	2b3e      	cmp	r3, #62	@ 0x3e
 8003fb8:	d841      	bhi.n	800403e <RCCEx_PLL3_Config+0x92>
  assert_param(IS_RCC_PLL3N_VALUE(pll3->PLL3N));
 8003fba:	6863      	ldr	r3, [r4, #4]
 8003fbc:	3b04      	subs	r3, #4
 8003fbe:	f5b3 7ffe 	cmp.w	r3, #508	@ 0x1fc
 8003fc2:	d842      	bhi.n	800404a <RCCEx_PLL3_Config+0x9e>
  assert_param(IS_RCC_PLL3P_VALUE(pll3->PLL3P));
 8003fc4:	68a3      	ldr	r3, [r4, #8]
 8003fc6:	3b01      	subs	r3, #1
 8003fc8:	2b7f      	cmp	r3, #127	@ 0x7f
 8003fca:	d844      	bhi.n	8004056 <RCCEx_PLL3_Config+0xaa>
  assert_param(IS_RCC_PLL3R_VALUE(pll3->PLL3R));
 8003fcc:	6923      	ldr	r3, [r4, #16]
 8003fce:	3b01      	subs	r3, #1
 8003fd0:	2b7f      	cmp	r3, #127	@ 0x7f
 8003fd2:	d846      	bhi.n	8004062 <RCCEx_PLL3_Config+0xb6>
  assert_param(IS_RCC_PLL3Q_VALUE(pll3->PLL3Q));
 8003fd4:	68e3      	ldr	r3, [r4, #12]
 8003fd6:	3b01      	subs	r3, #1
 8003fd8:	2b7f      	cmp	r3, #127	@ 0x7f
 8003fda:	d848      	bhi.n	800406e <RCCEx_PLL3_Config+0xc2>
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
 8003fdc:	6963      	ldr	r3, [r4, #20]
 8003fde:	2b00      	cmp	r3, #0
 8003fe0:	bf18      	it	ne
 8003fe2:	f5b3 6f80 	cmpne.w	r3, #1024	@ 0x400
 8003fe6:	d005      	beq.n	8003ff4 <RCCEx_PLL3_Config+0x48>
 8003fe8:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8003fec:	d002      	beq.n	8003ff4 <RCCEx_PLL3_Config+0x48>
 8003fee:	f5b3 6f40 	cmp.w	r3, #3072	@ 0xc00
 8003ff2:	d142      	bne.n	800407a <RCCEx_PLL3_Config+0xce>
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
 8003ff4:	69a3      	ldr	r3, [r4, #24]
 8003ff6:	2b00      	cmp	r3, #0
 8003ff8:	bf18      	it	ne
 8003ffa:	f5b3 7f00 	cmpne.w	r3, #512	@ 0x200
 8003ffe:	d142      	bne.n	8004086 <RCCEx_PLL3_Config+0xda>
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));
 8004000:	69e3      	ldr	r3, [r4, #28]
 8004002:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8004006:	d244      	bcs.n	8004092 <RCCEx_PLL3_Config+0xe6>

  /* Check that PLL3 OSC clock source is already set */
  if (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
 8004008:	4b57      	ldr	r3, [pc, #348]	@ (8004168 <RCCEx_PLL3_Config+0x1bc>)
 800400a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800400c:	f003 0303 	and.w	r3, r3, #3
 8004010:	2b03      	cmp	r3, #3
 8004012:	f000 80a7 	beq.w	8004164 <RCCEx_PLL3_Config+0x1b8>


  else
  {
    /* Disable  PLL3. */
    __HAL_RCC_PLL3_DISABLE();
 8004016:	4a54      	ldr	r2, [pc, #336]	@ (8004168 <RCCEx_PLL3_Config+0x1bc>)
 8004018:	6813      	ldr	r3, [r2, #0]
 800401a:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 800401e:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8004020:	f7fd f9ea 	bl	80013f8 <HAL_GetTick>
 8004024:	4605      	mov	r5, r0
    /* Wait till PLL3 is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 8004026:	4b50      	ldr	r3, [pc, #320]	@ (8004168 <RCCEx_PLL3_Config+0x1bc>)
 8004028:	681b      	ldr	r3, [r3, #0]
 800402a:	f013 5f00 	tst.w	r3, #536870912	@ 0x20000000
 800402e:	d036      	beq.n	800409e <RCCEx_PLL3_Config+0xf2>
    {
      if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
 8004030:	f7fd f9e2 	bl	80013f8 <HAL_GetTick>
 8004034:	1b43      	subs	r3, r0, r5
 8004036:	2b02      	cmp	r3, #2
 8004038:	d9f5      	bls.n	8004026 <RCCEx_PLL3_Config+0x7a>
      {
        return HAL_TIMEOUT;
 800403a:	2003      	movs	r0, #3
 800403c:	e093      	b.n	8004166 <RCCEx_PLL3_Config+0x1ba>
  assert_param(IS_RCC_PLL3M_VALUE(pll3->PLL3M));
 800403e:	f640 61da 	movw	r1, #3802	@ 0xeda
 8004042:	484a      	ldr	r0, [pc, #296]	@ (800416c <RCCEx_PLL3_Config+0x1c0>)
 8004044:	f7fc fd46 	bl	8000ad4 <assert_failed>
 8004048:	e7b7      	b.n	8003fba <RCCEx_PLL3_Config+0xe>
  assert_param(IS_RCC_PLL3N_VALUE(pll3->PLL3N));
 800404a:	f640 61db 	movw	r1, #3803	@ 0xedb
 800404e:	4847      	ldr	r0, [pc, #284]	@ (800416c <RCCEx_PLL3_Config+0x1c0>)
 8004050:	f7fc fd40 	bl	8000ad4 <assert_failed>
 8004054:	e7b6      	b.n	8003fc4 <RCCEx_PLL3_Config+0x18>
  assert_param(IS_RCC_PLL3P_VALUE(pll3->PLL3P));
 8004056:	f640 61dc 	movw	r1, #3804	@ 0xedc
 800405a:	4844      	ldr	r0, [pc, #272]	@ (800416c <RCCEx_PLL3_Config+0x1c0>)
 800405c:	f7fc fd3a 	bl	8000ad4 <assert_failed>
 8004060:	e7b4      	b.n	8003fcc <RCCEx_PLL3_Config+0x20>
  assert_param(IS_RCC_PLL3R_VALUE(pll3->PLL3R));
 8004062:	f640 61dd 	movw	r1, #3805	@ 0xedd
 8004066:	4841      	ldr	r0, [pc, #260]	@ (800416c <RCCEx_PLL3_Config+0x1c0>)
 8004068:	f7fc fd34 	bl	8000ad4 <assert_failed>
 800406c:	e7b2      	b.n	8003fd4 <RCCEx_PLL3_Config+0x28>
  assert_param(IS_RCC_PLL3Q_VALUE(pll3->PLL3Q));
 800406e:	f640 61de 	movw	r1, #3806	@ 0xede
 8004072:	483e      	ldr	r0, [pc, #248]	@ (800416c <RCCEx_PLL3_Config+0x1c0>)
 8004074:	f7fc fd2e 	bl	8000ad4 <assert_failed>
 8004078:	e7b0      	b.n	8003fdc <RCCEx_PLL3_Config+0x30>
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
 800407a:	f640 61df 	movw	r1, #3807	@ 0xedf
 800407e:	483b      	ldr	r0, [pc, #236]	@ (800416c <RCCEx_PLL3_Config+0x1c0>)
 8004080:	f7fc fd28 	bl	8000ad4 <assert_failed>
 8004084:	e7b6      	b.n	8003ff4 <RCCEx_PLL3_Config+0x48>
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
 8004086:	f44f 616e 	mov.w	r1, #3808	@ 0xee0
 800408a:	4838      	ldr	r0, [pc, #224]	@ (800416c <RCCEx_PLL3_Config+0x1c0>)
 800408c:	f7fc fd22 	bl	8000ad4 <assert_failed>
 8004090:	e7b6      	b.n	8004000 <RCCEx_PLL3_Config+0x54>
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));
 8004092:	f640 61e1 	movw	r1, #3809	@ 0xee1
 8004096:	4835      	ldr	r0, [pc, #212]	@ (800416c <RCCEx_PLL3_Config+0x1c0>)
 8004098:	f7fc fd1c 	bl	8000ad4 <assert_failed>
 800409c:	e7b4      	b.n	8004008 <RCCEx_PLL3_Config+0x5c>
      }
    }

    /* Configure the PLL3  multiplication and division factors. */
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
 800409e:	4b32      	ldr	r3, [pc, #200]	@ (8004168 <RCCEx_PLL3_Config+0x1bc>)
 80040a0:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 80040a2:	f022 727c 	bic.w	r2, r2, #66060288	@ 0x3f00000
 80040a6:	6821      	ldr	r1, [r4, #0]
 80040a8:	ea42 5201 	orr.w	r2, r2, r1, lsl #20
 80040ac:	629a      	str	r2, [r3, #40]	@ 0x28
 80040ae:	6862      	ldr	r2, [r4, #4]
 80040b0:	3a01      	subs	r2, #1
 80040b2:	f3c2 0208 	ubfx	r2, r2, #0, #9
 80040b6:	68a1      	ldr	r1, [r4, #8]
 80040b8:	3901      	subs	r1, #1
 80040ba:	0249      	lsls	r1, r1, #9
 80040bc:	b289      	uxth	r1, r1
 80040be:	430a      	orrs	r2, r1
 80040c0:	68e1      	ldr	r1, [r4, #12]
 80040c2:	3901      	subs	r1, #1
 80040c4:	0409      	lsls	r1, r1, #16
 80040c6:	f401 01fe 	and.w	r1, r1, #8323072	@ 0x7f0000
 80040ca:	430a      	orrs	r2, r1
 80040cc:	6921      	ldr	r1, [r4, #16]
 80040ce:	3901      	subs	r1, #1
 80040d0:	0609      	lsls	r1, r1, #24
 80040d2:	f001 41fe 	and.w	r1, r1, #2130706432	@ 0x7f000000
 80040d6:	430a      	orrs	r2, r1
 80040d8:	641a      	str	r2, [r3, #64]	@ 0x40
                          pll3->PLL3P,
                          pll3->PLL3Q,
                          pll3->PLL3R);

    /* Select PLL3 input reference frequency range: VCI */
    __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
 80040da:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 80040dc:	f422 6240 	bic.w	r2, r2, #3072	@ 0xc00
 80040e0:	6961      	ldr	r1, [r4, #20]
 80040e2:	430a      	orrs	r2, r1
 80040e4:	62da      	str	r2, [r3, #44]	@ 0x2c

    /* Select PLL3 output frequency range : VCO */
    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;
 80040e6:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 80040e8:	f422 7200 	bic.w	r2, r2, #512	@ 0x200
 80040ec:	69a1      	ldr	r1, [r4, #24]
 80040ee:	430a      	orrs	r2, r1
 80040f0:	62da      	str	r2, [r3, #44]	@ 0x2c

    /* Disable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_DISABLE();
 80040f2:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 80040f4:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
 80040f8:	62da      	str	r2, [r3, #44]	@ 0x2c

    /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
 80040fa:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80040fc:	f36f 02cf 	bfc	r2, #3, #13
 8004100:	69e1      	ldr	r1, [r4, #28]
 8004102:	ea42 02c1 	orr.w	r2, r2, r1, lsl #3
 8004106:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Enable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_ENABLE();
 8004108:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800410a:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 800410e:	62da      	str	r2, [r3, #44]	@ 0x2c

    /* Enable the PLL3 clock output */
    if (Divider == DIVIDER_P_UPDATE)
 8004110:	b9c6      	cbnz	r6, 8004144 <RCCEx_PLL3_Config+0x198>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
 8004112:	461a      	mov	r2, r3
 8004114:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8004116:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 800411a:	62d3      	str	r3, [r2, #44]	@ 0x2c
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
    }

    /* Enable  PLL3. */
    __HAL_RCC_PLL3_ENABLE();
 800411c:	4a12      	ldr	r2, [pc, #72]	@ (8004168 <RCCEx_PLL3_Config+0x1bc>)
 800411e:	6813      	ldr	r3, [r2, #0]
 8004120:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8004124:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8004126:	f7fd f967 	bl	80013f8 <HAL_GetTick>
 800412a:	4604      	mov	r4, r0

    /* Wait till PLL3 is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 800412c:	4b0e      	ldr	r3, [pc, #56]	@ (8004168 <RCCEx_PLL3_Config+0x1bc>)
 800412e:	681b      	ldr	r3, [r3, #0]
 8004130:	f013 5f00 	tst.w	r3, #536870912	@ 0x20000000
 8004134:	d114      	bne.n	8004160 <RCCEx_PLL3_Config+0x1b4>
    {
      if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
 8004136:	f7fd f95f 	bl	80013f8 <HAL_GetTick>
 800413a:	1b00      	subs	r0, r0, r4
 800413c:	2802      	cmp	r0, #2
 800413e:	d9f5      	bls.n	800412c <RCCEx_PLL3_Config+0x180>
      {
        return HAL_TIMEOUT;
 8004140:	2003      	movs	r0, #3
 8004142:	e010      	b.n	8004166 <RCCEx_PLL3_Config+0x1ba>
    else if (Divider == DIVIDER_Q_UPDATE)
 8004144:	2e01      	cmp	r6, #1
 8004146:	d005      	beq.n	8004154 <RCCEx_PLL3_Config+0x1a8>
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
 8004148:	4a07      	ldr	r2, [pc, #28]	@ (8004168 <RCCEx_PLL3_Config+0x1bc>)
 800414a:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 800414c:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8004150:	62d3      	str	r3, [r2, #44]	@ 0x2c
 8004152:	e7e3      	b.n	800411c <RCCEx_PLL3_Config+0x170>
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
 8004154:	4a04      	ldr	r2, [pc, #16]	@ (8004168 <RCCEx_PLL3_Config+0x1bc>)
 8004156:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 8004158:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
 800415c:	62d3      	str	r3, [r2, #44]	@ 0x2c
 800415e:	e7dd      	b.n	800411c <RCCEx_PLL3_Config+0x170>
    }

  }


  return status;
 8004160:	2000      	movs	r0, #0
 8004162:	e000      	b.n	8004166 <RCCEx_PLL3_Config+0x1ba>
    return HAL_ERROR;
 8004164:	2001      	movs	r0, #1
}
 8004166:	bd70      	pop	{r4, r5, r6, pc}
 8004168:	58024400 	.word	0x58024400
 800416c:	08015578 	.word	0x08015578

08004170 <HAL_RCCEx_PeriphCLKConfig>:
{
 8004170:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004172:	4604      	mov	r4, r0
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 8004174:	6803      	ldr	r3, [r0, #0]
 8004176:	f013 6f00 	tst.w	r3, #134217728	@ 0x8000000
 800417a:	d030      	beq.n	80041de <HAL_RCCEx_PeriphCLKConfig+0x6e>
    switch (PeriphClkInit->SpdifrxClockSelection)
 800417c:	6e83      	ldr	r3, [r0, #104]	@ 0x68
 800417e:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8004182:	d026      	beq.n	80041d2 <HAL_RCCEx_PeriphCLKConfig+0x62>
 8004184:	d80e      	bhi.n	80041a4 <HAL_RCCEx_PeriphCLKConfig+0x34>
 8004186:	b1ab      	cbz	r3, 80041b4 <HAL_RCCEx_PeriphCLKConfig+0x44>
 8004188:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 800418c:	d107      	bne.n	800419e <HAL_RCCEx_PeriphCLKConfig+0x2e>
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 800418e:	2102      	movs	r1, #2
 8004190:	3008      	adds	r0, #8
 8004192:	f7ff fe2d 	bl	8003df0 <RCCEx_PLL2_Config>
 8004196:	4605      	mov	r5, r0
    if (ret == HAL_OK)
 8004198:	b195      	cbz	r5, 80041c0 <HAL_RCCEx_PeriphCLKConfig+0x50>
      status = ret;
 800419a:	462e      	mov	r6, r5
 800419c:	e021      	b.n	80041e2 <HAL_RCCEx_PeriphCLKConfig+0x72>
    switch (PeriphClkInit->SpdifrxClockSelection)
 800419e:	2601      	movs	r6, #1
 80041a0:	4635      	mov	r5, r6
 80041a2:	e01e      	b.n	80041e2 <HAL_RCCEx_PeriphCLKConfig+0x72>
 80041a4:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 80041a8:	d101      	bne.n	80041ae <HAL_RCCEx_PeriphCLKConfig+0x3e>
 80041aa:	2500      	movs	r5, #0
 80041ac:	e008      	b.n	80041c0 <HAL_RCCEx_PeriphCLKConfig+0x50>
 80041ae:	2601      	movs	r6, #1
 80041b0:	4635      	mov	r5, r6
 80041b2:	e016      	b.n	80041e2 <HAL_RCCEx_PeriphCLKConfig+0x72>
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 80041b4:	4a9e      	ldr	r2, [pc, #632]	@ (8004430 <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 80041b6:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 80041b8:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 80041bc:	62d3      	str	r3, [r2, #44]	@ 0x2c
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
 80041be:	2500      	movs	r5, #0
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
 80041c0:	4a9b      	ldr	r2, [pc, #620]	@ (8004430 <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 80041c2:	6d13      	ldr	r3, [r2, #80]	@ 0x50
 80041c4:	f423 1340 	bic.w	r3, r3, #3145728	@ 0x300000
 80041c8:	6ea1      	ldr	r1, [r4, #104]	@ 0x68
 80041ca:	430b      	orrs	r3, r1
 80041cc:	6513      	str	r3, [r2, #80]	@ 0x50
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 80041ce:	2600      	movs	r6, #0
 80041d0:	e007      	b.n	80041e2 <HAL_RCCEx_PeriphCLKConfig+0x72>
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 80041d2:	2102      	movs	r1, #2
 80041d4:	3028      	adds	r0, #40	@ 0x28
 80041d6:	f7ff fee9 	bl	8003fac <RCCEx_PLL3_Config>
 80041da:	4605      	mov	r5, r0
        break;
 80041dc:	e7dc      	b.n	8004198 <HAL_RCCEx_PeriphCLKConfig+0x28>
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 80041de:	2600      	movs	r6, #0
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
 80041e0:	4635      	mov	r5, r6
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
 80041e2:	6823      	ldr	r3, [r4, #0]
 80041e4:	f413 7f80 	tst.w	r3, #256	@ 0x100
 80041e8:	d014      	beq.n	8004214 <HAL_RCCEx_PeriphCLKConfig+0xa4>
    switch (PeriphClkInit->Sai1ClockSelection)
 80041ea:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 80041ec:	2b04      	cmp	r3, #4
 80041ee:	d831      	bhi.n	8004254 <HAL_RCCEx_PeriphCLKConfig+0xe4>
 80041f0:	e8df f003 	tbb	[pc, r3]
 80041f4:	08292203 	.word	0x08292203
 80041f8:	08          	.byte	0x08
 80041f9:	00          	.byte	0x00
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 80041fa:	4a8d      	ldr	r2, [pc, #564]	@ (8004430 <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 80041fc:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 80041fe:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8004202:	62d3      	str	r3, [r2, #44]	@ 0x2c
    if (ret == HAL_OK)
 8004204:	bb4d      	cbnz	r5, 800425a <HAL_RCCEx_PeriphCLKConfig+0xea>
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8004206:	4a8a      	ldr	r2, [pc, #552]	@ (8004430 <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 8004208:	6d13      	ldr	r3, [r2, #80]	@ 0x50
 800420a:	f023 0307 	bic.w	r3, r3, #7
 800420e:	6da1      	ldr	r1, [r4, #88]	@ 0x58
 8004210:	430b      	orrs	r3, r1
 8004212:	6513      	str	r3, [r2, #80]	@ 0x50
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)
 8004214:	6823      	ldr	r3, [r4, #0]
 8004216:	f413 7f00 	tst.w	r3, #512	@ 0x200
 800421a:	d038      	beq.n	800428e <HAL_RCCEx_PeriphCLKConfig+0x11e>
    switch (PeriphClkInit->Sai23ClockSelection)
 800421c:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 800421e:	2b80      	cmp	r3, #128	@ 0x80
 8004220:	d04a      	beq.n	80042b8 <HAL_RCCEx_PeriphCLKConfig+0x148>
 8004222:	d81f      	bhi.n	8004264 <HAL_RCCEx_PeriphCLKConfig+0xf4>
 8004224:	b333      	cbz	r3, 8004274 <HAL_RCCEx_PeriphCLKConfig+0x104>
 8004226:	2b40      	cmp	r3, #64	@ 0x40
 8004228:	d119      	bne.n	800425e <HAL_RCCEx_PeriphCLKConfig+0xee>
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 800422a:	2100      	movs	r1, #0
 800422c:	f104 0008 	add.w	r0, r4, #8
 8004230:	f7ff fdde 	bl	8003df0 <RCCEx_PLL2_Config>
 8004234:	4605      	mov	r5, r0
        break;
 8004236:	e022      	b.n	800427e <HAL_RCCEx_PeriphCLKConfig+0x10e>
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8004238:	2100      	movs	r1, #0
 800423a:	f104 0008 	add.w	r0, r4, #8
 800423e:	f7ff fdd7 	bl	8003df0 <RCCEx_PLL2_Config>
 8004242:	4605      	mov	r5, r0
        break;
 8004244:	e7de      	b.n	8004204 <HAL_RCCEx_PeriphCLKConfig+0x94>
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 8004246:	2100      	movs	r1, #0
 8004248:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 800424c:	f7ff feae 	bl	8003fac <RCCEx_PLL3_Config>
 8004250:	4605      	mov	r5, r0
        break;
 8004252:	e7d7      	b.n	8004204 <HAL_RCCEx_PeriphCLKConfig+0x94>
    switch (PeriphClkInit->Sai1ClockSelection)
 8004254:	2601      	movs	r6, #1
 8004256:	4635      	mov	r5, r6
 8004258:	e7dc      	b.n	8004214 <HAL_RCCEx_PeriphCLKConfig+0xa4>
      status = ret;
 800425a:	462e      	mov	r6, r5
 800425c:	e7da      	b.n	8004214 <HAL_RCCEx_PeriphCLKConfig+0xa4>
    switch (PeriphClkInit->Sai23ClockSelection)
 800425e:	2601      	movs	r6, #1
 8004260:	4635      	mov	r5, r6
 8004262:	e014      	b.n	800428e <HAL_RCCEx_PeriphCLKConfig+0x11e>
 8004264:	2bc0      	cmp	r3, #192	@ 0xc0
 8004266:	d00a      	beq.n	800427e <HAL_RCCEx_PeriphCLKConfig+0x10e>
 8004268:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800426c:	d007      	beq.n	800427e <HAL_RCCEx_PeriphCLKConfig+0x10e>
 800426e:	2601      	movs	r6, #1
 8004270:	4635      	mov	r5, r6
 8004272:	e00c      	b.n	800428e <HAL_RCCEx_PeriphCLKConfig+0x11e>
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8004274:	4a6e      	ldr	r2, [pc, #440]	@ (8004430 <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 8004276:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 8004278:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800427c:	62d3      	str	r3, [r2, #44]	@ 0x2c
    if (ret == HAL_OK)
 800427e:	bb15      	cbnz	r5, 80042c6 <HAL_RCCEx_PeriphCLKConfig+0x156>
      __HAL_RCC_SAI23_CONFIG(PeriphClkInit->Sai23ClockSelection);
 8004280:	4a6b      	ldr	r2, [pc, #428]	@ (8004430 <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 8004282:	6d13      	ldr	r3, [r2, #80]	@ 0x50
 8004284:	f423 73e0 	bic.w	r3, r3, #448	@ 0x1c0
 8004288:	6de1      	ldr	r1, [r4, #92]	@ 0x5c
 800428a:	430b      	orrs	r3, r1
 800428c:	6513      	str	r3, [r2, #80]	@ 0x50
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)
 800428e:	6823      	ldr	r3, [r4, #0]
 8004290:	f413 6f80 	tst.w	r3, #1024	@ 0x400
 8004294:	d033      	beq.n	80042fe <HAL_RCCEx_PeriphCLKConfig+0x18e>
    switch (PeriphClkInit->Sai4AClockSelection)
 8004296:	f8d4 30a8 	ldr.w	r3, [r4, #168]	@ 0xa8
 800429a:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 800429e:	d043      	beq.n	8004328 <HAL_RCCEx_PeriphCLKConfig+0x1b8>
 80042a0:	d816      	bhi.n	80042d0 <HAL_RCCEx_PeriphCLKConfig+0x160>
 80042a2:	b1f3      	cbz	r3, 80042e2 <HAL_RCCEx_PeriphCLKConfig+0x172>
 80042a4:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 80042a8:	d10f      	bne.n	80042ca <HAL_RCCEx_PeriphCLKConfig+0x15a>
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 80042aa:	2100      	movs	r1, #0
 80042ac:	f104 0008 	add.w	r0, r4, #8
 80042b0:	f7ff fd9e 	bl	8003df0 <RCCEx_PLL2_Config>
 80042b4:	4605      	mov	r5, r0
        break;
 80042b6:	e019      	b.n	80042ec <HAL_RCCEx_PeriphCLKConfig+0x17c>
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 80042b8:	2100      	movs	r1, #0
 80042ba:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 80042be:	f7ff fe75 	bl	8003fac <RCCEx_PLL3_Config>
 80042c2:	4605      	mov	r5, r0
        break;
 80042c4:	e7db      	b.n	800427e <HAL_RCCEx_PeriphCLKConfig+0x10e>
      status = ret;
 80042c6:	462e      	mov	r6, r5
 80042c8:	e7e1      	b.n	800428e <HAL_RCCEx_PeriphCLKConfig+0x11e>
    switch (PeriphClkInit->Sai4AClockSelection)
 80042ca:	2601      	movs	r6, #1
 80042cc:	4635      	mov	r5, r6
 80042ce:	e016      	b.n	80042fe <HAL_RCCEx_PeriphCLKConfig+0x18e>
 80042d0:	f5b3 0fc0 	cmp.w	r3, #6291456	@ 0x600000
 80042d4:	d00a      	beq.n	80042ec <HAL_RCCEx_PeriphCLKConfig+0x17c>
 80042d6:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 80042da:	d007      	beq.n	80042ec <HAL_RCCEx_PeriphCLKConfig+0x17c>
 80042dc:	2601      	movs	r6, #1
 80042de:	4635      	mov	r5, r6
 80042e0:	e00d      	b.n	80042fe <HAL_RCCEx_PeriphCLKConfig+0x18e>
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 80042e2:	4a53      	ldr	r2, [pc, #332]	@ (8004430 <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 80042e4:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 80042e6:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 80042ea:	62d3      	str	r3, [r2, #44]	@ 0x2c
    if (ret == HAL_OK)
 80042ec:	bb1d      	cbnz	r5, 8004336 <HAL_RCCEx_PeriphCLKConfig+0x1c6>
      __HAL_RCC_SAI4A_CONFIG(PeriphClkInit->Sai4AClockSelection);
 80042ee:	4a50      	ldr	r2, [pc, #320]	@ (8004430 <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 80042f0:	6d93      	ldr	r3, [r2, #88]	@ 0x58
 80042f2:	f423 0360 	bic.w	r3, r3, #14680064	@ 0xe00000
 80042f6:	f8d4 10a8 	ldr.w	r1, [r4, #168]	@ 0xa8
 80042fa:	430b      	orrs	r3, r1
 80042fc:	6593      	str	r3, [r2, #88]	@ 0x58
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)
 80042fe:	6823      	ldr	r3, [r4, #0]
 8004300:	f413 6f00 	tst.w	r3, #2048	@ 0x800
 8004304:	d034      	beq.n	8004370 <HAL_RCCEx_PeriphCLKConfig+0x200>
    switch (PeriphClkInit->Sai4BClockSelection)
 8004306:	f8d4 30ac 	ldr.w	r3, [r4, #172]	@ 0xac
 800430a:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 800430e:	d05b      	beq.n	80043c8 <HAL_RCCEx_PeriphCLKConfig+0x258>
 8004310:	d816      	bhi.n	8004340 <HAL_RCCEx_PeriphCLKConfig+0x1d0>
 8004312:	b1f3      	cbz	r3, 8004352 <HAL_RCCEx_PeriphCLKConfig+0x1e2>
 8004314:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 8004318:	d10f      	bne.n	800433a <HAL_RCCEx_PeriphCLKConfig+0x1ca>
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 800431a:	2100      	movs	r1, #0
 800431c:	f104 0008 	add.w	r0, r4, #8
 8004320:	f7ff fd66 	bl	8003df0 <RCCEx_PLL2_Config>
 8004324:	4605      	mov	r5, r0
        break;
 8004326:	e019      	b.n	800435c <HAL_RCCEx_PeriphCLKConfig+0x1ec>
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 8004328:	2100      	movs	r1, #0
 800432a:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 800432e:	f7ff fe3d 	bl	8003fac <RCCEx_PLL3_Config>
 8004332:	4605      	mov	r5, r0
        break;
 8004334:	e7da      	b.n	80042ec <HAL_RCCEx_PeriphCLKConfig+0x17c>
      status = ret;
 8004336:	462e      	mov	r6, r5
 8004338:	e7e1      	b.n	80042fe <HAL_RCCEx_PeriphCLKConfig+0x18e>
    switch (PeriphClkInit->Sai4BClockSelection)
 800433a:	2601      	movs	r6, #1
 800433c:	4635      	mov	r5, r6
 800433e:	e017      	b.n	8004370 <HAL_RCCEx_PeriphCLKConfig+0x200>
 8004340:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 8004344:	d00a      	beq.n	800435c <HAL_RCCEx_PeriphCLKConfig+0x1ec>
 8004346:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 800434a:	d007      	beq.n	800435c <HAL_RCCEx_PeriphCLKConfig+0x1ec>
 800434c:	2601      	movs	r6, #1
 800434e:	4635      	mov	r5, r6
 8004350:	e00e      	b.n	8004370 <HAL_RCCEx_PeriphCLKConfig+0x200>
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8004352:	4a37      	ldr	r2, [pc, #220]	@ (8004430 <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 8004354:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 8004356:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800435a:	62d3      	str	r3, [r2, #44]	@ 0x2c
    if (ret == HAL_OK)
 800435c:	2d00      	cmp	r5, #0
 800435e:	d13a      	bne.n	80043d6 <HAL_RCCEx_PeriphCLKConfig+0x266>
      __HAL_RCC_SAI4B_CONFIG(PeriphClkInit->Sai4BClockSelection);
 8004360:	4a33      	ldr	r2, [pc, #204]	@ (8004430 <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 8004362:	6d93      	ldr	r3, [r2, #88]	@ 0x58
 8004364:	f023 63e0 	bic.w	r3, r3, #117440512	@ 0x7000000
 8004368:	f8d4 10ac 	ldr.w	r1, [r4, #172]	@ 0xac
 800436c:	430b      	orrs	r3, r1
 800436e:	6593      	str	r3, [r2, #88]	@ 0x58
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
 8004370:	6823      	ldr	r3, [r4, #0]
 8004372:	f013 7f00 	tst.w	r3, #33554432	@ 0x2000000
 8004376:	d013      	beq.n	80043a0 <HAL_RCCEx_PeriphCLKConfig+0x230>
    switch (PeriphClkInit->QspiClockSelection)
 8004378:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 800437a:	2b20      	cmp	r3, #32
 800437c:	d035      	beq.n	80043ea <HAL_RCCEx_PeriphCLKConfig+0x27a>
 800437e:	d82f      	bhi.n	80043e0 <HAL_RCCEx_PeriphCLKConfig+0x270>
 8004380:	b133      	cbz	r3, 8004390 <HAL_RCCEx_PeriphCLKConfig+0x220>
 8004382:	2b10      	cmp	r3, #16
 8004384:	d129      	bne.n	80043da <HAL_RCCEx_PeriphCLKConfig+0x26a>
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8004386:	4a2a      	ldr	r2, [pc, #168]	@ (8004430 <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 8004388:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 800438a:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800438e:	62d3      	str	r3, [r2, #44]	@ 0x2c
    if (ret == HAL_OK)
 8004390:	bb95      	cbnz	r5, 80043f8 <HAL_RCCEx_PeriphCLKConfig+0x288>
      __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
 8004392:	4a27      	ldr	r2, [pc, #156]	@ (8004430 <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 8004394:	6cd3      	ldr	r3, [r2, #76]	@ 0x4c
 8004396:	f023 0330 	bic.w	r3, r3, #48	@ 0x30
 800439a:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
 800439c:	430b      	orrs	r3, r1
 800439e:	64d3      	str	r3, [r2, #76]	@ 0x4c
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)
 80043a0:	6823      	ldr	r3, [r4, #0]
 80043a2:	f413 5f80 	tst.w	r3, #4096	@ 0x1000
 80043a6:	d04d      	beq.n	8004444 <HAL_RCCEx_PeriphCLKConfig+0x2d4>
    switch (PeriphClkInit->Spi123ClockSelection)
 80043a8:	6e23      	ldr	r3, [r4, #96]	@ 0x60
 80043aa:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 80043ae:	d041      	beq.n	8004434 <HAL_RCCEx_PeriphCLKConfig+0x2c4>
 80043b0:	d827      	bhi.n	8004402 <HAL_RCCEx_PeriphCLKConfig+0x292>
 80043b2:	b37b      	cbz	r3, 8004414 <HAL_RCCEx_PeriphCLKConfig+0x2a4>
 80043b4:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 80043b8:	d120      	bne.n	80043fc <HAL_RCCEx_PeriphCLKConfig+0x28c>
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 80043ba:	2100      	movs	r1, #0
 80043bc:	f104 0008 	add.w	r0, r4, #8
 80043c0:	f7ff fd16 	bl	8003df0 <RCCEx_PLL2_Config>
 80043c4:	4605      	mov	r5, r0
        break;
 80043c6:	e02a      	b.n	800441e <HAL_RCCEx_PeriphCLKConfig+0x2ae>
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 80043c8:	2100      	movs	r1, #0
 80043ca:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 80043ce:	f7ff fded 	bl	8003fac <RCCEx_PLL3_Config>
 80043d2:	4605      	mov	r5, r0
        break;
 80043d4:	e7c2      	b.n	800435c <HAL_RCCEx_PeriphCLKConfig+0x1ec>
      status = ret;
 80043d6:	462e      	mov	r6, r5
 80043d8:	e7ca      	b.n	8004370 <HAL_RCCEx_PeriphCLKConfig+0x200>
    switch (PeriphClkInit->QspiClockSelection)
 80043da:	2601      	movs	r6, #1
 80043dc:	4635      	mov	r5, r6
 80043de:	e7df      	b.n	80043a0 <HAL_RCCEx_PeriphCLKConfig+0x230>
 80043e0:	2b30      	cmp	r3, #48	@ 0x30
 80043e2:	d0d5      	beq.n	8004390 <HAL_RCCEx_PeriphCLKConfig+0x220>
 80043e4:	2601      	movs	r6, #1
 80043e6:	4635      	mov	r5, r6
 80043e8:	e7da      	b.n	80043a0 <HAL_RCCEx_PeriphCLKConfig+0x230>
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 80043ea:	2102      	movs	r1, #2
 80043ec:	f104 0008 	add.w	r0, r4, #8
 80043f0:	f7ff fcfe 	bl	8003df0 <RCCEx_PLL2_Config>
 80043f4:	4605      	mov	r5, r0
        break;
 80043f6:	e7cb      	b.n	8004390 <HAL_RCCEx_PeriphCLKConfig+0x220>
      status = ret;
 80043f8:	462e      	mov	r6, r5
 80043fa:	e7d1      	b.n	80043a0 <HAL_RCCEx_PeriphCLKConfig+0x230>
    switch (PeriphClkInit->Spi123ClockSelection)
 80043fc:	2601      	movs	r6, #1
 80043fe:	4635      	mov	r5, r6
 8004400:	e020      	b.n	8004444 <HAL_RCCEx_PeriphCLKConfig+0x2d4>
 8004402:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8004406:	d00a      	beq.n	800441e <HAL_RCCEx_PeriphCLKConfig+0x2ae>
 8004408:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 800440c:	d007      	beq.n	800441e <HAL_RCCEx_PeriphCLKConfig+0x2ae>
 800440e:	2601      	movs	r6, #1
 8004410:	4635      	mov	r5, r6
 8004412:	e017      	b.n	8004444 <HAL_RCCEx_PeriphCLKConfig+0x2d4>
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8004414:	4a06      	ldr	r2, [pc, #24]	@ (8004430 <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 8004416:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 8004418:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800441c:	62d3      	str	r3, [r2, #44]	@ 0x2c
    if (ret == HAL_OK)
 800441e:	b985      	cbnz	r5, 8004442 <HAL_RCCEx_PeriphCLKConfig+0x2d2>
      __HAL_RCC_SPI123_CONFIG(PeriphClkInit->Spi123ClockSelection);
 8004420:	4a03      	ldr	r2, [pc, #12]	@ (8004430 <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 8004422:	6d13      	ldr	r3, [r2, #80]	@ 0x50
 8004424:	f423 43e0 	bic.w	r3, r3, #28672	@ 0x7000
 8004428:	6e21      	ldr	r1, [r4, #96]	@ 0x60
 800442a:	430b      	orrs	r3, r1
 800442c:	6513      	str	r3, [r2, #80]	@ 0x50
 800442e:	e009      	b.n	8004444 <HAL_RCCEx_PeriphCLKConfig+0x2d4>
 8004430:	58024400 	.word	0x58024400
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 8004434:	2100      	movs	r1, #0
 8004436:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 800443a:	f7ff fdb7 	bl	8003fac <RCCEx_PLL3_Config>
 800443e:	4605      	mov	r5, r0
        break;
 8004440:	e7ed      	b.n	800441e <HAL_RCCEx_PeriphCLKConfig+0x2ae>
      status = ret;
 8004442:	462e      	mov	r6, r5
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
 8004444:	6823      	ldr	r3, [r4, #0]
 8004446:	f413 5f00 	tst.w	r3, #8192	@ 0x2000
 800444a:	d017      	beq.n	800447c <HAL_RCCEx_PeriphCLKConfig+0x30c>
    switch (PeriphClkInit->Spi45ClockSelection)
 800444c:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 800444e:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8004452:	d04f      	beq.n	80044f4 <HAL_RCCEx_PeriphCLKConfig+0x384>
 8004454:	d842      	bhi.n	80044dc <HAL_RCCEx_PeriphCLKConfig+0x36c>
 8004456:	b143      	cbz	r3, 800446a <HAL_RCCEx_PeriphCLKConfig+0x2fa>
 8004458:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800445c:	d13b      	bne.n	80044d6 <HAL_RCCEx_PeriphCLKConfig+0x366>
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 800445e:	2101      	movs	r1, #1
 8004460:	f104 0008 	add.w	r0, r4, #8
 8004464:	f7ff fcc4 	bl	8003df0 <RCCEx_PLL2_Config>
 8004468:	4605      	mov	r5, r0
    if (ret == HAL_OK)
 800446a:	2d00      	cmp	r5, #0
 800446c:	d149      	bne.n	8004502 <HAL_RCCEx_PeriphCLKConfig+0x392>
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
 800446e:	4a44      	ldr	r2, [pc, #272]	@ (8004580 <HAL_RCCEx_PeriphCLKConfig+0x410>)
 8004470:	6d13      	ldr	r3, [r2, #80]	@ 0x50
 8004472:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
 8004476:	6e61      	ldr	r1, [r4, #100]	@ 0x64
 8004478:	430b      	orrs	r3, r1
 800447a:	6513      	str	r3, [r2, #80]	@ 0x50
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
 800447c:	6823      	ldr	r3, [r4, #0]
 800447e:	f413 4f80 	tst.w	r3, #16384	@ 0x4000
 8004482:	d019      	beq.n	80044b8 <HAL_RCCEx_PeriphCLKConfig+0x348>
    switch (PeriphClkInit->Spi6ClockSelection)
 8004484:	f8d4 30b0 	ldr.w	r3, [r4, #176]	@ 0xb0
 8004488:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800448c:	d04a      	beq.n	8004524 <HAL_RCCEx_PeriphCLKConfig+0x3b4>
 800448e:	d83d      	bhi.n	800450c <HAL_RCCEx_PeriphCLKConfig+0x39c>
 8004490:	b143      	cbz	r3, 80044a4 <HAL_RCCEx_PeriphCLKConfig+0x334>
 8004492:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8004496:	d136      	bne.n	8004506 <HAL_RCCEx_PeriphCLKConfig+0x396>
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 8004498:	2101      	movs	r1, #1
 800449a:	f104 0008 	add.w	r0, r4, #8
 800449e:	f7ff fca7 	bl	8003df0 <RCCEx_PLL2_Config>
 80044a2:	4605      	mov	r5, r0
    if (ret == HAL_OK)
 80044a4:	2d00      	cmp	r5, #0
 80044a6:	d144      	bne.n	8004532 <HAL_RCCEx_PeriphCLKConfig+0x3c2>
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
 80044a8:	4a35      	ldr	r2, [pc, #212]	@ (8004580 <HAL_RCCEx_PeriphCLKConfig+0x410>)
 80044aa:	6d93      	ldr	r3, [r2, #88]	@ 0x58
 80044ac:	f023 43e0 	bic.w	r3, r3, #1879048192	@ 0x70000000
 80044b0:	f8d4 10b0 	ldr.w	r1, [r4, #176]	@ 0xb0
 80044b4:	430b      	orrs	r3, r1
 80044b6:	6593      	str	r3, [r2, #88]	@ 0x58
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
 80044b8:	6823      	ldr	r3, [r4, #0]
 80044ba:	f413 4f00 	tst.w	r3, #32768	@ 0x8000
 80044be:	d047      	beq.n	8004550 <HAL_RCCEx_PeriphCLKConfig+0x3e0>
    switch (PeriphClkInit->FdcanClockSelection)
 80044c0:	6f23      	ldr	r3, [r4, #112]	@ 0x70
 80044c2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 80044c6:	d036      	beq.n	8004536 <HAL_RCCEx_PeriphCLKConfig+0x3c6>
 80044c8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 80044cc:	d04e      	beq.n	800456c <HAL_RCCEx_PeriphCLKConfig+0x3fc>
 80044ce:	b3bb      	cbz	r3, 8004540 <HAL_RCCEx_PeriphCLKConfig+0x3d0>
 80044d0:	2601      	movs	r6, #1
 80044d2:	4635      	mov	r5, r6
 80044d4:	e03c      	b.n	8004550 <HAL_RCCEx_PeriphCLKConfig+0x3e0>
    switch (PeriphClkInit->Spi45ClockSelection)
 80044d6:	2601      	movs	r6, #1
 80044d8:	4635      	mov	r5, r6
 80044da:	e7cf      	b.n	800447c <HAL_RCCEx_PeriphCLKConfig+0x30c>
 80044dc:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 80044e0:	d0c3      	beq.n	800446a <HAL_RCCEx_PeriphCLKConfig+0x2fa>
 80044e2:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 80044e6:	d0c0      	beq.n	800446a <HAL_RCCEx_PeriphCLKConfig+0x2fa>
 80044e8:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 80044ec:	d0bd      	beq.n	800446a <HAL_RCCEx_PeriphCLKConfig+0x2fa>
 80044ee:	2601      	movs	r6, #1
 80044f0:	4635      	mov	r5, r6
 80044f2:	e7c3      	b.n	800447c <HAL_RCCEx_PeriphCLKConfig+0x30c>
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 80044f4:	2101      	movs	r1, #1
 80044f6:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 80044fa:	f7ff fd57 	bl	8003fac <RCCEx_PLL3_Config>
 80044fe:	4605      	mov	r5, r0
        break;
 8004500:	e7b3      	b.n	800446a <HAL_RCCEx_PeriphCLKConfig+0x2fa>
      status = ret;
 8004502:	462e      	mov	r6, r5
 8004504:	e7ba      	b.n	800447c <HAL_RCCEx_PeriphCLKConfig+0x30c>
    switch (PeriphClkInit->Spi6ClockSelection)
 8004506:	2601      	movs	r6, #1
 8004508:	4635      	mov	r5, r6
 800450a:	e7d5      	b.n	80044b8 <HAL_RCCEx_PeriphCLKConfig+0x348>
 800450c:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8004510:	d0c8      	beq.n	80044a4 <HAL_RCCEx_PeriphCLKConfig+0x334>
 8004512:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8004516:	d0c5      	beq.n	80044a4 <HAL_RCCEx_PeriphCLKConfig+0x334>
 8004518:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 800451c:	d0c2      	beq.n	80044a4 <HAL_RCCEx_PeriphCLKConfig+0x334>
 800451e:	2601      	movs	r6, #1
 8004520:	4635      	mov	r5, r6
 8004522:	e7c9      	b.n	80044b8 <HAL_RCCEx_PeriphCLKConfig+0x348>
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 8004524:	2101      	movs	r1, #1
 8004526:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 800452a:	f7ff fd3f 	bl	8003fac <RCCEx_PLL3_Config>
 800452e:	4605      	mov	r5, r0
        break;
 8004530:	e7b8      	b.n	80044a4 <HAL_RCCEx_PeriphCLKConfig+0x334>
      status = ret;
 8004532:	462e      	mov	r6, r5
 8004534:	e7c0      	b.n	80044b8 <HAL_RCCEx_PeriphCLKConfig+0x348>
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8004536:	4a12      	ldr	r2, [pc, #72]	@ (8004580 <HAL_RCCEx_PeriphCLKConfig+0x410>)
 8004538:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 800453a:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800453e:	62d3      	str	r3, [r2, #44]	@ 0x2c
    if (ret == HAL_OK)
 8004540:	b9dd      	cbnz	r5, 800457a <HAL_RCCEx_PeriphCLKConfig+0x40a>
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 8004542:	4a0f      	ldr	r2, [pc, #60]	@ (8004580 <HAL_RCCEx_PeriphCLKConfig+0x410>)
 8004544:	6d13      	ldr	r3, [r2, #80]	@ 0x50
 8004546:	f023 5340 	bic.w	r3, r3, #805306368	@ 0x30000000
 800454a:	6f21      	ldr	r1, [r4, #112]	@ 0x70
 800454c:	430b      	orrs	r3, r1
 800454e:	6513      	str	r3, [r2, #80]	@ 0x50
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
 8004550:	6823      	ldr	r3, [r4, #0]
 8004552:	f013 7f80 	tst.w	r3, #16777216	@ 0x1000000
 8004556:	d024      	beq.n	80045a2 <HAL_RCCEx_PeriphCLKConfig+0x432>
    switch (PeriphClkInit->FmcClockSelection)
 8004558:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 800455a:	2b03      	cmp	r3, #3
 800455c:	f200 8192 	bhi.w	8004884 <HAL_RCCEx_PeriphCLKConfig+0x714>
 8004560:	e8df f013 	tbh	[pc, r3, lsl #1]
 8004564:	00100015 	.word	0x00100015
 8004568:	00150189 	.word	0x00150189
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 800456c:	2101      	movs	r1, #1
 800456e:	f104 0008 	add.w	r0, r4, #8
 8004572:	f7ff fc3d 	bl	8003df0 <RCCEx_PLL2_Config>
 8004576:	4605      	mov	r5, r0
        break;
 8004578:	e7e2      	b.n	8004540 <HAL_RCCEx_PeriphCLKConfig+0x3d0>
      status = ret;
 800457a:	462e      	mov	r6, r5
 800457c:	e7e8      	b.n	8004550 <HAL_RCCEx_PeriphCLKConfig+0x3e0>
 800457e:	bf00      	nop
 8004580:	58024400 	.word	0x58024400
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8004584:	4ab7      	ldr	r2, [pc, #732]	@ (8004864 <HAL_RCCEx_PeriphCLKConfig+0x6f4>)
 8004586:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 8004588:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800458c:	62d3      	str	r3, [r2, #44]	@ 0x2c
    if (ret == HAL_OK)
 800458e:	2d00      	cmp	r5, #0
 8004590:	f040 817b 	bne.w	800488a <HAL_RCCEx_PeriphCLKConfig+0x71a>
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
 8004594:	4ab3      	ldr	r2, [pc, #716]	@ (8004864 <HAL_RCCEx_PeriphCLKConfig+0x6f4>)
 8004596:	6cd3      	ldr	r3, [r2, #76]	@ 0x4c
 8004598:	f023 0303 	bic.w	r3, r3, #3
 800459c:	6ca1      	ldr	r1, [r4, #72]	@ 0x48
 800459e:	430b      	orrs	r3, r1
 80045a0:	64d3      	str	r3, [r2, #76]	@ 0x4c
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 80045a2:	6823      	ldr	r3, [r4, #0]
 80045a4:	f413 0f80 	tst.w	r3, #4194304	@ 0x400000
 80045a8:	f000 818d 	beq.w	80048c6 <HAL_RCCEx_PeriphCLKConfig+0x756>
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
 80045ac:	f8d4 30b4 	ldr.w	r3, [r4, #180]	@ 0xb4
 80045b0:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80045b4:	bf18      	it	ne
 80045b6:	f5b3 7f00 	cmpne.w	r3, #512	@ 0x200
 80045ba:	f000 810d 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80045be:	f5b3 5f0c 	cmp.w	r3, #8960	@ 0x2300
 80045c2:	f000 8109 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80045c6:	f5b3 5f4c 	cmp.w	r3, #13056	@ 0x3300
 80045ca:	f000 8105 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80045ce:	f5b3 4f86 	cmp.w	r3, #17152	@ 0x4300
 80045d2:	f000 8101 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80045d6:	f5b3 4fa6 	cmp.w	r3, #21248	@ 0x5300
 80045da:	f000 80fd 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80045de:	f5b3 4fc6 	cmp.w	r3, #25344	@ 0x6300
 80045e2:	f000 80f9 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80045e6:	f5b3 4fe6 	cmp.w	r3, #29440	@ 0x7300
 80045ea:	f000 80f5 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80045ee:	f5b3 4f03 	cmp.w	r3, #33536	@ 0x8300
 80045f2:	f000 80f1 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80045f6:	f5b3 4f13 	cmp.w	r3, #37632	@ 0x9300
 80045fa:	f000 80ed 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80045fe:	f5b3 4f23 	cmp.w	r3, #41728	@ 0xa300
 8004602:	f000 80e9 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 8004606:	f5b3 4f33 	cmp.w	r3, #45824	@ 0xb300
 800460a:	f000 80e5 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 800460e:	f5b3 4f43 	cmp.w	r3, #49920	@ 0xc300
 8004612:	f000 80e1 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 8004616:	f5b3 4f53 	cmp.w	r3, #54016	@ 0xd300
 800461a:	f000 80dd 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 800461e:	f5b3 4f63 	cmp.w	r3, #58112	@ 0xe300
 8004622:	f000 80d9 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 8004626:	f5b3 4f73 	cmp.w	r3, #62208	@ 0xf300
 800462a:	f000 80d5 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 800462e:	4a8e      	ldr	r2, [pc, #568]	@ (8004868 <HAL_RCCEx_PeriphCLKConfig+0x6f8>)
 8004630:	4293      	cmp	r3, r2
 8004632:	f000 80d1 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 8004636:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 800463a:	4293      	cmp	r3, r2
 800463c:	f000 80cc 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 8004640:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 8004644:	4293      	cmp	r3, r2
 8004646:	f000 80c7 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 800464a:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 800464e:	4293      	cmp	r3, r2
 8004650:	f000 80c2 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 8004654:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 8004658:	4293      	cmp	r3, r2
 800465a:	f000 80bd 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 800465e:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 8004662:	4293      	cmp	r3, r2
 8004664:	f000 80b8 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 8004668:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 800466c:	4293      	cmp	r3, r2
 800466e:	f000 80b3 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 8004672:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 8004676:	4293      	cmp	r3, r2
 8004678:	f000 80ae 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 800467c:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 8004680:	4293      	cmp	r3, r2
 8004682:	f000 80a9 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 8004686:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 800468a:	4293      	cmp	r3, r2
 800468c:	f000 80a4 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 8004690:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 8004694:	4293      	cmp	r3, r2
 8004696:	f000 809f 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 800469a:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 800469e:	4293      	cmp	r3, r2
 80046a0:	f000 809a 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80046a4:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 80046a8:	4293      	cmp	r3, r2
 80046aa:	f000 8095 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80046ae:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 80046b2:	4293      	cmp	r3, r2
 80046b4:	f000 8090 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80046b8:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 80046bc:	4293      	cmp	r3, r2
 80046be:	f000 808b 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80046c2:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 80046c6:	4293      	cmp	r3, r2
 80046c8:	f000 8086 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80046cc:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 80046d0:	4293      	cmp	r3, r2
 80046d2:	f000 8081 	beq.w	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80046d6:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 80046da:	4293      	cmp	r3, r2
 80046dc:	d07c      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80046de:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 80046e2:	4293      	cmp	r3, r2
 80046e4:	d078      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80046e6:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 80046ea:	4293      	cmp	r3, r2
 80046ec:	d074      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80046ee:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 80046f2:	4293      	cmp	r3, r2
 80046f4:	d070      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80046f6:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 80046fa:	4293      	cmp	r3, r2
 80046fc:	d06c      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80046fe:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 8004702:	4293      	cmp	r3, r2
 8004704:	d068      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 8004706:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 800470a:	4293      	cmp	r3, r2
 800470c:	d064      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 800470e:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 8004712:	4293      	cmp	r3, r2
 8004714:	d060      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 8004716:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 800471a:	4293      	cmp	r3, r2
 800471c:	d05c      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 800471e:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 8004722:	4293      	cmp	r3, r2
 8004724:	d058      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 8004726:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 800472a:	4293      	cmp	r3, r2
 800472c:	d054      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 800472e:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 8004732:	4293      	cmp	r3, r2
 8004734:	d050      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 8004736:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 800473a:	4293      	cmp	r3, r2
 800473c:	d04c      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 800473e:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 8004742:	4293      	cmp	r3, r2
 8004744:	d048      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 8004746:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 800474a:	4293      	cmp	r3, r2
 800474c:	d044      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 800474e:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 8004752:	4293      	cmp	r3, r2
 8004754:	d040      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 8004756:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 800475a:	4293      	cmp	r3, r2
 800475c:	d03c      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 800475e:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 8004762:	4293      	cmp	r3, r2
 8004764:	d038      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 8004766:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 800476a:	4293      	cmp	r3, r2
 800476c:	d034      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 800476e:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 8004772:	4293      	cmp	r3, r2
 8004774:	d030      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 8004776:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 800477a:	4293      	cmp	r3, r2
 800477c:	d02c      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 800477e:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 8004782:	4293      	cmp	r3, r2
 8004784:	d028      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 8004786:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 800478a:	4293      	cmp	r3, r2
 800478c:	d024      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 800478e:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 8004792:	4293      	cmp	r3, r2
 8004794:	d020      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 8004796:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 800479a:	4293      	cmp	r3, r2
 800479c:	d01c      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 800479e:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 80047a2:	4293      	cmp	r3, r2
 80047a4:	d018      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80047a6:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 80047aa:	4293      	cmp	r3, r2
 80047ac:	d014      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80047ae:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 80047b2:	4293      	cmp	r3, r2
 80047b4:	d010      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80047b6:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 80047ba:	4293      	cmp	r3, r2
 80047bc:	d00c      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80047be:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 80047c2:	4293      	cmp	r3, r2
 80047c4:	d008      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80047c6:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 80047ca:	4293      	cmp	r3, r2
 80047cc:	d004      	beq.n	80047d8 <HAL_RCCEx_PeriphCLKConfig+0x668>
 80047ce:	f240 317d 	movw	r1, #893	@ 0x37d
 80047d2:	4826      	ldr	r0, [pc, #152]	@ (800486c <HAL_RCCEx_PeriphCLKConfig+0x6fc>)
 80047d4:	f7fc f97e 	bl	8000ad4 <assert_failed>
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80047d8:	4a25      	ldr	r2, [pc, #148]	@ (8004870 <HAL_RCCEx_PeriphCLKConfig+0x700>)
 80047da:	6813      	ldr	r3, [r2, #0]
 80047dc:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 80047e0:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 80047e2:	f7fc fe09 	bl	80013f8 <HAL_GetTick>
 80047e6:	4607      	mov	r7, r0
    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 80047e8:	4b21      	ldr	r3, [pc, #132]	@ (8004870 <HAL_RCCEx_PeriphCLKConfig+0x700>)
 80047ea:	681b      	ldr	r3, [r3, #0]
 80047ec:	f413 7f80 	tst.w	r3, #256	@ 0x100
 80047f0:	d105      	bne.n	80047fe <HAL_RCCEx_PeriphCLKConfig+0x68e>
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80047f2:	f7fc fe01 	bl	80013f8 <HAL_GetTick>
 80047f6:	1bc0      	subs	r0, r0, r7
 80047f8:	2864      	cmp	r0, #100	@ 0x64
 80047fa:	d9f5      	bls.n	80047e8 <HAL_RCCEx_PeriphCLKConfig+0x678>
        ret = HAL_TIMEOUT;
 80047fc:	2503      	movs	r5, #3
    if (ret == HAL_OK)
 80047fe:	2d00      	cmp	r5, #0
 8004800:	d160      	bne.n	80048c4 <HAL_RCCEx_PeriphCLKConfig+0x754>
      if ((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
 8004802:	4b18      	ldr	r3, [pc, #96]	@ (8004864 <HAL_RCCEx_PeriphCLKConfig+0x6f4>)
 8004804:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8004806:	f8d4 20b4 	ldr.w	r2, [r4, #180]	@ 0xb4
 800480a:	4053      	eors	r3, r2
 800480c:	f413 7f40 	tst.w	r3, #768	@ 0x300
 8004810:	d00c      	beq.n	800482c <HAL_RCCEx_PeriphCLKConfig+0x6bc>
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8004812:	4b14      	ldr	r3, [pc, #80]	@ (8004864 <HAL_RCCEx_PeriphCLKConfig+0x6f4>)
 8004814:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 8004816:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
        __HAL_RCC_BACKUPRESET_FORCE();
 800481a:	6f19      	ldr	r1, [r3, #112]	@ 0x70
 800481c:	f441 3180 	orr.w	r1, r1, #65536	@ 0x10000
 8004820:	6719      	str	r1, [r3, #112]	@ 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
 8004822:	6f19      	ldr	r1, [r3, #112]	@ 0x70
 8004824:	f421 3180 	bic.w	r1, r1, #65536	@ 0x10000
 8004828:	6719      	str	r1, [r3, #112]	@ 0x70
        RCC->BDCR = tmpreg;
 800482a:	671a      	str	r2, [r3, #112]	@ 0x70
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
 800482c:	f8d4 30b4 	ldr.w	r3, [r4, #180]	@ 0xb4
 8004830:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8004834:	d02b      	beq.n	800488e <HAL_RCCEx_PeriphCLKConfig+0x71e>
      if (ret == HAL_OK)
 8004836:	2d00      	cmp	r5, #0
 8004838:	d163      	bne.n	8004902 <HAL_RCCEx_PeriphCLKConfig+0x792>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 800483a:	f8d4 30b4 	ldr.w	r3, [r4, #180]	@ 0xb4
 800483e:	f403 7240 	and.w	r2, r3, #768	@ 0x300
 8004842:	f5b2 7f40 	cmp.w	r2, #768	@ 0x300
 8004846:	d033      	beq.n	80048b0 <HAL_RCCEx_PeriphCLKConfig+0x740>
 8004848:	4a06      	ldr	r2, [pc, #24]	@ (8004864 <HAL_RCCEx_PeriphCLKConfig+0x6f4>)
 800484a:	6913      	ldr	r3, [r2, #16]
 800484c:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
 8004850:	6113      	str	r3, [r2, #16]
 8004852:	4904      	ldr	r1, [pc, #16]	@ (8004864 <HAL_RCCEx_PeriphCLKConfig+0x6f4>)
 8004854:	6f0b      	ldr	r3, [r1, #112]	@ 0x70
 8004856:	f8d4 20b4 	ldr.w	r2, [r4, #180]	@ 0xb4
 800485a:	f3c2 020b 	ubfx	r2, r2, #0, #12
 800485e:	4313      	orrs	r3, r2
 8004860:	670b      	str	r3, [r1, #112]	@ 0x70
 8004862:	e007      	b.n	8004874 <HAL_RCCEx_PeriphCLKConfig+0x704>
 8004864:	58024400 	.word	0x58024400
 8004868:	00010300 	.word	0x00010300
 800486c:	08015578 	.word	0x08015578
 8004870:	58024800 	.word	0x58024800
 8004874:	e027      	b.n	80048c6 <HAL_RCCEx_PeriphCLKConfig+0x756>
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 8004876:	2102      	movs	r1, #2
 8004878:	f104 0008 	add.w	r0, r4, #8
 800487c:	f7ff fab8 	bl	8003df0 <RCCEx_PLL2_Config>
 8004880:	4605      	mov	r5, r0
        break;
 8004882:	e684      	b.n	800458e <HAL_RCCEx_PeriphCLKConfig+0x41e>
    switch (PeriphClkInit->FmcClockSelection)
 8004884:	2601      	movs	r6, #1
 8004886:	4635      	mov	r5, r6
 8004888:	e68b      	b.n	80045a2 <HAL_RCCEx_PeriphCLKConfig+0x432>
      status = ret;
 800488a:	462e      	mov	r6, r5
 800488c:	e689      	b.n	80045a2 <HAL_RCCEx_PeriphCLKConfig+0x432>
        tickstart = HAL_GetTick();
 800488e:	f7fc fdb3 	bl	80013f8 <HAL_GetTick>
 8004892:	4607      	mov	r7, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8004894:	4b44      	ldr	r3, [pc, #272]	@ (80049a8 <HAL_RCCEx_PeriphCLKConfig+0x838>)
 8004896:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8004898:	f013 0f02 	tst.w	r3, #2
 800489c:	d1cb      	bne.n	8004836 <HAL_RCCEx_PeriphCLKConfig+0x6c6>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800489e:	f7fc fdab 	bl	80013f8 <HAL_GetTick>
 80048a2:	1bc0      	subs	r0, r0, r7
 80048a4:	f241 3388 	movw	r3, #5000	@ 0x1388
 80048a8:	4298      	cmp	r0, r3
 80048aa:	d9f3      	bls.n	8004894 <HAL_RCCEx_PeriphCLKConfig+0x724>
            ret = HAL_TIMEOUT;
 80048ac:	2503      	movs	r5, #3
 80048ae:	e7c2      	b.n	8004836 <HAL_RCCEx_PeriphCLKConfig+0x6c6>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80048b0:	483d      	ldr	r0, [pc, #244]	@ (80049a8 <HAL_RCCEx_PeriphCLKConfig+0x838>)
 80048b2:	6902      	ldr	r2, [r0, #16]
 80048b4:	f422 527c 	bic.w	r2, r2, #16128	@ 0x3f00
 80048b8:	493c      	ldr	r1, [pc, #240]	@ (80049ac <HAL_RCCEx_PeriphCLKConfig+0x83c>)
 80048ba:	ea01 1313 	and.w	r3, r1, r3, lsr #4
 80048be:	4313      	orrs	r3, r2
 80048c0:	6103      	str	r3, [r0, #16]
 80048c2:	e7c6      	b.n	8004852 <HAL_RCCEx_PeriphCLKConfig+0x6e2>
      status = ret;
 80048c4:	462e      	mov	r6, r5
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
 80048c6:	6823      	ldr	r3, [r4, #0]
 80048c8:	f013 0f01 	tst.w	r3, #1
 80048cc:	d033      	beq.n	8004936 <HAL_RCCEx_PeriphCLKConfig+0x7c6>
    switch (PeriphClkInit->Usart16ClockSelection)
 80048ce:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
 80048d0:	2b28      	cmp	r3, #40	@ 0x28
 80048d2:	d82e      	bhi.n	8004932 <HAL_RCCEx_PeriphCLKConfig+0x7c2>
 80048d4:	e8df f003 	tbb	[pc, r3]
 80048d8:	2d2d2d1d 	.word	0x2d2d2d1d
 80048dc:	2d2d2d2d 	.word	0x2d2d2d2d
 80048e0:	2d2d2d17 	.word	0x2d2d2d17
 80048e4:	2d2d2d2d 	.word	0x2d2d2d2d
 80048e8:	2d2d2d26 	.word	0x2d2d2d26
 80048ec:	2d2d2d2d 	.word	0x2d2d2d2d
 80048f0:	2d2d2d1d 	.word	0x2d2d2d1d
 80048f4:	2d2d2d2d 	.word	0x2d2d2d2d
 80048f8:	2d2d2d1d 	.word	0x2d2d2d1d
 80048fc:	2d2d2d2d 	.word	0x2d2d2d2d
 8004900:	1d          	.byte	0x1d
 8004901:	00          	.byte	0x00
        status = ret;
 8004902:	462e      	mov	r6, r5
 8004904:	e7df      	b.n	80048c6 <HAL_RCCEx_PeriphCLKConfig+0x756>
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 8004906:	2101      	movs	r1, #1
 8004908:	f104 0008 	add.w	r0, r4, #8
 800490c:	f7ff fa70 	bl	8003df0 <RCCEx_PLL2_Config>
 8004910:	4605      	mov	r5, r0
    if (ret == HAL_OK)
 8004912:	b9e5      	cbnz	r5, 800494e <HAL_RCCEx_PeriphCLKConfig+0x7de>
      __HAL_RCC_USART16_CONFIG(PeriphClkInit->Usart16ClockSelection);
 8004914:	4a24      	ldr	r2, [pc, #144]	@ (80049a8 <HAL_RCCEx_PeriphCLKConfig+0x838>)
 8004916:	6d53      	ldr	r3, [r2, #84]	@ 0x54
 8004918:	f023 0338 	bic.w	r3, r3, #56	@ 0x38
 800491c:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
 800491e:	430b      	orrs	r3, r1
 8004920:	6553      	str	r3, [r2, #84]	@ 0x54
 8004922:	e008      	b.n	8004936 <HAL_RCCEx_PeriphCLKConfig+0x7c6>
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 8004924:	2101      	movs	r1, #1
 8004926:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 800492a:	f7ff fb3f 	bl	8003fac <RCCEx_PLL3_Config>
 800492e:	4605      	mov	r5, r0
        break;
 8004930:	e7ef      	b.n	8004912 <HAL_RCCEx_PeriphCLKConfig+0x7a2>
    switch (PeriphClkInit->Usart16ClockSelection)
 8004932:	2601      	movs	r6, #1
 8004934:	4635      	mov	r5, r6
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
 8004936:	6823      	ldr	r3, [r4, #0]
 8004938:	f013 0f02 	tst.w	r3, #2
 800493c:	d017      	beq.n	800496e <HAL_RCCEx_PeriphCLKConfig+0x7fe>
    switch (PeriphClkInit->Usart234578ClockSelection)
 800493e:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
 8004940:	2b05      	cmp	r3, #5
 8004942:	d82c      	bhi.n	800499e <HAL_RCCEx_PeriphCLKConfig+0x82e>
 8004944:	e8df f003 	tbb	[pc, r3]
 8004948:	0b24050b 	.word	0x0b24050b
 800494c:	0b0b      	.short	0x0b0b
      status = ret;
 800494e:	462e      	mov	r6, r5
 8004950:	e7f1      	b.n	8004936 <HAL_RCCEx_PeriphCLKConfig+0x7c6>
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 8004952:	2101      	movs	r1, #1
 8004954:	f104 0008 	add.w	r0, r4, #8
 8004958:	f7ff fa4a 	bl	8003df0 <RCCEx_PLL2_Config>
 800495c:	4605      	mov	r5, r0
    if (ret == HAL_OK)
 800495e:	bb0d      	cbnz	r5, 80049a4 <HAL_RCCEx_PeriphCLKConfig+0x834>
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
 8004960:	4a11      	ldr	r2, [pc, #68]	@ (80049a8 <HAL_RCCEx_PeriphCLKConfig+0x838>)
 8004962:	6d53      	ldr	r3, [r2, #84]	@ 0x54
 8004964:	f023 0307 	bic.w	r3, r3, #7
 8004968:	6fa1      	ldr	r1, [r4, #120]	@ 0x78
 800496a:	430b      	orrs	r3, r1
 800496c:	6553      	str	r3, [r2, #84]	@ 0x54
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 800496e:	6823      	ldr	r3, [r4, #0]
 8004970:	f013 0f04 	tst.w	r3, #4
 8004974:	d02d      	beq.n	80049d2 <HAL_RCCEx_PeriphCLKConfig+0x862>
    switch (PeriphClkInit->Lpuart1ClockSelection)
 8004976:	f8d4 3094 	ldr.w	r3, [r4, #148]	@ 0x94
 800497a:	2b05      	cmp	r3, #5
 800497c:	f200 80f7 	bhi.w	8004b6e <HAL_RCCEx_PeriphCLKConfig+0x9fe>
 8004980:	e8df f013 	tbh	[pc, r3, lsl #1]
 8004984:	0016001c 	.word	0x0016001c
 8004988:	001c00ee 	.word	0x001c00ee
 800498c:	001c001c 	.word	0x001c001c
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 8004990:	2101      	movs	r1, #1
 8004992:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 8004996:	f7ff fb09 	bl	8003fac <RCCEx_PLL3_Config>
 800499a:	4605      	mov	r5, r0
        break;
 800499c:	e7df      	b.n	800495e <HAL_RCCEx_PeriphCLKConfig+0x7ee>
    switch (PeriphClkInit->Usart234578ClockSelection)
 800499e:	2601      	movs	r6, #1
 80049a0:	4635      	mov	r5, r6
 80049a2:	e7e4      	b.n	800496e <HAL_RCCEx_PeriphCLKConfig+0x7fe>
      status = ret;
 80049a4:	462e      	mov	r6, r5
 80049a6:	e7e2      	b.n	800496e <HAL_RCCEx_PeriphCLKConfig+0x7fe>
 80049a8:	58024400 	.word	0x58024400
 80049ac:	00ffffcf 	.word	0x00ffffcf
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 80049b0:	2101      	movs	r1, #1
 80049b2:	f104 0008 	add.w	r0, r4, #8
 80049b6:	f7ff fa1b 	bl	8003df0 <RCCEx_PLL2_Config>
 80049ba:	4605      	mov	r5, r0
    if (ret == HAL_OK)
 80049bc:	2d00      	cmp	r5, #0
 80049be:	f040 80d9 	bne.w	8004b74 <HAL_RCCEx_PeriphCLKConfig+0xa04>
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 80049c2:	4aba      	ldr	r2, [pc, #744]	@ (8004cac <HAL_RCCEx_PeriphCLKConfig+0xb3c>)
 80049c4:	6d93      	ldr	r3, [r2, #88]	@ 0x58
 80049c6:	f023 0307 	bic.w	r3, r3, #7
 80049ca:	f8d4 1094 	ldr.w	r1, [r4, #148]	@ 0x94
 80049ce:	430b      	orrs	r3, r1
 80049d0:	6593      	str	r3, [r2, #88]	@ 0x58
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 80049d2:	6823      	ldr	r3, [r4, #0]
 80049d4:	f013 0f20 	tst.w	r3, #32
 80049d8:	d01d      	beq.n	8004a16 <HAL_RCCEx_PeriphCLKConfig+0x8a6>
    switch (PeriphClkInit->Lptim1ClockSelection)
 80049da:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 80049de:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 80049e2:	f000 80db 	beq.w	8004b9c <HAL_RCCEx_PeriphCLKConfig+0xa2c>
 80049e6:	f200 80ca 	bhi.w	8004b7e <HAL_RCCEx_PeriphCLKConfig+0xa0e>
 80049ea:	b14b      	cbz	r3, 8004a00 <HAL_RCCEx_PeriphCLKConfig+0x890>
 80049ec:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 80049f0:	f040 80c2 	bne.w	8004b78 <HAL_RCCEx_PeriphCLKConfig+0xa08>
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 80049f4:	2100      	movs	r1, #0
 80049f6:	f104 0008 	add.w	r0, r4, #8
 80049fa:	f7ff f9f9 	bl	8003df0 <RCCEx_PLL2_Config>
 80049fe:	4605      	mov	r5, r0
    if (ret == HAL_OK)
 8004a00:	2d00      	cmp	r5, #0
 8004a02:	f040 80d2 	bne.w	8004baa <HAL_RCCEx_PeriphCLKConfig+0xa3a>
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8004a06:	4aa9      	ldr	r2, [pc, #676]	@ (8004cac <HAL_RCCEx_PeriphCLKConfig+0xb3c>)
 8004a08:	6d53      	ldr	r3, [r2, #84]	@ 0x54
 8004a0a:	f023 43e0 	bic.w	r3, r3, #1879048192	@ 0x70000000
 8004a0e:	f8d4 1090 	ldr.w	r1, [r4, #144]	@ 0x90
 8004a12:	430b      	orrs	r3, r1
 8004a14:	6553      	str	r3, [r2, #84]	@ 0x54
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
 8004a16:	6823      	ldr	r3, [r4, #0]
 8004a18:	f013 0f40 	tst.w	r3, #64	@ 0x40
 8004a1c:	d01d      	beq.n	8004a5a <HAL_RCCEx_PeriphCLKConfig+0x8ea>
    switch (PeriphClkInit->Lptim2ClockSelection)
 8004a1e:	f8d4 309c 	ldr.w	r3, [r4, #156]	@ 0x9c
 8004a22:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8004a26:	f000 80d4 	beq.w	8004bd2 <HAL_RCCEx_PeriphCLKConfig+0xa62>
 8004a2a:	f200 80c3 	bhi.w	8004bb4 <HAL_RCCEx_PeriphCLKConfig+0xa44>
 8004a2e:	b14b      	cbz	r3, 8004a44 <HAL_RCCEx_PeriphCLKConfig+0x8d4>
 8004a30:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8004a34:	f040 80bb 	bne.w	8004bae <HAL_RCCEx_PeriphCLKConfig+0xa3e>
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8004a38:	2100      	movs	r1, #0
 8004a3a:	f104 0008 	add.w	r0, r4, #8
 8004a3e:	f7ff f9d7 	bl	8003df0 <RCCEx_PLL2_Config>
 8004a42:	4605      	mov	r5, r0
    if (ret == HAL_OK)
 8004a44:	2d00      	cmp	r5, #0
 8004a46:	f040 80cb 	bne.w	8004be0 <HAL_RCCEx_PeriphCLKConfig+0xa70>
      __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8004a4a:	4a98      	ldr	r2, [pc, #608]	@ (8004cac <HAL_RCCEx_PeriphCLKConfig+0xb3c>)
 8004a4c:	6d93      	ldr	r3, [r2, #88]	@ 0x58
 8004a4e:	f423 53e0 	bic.w	r3, r3, #7168	@ 0x1c00
 8004a52:	f8d4 109c 	ldr.w	r1, [r4, #156]	@ 0x9c
 8004a56:	430b      	orrs	r3, r1
 8004a58:	6593      	str	r3, [r2, #88]	@ 0x58
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
 8004a5a:	6823      	ldr	r3, [r4, #0]
 8004a5c:	f013 0f80 	tst.w	r3, #128	@ 0x80
 8004a60:	d01d      	beq.n	8004a9e <HAL_RCCEx_PeriphCLKConfig+0x92e>
    switch (PeriphClkInit->Lptim345ClockSelection)
 8004a62:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
 8004a66:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8004a6a:	f000 80cd 	beq.w	8004c08 <HAL_RCCEx_PeriphCLKConfig+0xa98>
 8004a6e:	f200 80bc 	bhi.w	8004bea <HAL_RCCEx_PeriphCLKConfig+0xa7a>
 8004a72:	b14b      	cbz	r3, 8004a88 <HAL_RCCEx_PeriphCLKConfig+0x918>
 8004a74:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8004a78:	f040 80b4 	bne.w	8004be4 <HAL_RCCEx_PeriphCLKConfig+0xa74>
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8004a7c:	2100      	movs	r1, #0
 8004a7e:	f104 0008 	add.w	r0, r4, #8
 8004a82:	f7ff f9b5 	bl	8003df0 <RCCEx_PLL2_Config>
 8004a86:	4605      	mov	r5, r0
    if (ret == HAL_OK)
 8004a88:	2d00      	cmp	r5, #0
 8004a8a:	f040 80c4 	bne.w	8004c16 <HAL_RCCEx_PeriphCLKConfig+0xaa6>
      __HAL_RCC_LPTIM345_CONFIG(PeriphClkInit->Lptim345ClockSelection);
 8004a8e:	4a87      	ldr	r2, [pc, #540]	@ (8004cac <HAL_RCCEx_PeriphCLKConfig+0xb3c>)
 8004a90:	6d93      	ldr	r3, [r2, #88]	@ 0x58
 8004a92:	f423 4360 	bic.w	r3, r3, #57344	@ 0xe000
 8004a96:	f8d4 10a0 	ldr.w	r1, [r4, #160]	@ 0xa0
 8004a9a:	430b      	orrs	r3, r1
 8004a9c:	6593      	str	r3, [r2, #88]	@ 0x58
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
 8004a9e:	6823      	ldr	r3, [r4, #0]
 8004aa0:	f013 0f08 	tst.w	r3, #8
 8004aa4:	d01a      	beq.n	8004adc <HAL_RCCEx_PeriphCLKConfig+0x96c>
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));
 8004aa6:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
 8004aaa:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8004aae:	bf18      	it	ne
 8004ab0:	f5b3 5f00 	cmpne.w	r3, #8192	@ 0x2000
 8004ab4:	d004      	beq.n	8004ac0 <HAL_RCCEx_PeriphCLKConfig+0x950>
 8004ab6:	b11b      	cbz	r3, 8004ac0 <HAL_RCCEx_PeriphCLKConfig+0x950>
 8004ab8:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8004abc:	f040 80ad 	bne.w	8004c1a <HAL_RCCEx_PeriphCLKConfig+0xaaa>
    if ((PeriphClkInit->I2c123ClockSelection) == RCC_I2C123CLKSOURCE_PLL3)
 8004ac0:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
 8004ac4:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8004ac8:	f000 80ad 	beq.w	8004c26 <HAL_RCCEx_PeriphCLKConfig+0xab6>
    __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);
 8004acc:	4a77      	ldr	r2, [pc, #476]	@ (8004cac <HAL_RCCEx_PeriphCLKConfig+0xb3c>)
 8004ace:	6d53      	ldr	r3, [r2, #84]	@ 0x54
 8004ad0:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
 8004ad4:	f8d4 1084 	ldr.w	r1, [r4, #132]	@ 0x84
 8004ad8:	430b      	orrs	r3, r1
 8004ada:	6553      	str	r3, [r2, #84]	@ 0x54
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8004adc:	6823      	ldr	r3, [r4, #0]
 8004ade:	f013 0f10 	tst.w	r3, #16
 8004ae2:	d01a      	beq.n	8004b1a <HAL_RCCEx_PeriphCLKConfig+0x9aa>
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
 8004ae4:	f8d4 3098 	ldr.w	r3, [r4, #152]	@ 0x98
 8004ae8:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8004aec:	bf18      	it	ne
 8004aee:	f5b3 7f00 	cmpne.w	r3, #512	@ 0x200
 8004af2:	d004      	beq.n	8004afe <HAL_RCCEx_PeriphCLKConfig+0x98e>
 8004af4:	b11b      	cbz	r3, 8004afe <HAL_RCCEx_PeriphCLKConfig+0x98e>
 8004af6:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 8004afa:	f040 809e 	bne.w	8004c3a <HAL_RCCEx_PeriphCLKConfig+0xaca>
    if ((PeriphClkInit->I2c4ClockSelection) == RCC_I2C4CLKSOURCE_PLL3)
 8004afe:	f8d4 3098 	ldr.w	r3, [r4, #152]	@ 0x98
 8004b02:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8004b06:	f000 809e 	beq.w	8004c46 <HAL_RCCEx_PeriphCLKConfig+0xad6>
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8004b0a:	4a68      	ldr	r2, [pc, #416]	@ (8004cac <HAL_RCCEx_PeriphCLKConfig+0xb3c>)
 8004b0c:	6d93      	ldr	r3, [r2, #88]	@ 0x58
 8004b0e:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8004b12:	f8d4 1098 	ldr.w	r1, [r4, #152]	@ 0x98
 8004b16:	430b      	orrs	r3, r1
 8004b18:	6593      	str	r3, [r2, #88]	@ 0x58
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8004b1a:	6823      	ldr	r3, [r4, #0]
 8004b1c:	f413 2f00 	tst.w	r3, #524288	@ 0x80000
 8004b20:	f000 80a6 	beq.w	8004c70 <HAL_RCCEx_PeriphCLKConfig+0xb00>
    switch (PeriphClkInit->AdcClockSelection)
 8004b24:	f8d4 30a4 	ldr.w	r3, [r4, #164]	@ 0xa4
 8004b28:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8004b2c:	f000 8095 	beq.w	8004c5a <HAL_RCCEx_PeriphCLKConfig+0xaea>
 8004b30:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8004b34:	d008      	beq.n	8004b48 <HAL_RCCEx_PeriphCLKConfig+0x9d8>
 8004b36:	2b00      	cmp	r3, #0
 8004b38:	f040 8096 	bne.w	8004c68 <HAL_RCCEx_PeriphCLKConfig+0xaf8>
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8004b3c:	2100      	movs	r1, #0
 8004b3e:	f104 0008 	add.w	r0, r4, #8
 8004b42:	f7ff f955 	bl	8003df0 <RCCEx_PLL2_Config>
 8004b46:	4605      	mov	r5, r0
    if (ret == HAL_OK)
 8004b48:	2d00      	cmp	r5, #0
 8004b4a:	f040 8090 	bne.w	8004c6e <HAL_RCCEx_PeriphCLKConfig+0xafe>
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8004b4e:	4a57      	ldr	r2, [pc, #348]	@ (8004cac <HAL_RCCEx_PeriphCLKConfig+0xb3c>)
 8004b50:	6d93      	ldr	r3, [r2, #88]	@ 0x58
 8004b52:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
 8004b56:	f8d4 10a4 	ldr.w	r1, [r4, #164]	@ 0xa4
 8004b5a:	430b      	orrs	r3, r1
 8004b5c:	6593      	str	r3, [r2, #88]	@ 0x58
 8004b5e:	e087      	b.n	8004c70 <HAL_RCCEx_PeriphCLKConfig+0xb00>
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 8004b60:	2101      	movs	r1, #1
 8004b62:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 8004b66:	f7ff fa21 	bl	8003fac <RCCEx_PLL3_Config>
 8004b6a:	4605      	mov	r5, r0
        break;
 8004b6c:	e726      	b.n	80049bc <HAL_RCCEx_PeriphCLKConfig+0x84c>
    switch (PeriphClkInit->Lpuart1ClockSelection)
 8004b6e:	2601      	movs	r6, #1
 8004b70:	4635      	mov	r5, r6
 8004b72:	e72e      	b.n	80049d2 <HAL_RCCEx_PeriphCLKConfig+0x862>
      status = ret;
 8004b74:	462e      	mov	r6, r5
 8004b76:	e72c      	b.n	80049d2 <HAL_RCCEx_PeriphCLKConfig+0x862>
    switch (PeriphClkInit->Lptim1ClockSelection)
 8004b78:	2601      	movs	r6, #1
 8004b7a:	4635      	mov	r5, r6
 8004b7c:	e74b      	b.n	8004a16 <HAL_RCCEx_PeriphCLKConfig+0x8a6>
 8004b7e:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8004b82:	f43f af3d 	beq.w	8004a00 <HAL_RCCEx_PeriphCLKConfig+0x890>
 8004b86:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8004b8a:	f43f af39 	beq.w	8004a00 <HAL_RCCEx_PeriphCLKConfig+0x890>
 8004b8e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 8004b92:	f43f af35 	beq.w	8004a00 <HAL_RCCEx_PeriphCLKConfig+0x890>
 8004b96:	2601      	movs	r6, #1
 8004b98:	4635      	mov	r5, r6
 8004b9a:	e73c      	b.n	8004a16 <HAL_RCCEx_PeriphCLKConfig+0x8a6>
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 8004b9c:	2102      	movs	r1, #2
 8004b9e:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 8004ba2:	f7ff fa03 	bl	8003fac <RCCEx_PLL3_Config>
 8004ba6:	4605      	mov	r5, r0
        break;
 8004ba8:	e72a      	b.n	8004a00 <HAL_RCCEx_PeriphCLKConfig+0x890>
      status = ret;
 8004baa:	462e      	mov	r6, r5
 8004bac:	e733      	b.n	8004a16 <HAL_RCCEx_PeriphCLKConfig+0x8a6>
    switch (PeriphClkInit->Lptim2ClockSelection)
 8004bae:	2601      	movs	r6, #1
 8004bb0:	4635      	mov	r5, r6
 8004bb2:	e752      	b.n	8004a5a <HAL_RCCEx_PeriphCLKConfig+0x8ea>
 8004bb4:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8004bb8:	f43f af44 	beq.w	8004a44 <HAL_RCCEx_PeriphCLKConfig+0x8d4>
 8004bbc:	f5b3 5fa0 	cmp.w	r3, #5120	@ 0x1400
 8004bc0:	f43f af40 	beq.w	8004a44 <HAL_RCCEx_PeriphCLKConfig+0x8d4>
 8004bc4:	f5b3 6f40 	cmp.w	r3, #3072	@ 0xc00
 8004bc8:	f43f af3c 	beq.w	8004a44 <HAL_RCCEx_PeriphCLKConfig+0x8d4>
 8004bcc:	2601      	movs	r6, #1
 8004bce:	4635      	mov	r5, r6
 8004bd0:	e743      	b.n	8004a5a <HAL_RCCEx_PeriphCLKConfig+0x8ea>
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 8004bd2:	2102      	movs	r1, #2
 8004bd4:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 8004bd8:	f7ff f9e8 	bl	8003fac <RCCEx_PLL3_Config>
 8004bdc:	4605      	mov	r5, r0
        break;
 8004bde:	e731      	b.n	8004a44 <HAL_RCCEx_PeriphCLKConfig+0x8d4>
      status = ret;
 8004be0:	462e      	mov	r6, r5
 8004be2:	e73a      	b.n	8004a5a <HAL_RCCEx_PeriphCLKConfig+0x8ea>
    switch (PeriphClkInit->Lptim345ClockSelection)
 8004be4:	2601      	movs	r6, #1
 8004be6:	4635      	mov	r5, r6
 8004be8:	e759      	b.n	8004a9e <HAL_RCCEx_PeriphCLKConfig+0x92e>
 8004bea:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8004bee:	f43f af4b 	beq.w	8004a88 <HAL_RCCEx_PeriphCLKConfig+0x918>
 8004bf2:	f5b3 4f20 	cmp.w	r3, #40960	@ 0xa000
 8004bf6:	f43f af47 	beq.w	8004a88 <HAL_RCCEx_PeriphCLKConfig+0x918>
 8004bfa:	f5b3 4fc0 	cmp.w	r3, #24576	@ 0x6000
 8004bfe:	f43f af43 	beq.w	8004a88 <HAL_RCCEx_PeriphCLKConfig+0x918>
 8004c02:	2601      	movs	r6, #1
 8004c04:	4635      	mov	r5, r6
 8004c06:	e74a      	b.n	8004a9e <HAL_RCCEx_PeriphCLKConfig+0x92e>
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 8004c08:	2102      	movs	r1, #2
 8004c0a:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 8004c0e:	f7ff f9cd 	bl	8003fac <RCCEx_PLL3_Config>
 8004c12:	4605      	mov	r5, r0
        break;
 8004c14:	e738      	b.n	8004a88 <HAL_RCCEx_PeriphCLKConfig+0x918>
      status = ret;
 8004c16:	462e      	mov	r6, r5
 8004c18:	e741      	b.n	8004a9e <HAL_RCCEx_PeriphCLKConfig+0x92e>
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));
 8004c1a:	f240 510d 	movw	r1, #1293	@ 0x50d
 8004c1e:	4824      	ldr	r0, [pc, #144]	@ (8004cb0 <HAL_RCCEx_PeriphCLKConfig+0xb40>)
 8004c20:	f7fb ff58 	bl	8000ad4 <assert_failed>
 8004c24:	e74c      	b.n	8004ac0 <HAL_RCCEx_PeriphCLKConfig+0x950>
      if (RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE) != HAL_OK)
 8004c26:	2102      	movs	r1, #2
 8004c28:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 8004c2c:	f7ff f9be 	bl	8003fac <RCCEx_PLL3_Config>
 8004c30:	2800      	cmp	r0, #0
 8004c32:	f43f af4b 	beq.w	8004acc <HAL_RCCEx_PeriphCLKConfig+0x95c>
        status = HAL_ERROR;
 8004c36:	2601      	movs	r6, #1
 8004c38:	e748      	b.n	8004acc <HAL_RCCEx_PeriphCLKConfig+0x95c>
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
 8004c3a:	f44f 61a4 	mov.w	r1, #1312	@ 0x520
 8004c3e:	481c      	ldr	r0, [pc, #112]	@ (8004cb0 <HAL_RCCEx_PeriphCLKConfig+0xb40>)
 8004c40:	f7fb ff48 	bl	8000ad4 <assert_failed>
 8004c44:	e75b      	b.n	8004afe <HAL_RCCEx_PeriphCLKConfig+0x98e>
      if (RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE) != HAL_OK)
 8004c46:	2102      	movs	r1, #2
 8004c48:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 8004c4c:	f7ff f9ae 	bl	8003fac <RCCEx_PLL3_Config>
 8004c50:	2800      	cmp	r0, #0
 8004c52:	f43f af5a 	beq.w	8004b0a <HAL_RCCEx_PeriphCLKConfig+0x99a>
        status = HAL_ERROR;
 8004c56:	2601      	movs	r6, #1
 8004c58:	e757      	b.n	8004b0a <HAL_RCCEx_PeriphCLKConfig+0x99a>
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 8004c5a:	2102      	movs	r1, #2
 8004c5c:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 8004c60:	f7ff f9a4 	bl	8003fac <RCCEx_PLL3_Config>
 8004c64:	4605      	mov	r5, r0
        break;
 8004c66:	e76f      	b.n	8004b48 <HAL_RCCEx_PeriphCLKConfig+0x9d8>
    switch (PeriphClkInit->AdcClockSelection)
 8004c68:	2601      	movs	r6, #1
 8004c6a:	4635      	mov	r5, r6
 8004c6c:	e000      	b.n	8004c70 <HAL_RCCEx_PeriphCLKConfig+0xb00>
      status = ret;
 8004c6e:	462e      	mov	r6, r5
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 8004c70:	6823      	ldr	r3, [r4, #0]
 8004c72:	f413 2f80 	tst.w	r3, #262144	@ 0x40000
 8004c76:	d028      	beq.n	8004cca <HAL_RCCEx_PeriphCLKConfig+0xb5a>
    switch (PeriphClkInit->UsbClockSelection)
 8004c78:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
 8004c7c:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8004c80:	d018      	beq.n	8004cb4 <HAL_RCCEx_PeriphCLKConfig+0xb44>
 8004c82:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 8004c86:	d007      	beq.n	8004c98 <HAL_RCCEx_PeriphCLKConfig+0xb28>
 8004c88:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 8004c8c:	d119      	bne.n	8004cc2 <HAL_RCCEx_PeriphCLKConfig+0xb52>
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8004c8e:	4a07      	ldr	r2, [pc, #28]	@ (8004cac <HAL_RCCEx_PeriphCLKConfig+0xb3c>)
 8004c90:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 8004c92:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8004c96:	62d3      	str	r3, [r2, #44]	@ 0x2c
    if (ret == HAL_OK)
 8004c98:	b9b5      	cbnz	r5, 8004cc8 <HAL_RCCEx_PeriphCLKConfig+0xb58>
      __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8004c9a:	4a04      	ldr	r2, [pc, #16]	@ (8004cac <HAL_RCCEx_PeriphCLKConfig+0xb3c>)
 8004c9c:	6d53      	ldr	r3, [r2, #84]	@ 0x54
 8004c9e:	f423 1340 	bic.w	r3, r3, #3145728	@ 0x300000
 8004ca2:	f8d4 1088 	ldr.w	r1, [r4, #136]	@ 0x88
 8004ca6:	430b      	orrs	r3, r1
 8004ca8:	6553      	str	r3, [r2, #84]	@ 0x54
 8004caa:	e00e      	b.n	8004cca <HAL_RCCEx_PeriphCLKConfig+0xb5a>
 8004cac:	58024400 	.word	0x58024400
 8004cb0:	08015578 	.word	0x08015578
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 8004cb4:	2101      	movs	r1, #1
 8004cb6:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 8004cba:	f7ff f977 	bl	8003fac <RCCEx_PLL3_Config>
 8004cbe:	4605      	mov	r5, r0
        break;
 8004cc0:	e7ea      	b.n	8004c98 <HAL_RCCEx_PeriphCLKConfig+0xb28>
    switch (PeriphClkInit->UsbClockSelection)
 8004cc2:	2601      	movs	r6, #1
 8004cc4:	4635      	mov	r5, r6
 8004cc6:	e000      	b.n	8004cca <HAL_RCCEx_PeriphCLKConfig+0xb5a>
      status = ret;
 8004cc8:	462e      	mov	r6, r5
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)
 8004cca:	6823      	ldr	r3, [r4, #0]
 8004ccc:	f413 3f80 	tst.w	r3, #65536	@ 0x10000
 8004cd0:	d00c      	beq.n	8004cec <HAL_RCCEx_PeriphCLKConfig+0xb7c>
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));
 8004cd2:	6d23      	ldr	r3, [r4, #80]	@ 0x50
 8004cd4:	2b00      	cmp	r3, #0
 8004cd6:	bf18      	it	ne
 8004cd8:	f5b3 3f80 	cmpne.w	r3, #65536	@ 0x10000
 8004cdc:	d11c      	bne.n	8004d18 <HAL_RCCEx_PeriphCLKConfig+0xba8>
    switch (PeriphClkInit->SdmmcClockSelection)
 8004cde:	6d23      	ldr	r3, [r4, #80]	@ 0x50
 8004ce0:	b303      	cbz	r3, 8004d24 <HAL_RCCEx_PeriphCLKConfig+0xbb4>
 8004ce2:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8004ce6:	d02b      	beq.n	8004d40 <HAL_RCCEx_PeriphCLKConfig+0xbd0>
 8004ce8:	2601      	movs	r6, #1
 8004cea:	4635      	mov	r5, r6
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
 8004cec:	6823      	ldr	r3, [r4, #0]
 8004cee:	f013 5f00 	tst.w	r3, #536870912	@ 0x20000000
 8004cf2:	d12e      	bne.n	8004d52 <HAL_RCCEx_PeriphCLKConfig+0xbe2>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
 8004cf4:	6823      	ldr	r3, [r4, #0]
 8004cf6:	f413 3f00 	tst.w	r3, #131072	@ 0x20000
 8004cfa:	d046      	beq.n	8004d8a <HAL_RCCEx_PeriphCLKConfig+0xc1a>
    switch (PeriphClkInit->RngClockSelection)
 8004cfc:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 8004d00:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8004d04:	d031      	beq.n	8004d6a <HAL_RCCEx_PeriphCLKConfig+0xbfa>
 8004d06:	d92d      	bls.n	8004d64 <HAL_RCCEx_PeriphCLKConfig+0xbf4>
 8004d08:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8004d0c:	d032      	beq.n	8004d74 <HAL_RCCEx_PeriphCLKConfig+0xc04>
 8004d0e:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 8004d12:	d02f      	beq.n	8004d74 <HAL_RCCEx_PeriphCLKConfig+0xc04>
 8004d14:	2601      	movs	r6, #1
 8004d16:	e038      	b.n	8004d8a <HAL_RCCEx_PeriphCLKConfig+0xc1a>
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));
 8004d18:	f240 5186 	movw	r1, #1414	@ 0x586
 8004d1c:	4890      	ldr	r0, [pc, #576]	@ (8004f60 <HAL_RCCEx_PeriphCLKConfig+0xdf0>)
 8004d1e:	f7fb fed9 	bl	8000ad4 <assert_failed>
 8004d22:	e7dc      	b.n	8004cde <HAL_RCCEx_PeriphCLKConfig+0xb6e>
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8004d24:	4a8f      	ldr	r2, [pc, #572]	@ (8004f64 <HAL_RCCEx_PeriphCLKConfig+0xdf4>)
 8004d26:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 8004d28:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8004d2c:	62d3      	str	r3, [r2, #44]	@ 0x2c
    if (ret == HAL_OK)
 8004d2e:	b975      	cbnz	r5, 8004d4e <HAL_RCCEx_PeriphCLKConfig+0xbde>
      __HAL_RCC_SDMMC_CONFIG(PeriphClkInit->SdmmcClockSelection);
 8004d30:	4a8c      	ldr	r2, [pc, #560]	@ (8004f64 <HAL_RCCEx_PeriphCLKConfig+0xdf4>)
 8004d32:	6cd3      	ldr	r3, [r2, #76]	@ 0x4c
 8004d34:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8004d38:	6d21      	ldr	r1, [r4, #80]	@ 0x50
 8004d3a:	430b      	orrs	r3, r1
 8004d3c:	64d3      	str	r3, [r2, #76]	@ 0x4c
 8004d3e:	e7d5      	b.n	8004cec <HAL_RCCEx_PeriphCLKConfig+0xb7c>
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 8004d40:	2102      	movs	r1, #2
 8004d42:	f104 0008 	add.w	r0, r4, #8
 8004d46:	f7ff f853 	bl	8003df0 <RCCEx_PLL2_Config>
 8004d4a:	4605      	mov	r5, r0
        break;
 8004d4c:	e7ef      	b.n	8004d2e <HAL_RCCEx_PeriphCLKConfig+0xbbe>
      status = ret;
 8004d4e:	462e      	mov	r6, r5
 8004d50:	e7cc      	b.n	8004cec <HAL_RCCEx_PeriphCLKConfig+0xb7c>
    if (RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE) != HAL_OK)
 8004d52:	2102      	movs	r1, #2
 8004d54:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 8004d58:	f7ff f928 	bl	8003fac <RCCEx_PLL3_Config>
 8004d5c:	2800      	cmp	r0, #0
 8004d5e:	d0c9      	beq.n	8004cf4 <HAL_RCCEx_PeriphCLKConfig+0xb84>
      status = HAL_ERROR;
 8004d60:	2601      	movs	r6, #1
 8004d62:	e7c7      	b.n	8004cf4 <HAL_RCCEx_PeriphCLKConfig+0xb84>
    switch (PeriphClkInit->RngClockSelection)
 8004d64:	b133      	cbz	r3, 8004d74 <HAL_RCCEx_PeriphCLKConfig+0xc04>
 8004d66:	2601      	movs	r6, #1
 8004d68:	e00f      	b.n	8004d8a <HAL_RCCEx_PeriphCLKConfig+0xc1a>
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8004d6a:	4a7e      	ldr	r2, [pc, #504]	@ (8004f64 <HAL_RCCEx_PeriphCLKConfig+0xdf4>)
 8004d6c:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 8004d6e:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8004d72:	62d3      	str	r3, [r2, #44]	@ 0x2c
    if (ret == HAL_OK)
 8004d74:	b945      	cbnz	r5, 8004d88 <HAL_RCCEx_PeriphCLKConfig+0xc18>
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8004d76:	4a7b      	ldr	r2, [pc, #492]	@ (8004f64 <HAL_RCCEx_PeriphCLKConfig+0xdf4>)
 8004d78:	6d53      	ldr	r3, [r2, #84]	@ 0x54
 8004d7a:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8004d7e:	f8d4 1080 	ldr.w	r1, [r4, #128]	@ 0x80
 8004d82:	430b      	orrs	r3, r1
 8004d84:	6553      	str	r3, [r2, #84]	@ 0x54
 8004d86:	e000      	b.n	8004d8a <HAL_RCCEx_PeriphCLKConfig+0xc1a>
      status = ret;
 8004d88:	462e      	mov	r6, r5
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
 8004d8a:	6823      	ldr	r3, [r4, #0]
 8004d8c:	f413 1f80 	tst.w	r3, #1048576	@ 0x100000
 8004d90:	d00d      	beq.n	8004dae <HAL_RCCEx_PeriphCLKConfig+0xc3e>
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));
 8004d92:	6f63      	ldr	r3, [r4, #116]	@ 0x74
 8004d94:	2b00      	cmp	r3, #0
 8004d96:	bf18      	it	ne
 8004d98:	f1b3 4f00 	cmpne.w	r3, #2147483648	@ 0x80000000
 8004d9c:	f040 8085 	bne.w	8004eaa <HAL_RCCEx_PeriphCLKConfig+0xd3a>
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
 8004da0:	4a70      	ldr	r2, [pc, #448]	@ (8004f64 <HAL_RCCEx_PeriphCLKConfig+0xdf4>)
 8004da2:	6d13      	ldr	r3, [r2, #80]	@ 0x50
 8004da4:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 8004da8:	6f61      	ldr	r1, [r4, #116]	@ 0x74
 8004daa:	430b      	orrs	r3, r1
 8004dac:	6513      	str	r3, [r2, #80]	@ 0x50
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_HRTIM1) == RCC_PERIPHCLK_HRTIM1)
 8004dae:	6823      	ldr	r3, [r4, #0]
 8004db0:	f013 5f80 	tst.w	r3, #268435456	@ 0x10000000
 8004db4:	d00e      	beq.n	8004dd4 <HAL_RCCEx_PeriphCLKConfig+0xc64>
    assert_param(IS_RCC_HRTIM1CLKSOURCE(PeriphClkInit->Hrtim1ClockSelection));
 8004db6:	f8d4 30b8 	ldr.w	r3, [r4, #184]	@ 0xb8
 8004dba:	2b00      	cmp	r3, #0
 8004dbc:	bf18      	it	ne
 8004dbe:	f5b3 4f80 	cmpne.w	r3, #16384	@ 0x4000
 8004dc2:	d178      	bne.n	8004eb6 <HAL_RCCEx_PeriphCLKConfig+0xd46>
    __HAL_RCC_HRTIM1_CONFIG(PeriphClkInit->Hrtim1ClockSelection);
 8004dc4:	4a67      	ldr	r2, [pc, #412]	@ (8004f64 <HAL_RCCEx_PeriphCLKConfig+0xdf4>)
 8004dc6:	6913      	ldr	r3, [r2, #16]
 8004dc8:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
 8004dcc:	f8d4 10b8 	ldr.w	r1, [r4, #184]	@ 0xb8
 8004dd0:	430b      	orrs	r3, r1
 8004dd2:	6113      	str	r3, [r2, #16]
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 8004dd4:	6823      	ldr	r3, [r4, #0]
 8004dd6:	f413 1f00 	tst.w	r3, #2097152	@ 0x200000
 8004dda:	d00c      	beq.n	8004df6 <HAL_RCCEx_PeriphCLKConfig+0xc86>
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));
 8004ddc:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
 8004dde:	2b00      	cmp	r3, #0
 8004de0:	bf18      	it	ne
 8004de2:	f1b3 7f80 	cmpne.w	r3, #16777216	@ 0x1000000
 8004de6:	d16c      	bne.n	8004ec2 <HAL_RCCEx_PeriphCLKConfig+0xd52>
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 8004de8:	4a5e      	ldr	r2, [pc, #376]	@ (8004f64 <HAL_RCCEx_PeriphCLKConfig+0xdf4>)
 8004dea:	6d13      	ldr	r3, [r2, #80]	@ 0x50
 8004dec:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 8004df0:	6ee1      	ldr	r1, [r4, #108]	@ 0x6c
 8004df2:	430b      	orrs	r3, r1
 8004df4:	6513      	str	r3, [r2, #80]	@ 0x50
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
 8004df6:	6823      	ldr	r3, [r4, #0]
 8004df8:	f013 4f80 	tst.w	r3, #1073741824	@ 0x40000000
 8004dfc:	d010      	beq.n	8004e20 <HAL_RCCEx_PeriphCLKConfig+0xcb0>
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
 8004dfe:	f8d4 30bc 	ldr.w	r3, [r4, #188]	@ 0xbc
 8004e02:	2b00      	cmp	r3, #0
 8004e04:	bf18      	it	ne
 8004e06:	f5b3 4f00 	cmpne.w	r3, #32768	@ 0x8000
 8004e0a:	d160      	bne.n	8004ece <HAL_RCCEx_PeriphCLKConfig+0xd5e>
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 8004e0c:	4b55      	ldr	r3, [pc, #340]	@ (8004f64 <HAL_RCCEx_PeriphCLKConfig+0xdf4>)
 8004e0e:	691a      	ldr	r2, [r3, #16]
 8004e10:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 8004e14:	611a      	str	r2, [r3, #16]
 8004e16:	691a      	ldr	r2, [r3, #16]
 8004e18:	f8d4 10bc 	ldr.w	r1, [r4, #188]	@ 0xbc
 8004e1c:	430a      	orrs	r2, r1
 8004e1e:	611a      	str	r2, [r3, #16]
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
 8004e20:	6823      	ldr	r3, [r4, #0]
 8004e22:	2b00      	cmp	r3, #0
 8004e24:	da0f      	bge.n	8004e46 <HAL_RCCEx_PeriphCLKConfig+0xcd6>
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));
 8004e26:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 8004e28:	2b00      	cmp	r3, #0
 8004e2a:	bf18      	it	ne
 8004e2c:	f1b3 5f80 	cmpne.w	r3, #268435456	@ 0x10000000
 8004e30:	d002      	beq.n	8004e38 <HAL_RCCEx_PeriphCLKConfig+0xcc8>
 8004e32:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8004e36:	d150      	bne.n	8004eda <HAL_RCCEx_PeriphCLKConfig+0xd6a>
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
 8004e38:	4a4a      	ldr	r2, [pc, #296]	@ (8004f64 <HAL_RCCEx_PeriphCLKConfig+0xdf4>)
 8004e3a:	6cd3      	ldr	r3, [r2, #76]	@ 0x4c
 8004e3c:	f023 5340 	bic.w	r3, r3, #805306368	@ 0x30000000
 8004e40:	6d61      	ldr	r1, [r4, #84]	@ 0x54
 8004e42:	430b      	orrs	r3, r1
 8004e44:	64d3      	str	r3, [r2, #76]	@ 0x4c
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 8004e46:	6823      	ldr	r3, [r4, #0]
 8004e48:	f413 0f00 	tst.w	r3, #8388608	@ 0x800000
 8004e4c:	d011      	beq.n	8004e72 <HAL_RCCEx_PeriphCLKConfig+0xd02>
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));
 8004e4e:	f8d4 308c 	ldr.w	r3, [r4, #140]	@ 0x8c
 8004e52:	2b00      	cmp	r3, #0
 8004e54:	bf18      	it	ne
 8004e56:	f5b3 0f80 	cmpne.w	r3, #4194304	@ 0x400000
 8004e5a:	d002      	beq.n	8004e62 <HAL_RCCEx_PeriphCLKConfig+0xcf2>
 8004e5c:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 8004e60:	d141      	bne.n	8004ee6 <HAL_RCCEx_PeriphCLKConfig+0xd76>
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 8004e62:	4a40      	ldr	r2, [pc, #256]	@ (8004f64 <HAL_RCCEx_PeriphCLKConfig+0xdf4>)
 8004e64:	6d53      	ldr	r3, [r2, #84]	@ 0x54
 8004e66:	f423 0340 	bic.w	r3, r3, #12582912	@ 0xc00000
 8004e6a:	f8d4 108c 	ldr.w	r1, [r4, #140]	@ 0x8c
 8004e6e:	430b      	orrs	r3, r1
 8004e70:	6553      	str	r3, [r2, #84]	@ 0x54
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL2_DIVP) == RCC_PERIPHCLK_PLL2_DIVP)
 8004e72:	6863      	ldr	r3, [r4, #4]
 8004e74:	f013 0f01 	tst.w	r3, #1
 8004e78:	d13b      	bne.n	8004ef2 <HAL_RCCEx_PeriphCLKConfig+0xd82>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL2_DIVQ) == RCC_PERIPHCLK_PLL2_DIVQ)
 8004e7a:	6863      	ldr	r3, [r4, #4]
 8004e7c:	f013 0f02 	tst.w	r3, #2
 8004e80:	d140      	bne.n	8004f04 <HAL_RCCEx_PeriphCLKConfig+0xd94>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL2_DIVR) == RCC_PERIPHCLK_PLL2_DIVR)
 8004e82:	6863      	ldr	r3, [r4, #4]
 8004e84:	f013 0f04 	tst.w	r3, #4
 8004e88:	d145      	bne.n	8004f16 <HAL_RCCEx_PeriphCLKConfig+0xda6>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL3_DIVP) == RCC_PERIPHCLK_PLL3_DIVP)
 8004e8a:	6863      	ldr	r3, [r4, #4]
 8004e8c:	f013 0f08 	tst.w	r3, #8
 8004e90:	d14a      	bne.n	8004f28 <HAL_RCCEx_PeriphCLKConfig+0xdb8>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL3_DIVQ) == RCC_PERIPHCLK_PLL3_DIVQ)
 8004e92:	6863      	ldr	r3, [r4, #4]
 8004e94:	f013 0f10 	tst.w	r3, #16
 8004e98:	d14f      	bne.n	8004f3a <HAL_RCCEx_PeriphCLKConfig+0xdca>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL3_DIVR) == RCC_PERIPHCLK_PLL3_DIVR)
 8004e9a:	6863      	ldr	r3, [r4, #4]
 8004e9c:	f013 0f20 	tst.w	r3, #32
 8004ea0:	d154      	bne.n	8004f4c <HAL_RCCEx_PeriphCLKConfig+0xddc>
  if (status == HAL_OK)
 8004ea2:	b106      	cbz	r6, 8004ea6 <HAL_RCCEx_PeriphCLKConfig+0xd36>
  return HAL_ERROR;
 8004ea4:	2601      	movs	r6, #1
}
 8004ea6:	4630      	mov	r0, r6
 8004ea8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));
 8004eaa:	f240 51e5 	movw	r1, #1509	@ 0x5e5
 8004eae:	482c      	ldr	r0, [pc, #176]	@ (8004f60 <HAL_RCCEx_PeriphCLKConfig+0xdf0>)
 8004eb0:	f7fb fe10 	bl	8000ad4 <assert_failed>
 8004eb4:	e774      	b.n	8004da0 <HAL_RCCEx_PeriphCLKConfig+0xc30>
    assert_param(IS_RCC_HRTIM1CLKSOURCE(PeriphClkInit->Hrtim1ClockSelection));
 8004eb6:	f240 51ef 	movw	r1, #1519	@ 0x5ef
 8004eba:	4829      	ldr	r0, [pc, #164]	@ (8004f60 <HAL_RCCEx_PeriphCLKConfig+0xdf0>)
 8004ebc:	f7fb fe0a 	bl	8000ad4 <assert_failed>
 8004ec0:	e780      	b.n	8004dc4 <HAL_RCCEx_PeriphCLKConfig+0xc54>
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));
 8004ec2:	f240 51f9 	movw	r1, #1529	@ 0x5f9
 8004ec6:	4826      	ldr	r0, [pc, #152]	@ (8004f60 <HAL_RCCEx_PeriphCLKConfig+0xdf0>)
 8004ec8:	f7fb fe04 	bl	8000ad4 <assert_failed>
 8004ecc:	e78c      	b.n	8004de8 <HAL_RCCEx_PeriphCLKConfig+0xc78>
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
 8004ece:	f240 610f 	movw	r1, #1551	@ 0x60f
 8004ed2:	4823      	ldr	r0, [pc, #140]	@ (8004f60 <HAL_RCCEx_PeriphCLKConfig+0xdf0>)
 8004ed4:	f7fb fdfe 	bl	8000ad4 <assert_failed>
 8004ed8:	e798      	b.n	8004e0c <HAL_RCCEx_PeriphCLKConfig+0xc9c>
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));
 8004eda:	f240 6119 	movw	r1, #1561	@ 0x619
 8004ede:	4820      	ldr	r0, [pc, #128]	@ (8004f60 <HAL_RCCEx_PeriphCLKConfig+0xdf0>)
 8004ee0:	f7fb fdf8 	bl	8000ad4 <assert_failed>
 8004ee4:	e7a8      	b.n	8004e38 <HAL_RCCEx_PeriphCLKConfig+0xcc8>
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));
 8004ee6:	f240 6123 	movw	r1, #1571	@ 0x623
 8004eea:	481d      	ldr	r0, [pc, #116]	@ (8004f60 <HAL_RCCEx_PeriphCLKConfig+0xdf0>)
 8004eec:	f7fb fdf2 	bl	8000ad4 <assert_failed>
 8004ef0:	e7b7      	b.n	8004e62 <HAL_RCCEx_PeriphCLKConfig+0xcf2>
    ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8004ef2:	2100      	movs	r1, #0
 8004ef4:	f104 0008 	add.w	r0, r4, #8
 8004ef8:	f7fe ff7a 	bl	8003df0 <RCCEx_PLL2_Config>
    if (ret == HAL_OK)
 8004efc:	2800      	cmp	r0, #0
 8004efe:	d0bc      	beq.n	8004e7a <HAL_RCCEx_PeriphCLKConfig+0xd0a>
      status = ret;
 8004f00:	4606      	mov	r6, r0
 8004f02:	e7ba      	b.n	8004e7a <HAL_RCCEx_PeriphCLKConfig+0xd0a>
    ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 8004f04:	2101      	movs	r1, #1
 8004f06:	f104 0008 	add.w	r0, r4, #8
 8004f0a:	f7fe ff71 	bl	8003df0 <RCCEx_PLL2_Config>
    if (ret == HAL_OK)
 8004f0e:	2800      	cmp	r0, #0
 8004f10:	d0b7      	beq.n	8004e82 <HAL_RCCEx_PeriphCLKConfig+0xd12>
      status = ret;
 8004f12:	4606      	mov	r6, r0
 8004f14:	e7b5      	b.n	8004e82 <HAL_RCCEx_PeriphCLKConfig+0xd12>
    ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 8004f16:	2102      	movs	r1, #2
 8004f18:	f104 0008 	add.w	r0, r4, #8
 8004f1c:	f7fe ff68 	bl	8003df0 <RCCEx_PLL2_Config>
    if (ret == HAL_OK)
 8004f20:	2800      	cmp	r0, #0
 8004f22:	d0b2      	beq.n	8004e8a <HAL_RCCEx_PeriphCLKConfig+0xd1a>
      status = ret;
 8004f24:	4606      	mov	r6, r0
 8004f26:	e7b0      	b.n	8004e8a <HAL_RCCEx_PeriphCLKConfig+0xd1a>
    ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 8004f28:	2100      	movs	r1, #0
 8004f2a:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 8004f2e:	f7ff f83d 	bl	8003fac <RCCEx_PLL3_Config>
    if (ret == HAL_OK)
 8004f32:	2800      	cmp	r0, #0
 8004f34:	d0ad      	beq.n	8004e92 <HAL_RCCEx_PeriphCLKConfig+0xd22>
      status = ret;
 8004f36:	4606      	mov	r6, r0
 8004f38:	e7ab      	b.n	8004e92 <HAL_RCCEx_PeriphCLKConfig+0xd22>
    ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 8004f3a:	2101      	movs	r1, #1
 8004f3c:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 8004f40:	f7ff f834 	bl	8003fac <RCCEx_PLL3_Config>
    if (ret == HAL_OK)
 8004f44:	2800      	cmp	r0, #0
 8004f46:	d0a8      	beq.n	8004e9a <HAL_RCCEx_PeriphCLKConfig+0xd2a>
      status = ret;
 8004f48:	4606      	mov	r6, r0
 8004f4a:	e7a6      	b.n	8004e9a <HAL_RCCEx_PeriphCLKConfig+0xd2a>
    ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 8004f4c:	2102      	movs	r1, #2
 8004f4e:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 8004f52:	f7ff f82b 	bl	8003fac <RCCEx_PLL3_Config>
    if (ret == HAL_OK)
 8004f56:	2800      	cmp	r0, #0
 8004f58:	d0a3      	beq.n	8004ea2 <HAL_RCCEx_PeriphCLKConfig+0xd32>
  return HAL_ERROR;
 8004f5a:	2601      	movs	r6, #1
 8004f5c:	e7a3      	b.n	8004ea6 <HAL_RCCEx_PeriphCLKConfig+0xd36>
 8004f5e:	bf00      	nop
 8004f60:	08015578 	.word	0x08015578
 8004f64:	58024400 	.word	0x58024400

08004f68 <HAL_RCCEx_GetD3PCLK1Freq>:
{
 8004f68:	b508      	push	{r3, lr}
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE) >> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));
 8004f6a:	f7fe fed1 	bl	8003d10 <HAL_RCC_GetHCLKFreq>
 8004f6e:	4b05      	ldr	r3, [pc, #20]	@ (8004f84 <HAL_RCCEx_GetD3PCLK1Freq+0x1c>)
 8004f70:	6a1b      	ldr	r3, [r3, #32]
 8004f72:	f3c3 1302 	ubfx	r3, r3, #4, #3
 8004f76:	4a04      	ldr	r2, [pc, #16]	@ (8004f88 <HAL_RCCEx_GetD3PCLK1Freq+0x20>)
 8004f78:	5cd3      	ldrb	r3, [r2, r3]
 8004f7a:	f003 031f 	and.w	r3, r3, #31
}
 8004f7e:	40d8      	lsrs	r0, r3
 8004f80:	bd08      	pop	{r3, pc}
 8004f82:	bf00      	nop
 8004f84:	58024400 	.word	0x58024400
 8004f88:	08018cc4 	.word	0x08018cc4

08004f8c <HAL_RCCEx_GetPLL2ClockFreq>:
{
 8004f8c:	b410      	push	{r4}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8004f8e:	4b79      	ldr	r3, [pc, #484]	@ (8005174 <HAL_RCCEx_GetPLL2ClockFreq+0x1e8>)
 8004f90:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2) >> 12);
 8004f92:	6a9c      	ldr	r4, [r3, #40]	@ 0x28
 8004f94:	f3c4 3c05 	ubfx	ip, r4, #12, #6
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
 8004f98:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 8004f9a:	f3c1 1100 	ubfx	r1, r1, #4, #1
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2) >> 3));
 8004f9e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8004fa0:	f3c3 03cc 	ubfx	r3, r3, #3, #13
 8004fa4:	fb01 f303 	mul.w	r3, r1, r3
  if (pll2m != 0U)
 8004fa8:	f414 3f7c 	tst.w	r4, #258048	@ 0x3f000
 8004fac:	f000 80dd 	beq.w	800516a <HAL_RCCEx_GetPLL2ClockFreq+0x1de>
 8004fb0:	f002 0203 	and.w	r2, r2, #3
 8004fb4:	ee07 3a90 	vmov	s15, r3
 8004fb8:	eef8 7a67 	vcvt.f32.u32	s15, s15
    switch (pllsource)
 8004fbc:	2a01      	cmp	r2, #1
 8004fbe:	d04b      	beq.n	8005058 <HAL_RCCEx_GetPLL2ClockFreq+0xcc>
 8004fc0:	2a02      	cmp	r2, #2
 8004fc2:	f000 8098 	beq.w	80050f6 <HAL_RCCEx_GetPLL2ClockFreq+0x16a>
 8004fc6:	2a00      	cmp	r2, #0
 8004fc8:	f040 80b2 	bne.w	8005130 <HAL_RCCEx_GetPLL2ClockFreq+0x1a4>
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8004fcc:	4b69      	ldr	r3, [pc, #420]	@ (8005174 <HAL_RCCEx_GetPLL2ClockFreq+0x1e8>)
 8004fce:	681b      	ldr	r3, [r3, #0]
 8004fd0:	f013 0f20 	tst.w	r3, #32
 8004fd4:	d023      	beq.n	800501e <HAL_RCCEx_GetPLL2ClockFreq+0x92>
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8004fd6:	4967      	ldr	r1, [pc, #412]	@ (8005174 <HAL_RCCEx_GetPLL2ClockFreq+0x1e8>)
 8004fd8:	680a      	ldr	r2, [r1, #0]
 8004fda:	f3c2 02c1 	ubfx	r2, r2, #3, #2
 8004fde:	4b66      	ldr	r3, [pc, #408]	@ (8005178 <HAL_RCCEx_GetPLL2ClockFreq+0x1ec>)
 8004fe0:	40d3      	lsrs	r3, r2
          pll2vco = ((float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 8004fe2:	ee07 3a10 	vmov	s14, r3
 8004fe6:	eef8 6a47 	vcvt.f32.u32	s13, s14
 8004fea:	ee07 ca10 	vmov	s14, ip
 8004fee:	eeb8 6a47 	vcvt.f32.u32	s12, s14
 8004ff2:	ee86 7a86 	vdiv.f32	s14, s13, s12
 8004ff6:	6b8b      	ldr	r3, [r1, #56]	@ 0x38
 8004ff8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8004ffc:	ee06 3a90 	vmov	s13, r3
 8005000:	eef8 6a66 	vcvt.f32.u32	s13, s13
 8005004:	ed9f 6a5d 	vldr	s12, [pc, #372]	@ 800517c <HAL_RCCEx_GetPLL2ClockFreq+0x1f0>
 8005008:	ee67 7a86 	vmul.f32	s15, s15, s12
 800500c:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8005010:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8005014:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8005018:	ee27 7a27 	vmul.f32	s14, s14, s15
 800501c:	e038      	b.n	8005090 <HAL_RCCEx_GetPLL2ClockFreq+0x104>
          pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800501e:	ee07 ca10 	vmov	s14, ip
 8005022:	eef8 6a47 	vcvt.f32.u32	s13, s14
 8005026:	ed9f 6a56 	vldr	s12, [pc, #344]	@ 8005180 <HAL_RCCEx_GetPLL2ClockFreq+0x1f4>
 800502a:	ee86 7a26 	vdiv.f32	s14, s12, s13
 800502e:	4b51      	ldr	r3, [pc, #324]	@ (8005174 <HAL_RCCEx_GetPLL2ClockFreq+0x1e8>)
 8005030:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8005032:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8005036:	ee06 3a90 	vmov	s13, r3
 800503a:	eef8 6a66 	vcvt.f32.u32	s13, s13
 800503e:	ed9f 6a4f 	vldr	s12, [pc, #316]	@ 800517c <HAL_RCCEx_GetPLL2ClockFreq+0x1f0>
 8005042:	ee67 7a86 	vmul.f32	s15, s15, s12
 8005046:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800504a:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800504e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8005052:	ee27 7a27 	vmul.f32	s14, s14, s15
 8005056:	e01b      	b.n	8005090 <HAL_RCCEx_GetPLL2ClockFreq+0x104>
        pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 8005058:	ee07 ca10 	vmov	s14, ip
 800505c:	eef8 6a47 	vcvt.f32.u32	s13, s14
 8005060:	ed9f 6a48 	vldr	s12, [pc, #288]	@ 8005184 <HAL_RCCEx_GetPLL2ClockFreq+0x1f8>
 8005064:	ee86 7a26 	vdiv.f32	s14, s12, s13
 8005068:	4b42      	ldr	r3, [pc, #264]	@ (8005174 <HAL_RCCEx_GetPLL2ClockFreq+0x1e8>)
 800506a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800506c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8005070:	ee06 3a90 	vmov	s13, r3
 8005074:	eef8 6a66 	vcvt.f32.u32	s13, s13
 8005078:	ed9f 6a40 	vldr	s12, [pc, #256]	@ 800517c <HAL_RCCEx_GetPLL2ClockFreq+0x1f0>
 800507c:	ee67 7a86 	vmul.f32	s15, s15, s12
 8005080:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8005084:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8005088:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800508c:	ee27 7a27 	vmul.f32	s14, s14, s15
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >> 9)  + (float_t)1)) ;
 8005090:	4a38      	ldr	r2, [pc, #224]	@ (8005174 <HAL_RCCEx_GetPLL2ClockFreq+0x1e8>)
 8005092:	6b93      	ldr	r3, [r2, #56]	@ 0x38
 8005094:	f3c3 2346 	ubfx	r3, r3, #9, #7
 8005098:	ee07 3a90 	vmov	s15, r3
 800509c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80050a0:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 80050a4:	ee77 7aa6 	vadd.f32	s15, s15, s13
 80050a8:	ee87 6a27 	vdiv.f32	s12, s14, s15
 80050ac:	eebc 6ac6 	vcvt.u32.f32	s12, s12
 80050b0:	ed80 6a00 	vstr	s12, [r0]
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >> 16) + (float_t)1)) ;
 80050b4:	6b93      	ldr	r3, [r2, #56]	@ 0x38
 80050b6:	f3c3 4306 	ubfx	r3, r3, #16, #7
 80050ba:	ee07 3a90 	vmov	s15, r3
 80050be:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80050c2:	ee77 7aa6 	vadd.f32	s15, s15, s13
 80050c6:	ee87 6a27 	vdiv.f32	s12, s14, s15
 80050ca:	eebc 6ac6 	vcvt.u32.f32	s12, s12
 80050ce:	ed80 6a01 	vstr	s12, [r0, #4]
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >> 24) + (float_t)1)) ;
 80050d2:	6b93      	ldr	r3, [r2, #56]	@ 0x38
 80050d4:	f3c3 6306 	ubfx	r3, r3, #24, #7
 80050d8:	ee07 3a90 	vmov	s15, r3
 80050dc:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80050e0:	ee77 7aa6 	vadd.f32	s15, s15, s13
 80050e4:	eec7 6a27 	vdiv.f32	s13, s14, s15
 80050e8:	eefc 6ae6 	vcvt.u32.f32	s13, s13
 80050ec:	edc0 6a02 	vstr	s13, [r0, #8]
}
 80050f0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80050f4:	4770      	bx	lr
        pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 80050f6:	ee07 ca10 	vmov	s14, ip
 80050fa:	eef8 6a47 	vcvt.f32.u32	s13, s14
 80050fe:	ed9f 6a22 	vldr	s12, [pc, #136]	@ 8005188 <HAL_RCCEx_GetPLL2ClockFreq+0x1fc>
 8005102:	ee86 7a26 	vdiv.f32	s14, s12, s13
 8005106:	4b1b      	ldr	r3, [pc, #108]	@ (8005174 <HAL_RCCEx_GetPLL2ClockFreq+0x1e8>)
 8005108:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800510a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800510e:	ee06 3a90 	vmov	s13, r3
 8005112:	eef8 6a66 	vcvt.f32.u32	s13, s13
 8005116:	ed9f 6a19 	vldr	s12, [pc, #100]	@ 800517c <HAL_RCCEx_GetPLL2ClockFreq+0x1f0>
 800511a:	ee67 7a86 	vmul.f32	s15, s15, s12
 800511e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8005122:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8005126:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800512a:	ee27 7a27 	vmul.f32	s14, s14, s15
        break;
 800512e:	e7af      	b.n	8005090 <HAL_RCCEx_GetPLL2ClockFreq+0x104>
        pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 8005130:	ee07 ca10 	vmov	s14, ip
 8005134:	eef8 6a47 	vcvt.f32.u32	s13, s14
 8005138:	ed9f 6a12 	vldr	s12, [pc, #72]	@ 8005184 <HAL_RCCEx_GetPLL2ClockFreq+0x1f8>
 800513c:	ee86 7a26 	vdiv.f32	s14, s12, s13
 8005140:	4b0c      	ldr	r3, [pc, #48]	@ (8005174 <HAL_RCCEx_GetPLL2ClockFreq+0x1e8>)
 8005142:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8005144:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8005148:	ee06 3a90 	vmov	s13, r3
 800514c:	eef8 6a66 	vcvt.f32.u32	s13, s13
 8005150:	ed9f 6a0a 	vldr	s12, [pc, #40]	@ 800517c <HAL_RCCEx_GetPLL2ClockFreq+0x1f0>
 8005154:	ee67 7a86 	vmul.f32	s15, s15, s12
 8005158:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800515c:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8005160:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8005164:	ee27 7a27 	vmul.f32	s14, s14, s15
        break;
 8005168:	e792      	b.n	8005090 <HAL_RCCEx_GetPLL2ClockFreq+0x104>
    PLL2_Clocks->PLL2_P_Frequency = 0U;
 800516a:	2300      	movs	r3, #0
 800516c:	6003      	str	r3, [r0, #0]
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
 800516e:	6043      	str	r3, [r0, #4]
    PLL2_Clocks->PLL2_R_Frequency = 0U;
 8005170:	6083      	str	r3, [r0, #8]
}
 8005172:	e7bd      	b.n	80050f0 <HAL_RCCEx_GetPLL2ClockFreq+0x164>
 8005174:	58024400 	.word	0x58024400
 8005178:	03d09000 	.word	0x03d09000
 800517c:	39000000 	.word	0x39000000
 8005180:	4c742400 	.word	0x4c742400
 8005184:	4a742400 	.word	0x4a742400
 8005188:	4b989680 	.word	0x4b989680

0800518c <HAL_RCCEx_GetPLL3ClockFreq>:
{
 800518c:	b410      	push	{r4}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800518e:	4b79      	ldr	r3, [pc, #484]	@ (8005374 <HAL_RCCEx_GetPLL3ClockFreq+0x1e8>)
 8005190:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3) >> 20)  ;
 8005192:	6a9c      	ldr	r4, [r3, #40]	@ 0x28
 8005194:	f3c4 5c05 	ubfx	ip, r4, #20, #6
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
 8005198:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 800519a:	f3c1 2100 	ubfx	r1, r1, #8, #1
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3) >> 3));
 800519e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80051a0:	f3c3 03cc 	ubfx	r3, r3, #3, #13
 80051a4:	fb01 f303 	mul.w	r3, r1, r3
  if (pll3m != 0U)
 80051a8:	f014 7f7c 	tst.w	r4, #66060288	@ 0x3f00000
 80051ac:	f000 80dd 	beq.w	800536a <HAL_RCCEx_GetPLL3ClockFreq+0x1de>
 80051b0:	f002 0203 	and.w	r2, r2, #3
 80051b4:	ee07 3a90 	vmov	s15, r3
 80051b8:	eef8 7a67 	vcvt.f32.u32	s15, s15
    switch (pllsource)
 80051bc:	2a01      	cmp	r2, #1
 80051be:	d04b      	beq.n	8005258 <HAL_RCCEx_GetPLL3ClockFreq+0xcc>
 80051c0:	2a02      	cmp	r2, #2
 80051c2:	f000 8098 	beq.w	80052f6 <HAL_RCCEx_GetPLL3ClockFreq+0x16a>
 80051c6:	2a00      	cmp	r2, #0
 80051c8:	f040 80b2 	bne.w	8005330 <HAL_RCCEx_GetPLL3ClockFreq+0x1a4>
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 80051cc:	4b69      	ldr	r3, [pc, #420]	@ (8005374 <HAL_RCCEx_GetPLL3ClockFreq+0x1e8>)
 80051ce:	681b      	ldr	r3, [r3, #0]
 80051d0:	f013 0f20 	tst.w	r3, #32
 80051d4:	d023      	beq.n	800521e <HAL_RCCEx_GetPLL3ClockFreq+0x92>
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 80051d6:	4967      	ldr	r1, [pc, #412]	@ (8005374 <HAL_RCCEx_GetPLL3ClockFreq+0x1e8>)
 80051d8:	680a      	ldr	r2, [r1, #0]
 80051da:	f3c2 02c1 	ubfx	r2, r2, #3, #2
 80051de:	4b66      	ldr	r3, [pc, #408]	@ (8005378 <HAL_RCCEx_GetPLL3ClockFreq+0x1ec>)
 80051e0:	40d3      	lsrs	r3, r2
          pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 80051e2:	ee07 3a10 	vmov	s14, r3
 80051e6:	eef8 6a47 	vcvt.f32.u32	s13, s14
 80051ea:	ee07 ca10 	vmov	s14, ip
 80051ee:	eeb8 6a47 	vcvt.f32.u32	s12, s14
 80051f2:	ee86 7a86 	vdiv.f32	s14, s13, s12
 80051f6:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 80051f8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80051fc:	ee06 3a90 	vmov	s13, r3
 8005200:	eef8 6a66 	vcvt.f32.u32	s13, s13
 8005204:	ed9f 6a5d 	vldr	s12, [pc, #372]	@ 800537c <HAL_RCCEx_GetPLL3ClockFreq+0x1f0>
 8005208:	ee67 7a86 	vmul.f32	s15, s15, s12
 800520c:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8005210:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8005214:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8005218:	ee27 7a27 	vmul.f32	s14, s14, s15
 800521c:	e038      	b.n	8005290 <HAL_RCCEx_GetPLL3ClockFreq+0x104>
          pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800521e:	ee07 ca10 	vmov	s14, ip
 8005222:	eef8 6a47 	vcvt.f32.u32	s13, s14
 8005226:	ed9f 6a56 	vldr	s12, [pc, #344]	@ 8005380 <HAL_RCCEx_GetPLL3ClockFreq+0x1f4>
 800522a:	ee86 7a26 	vdiv.f32	s14, s12, s13
 800522e:	4b51      	ldr	r3, [pc, #324]	@ (8005374 <HAL_RCCEx_GetPLL3ClockFreq+0x1e8>)
 8005230:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8005232:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8005236:	ee06 3a90 	vmov	s13, r3
 800523a:	eef8 6a66 	vcvt.f32.u32	s13, s13
 800523e:	ed9f 6a4f 	vldr	s12, [pc, #316]	@ 800537c <HAL_RCCEx_GetPLL3ClockFreq+0x1f0>
 8005242:	ee67 7a86 	vmul.f32	s15, s15, s12
 8005246:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800524a:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800524e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8005252:	ee27 7a27 	vmul.f32	s14, s14, s15
 8005256:	e01b      	b.n	8005290 <HAL_RCCEx_GetPLL3ClockFreq+0x104>
        pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 8005258:	ee07 ca10 	vmov	s14, ip
 800525c:	eef8 6a47 	vcvt.f32.u32	s13, s14
 8005260:	ed9f 6a48 	vldr	s12, [pc, #288]	@ 8005384 <HAL_RCCEx_GetPLL3ClockFreq+0x1f8>
 8005264:	ee86 7a26 	vdiv.f32	s14, s12, s13
 8005268:	4b42      	ldr	r3, [pc, #264]	@ (8005374 <HAL_RCCEx_GetPLL3ClockFreq+0x1e8>)
 800526a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800526c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8005270:	ee06 3a90 	vmov	s13, r3
 8005274:	eef8 6a66 	vcvt.f32.u32	s13, s13
 8005278:	ed9f 6a40 	vldr	s12, [pc, #256]	@ 800537c <HAL_RCCEx_GetPLL3ClockFreq+0x1f0>
 800527c:	ee67 7a86 	vmul.f32	s15, s15, s12
 8005280:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8005284:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8005288:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800528c:	ee27 7a27 	vmul.f32	s14, s14, s15
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >> 9)  + (float_t)1)) ;
 8005290:	4a38      	ldr	r2, [pc, #224]	@ (8005374 <HAL_RCCEx_GetPLL3ClockFreq+0x1e8>)
 8005292:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 8005294:	f3c3 2346 	ubfx	r3, r3, #9, #7
 8005298:	ee07 3a90 	vmov	s15, r3
 800529c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80052a0:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 80052a4:	ee77 7aa6 	vadd.f32	s15, s15, s13
 80052a8:	ee87 6a27 	vdiv.f32	s12, s14, s15
 80052ac:	eebc 6ac6 	vcvt.u32.f32	s12, s12
 80052b0:	ed80 6a00 	vstr	s12, [r0]
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >> 16) + (float_t)1)) ;
 80052b4:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 80052b6:	f3c3 4306 	ubfx	r3, r3, #16, #7
 80052ba:	ee07 3a90 	vmov	s15, r3
 80052be:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80052c2:	ee77 7aa6 	vadd.f32	s15, s15, s13
 80052c6:	ee87 6a27 	vdiv.f32	s12, s14, s15
 80052ca:	eebc 6ac6 	vcvt.u32.f32	s12, s12
 80052ce:	ed80 6a01 	vstr	s12, [r0, #4]
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >> 24) + (float_t)1)) ;
 80052d2:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 80052d4:	f3c3 6306 	ubfx	r3, r3, #24, #7
 80052d8:	ee07 3a90 	vmov	s15, r3
 80052dc:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80052e0:	ee77 7aa6 	vadd.f32	s15, s15, s13
 80052e4:	eec7 6a27 	vdiv.f32	s13, s14, s15
 80052e8:	eefc 6ae6 	vcvt.u32.f32	s13, s13
 80052ec:	edc0 6a02 	vstr	s13, [r0, #8]
}
 80052f0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80052f4:	4770      	bx	lr
        pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 80052f6:	ee07 ca10 	vmov	s14, ip
 80052fa:	eef8 6a47 	vcvt.f32.u32	s13, s14
 80052fe:	ed9f 6a22 	vldr	s12, [pc, #136]	@ 8005388 <HAL_RCCEx_GetPLL3ClockFreq+0x1fc>
 8005302:	ee86 7a26 	vdiv.f32	s14, s12, s13
 8005306:	4b1b      	ldr	r3, [pc, #108]	@ (8005374 <HAL_RCCEx_GetPLL3ClockFreq+0x1e8>)
 8005308:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800530a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800530e:	ee06 3a90 	vmov	s13, r3
 8005312:	eef8 6a66 	vcvt.f32.u32	s13, s13
 8005316:	ed9f 6a19 	vldr	s12, [pc, #100]	@ 800537c <HAL_RCCEx_GetPLL3ClockFreq+0x1f0>
 800531a:	ee67 7a86 	vmul.f32	s15, s15, s12
 800531e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8005322:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8005326:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800532a:	ee27 7a27 	vmul.f32	s14, s14, s15
        break;
 800532e:	e7af      	b.n	8005290 <HAL_RCCEx_GetPLL3ClockFreq+0x104>
        pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 8005330:	ee07 ca10 	vmov	s14, ip
 8005334:	eef8 6a47 	vcvt.f32.u32	s13, s14
 8005338:	ed9f 6a12 	vldr	s12, [pc, #72]	@ 8005384 <HAL_RCCEx_GetPLL3ClockFreq+0x1f8>
 800533c:	ee86 7a26 	vdiv.f32	s14, s12, s13
 8005340:	4b0c      	ldr	r3, [pc, #48]	@ (8005374 <HAL_RCCEx_GetPLL3ClockFreq+0x1e8>)
 8005342:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8005344:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8005348:	ee06 3a90 	vmov	s13, r3
 800534c:	eef8 6a66 	vcvt.f32.u32	s13, s13
 8005350:	ed9f 6a0a 	vldr	s12, [pc, #40]	@ 800537c <HAL_RCCEx_GetPLL3ClockFreq+0x1f0>
 8005354:	ee67 7a86 	vmul.f32	s15, s15, s12
 8005358:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800535c:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8005360:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8005364:	ee27 7a27 	vmul.f32	s14, s14, s15
        break;
 8005368:	e792      	b.n	8005290 <HAL_RCCEx_GetPLL3ClockFreq+0x104>
    PLL3_Clocks->PLL3_P_Frequency = 0U;
 800536a:	2300      	movs	r3, #0
 800536c:	6003      	str	r3, [r0, #0]
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
 800536e:	6043      	str	r3, [r0, #4]
    PLL3_Clocks->PLL3_R_Frequency = 0U;
 8005370:	6083      	str	r3, [r0, #8]
}
 8005372:	e7bd      	b.n	80052f0 <HAL_RCCEx_GetPLL3ClockFreq+0x164>
 8005374:	58024400 	.word	0x58024400
 8005378:	03d09000 	.word	0x03d09000
 800537c:	39000000 	.word	0x39000000
 8005380:	4c742400 	.word	0x4c742400
 8005384:	4a742400 	.word	0x4a742400
 8005388:	4b989680 	.word	0x4b989680

0800538c <HAL_RNG_Init>:
  */
HAL_StatusTypeDef HAL_RNG_Init(RNG_HandleTypeDef *hrng)
{
  uint32_t tickstart;
  /* Check the RNG handle allocation */
  if (hrng == NULL)
 800538c:	2800      	cmp	r0, #0
 800538e:	d04e      	beq.n	800542e <HAL_RNG_Init+0xa2>
{
 8005390:	b538      	push	{r3, r4, r5, lr}
 8005392:	4604      	mov	r4, r0
  {
    return HAL_ERROR;
  }
  /* Check the parameters */
  assert_param(IS_RNG_ALL_INSTANCE(hrng->Instance));
 8005394:	6802      	ldr	r2, [r0, #0]
 8005396:	4b27      	ldr	r3, [pc, #156]	@ (8005434 <HAL_RNG_Init+0xa8>)
 8005398:	429a      	cmp	r2, r3
 800539a:	d003      	beq.n	80053a4 <HAL_RNG_Init+0x18>
 800539c:	21b0      	movs	r1, #176	@ 0xb0
 800539e:	4826      	ldr	r0, [pc, #152]	@ (8005438 <HAL_RNG_Init+0xac>)
 80053a0:	f7fb fb98 	bl	8000ad4 <assert_failed>
  assert_param(IS_RNG_CED(hrng->Init.ClockErrorDetection));
 80053a4:	6863      	ldr	r3, [r4, #4]
 80053a6:	2b00      	cmp	r3, #0
 80053a8:	bf18      	it	ne
 80053aa:	2b20      	cmpne	r3, #32
 80053ac:	d118      	bne.n	80053e0 <HAL_RNG_Init+0x54>

    /* Init the low level hardware */
    hrng->MspInitCallback(hrng);
  }
#else
  if (hrng->State == HAL_RNG_STATE_RESET)
 80053ae:	7a63      	ldrb	r3, [r4, #9]
 80053b0:	b1db      	cbz	r3, 80053ea <HAL_RNG_Init+0x5e>
    HAL_RNG_MspInit(hrng);
  }
#endif /* USE_HAL_RNG_REGISTER_CALLBACKS */

  /* Change RNG peripheral state */
  hrng->State = HAL_RNG_STATE_BUSY;
 80053b2:	2302      	movs	r3, #2
 80053b4:	7263      	strb	r3, [r4, #9]
      }
    }
  }
#else
  /* Clock Error Detection Configuration */
  MODIFY_REG(hrng->Instance->CR, RNG_CR_CED, hrng->Init.ClockErrorDetection);
 80053b6:	6822      	ldr	r2, [r4, #0]
 80053b8:	6813      	ldr	r3, [r2, #0]
 80053ba:	f023 0320 	bic.w	r3, r3, #32
 80053be:	6861      	ldr	r1, [r4, #4]
 80053c0:	430b      	orrs	r3, r1
 80053c2:	6013      	str	r3, [r2, #0]
#endif /* RNG_CR_CONDRST */

  /* Enable the RNG Peripheral */
  __HAL_RNG_ENABLE(hrng);
 80053c4:	6822      	ldr	r2, [r4, #0]
 80053c6:	6813      	ldr	r3, [r2, #0]
 80053c8:	f043 0304 	orr.w	r3, r3, #4
 80053cc:	6013      	str	r3, [r2, #0]

  /* verify that no seed error */
  if (__HAL_RNG_GET_IT(hrng, RNG_IT_SEI) != RESET)
 80053ce:	6823      	ldr	r3, [r4, #0]
 80053d0:	685b      	ldr	r3, [r3, #4]
 80053d2:	f013 0f40 	tst.w	r3, #64	@ 0x40
 80053d6:	d00d      	beq.n	80053f4 <HAL_RNG_Init+0x68>
  {
    hrng->State = HAL_RNG_STATE_ERROR;
 80053d8:	2304      	movs	r3, #4
 80053da:	7263      	strb	r3, [r4, #9]
    return HAL_ERROR;
 80053dc:	2001      	movs	r0, #1
  /* Initialise the error code */
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;

  /* Return function status */
  return HAL_OK;
}
 80053de:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_RNG_CED(hrng->Init.ClockErrorDetection));
 80053e0:	21b1      	movs	r1, #177	@ 0xb1
 80053e2:	4815      	ldr	r0, [pc, #84]	@ (8005438 <HAL_RNG_Init+0xac>)
 80053e4:	f7fb fb76 	bl	8000ad4 <assert_failed>
 80053e8:	e7e1      	b.n	80053ae <HAL_RNG_Init+0x22>
    hrng->Lock = HAL_UNLOCKED;
 80053ea:	7223      	strb	r3, [r4, #8]
    HAL_RNG_MspInit(hrng);
 80053ec:	4620      	mov	r0, r4
 80053ee:	f7fb fb85 	bl	8000afc <HAL_RNG_MspInit>
 80053f2:	e7de      	b.n	80053b2 <HAL_RNG_Init+0x26>
  tickstart = HAL_GetTick();
 80053f4:	f7fc f800 	bl	80013f8 <HAL_GetTick>
 80053f8:	4605      	mov	r5, r0
  while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
 80053fa:	6823      	ldr	r3, [r4, #0]
 80053fc:	685b      	ldr	r3, [r3, #4]
 80053fe:	f013 0f04 	tst.w	r3, #4
 8005402:	d00f      	beq.n	8005424 <HAL_RNG_Init+0x98>
    if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 8005404:	f7fb fff8 	bl	80013f8 <HAL_GetTick>
 8005408:	1b40      	subs	r0, r0, r5
 800540a:	2802      	cmp	r0, #2
 800540c:	d9f5      	bls.n	80053fa <HAL_RNG_Init+0x6e>
      if (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
 800540e:	6823      	ldr	r3, [r4, #0]
 8005410:	685b      	ldr	r3, [r3, #4]
 8005412:	f013 0f04 	tst.w	r3, #4
 8005416:	d0f0      	beq.n	80053fa <HAL_RNG_Init+0x6e>
        hrng->State = HAL_RNG_STATE_ERROR;
 8005418:	2304      	movs	r3, #4
 800541a:	7263      	strb	r3, [r4, #9]
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 800541c:	2302      	movs	r3, #2
 800541e:	60e3      	str	r3, [r4, #12]
        return HAL_ERROR;
 8005420:	2001      	movs	r0, #1
 8005422:	e7dc      	b.n	80053de <HAL_RNG_Init+0x52>
  hrng->State = HAL_RNG_STATE_READY;
 8005424:	2301      	movs	r3, #1
 8005426:	7263      	strb	r3, [r4, #9]
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
 8005428:	2000      	movs	r0, #0
 800542a:	60e0      	str	r0, [r4, #12]
  return HAL_OK;
 800542c:	e7d7      	b.n	80053de <HAL_RNG_Init+0x52>
    return HAL_ERROR;
 800542e:	2001      	movs	r0, #1
}
 8005430:	4770      	bx	lr
 8005432:	bf00      	nop
 8005434:	48021800 	.word	0x48021800
 8005438:	080155b4 	.word	0x080155b4

0800543c <SPI_GetPacketSize>:
  *               the configuration information for SPI module.
  * @retval Packet size occupied in the fifo
  */
static uint32_t SPI_GetPacketSize(SPI_HandleTypeDef *hspi)
{
  uint32_t fifo_threashold = (hspi->Init.FifoThreshold >> SPI_CFG1_FTHLV_Pos) + 1UL;
 800543c:	6bc3      	ldr	r3, [r0, #60]	@ 0x3c
 800543e:	095b      	lsrs	r3, r3, #5
  uint32_t data_size       = (hspi->Init.DataSize      >> SPI_CFG1_DSIZE_Pos) + 1UL;
 8005440:	68c0      	ldr	r0, [r0, #12]

  /* Convert data size to Byte */
  data_size = (data_size + 7UL) / 8UL;
 8005442:	3008      	adds	r0, #8
 8005444:	08c0      	lsrs	r0, r0, #3

  return data_size * fifo_threashold;
}
 8005446:	fb03 0000 	mla	r0, r3, r0, r0
 800544a:	4770      	bx	lr

0800544c <HAL_SPI_Init>:
  if (hspi == NULL)
 800544c:	2800      	cmp	r0, #0
 800544e:	f000 81a8 	beq.w	80057a2 <HAL_SPI_Init+0x356>
{
 8005452:	b570      	push	{r4, r5, r6, lr}
 8005454:	4604      	mov	r4, r0
  assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
 8005456:	6803      	ldr	r3, [r0, #0]
 8005458:	49a5      	ldr	r1, [pc, #660]	@ (80056f0 <HAL_SPI_Init+0x2a4>)
 800545a:	4aa6      	ldr	r2, [pc, #664]	@ (80056f4 <HAL_SPI_Init+0x2a8>)
 800545c:	428b      	cmp	r3, r1
 800545e:	bf18      	it	ne
 8005460:	4293      	cmpne	r3, r2
 8005462:	d012      	beq.n	800548a <HAL_SPI_Init+0x3e>
 8005464:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8005468:	4293      	cmp	r3, r2
 800546a:	d00e      	beq.n	800548a <HAL_SPI_Init+0x3e>
 800546c:	f502 4278 	add.w	r2, r2, #63488	@ 0xf800
 8005470:	4293      	cmp	r3, r2
 8005472:	d00a      	beq.n	800548a <HAL_SPI_Init+0x3e>
 8005474:	f502 52e0 	add.w	r2, r2, #7168	@ 0x1c00
 8005478:	4293      	cmp	r3, r2
 800547a:	d006      	beq.n	800548a <HAL_SPI_Init+0x3e>
 800547c:	4a9e      	ldr	r2, [pc, #632]	@ (80056f8 <HAL_SPI_Init+0x2ac>)
 800547e:	4293      	cmp	r3, r2
 8005480:	d003      	beq.n	800548a <HAL_SPI_Init+0x3e>
 8005482:	21fd      	movs	r1, #253	@ 0xfd
 8005484:	489d      	ldr	r0, [pc, #628]	@ (80056fc <HAL_SPI_Init+0x2b0>)
 8005486:	f7fb fb25 	bl	8000ad4 <assert_failed>
  assert_param(IS_SPI_MODE(hspi->Init.Mode));
 800548a:	6863      	ldr	r3, [r4, #4]
 800548c:	2b00      	cmp	r3, #0
 800548e:	bf18      	it	ne
 8005490:	f5b3 0f80 	cmpne.w	r3, #4194304	@ 0x400000
 8005494:	f040 80d2 	bne.w	800563c <HAL_SPI_Init+0x1f0>
  assert_param(IS_SPI_DIRECTION(hspi->Init.Direction));
 8005498:	68a3      	ldr	r3, [r4, #8]
 800549a:	2b00      	cmp	r3, #0
 800549c:	bf18      	it	ne
 800549e:	f5b3 2f80 	cmpne.w	r3, #262144	@ 0x40000
 80054a2:	d006      	beq.n	80054b2 <HAL_SPI_Init+0x66>
 80054a4:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
 80054a8:	d003      	beq.n	80054b2 <HAL_SPI_Init+0x66>
 80054aa:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 80054ae:	f040 80ca 	bne.w	8005646 <HAL_SPI_Init+0x1fa>
  assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
 80054b2:	68e3      	ldr	r3, [r4, #12]
 80054b4:	3b03      	subs	r3, #3
 80054b6:	2b1c      	cmp	r3, #28
 80054b8:	f200 80ca 	bhi.w	8005650 <HAL_SPI_Init+0x204>
  assert_param(IS_SPI_FIFOTHRESHOLD(hspi->Init.FifoThreshold));
 80054bc:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 80054be:	2b00      	cmp	r3, #0
 80054c0:	bf18      	it	ne
 80054c2:	2b20      	cmpne	r3, #32
 80054c4:	d024      	beq.n	8005510 <HAL_SPI_Init+0xc4>
 80054c6:	2b40      	cmp	r3, #64	@ 0x40
 80054c8:	d022      	beq.n	8005510 <HAL_SPI_Init+0xc4>
 80054ca:	2b60      	cmp	r3, #96	@ 0x60
 80054cc:	d020      	beq.n	8005510 <HAL_SPI_Init+0xc4>
 80054ce:	2b80      	cmp	r3, #128	@ 0x80
 80054d0:	d01e      	beq.n	8005510 <HAL_SPI_Init+0xc4>
 80054d2:	2ba0      	cmp	r3, #160	@ 0xa0
 80054d4:	d01c      	beq.n	8005510 <HAL_SPI_Init+0xc4>
 80054d6:	2bc0      	cmp	r3, #192	@ 0xc0
 80054d8:	d01a      	beq.n	8005510 <HAL_SPI_Init+0xc4>
 80054da:	2be0      	cmp	r3, #224	@ 0xe0
 80054dc:	d018      	beq.n	8005510 <HAL_SPI_Init+0xc4>
 80054de:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80054e2:	d015      	beq.n	8005510 <HAL_SPI_Init+0xc4>
 80054e4:	f5b3 7f90 	cmp.w	r3, #288	@ 0x120
 80054e8:	d012      	beq.n	8005510 <HAL_SPI_Init+0xc4>
 80054ea:	f5b3 7fa0 	cmp.w	r3, #320	@ 0x140
 80054ee:	d00f      	beq.n	8005510 <HAL_SPI_Init+0xc4>
 80054f0:	f5b3 7fb0 	cmp.w	r3, #352	@ 0x160
 80054f4:	d00c      	beq.n	8005510 <HAL_SPI_Init+0xc4>
 80054f6:	f5b3 7fc0 	cmp.w	r3, #384	@ 0x180
 80054fa:	d009      	beq.n	8005510 <HAL_SPI_Init+0xc4>
 80054fc:	f5b3 7fd0 	cmp.w	r3, #416	@ 0x1a0
 8005500:	d006      	beq.n	8005510 <HAL_SPI_Init+0xc4>
 8005502:	f5b3 7fe0 	cmp.w	r3, #448	@ 0x1c0
 8005506:	d003      	beq.n	8005510 <HAL_SPI_Init+0xc4>
 8005508:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
 800550c:	f040 80a6 	bne.w	800565c <HAL_SPI_Init+0x210>
  assert_param(IS_SPI_NSS(hspi->Init.NSS));
 8005510:	69a3      	ldr	r3, [r4, #24]
 8005512:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 8005516:	bf18      	it	ne
 8005518:	2b00      	cmpne	r3, #0
 800551a:	d003      	beq.n	8005524 <HAL_SPI_Init+0xd8>
 800551c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8005520:	f040 80a2 	bne.w	8005668 <HAL_SPI_Init+0x21c>
  assert_param(IS_SPI_NSSP(hspi->Init.NSSPMode));
 8005524:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 8005526:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 800552a:	bf18      	it	ne
 800552c:	2b00      	cmpne	r3, #0
 800552e:	f040 80a1 	bne.w	8005674 <HAL_SPI_Init+0x228>
  assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
 8005532:	69e3      	ldr	r3, [r4, #28]
 8005534:	2b00      	cmp	r3, #0
 8005536:	bf18      	it	ne
 8005538:	f1b3 5f80 	cmpne.w	r3, #268435456	@ 0x10000000
 800553c:	d012      	beq.n	8005564 <HAL_SPI_Init+0x118>
 800553e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8005542:	d00f      	beq.n	8005564 <HAL_SPI_Init+0x118>
 8005544:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 8005548:	d00c      	beq.n	8005564 <HAL_SPI_Init+0x118>
 800554a:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 800554e:	d009      	beq.n	8005564 <HAL_SPI_Init+0x118>
 8005550:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8005554:	d006      	beq.n	8005564 <HAL_SPI_Init+0x118>
 8005556:	f1b3 4fc0 	cmp.w	r3, #1610612736	@ 0x60000000
 800555a:	d003      	beq.n	8005564 <HAL_SPI_Init+0x118>
 800555c:	f1b3 4fe0 	cmp.w	r3, #1879048192	@ 0x70000000
 8005560:	f040 808e 	bne.w	8005680 <HAL_SPI_Init+0x234>
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
 8005564:	6a23      	ldr	r3, [r4, #32]
 8005566:	2b00      	cmp	r3, #0
 8005568:	bf18      	it	ne
 800556a:	f5b3 0f00 	cmpne.w	r3, #8388608	@ 0x800000
 800556e:	f040 808d 	bne.w	800568c <HAL_SPI_Init+0x240>
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
 8005572:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8005574:	2b00      	cmp	r3, #0
 8005576:	bf18      	it	ne
 8005578:	f5b3 2f00 	cmpne.w	r3, #524288	@ 0x80000
 800557c:	f040 808c 	bne.w	8005698 <HAL_SPI_Init+0x24c>
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 8005580:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8005582:	b96b      	cbnz	r3, 80055a0 <HAL_SPI_Init+0x154>
    assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
 8005584:	6923      	ldr	r3, [r4, #16]
 8005586:	2b00      	cmp	r3, #0
 8005588:	bf18      	it	ne
 800558a:	f1b3 7f00 	cmpne.w	r3, #33554432	@ 0x2000000
 800558e:	f040 8089 	bne.w	80056a4 <HAL_SPI_Init+0x258>
    assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));
 8005592:	6963      	ldr	r3, [r4, #20]
 8005594:	2b00      	cmp	r3, #0
 8005596:	bf18      	it	ne
 8005598:	f1b3 7f80 	cmpne.w	r3, #16777216	@ 0x1000000
 800559c:	f040 8088 	bne.w	80056b0 <HAL_SPI_Init+0x264>
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80055a0:	2300      	movs	r3, #0
 80055a2:	62a3      	str	r3, [r4, #40]	@ 0x28
  if ((!IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (hspi->Init.DataSize > SPI_DATASIZE_16BIT))
 80055a4:	6825      	ldr	r5, [r4, #0]
 80055a6:	4b52      	ldr	r3, [pc, #328]	@ (80056f0 <HAL_SPI_Init+0x2a4>)
 80055a8:	4e52      	ldr	r6, [pc, #328]	@ (80056f4 <HAL_SPI_Init+0x2a8>)
 80055aa:	429d      	cmp	r5, r3
 80055ac:	bf18      	it	ne
 80055ae:	42b5      	cmpne	r5, r6
 80055b0:	bf14      	ite	ne
 80055b2:	2601      	movne	r6, #1
 80055b4:	2600      	moveq	r6, #0
 80055b6:	d007      	beq.n	80055c8 <HAL_SPI_Init+0x17c>
 80055b8:	f5a3 4374 	sub.w	r3, r3, #62464	@ 0xf400
 80055bc:	429d      	cmp	r5, r3
 80055be:	d003      	beq.n	80055c8 <HAL_SPI_Init+0x17c>
 80055c0:	68e3      	ldr	r3, [r4, #12]
 80055c2:	2b0f      	cmp	r3, #15
 80055c4:	f200 80ef 	bhi.w	80057a6 <HAL_SPI_Init+0x35a>
  packet_length = SPI_GetPacketSize(hspi);
 80055c8:	4620      	mov	r0, r4
 80055ca:	f7ff ff37 	bl	800543c <SPI_GetPacketSize>
  if (((!IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (packet_length > SPI_LOWEND_FIFO_SIZE)) ||
 80055ce:	b12e      	cbz	r6, 80055dc <HAL_SPI_Init+0x190>
 80055d0:	4b4b      	ldr	r3, [pc, #300]	@ (8005700 <HAL_SPI_Init+0x2b4>)
 80055d2:	429d      	cmp	r5, r3
 80055d4:	d002      	beq.n	80055dc <HAL_SPI_Init+0x190>
 80055d6:	2808      	cmp	r0, #8
 80055d8:	f200 80e7 	bhi.w	80057aa <HAL_SPI_Init+0x35e>
 80055dc:	4a44      	ldr	r2, [pc, #272]	@ (80056f0 <HAL_SPI_Init+0x2a4>)
 80055de:	4b45      	ldr	r3, [pc, #276]	@ (80056f4 <HAL_SPI_Init+0x2a8>)
 80055e0:	429d      	cmp	r5, r3
 80055e2:	bf18      	it	ne
 80055e4:	4295      	cmpne	r5, r2
 80055e6:	d003      	beq.n	80055f0 <HAL_SPI_Init+0x1a4>
      ((IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (packet_length > SPI_HIGHEND_FIFO_SIZE)))
 80055e8:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80055ec:	429d      	cmp	r5, r3
 80055ee:	d102      	bne.n	80055f6 <HAL_SPI_Init+0x1aa>
 80055f0:	2810      	cmp	r0, #16
 80055f2:	f200 80dc 	bhi.w	80057ae <HAL_SPI_Init+0x362>
  if (hspi->State == HAL_SPI_STATE_RESET)
 80055f6:	f894 3081 	ldrb.w	r3, [r4, #129]	@ 0x81
 80055fa:	2b00      	cmp	r3, #0
 80055fc:	d05e      	beq.n	80056bc <HAL_SPI_Init+0x270>
  hspi->State = HAL_SPI_STATE_BUSY;
 80055fe:	2302      	movs	r3, #2
 8005600:	f884 3081 	strb.w	r3, [r4, #129]	@ 0x81
  __HAL_SPI_DISABLE(hspi);
 8005604:	6822      	ldr	r2, [r4, #0]
 8005606:	6813      	ldr	r3, [r2, #0]
 8005608:	f023 0301 	bic.w	r3, r3, #1
 800560c:	6013      	str	r3, [r2, #0]
  crc_length = hspi->Instance->CFG1 & SPI_CFG1_CRCSIZE;
 800560e:	6823      	ldr	r3, [r4, #0]
 8005610:	689a      	ldr	r2, [r3, #8]
 8005612:	f402 12f8 	and.w	r2, r2, #2031616	@ 0x1f0000
  if ((hspi->Init.NSS == SPI_NSS_SOFT) && (((hspi->Init.Mode == SPI_MODE_MASTER) &&  \
 8005616:	69a1      	ldr	r1, [r4, #24]
 8005618:	f1b1 6f80 	cmp.w	r1, #67108864	@ 0x4000000
 800561c:	d054      	beq.n	80056c8 <HAL_SPI_Init+0x27c>
  if (((hspi->Init.Mode & SPI_MODE_MASTER) == SPI_MODE_MASTER) && (hspi->Init.DataSize >= SPI_DATASIZE_8BIT))
 800561e:	6863      	ldr	r3, [r4, #4]
 8005620:	f413 0f80 	tst.w	r3, #4194304	@ 0x400000
 8005624:	d06e      	beq.n	8005704 <HAL_SPI_Init+0x2b8>
 8005626:	68e3      	ldr	r3, [r4, #12]
 8005628:	2b06      	cmp	r3, #6
 800562a:	d96b      	bls.n	8005704 <HAL_SPI_Init+0x2b8>
    MODIFY_REG(hspi->Instance->CR1, SPI_CR1_MASRX, hspi->Init.MasterReceiverAutoSusp);
 800562c:	6821      	ldr	r1, [r4, #0]
 800562e:	680b      	ldr	r3, [r1, #0]
 8005630:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8005634:	6d20      	ldr	r0, [r4, #80]	@ 0x50
 8005636:	4303      	orrs	r3, r0
 8005638:	600b      	str	r3, [r1, #0]
 800563a:	e068      	b.n	800570e <HAL_SPI_Init+0x2c2>
  assert_param(IS_SPI_MODE(hspi->Init.Mode));
 800563c:	21fe      	movs	r1, #254	@ 0xfe
 800563e:	482f      	ldr	r0, [pc, #188]	@ (80056fc <HAL_SPI_Init+0x2b0>)
 8005640:	f7fb fa48 	bl	8000ad4 <assert_failed>
 8005644:	e728      	b.n	8005498 <HAL_SPI_Init+0x4c>
  assert_param(IS_SPI_DIRECTION(hspi->Init.Direction));
 8005646:	21ff      	movs	r1, #255	@ 0xff
 8005648:	482c      	ldr	r0, [pc, #176]	@ (80056fc <HAL_SPI_Init+0x2b0>)
 800564a:	f7fb fa43 	bl	8000ad4 <assert_failed>
 800564e:	e730      	b.n	80054b2 <HAL_SPI_Init+0x66>
  assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
 8005650:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8005654:	4829      	ldr	r0, [pc, #164]	@ (80056fc <HAL_SPI_Init+0x2b0>)
 8005656:	f7fb fa3d 	bl	8000ad4 <assert_failed>
 800565a:	e72f      	b.n	80054bc <HAL_SPI_Init+0x70>
  assert_param(IS_SPI_FIFOTHRESHOLD(hspi->Init.FifoThreshold));
 800565c:	f240 1101 	movw	r1, #257	@ 0x101
 8005660:	4826      	ldr	r0, [pc, #152]	@ (80056fc <HAL_SPI_Init+0x2b0>)
 8005662:	f7fb fa37 	bl	8000ad4 <assert_failed>
 8005666:	e753      	b.n	8005510 <HAL_SPI_Init+0xc4>
  assert_param(IS_SPI_NSS(hspi->Init.NSS));
 8005668:	f44f 7181 	mov.w	r1, #258	@ 0x102
 800566c:	4823      	ldr	r0, [pc, #140]	@ (80056fc <HAL_SPI_Init+0x2b0>)
 800566e:	f7fb fa31 	bl	8000ad4 <assert_failed>
 8005672:	e757      	b.n	8005524 <HAL_SPI_Init+0xd8>
  assert_param(IS_SPI_NSSP(hspi->Init.NSSPMode));
 8005674:	f240 1103 	movw	r1, #259	@ 0x103
 8005678:	4820      	ldr	r0, [pc, #128]	@ (80056fc <HAL_SPI_Init+0x2b0>)
 800567a:	f7fb fa2b 	bl	8000ad4 <assert_failed>
 800567e:	e758      	b.n	8005532 <HAL_SPI_Init+0xe6>
  assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
 8005680:	f44f 7182 	mov.w	r1, #260	@ 0x104
 8005684:	481d      	ldr	r0, [pc, #116]	@ (80056fc <HAL_SPI_Init+0x2b0>)
 8005686:	f7fb fa25 	bl	8000ad4 <assert_failed>
 800568a:	e76b      	b.n	8005564 <HAL_SPI_Init+0x118>
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
 800568c:	f240 1105 	movw	r1, #261	@ 0x105
 8005690:	481a      	ldr	r0, [pc, #104]	@ (80056fc <HAL_SPI_Init+0x2b0>)
 8005692:	f7fb fa1f 	bl	8000ad4 <assert_failed>
 8005696:	e76c      	b.n	8005572 <HAL_SPI_Init+0x126>
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
 8005698:	f44f 7183 	mov.w	r1, #262	@ 0x106
 800569c:	4817      	ldr	r0, [pc, #92]	@ (80056fc <HAL_SPI_Init+0x2b0>)
 800569e:	f7fb fa19 	bl	8000ad4 <assert_failed>
 80056a2:	e76d      	b.n	8005580 <HAL_SPI_Init+0x134>
    assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
 80056a4:	f240 1109 	movw	r1, #265	@ 0x109
 80056a8:	4814      	ldr	r0, [pc, #80]	@ (80056fc <HAL_SPI_Init+0x2b0>)
 80056aa:	f7fb fa13 	bl	8000ad4 <assert_failed>
 80056ae:	e770      	b.n	8005592 <HAL_SPI_Init+0x146>
    assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));
 80056b0:	f44f 7185 	mov.w	r1, #266	@ 0x10a
 80056b4:	4811      	ldr	r0, [pc, #68]	@ (80056fc <HAL_SPI_Init+0x2b0>)
 80056b6:	f7fb fa0d 	bl	8000ad4 <assert_failed>
 80056ba:	e771      	b.n	80055a0 <HAL_SPI_Init+0x154>
    hspi->Lock = HAL_UNLOCKED;
 80056bc:	f884 3080 	strb.w	r3, [r4, #128]	@ 0x80
    HAL_SPI_MspInit(hspi);
 80056c0:	4620      	mov	r0, r4
 80056c2:	f7fb fa73 	bl	8000bac <HAL_SPI_MspInit>
 80056c6:	e79a      	b.n	80055fe <HAL_SPI_Init+0x1b2>
  if ((hspi->Init.NSS == SPI_NSS_SOFT) && (((hspi->Init.Mode == SPI_MODE_MASTER) &&  \
 80056c8:	6861      	ldr	r1, [r4, #4]
 80056ca:	f5b1 0f80 	cmp.w	r1, #4194304	@ 0x400000
 80056ce:	d006      	beq.n	80056de <HAL_SPI_Init+0x292>
                                            (hspi->Init.NSSPolarity == SPI_NSS_POLARITY_LOW)) || \
 80056d0:	2900      	cmp	r1, #0
 80056d2:	d1a4      	bne.n	800561e <HAL_SPI_Init+0x1d2>
                                            (hspi->Init.NSSPolarity == SPI_NSS_POLARITY_HIGH))))
 80056d4:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
                                           ((hspi->Init.Mode == SPI_MODE_SLAVE) && \
 80056d6:	f1b1 5f80 	cmp.w	r1, #268435456	@ 0x10000000
 80056da:	d1a0      	bne.n	800561e <HAL_SPI_Init+0x1d2>
 80056dc:	e002      	b.n	80056e4 <HAL_SPI_Init+0x298>
                                            (hspi->Init.NSSPolarity == SPI_NSS_POLARITY_LOW)) || \
 80056de:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
  if ((hspi->Init.NSS == SPI_NSS_SOFT) && (((hspi->Init.Mode == SPI_MODE_MASTER) &&  \
 80056e0:	2800      	cmp	r0, #0
 80056e2:	d1f5      	bne.n	80056d0 <HAL_SPI_Init+0x284>
    SET_BIT(hspi->Instance->CR1, SPI_CR1_SSI);
 80056e4:	6819      	ldr	r1, [r3, #0]
 80056e6:	f441 5180 	orr.w	r1, r1, #4096	@ 0x1000
 80056ea:	6019      	str	r1, [r3, #0]
 80056ec:	e797      	b.n	800561e <HAL_SPI_Init+0x1d2>
 80056ee:	bf00      	nop
 80056f0:	40013000 	.word	0x40013000
 80056f4:	40003800 	.word	0x40003800
 80056f8:	58001400 	.word	0x58001400
 80056fc:	080155ec 	.word	0x080155ec
 8005700:	40003c00 	.word	0x40003c00
    CLEAR_BIT(hspi->Instance->CR1, SPI_CR1_MASRX);
 8005704:	6821      	ldr	r1, [r4, #0]
 8005706:	680b      	ldr	r3, [r1, #0]
 8005708:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 800570c:	600b      	str	r3, [r1, #0]
  WRITE_REG(hspi->Instance->CFG1, (hspi->Init.BaudRatePrescaler | hspi->Init.CRCCalculation | crc_length |
 800570e:	69e3      	ldr	r3, [r4, #28]
 8005710:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 8005712:	430b      	orrs	r3, r1
 8005714:	4313      	orrs	r3, r2
 8005716:	6be2      	ldr	r2, [r4, #60]	@ 0x3c
 8005718:	4313      	orrs	r3, r2
 800571a:	68e1      	ldr	r1, [r4, #12]
 800571c:	6822      	ldr	r2, [r4, #0]
 800571e:	430b      	orrs	r3, r1
 8005720:	6093      	str	r3, [r2, #8]
  WRITE_REG(hspi->Instance->CFG2, (hspi->Init.NSSPMode                | hspi->Init.TIMode    |
 8005722:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 8005724:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 8005726:	4313      	orrs	r3, r2
 8005728:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 800572a:	4313      	orrs	r3, r2
 800572c:	69a2      	ldr	r2, [r4, #24]
 800572e:	4313      	orrs	r3, r2
 8005730:	6922      	ldr	r2, [r4, #16]
 8005732:	4313      	orrs	r3, r2
 8005734:	6962      	ldr	r2, [r4, #20]
 8005736:	4313      	orrs	r3, r2
 8005738:	6a22      	ldr	r2, [r4, #32]
 800573a:	4313      	orrs	r3, r2
 800573c:	6862      	ldr	r2, [r4, #4]
 800573e:	4313      	orrs	r3, r2
 8005740:	6ce2      	ldr	r2, [r4, #76]	@ 0x4c
 8005742:	4313      	orrs	r3, r2
 8005744:	68a2      	ldr	r2, [r4, #8]
 8005746:	4313      	orrs	r3, r2
 8005748:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
 800574a:	4313      	orrs	r3, r2
 800574c:	6da1      	ldr	r1, [r4, #88]	@ 0x58
 800574e:	6822      	ldr	r2, [r4, #0]
 8005750:	430b      	orrs	r3, r1
 8005752:	60d3      	str	r3, [r2, #12]
  if (hspi->Init.Mode == SPI_MODE_SLAVE)
 8005754:	6863      	ldr	r3, [r4, #4]
 8005756:	b96b      	cbnz	r3, 8005774 <HAL_SPI_Init+0x328>
      MODIFY_REG(hspi->Instance->CFG1, SPI_CFG1_UDRDET, SPI_CFG1_UDRDET_0);
 8005758:	6822      	ldr	r2, [r4, #0]
 800575a:	6893      	ldr	r3, [r2, #8]
 800575c:	f423 53c0 	bic.w	r3, r3, #6144	@ 0x1800
 8005760:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 8005764:	6093      	str	r3, [r2, #8]
    MODIFY_REG(hspi->Instance->CFG1, SPI_CFG1_UDRCFG, SPI_CFG1_UDRCFG_1);
 8005766:	6822      	ldr	r2, [r4, #0]
 8005768:	6893      	ldr	r3, [r2, #8]
 800576a:	f423 63c0 	bic.w	r3, r3, #1536	@ 0x600
 800576e:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8005772:	6093      	str	r3, [r2, #8]
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8005774:	6822      	ldr	r2, [r4, #0]
 8005776:	6d13      	ldr	r3, [r2, #80]	@ 0x50
 8005778:	f023 0301 	bic.w	r3, r3, #1
 800577c:	6513      	str	r3, [r2, #80]	@ 0x50
  if ((hspi->Init.Mode & SPI_MODE_MASTER) == SPI_MODE_MASTER)
 800577e:	6863      	ldr	r3, [r4, #4]
 8005780:	f413 0f80 	tst.w	r3, #4194304	@ 0x400000
 8005784:	d006      	beq.n	8005794 <HAL_SPI_Init+0x348>
    MODIFY_REG(hspi->Instance->CFG2, SPI_CFG2_AFCNTR, (hspi->Init.MasterKeepIOState));
 8005786:	6822      	ldr	r2, [r4, #0]
 8005788:	68d3      	ldr	r3, [r2, #12]
 800578a:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 800578e:	6d61      	ldr	r1, [r4, #84]	@ 0x54
 8005790:	430b      	orrs	r3, r1
 8005792:	60d3      	str	r3, [r2, #12]
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8005794:	2000      	movs	r0, #0
 8005796:	f8c4 0084 	str.w	r0, [r4, #132]	@ 0x84
  hspi->State     = HAL_SPI_STATE_READY;
 800579a:	2301      	movs	r3, #1
 800579c:	f884 3081 	strb.w	r3, [r4, #129]	@ 0x81
}
 80057a0:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 80057a2:	2001      	movs	r0, #1
}
 80057a4:	4770      	bx	lr
    return HAL_ERROR;
 80057a6:	2001      	movs	r0, #1
 80057a8:	e7fa      	b.n	80057a0 <HAL_SPI_Init+0x354>
    return HAL_ERROR;
 80057aa:	2001      	movs	r0, #1
 80057ac:	e7f8      	b.n	80057a0 <HAL_SPI_Init+0x354>
 80057ae:	2001      	movs	r0, #1
 80057b0:	e7f6      	b.n	80057a0 <HAL_SPI_Init+0x354>
 80057b2:	bf00      	nop

080057b4 <HAL_TIM_Base_MspInit>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   */
}
 80057b4:	4770      	bx	lr
	...

080057b8 <HAL_TIM_Base_Start_IT>:
  * @brief  Starts the TIM Base generation in interrupt mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
{
 80057b8:	b510      	push	{r4, lr}
 80057ba:	4604      	mov	r4, r0
  uint32_t tmpsmcr;

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 80057bc:	6803      	ldr	r3, [r0, #0]
 80057be:	4a3f      	ldr	r2, [pc, #252]	@ (80058bc <HAL_TIM_Base_Start_IT+0x104>)
 80057c0:	4293      	cmp	r3, r2
 80057c2:	bf18      	it	ne
 80057c4:	f1b3 4f80 	cmpne.w	r3, #1073741824	@ 0x40000000
 80057c8:	d034      	beq.n	8005834 <HAL_TIM_Base_Start_IT+0x7c>
 80057ca:	f5a2 427c 	sub.w	r2, r2, #64512	@ 0xfc00
 80057ce:	4293      	cmp	r3, r2
 80057d0:	d030      	beq.n	8005834 <HAL_TIM_Base_Start_IT+0x7c>
 80057d2:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 80057d6:	4293      	cmp	r3, r2
 80057d8:	d02c      	beq.n	8005834 <HAL_TIM_Base_Start_IT+0x7c>
 80057da:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 80057de:	4293      	cmp	r3, r2
 80057e0:	d028      	beq.n	8005834 <HAL_TIM_Base_Start_IT+0x7c>
 80057e2:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 80057e6:	4293      	cmp	r3, r2
 80057e8:	d024      	beq.n	8005834 <HAL_TIM_Base_Start_IT+0x7c>
 80057ea:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 80057ee:	4293      	cmp	r3, r2
 80057f0:	d020      	beq.n	8005834 <HAL_TIM_Base_Start_IT+0x7c>
 80057f2:	f502 4270 	add.w	r2, r2, #61440	@ 0xf000
 80057f6:	4293      	cmp	r3, r2
 80057f8:	d01c      	beq.n	8005834 <HAL_TIM_Base_Start_IT+0x7c>
 80057fa:	f5a2 426c 	sub.w	r2, r2, #60416	@ 0xec00
 80057fe:	4293      	cmp	r3, r2
 8005800:	d018      	beq.n	8005834 <HAL_TIM_Base_Start_IT+0x7c>
 8005802:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8005806:	4293      	cmp	r3, r2
 8005808:	d014      	beq.n	8005834 <HAL_TIM_Base_Start_IT+0x7c>
 800580a:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 800580e:	4293      	cmp	r3, r2
 8005810:	d010      	beq.n	8005834 <HAL_TIM_Base_Start_IT+0x7c>
 8005812:	f502 3290 	add.w	r2, r2, #73728	@ 0x12000
 8005816:	4293      	cmp	r3, r2
 8005818:	d00c      	beq.n	8005834 <HAL_TIM_Base_Start_IT+0x7c>
 800581a:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 800581e:	4293      	cmp	r3, r2
 8005820:	d008      	beq.n	8005834 <HAL_TIM_Base_Start_IT+0x7c>
 8005822:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8005826:	4293      	cmp	r3, r2
 8005828:	d004      	beq.n	8005834 <HAL_TIM_Base_Start_IT+0x7c>
 800582a:	f240 11d3 	movw	r1, #467	@ 0x1d3
 800582e:	4824      	ldr	r0, [pc, #144]	@ (80058c0 <HAL_TIM_Base_Start_IT+0x108>)
 8005830:	f7fb f950 	bl	8000ad4 <assert_failed>

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 8005834:	f894 303d 	ldrb.w	r3, [r4, #61]	@ 0x3d
 8005838:	b2db      	uxtb	r3, r3
 800583a:	2b01      	cmp	r3, #1
 800583c:	d13a      	bne.n	80058b4 <HAL_TIM_Base_Start_IT+0xfc>
  {
    return HAL_ERROR;
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 800583e:	2302      	movs	r3, #2
 8005840:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8005844:	6822      	ldr	r2, [r4, #0]
 8005846:	68d3      	ldr	r3, [r2, #12]
 8005848:	f043 0301 	orr.w	r3, r3, #1
 800584c:	60d3      	str	r3, [r2, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800584e:	6823      	ldr	r3, [r4, #0]
 8005850:	4a1a      	ldr	r2, [pc, #104]	@ (80058bc <HAL_TIM_Base_Start_IT+0x104>)
 8005852:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8005856:	bf18      	it	ne
 8005858:	4293      	cmpne	r3, r2
 800585a:	d01d      	beq.n	8005898 <HAL_TIM_Base_Start_IT+0xe0>
 800585c:	f5a2 427c 	sub.w	r2, r2, #64512	@ 0xfc00
 8005860:	4293      	cmp	r3, r2
 8005862:	d019      	beq.n	8005898 <HAL_TIM_Base_Start_IT+0xe0>
 8005864:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8005868:	4293      	cmp	r3, r2
 800586a:	d015      	beq.n	8005898 <HAL_TIM_Base_Start_IT+0xe0>
 800586c:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8005870:	4293      	cmp	r3, r2
 8005872:	d011      	beq.n	8005898 <HAL_TIM_Base_Start_IT+0xe0>
 8005874:	f502 4278 	add.w	r2, r2, #63488	@ 0xf800
 8005878:	4293      	cmp	r3, r2
 800587a:	d00d      	beq.n	8005898 <HAL_TIM_Base_Start_IT+0xe0>
 800587c:	f5a2 426c 	sub.w	r2, r2, #60416	@ 0xec00
 8005880:	4293      	cmp	r3, r2
 8005882:	d009      	beq.n	8005898 <HAL_TIM_Base_Start_IT+0xe0>
 8005884:	f502 3294 	add.w	r2, r2, #75776	@ 0x12800
 8005888:	4293      	cmp	r3, r2
 800588a:	d005      	beq.n	8005898 <HAL_TIM_Base_Start_IT+0xe0>
      __HAL_TIM_ENABLE(htim);
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 800588c:	681a      	ldr	r2, [r3, #0]
 800588e:	f042 0201 	orr.w	r2, r2, #1
 8005892:	601a      	str	r2, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
 8005894:	2000      	movs	r0, #0
 8005896:	e00e      	b.n	80058b6 <HAL_TIM_Base_Start_IT+0xfe>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8005898:	6899      	ldr	r1, [r3, #8]
 800589a:	4a0a      	ldr	r2, [pc, #40]	@ (80058c4 <HAL_TIM_Base_Start_IT+0x10c>)
 800589c:	400a      	ands	r2, r1
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800589e:	2a06      	cmp	r2, #6
 80058a0:	bf18      	it	ne
 80058a2:	f5b2 3f80 	cmpne.w	r2, #65536	@ 0x10000
 80058a6:	d007      	beq.n	80058b8 <HAL_TIM_Base_Start_IT+0x100>
      __HAL_TIM_ENABLE(htim);
 80058a8:	681a      	ldr	r2, [r3, #0]
 80058aa:	f042 0201 	orr.w	r2, r2, #1
 80058ae:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 80058b0:	2000      	movs	r0, #0
 80058b2:	e000      	b.n	80058b6 <HAL_TIM_Base_Start_IT+0xfe>
    return HAL_ERROR;
 80058b4:	2001      	movs	r0, #1
}
 80058b6:	bd10      	pop	{r4, pc}
  return HAL_OK;
 80058b8:	2000      	movs	r0, #0
 80058ba:	e7fc      	b.n	80058b6 <HAL_TIM_Base_Start_IT+0xfe>
 80058bc:	40010000 	.word	0x40010000
 80058c0:	08015624 	.word	0x08015624
 80058c4:	00010007 	.word	0x00010007

080058c8 <HAL_TIM_OC_DelayElapsedCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 80058c8:	4770      	bx	lr

080058ca <HAL_TIM_IC_CaptureCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 80058ca:	4770      	bx	lr

080058cc <HAL_TIM_PWM_PulseFinishedCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 80058cc:	4770      	bx	lr

080058ce <HAL_TIM_TriggerCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 80058ce:	4770      	bx	lr

080058d0 <HAL_TIM_IRQHandler>:
{
 80058d0:	b510      	push	{r4, lr}
 80058d2:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 80058d4:	6803      	ldr	r3, [r0, #0]
 80058d6:	691a      	ldr	r2, [r3, #16]
 80058d8:	f012 0f02 	tst.w	r2, #2
 80058dc:	d011      	beq.n	8005902 <HAL_TIM_IRQHandler+0x32>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 80058de:	68da      	ldr	r2, [r3, #12]
 80058e0:	f012 0f02 	tst.w	r2, #2
 80058e4:	d00d      	beq.n	8005902 <HAL_TIM_IRQHandler+0x32>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 80058e6:	f06f 0202 	mvn.w	r2, #2
 80058ea:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 80058ec:	2301      	movs	r3, #1
 80058ee:	7703      	strb	r3, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 80058f0:	6803      	ldr	r3, [r0, #0]
 80058f2:	699b      	ldr	r3, [r3, #24]
 80058f4:	f013 0f03 	tst.w	r3, #3
 80058f8:	d079      	beq.n	80059ee <HAL_TIM_IRQHandler+0x11e>
          HAL_TIM_IC_CaptureCallback(htim);
 80058fa:	f7ff ffe6 	bl	80058ca <HAL_TIM_IC_CaptureCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80058fe:	2300      	movs	r3, #0
 8005900:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8005902:	6823      	ldr	r3, [r4, #0]
 8005904:	691a      	ldr	r2, [r3, #16]
 8005906:	f012 0f04 	tst.w	r2, #4
 800590a:	d012      	beq.n	8005932 <HAL_TIM_IRQHandler+0x62>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 800590c:	68da      	ldr	r2, [r3, #12]
 800590e:	f012 0f04 	tst.w	r2, #4
 8005912:	d00e      	beq.n	8005932 <HAL_TIM_IRQHandler+0x62>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8005914:	f06f 0204 	mvn.w	r2, #4
 8005918:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800591a:	2302      	movs	r3, #2
 800591c:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 800591e:	6823      	ldr	r3, [r4, #0]
 8005920:	699b      	ldr	r3, [r3, #24]
 8005922:	f413 7f40 	tst.w	r3, #768	@ 0x300
 8005926:	d068      	beq.n	80059fa <HAL_TIM_IRQHandler+0x12a>
        HAL_TIM_IC_CaptureCallback(htim);
 8005928:	4620      	mov	r0, r4
 800592a:	f7ff ffce 	bl	80058ca <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800592e:	2300      	movs	r3, #0
 8005930:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8005932:	6823      	ldr	r3, [r4, #0]
 8005934:	691a      	ldr	r2, [r3, #16]
 8005936:	f012 0f08 	tst.w	r2, #8
 800593a:	d012      	beq.n	8005962 <HAL_TIM_IRQHandler+0x92>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 800593c:	68da      	ldr	r2, [r3, #12]
 800593e:	f012 0f08 	tst.w	r2, #8
 8005942:	d00e      	beq.n	8005962 <HAL_TIM_IRQHandler+0x92>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8005944:	f06f 0208 	mvn.w	r2, #8
 8005948:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 800594a:	2304      	movs	r3, #4
 800594c:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 800594e:	6823      	ldr	r3, [r4, #0]
 8005950:	69db      	ldr	r3, [r3, #28]
 8005952:	f013 0f03 	tst.w	r3, #3
 8005956:	d057      	beq.n	8005a08 <HAL_TIM_IRQHandler+0x138>
        HAL_TIM_IC_CaptureCallback(htim);
 8005958:	4620      	mov	r0, r4
 800595a:	f7ff ffb6 	bl	80058ca <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800595e:	2300      	movs	r3, #0
 8005960:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8005962:	6823      	ldr	r3, [r4, #0]
 8005964:	691a      	ldr	r2, [r3, #16]
 8005966:	f012 0f10 	tst.w	r2, #16
 800596a:	d012      	beq.n	8005992 <HAL_TIM_IRQHandler+0xc2>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 800596c:	68da      	ldr	r2, [r3, #12]
 800596e:	f012 0f10 	tst.w	r2, #16
 8005972:	d00e      	beq.n	8005992 <HAL_TIM_IRQHandler+0xc2>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8005974:	f06f 0210 	mvn.w	r2, #16
 8005978:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 800597a:	2308      	movs	r3, #8
 800597c:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 800597e:	6823      	ldr	r3, [r4, #0]
 8005980:	69db      	ldr	r3, [r3, #28]
 8005982:	f413 7f40 	tst.w	r3, #768	@ 0x300
 8005986:	d046      	beq.n	8005a16 <HAL_TIM_IRQHandler+0x146>
        HAL_TIM_IC_CaptureCallback(htim);
 8005988:	4620      	mov	r0, r4
 800598a:	f7ff ff9e 	bl	80058ca <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800598e:	2300      	movs	r3, #0
 8005990:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8005992:	6823      	ldr	r3, [r4, #0]
 8005994:	691a      	ldr	r2, [r3, #16]
 8005996:	f012 0f01 	tst.w	r2, #1
 800599a:	d003      	beq.n	80059a4 <HAL_TIM_IRQHandler+0xd4>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 800599c:	68da      	ldr	r2, [r3, #12]
 800599e:	f012 0f01 	tst.w	r2, #1
 80059a2:	d13f      	bne.n	8005a24 <HAL_TIM_IRQHandler+0x154>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 80059a4:	6823      	ldr	r3, [r4, #0]
 80059a6:	691a      	ldr	r2, [r3, #16]
 80059a8:	f012 0f80 	tst.w	r2, #128	@ 0x80
 80059ac:	d003      	beq.n	80059b6 <HAL_TIM_IRQHandler+0xe6>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 80059ae:	68da      	ldr	r2, [r3, #12]
 80059b0:	f012 0f80 	tst.w	r2, #128	@ 0x80
 80059b4:	d13d      	bne.n	8005a32 <HAL_TIM_IRQHandler+0x162>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 80059b6:	6823      	ldr	r3, [r4, #0]
 80059b8:	691a      	ldr	r2, [r3, #16]
 80059ba:	f412 7f80 	tst.w	r2, #256	@ 0x100
 80059be:	d003      	beq.n	80059c8 <HAL_TIM_IRQHandler+0xf8>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 80059c0:	68da      	ldr	r2, [r3, #12]
 80059c2:	f012 0f80 	tst.w	r2, #128	@ 0x80
 80059c6:	d13b      	bne.n	8005a40 <HAL_TIM_IRQHandler+0x170>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 80059c8:	6823      	ldr	r3, [r4, #0]
 80059ca:	691a      	ldr	r2, [r3, #16]
 80059cc:	f012 0f40 	tst.w	r2, #64	@ 0x40
 80059d0:	d003      	beq.n	80059da <HAL_TIM_IRQHandler+0x10a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 80059d2:	68da      	ldr	r2, [r3, #12]
 80059d4:	f012 0f40 	tst.w	r2, #64	@ 0x40
 80059d8:	d139      	bne.n	8005a4e <HAL_TIM_IRQHandler+0x17e>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 80059da:	6823      	ldr	r3, [r4, #0]
 80059dc:	691a      	ldr	r2, [r3, #16]
 80059de:	f012 0f20 	tst.w	r2, #32
 80059e2:	d003      	beq.n	80059ec <HAL_TIM_IRQHandler+0x11c>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 80059e4:	68da      	ldr	r2, [r3, #12]
 80059e6:	f012 0f20 	tst.w	r2, #32
 80059ea:	d137      	bne.n	8005a5c <HAL_TIM_IRQHandler+0x18c>
}
 80059ec:	bd10      	pop	{r4, pc}
          HAL_TIM_OC_DelayElapsedCallback(htim);
 80059ee:	f7ff ff6b 	bl	80058c8 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 80059f2:	4620      	mov	r0, r4
 80059f4:	f7ff ff6a 	bl	80058cc <HAL_TIM_PWM_PulseFinishedCallback>
 80059f8:	e781      	b.n	80058fe <HAL_TIM_IRQHandler+0x2e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80059fa:	4620      	mov	r0, r4
 80059fc:	f7ff ff64 	bl	80058c8 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8005a00:	4620      	mov	r0, r4
 8005a02:	f7ff ff63 	bl	80058cc <HAL_TIM_PWM_PulseFinishedCallback>
 8005a06:	e792      	b.n	800592e <HAL_TIM_IRQHandler+0x5e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8005a08:	4620      	mov	r0, r4
 8005a0a:	f7ff ff5d 	bl	80058c8 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8005a0e:	4620      	mov	r0, r4
 8005a10:	f7ff ff5c 	bl	80058cc <HAL_TIM_PWM_PulseFinishedCallback>
 8005a14:	e7a3      	b.n	800595e <HAL_TIM_IRQHandler+0x8e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8005a16:	4620      	mov	r0, r4
 8005a18:	f7ff ff56 	bl	80058c8 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8005a1c:	4620      	mov	r0, r4
 8005a1e:	f7ff ff55 	bl	80058cc <HAL_TIM_PWM_PulseFinishedCallback>
 8005a22:	e7b4      	b.n	800598e <HAL_TIM_IRQHandler+0xbe>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8005a24:	f06f 0201 	mvn.w	r2, #1
 8005a28:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8005a2a:	4620      	mov	r0, r4
 8005a2c:	f7fa ff92 	bl	8000954 <HAL_TIM_PeriodElapsedCallback>
 8005a30:	e7b8      	b.n	80059a4 <HAL_TIM_IRQHandler+0xd4>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8005a32:	f06f 0280 	mvn.w	r2, #128	@ 0x80
 8005a36:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8005a38:	4620      	mov	r0, r4
 8005a3a:	f000 f958 	bl	8005cee <HAL_TIMEx_BreakCallback>
 8005a3e:	e7ba      	b.n	80059b6 <HAL_TIM_IRQHandler+0xe6>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 8005a40:	f46f 7280 	mvn.w	r2, #256	@ 0x100
 8005a44:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_Break2Callback(htim);
 8005a46:	4620      	mov	r0, r4
 8005a48:	f000 f952 	bl	8005cf0 <HAL_TIMEx_Break2Callback>
 8005a4c:	e7bc      	b.n	80059c8 <HAL_TIM_IRQHandler+0xf8>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8005a4e:	f06f 0240 	mvn.w	r2, #64	@ 0x40
 8005a52:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 8005a54:	4620      	mov	r0, r4
 8005a56:	f7ff ff3a 	bl	80058ce <HAL_TIM_TriggerCallback>
 8005a5a:	e7be      	b.n	80059da <HAL_TIM_IRQHandler+0x10a>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8005a5c:	f06f 0220 	mvn.w	r2, #32
 8005a60:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutCallback(htim);
 8005a62:	4620      	mov	r0, r4
 8005a64:	f000 f942 	bl	8005cec <HAL_TIMEx_CommutCallback>
}
 8005a68:	e7c0      	b.n	80059ec <HAL_TIM_IRQHandler+0x11c>
	...

08005a6c <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, const TIM_Base_InitTypeDef *Structure)
{
 8005a6c:	b530      	push	{r4, r5, lr}
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 8005a6e:	6803      	ldr	r3, [r0, #0]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8005a70:	4a39      	ldr	r2, [pc, #228]	@ (8005b58 <TIM_Base_SetConfig+0xec>)
 8005a72:	4290      	cmp	r0, r2
 8005a74:	bf14      	ite	ne
 8005a76:	f04f 0e00 	movne.w	lr, #0
 8005a7a:	f04f 0e01 	moveq.w	lr, #1
 8005a7e:	f1b0 4f80 	cmp.w	r0, #1073741824	@ 0x40000000
 8005a82:	bf14      	ite	ne
 8005a84:	4672      	movne	r2, lr
 8005a86:	f04e 0201 	orreq.w	r2, lr, #1
 8005a8a:	b9aa      	cbnz	r2, 8005ab8 <TIM_Base_SetConfig+0x4c>
 8005a8c:	4c33      	ldr	r4, [pc, #204]	@ (8005b5c <TIM_Base_SetConfig+0xf0>)
 8005a8e:	42a0      	cmp	r0, r4
 8005a90:	bf14      	ite	ne
 8005a92:	2400      	movne	r4, #0
 8005a94:	2401      	moveq	r4, #1
 8005a96:	4d32      	ldr	r5, [pc, #200]	@ (8005b60 <TIM_Base_SetConfig+0xf4>)
 8005a98:	42a8      	cmp	r0, r5
 8005a9a:	d00d      	beq.n	8005ab8 <TIM_Base_SetConfig+0x4c>
 8005a9c:	b964      	cbnz	r4, 8005ab8 <TIM_Base_SetConfig+0x4c>
 8005a9e:	f104 4480 	add.w	r4, r4, #1073741824	@ 0x40000000
 8005aa2:	f504 3482 	add.w	r4, r4, #66560	@ 0x10400
 8005aa6:	42a0      	cmp	r0, r4
 8005aa8:	bf14      	ite	ne
 8005aaa:	2400      	movne	r4, #0
 8005aac:	2401      	moveq	r4, #1
 8005aae:	f505 6500 	add.w	r5, r5, #2048	@ 0x800
 8005ab2:	42a8      	cmp	r0, r5
 8005ab4:	d000      	beq.n	8005ab8 <TIM_Base_SetConfig+0x4c>
 8005ab6:	b11c      	cbz	r4, 8005ac0 <TIM_Base_SetConfig+0x54>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8005ab8:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
    tmpcr1 |= Structure->CounterMode;
 8005abc:	684c      	ldr	r4, [r1, #4]
 8005abe:	4323      	orrs	r3, r4
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8005ac0:	bb12      	cbnz	r2, 8005b08 <TIM_Base_SetConfig+0x9c>
 8005ac2:	4a26      	ldr	r2, [pc, #152]	@ (8005b5c <TIM_Base_SetConfig+0xf0>)
 8005ac4:	4290      	cmp	r0, r2
 8005ac6:	bf14      	ite	ne
 8005ac8:	2200      	movne	r2, #0
 8005aca:	2201      	moveq	r2, #1
 8005acc:	4c24      	ldr	r4, [pc, #144]	@ (8005b60 <TIM_Base_SetConfig+0xf4>)
 8005ace:	42a0      	cmp	r0, r4
 8005ad0:	d01a      	beq.n	8005b08 <TIM_Base_SetConfig+0x9c>
 8005ad2:	b9ca      	cbnz	r2, 8005b08 <TIM_Base_SetConfig+0x9c>
 8005ad4:	f102 4280 	add.w	r2, r2, #1073741824	@ 0x40000000
 8005ad8:	f502 3282 	add.w	r2, r2, #66560	@ 0x10400
 8005adc:	4290      	cmp	r0, r2
 8005ade:	bf14      	ite	ne
 8005ae0:	2200      	movne	r2, #0
 8005ae2:	2201      	moveq	r2, #1
 8005ae4:	f504 6400 	add.w	r4, r4, #2048	@ 0x800
 8005ae8:	42a0      	cmp	r0, r4
 8005aea:	d00d      	beq.n	8005b08 <TIM_Base_SetConfig+0x9c>
 8005aec:	b962      	cbnz	r2, 8005b08 <TIM_Base_SetConfig+0x9c>
 8005aee:	4a1d      	ldr	r2, [pc, #116]	@ (8005b64 <TIM_Base_SetConfig+0xf8>)
 8005af0:	4290      	cmp	r0, r2
 8005af2:	bf14      	ite	ne
 8005af4:	2200      	movne	r2, #0
 8005af6:	2201      	moveq	r2, #1
 8005af8:	f504 349a 	add.w	r4, r4, #78848	@ 0x13400
 8005afc:	42a0      	cmp	r0, r4
 8005afe:	d003      	beq.n	8005b08 <TIM_Base_SetConfig+0x9c>
 8005b00:	b912      	cbnz	r2, 8005b08 <TIM_Base_SetConfig+0x9c>
 8005b02:	4a19      	ldr	r2, [pc, #100]	@ (8005b68 <TIM_Base_SetConfig+0xfc>)
 8005b04:	4290      	cmp	r0, r2
 8005b06:	d104      	bne.n	8005b12 <TIM_Base_SetConfig+0xa6>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8005b08:	f423 7c40 	bic.w	ip, r3, #768	@ 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8005b0c:	68cb      	ldr	r3, [r1, #12]
 8005b0e:	ea43 030c 	orr.w	r3, r3, ip
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8005b12:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8005b16:	694a      	ldr	r2, [r1, #20]
 8005b18:	4313      	orrs	r3, r2

  TIMx->CR1 = tmpcr1;
 8005b1a:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8005b1c:	688a      	ldr	r2, [r1, #8]
 8005b1e:	62c2      	str	r2, [r0, #44]	@ 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8005b20:	680a      	ldr	r2, [r1, #0]
 8005b22:	6282      	str	r2, [r0, #40]	@ 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8005b24:	4a11      	ldr	r2, [pc, #68]	@ (8005b6c <TIM_Base_SetConfig+0x100>)
 8005b26:	4290      	cmp	r0, r2
 8005b28:	bf14      	ite	ne
 8005b2a:	4673      	movne	r3, lr
 8005b2c:	f04e 0301 	orreq.w	r3, lr, #1
 8005b30:	b963      	cbnz	r3, 8005b4c <TIM_Base_SetConfig+0xe0>
 8005b32:	4b0c      	ldr	r3, [pc, #48]	@ (8005b64 <TIM_Base_SetConfig+0xf8>)
 8005b34:	4298      	cmp	r0, r3
 8005b36:	bf14      	ite	ne
 8005b38:	2300      	movne	r3, #0
 8005b3a:	2301      	moveq	r3, #1
 8005b3c:	f502 5270 	add.w	r2, r2, #15360	@ 0x3c00
 8005b40:	4290      	cmp	r0, r2
 8005b42:	d003      	beq.n	8005b4c <TIM_Base_SetConfig+0xe0>
 8005b44:	b913      	cbnz	r3, 8005b4c <TIM_Base_SetConfig+0xe0>
 8005b46:	4b08      	ldr	r3, [pc, #32]	@ (8005b68 <TIM_Base_SetConfig+0xfc>)
 8005b48:	4298      	cmp	r0, r3
 8005b4a:	d101      	bne.n	8005b50 <TIM_Base_SetConfig+0xe4>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8005b4c:	690b      	ldr	r3, [r1, #16]
 8005b4e:	6303      	str	r3, [r0, #48]	@ 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8005b50:	2301      	movs	r3, #1
 8005b52:	6143      	str	r3, [r0, #20]
}
 8005b54:	bd30      	pop	{r4, r5, pc}
 8005b56:	bf00      	nop
 8005b58:	40010000 	.word	0x40010000
 8005b5c:	40000800 	.word	0x40000800
 8005b60:	40000400 	.word	0x40000400
 8005b64:	40014400 	.word	0x40014400
 8005b68:	40014800 	.word	0x40014800
 8005b6c:	40010400 	.word	0x40010400

08005b70 <HAL_TIM_Base_Init>:
  if (htim == NULL)
 8005b70:	2800      	cmp	r0, #0
 8005b72:	f000 80b2 	beq.w	8005cda <HAL_TIM_Base_Init+0x16a>
{
 8005b76:	b510      	push	{r4, lr}
 8005b78:	4604      	mov	r4, r0
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 8005b7a:	6803      	ldr	r3, [r0, #0]
 8005b7c:	4a58      	ldr	r2, [pc, #352]	@ (8005ce0 <HAL_TIM_Base_Init+0x170>)
 8005b7e:	4293      	cmp	r3, r2
 8005b80:	bf18      	it	ne
 8005b82:	f1b3 4f80 	cmpne.w	r3, #1073741824	@ 0x40000000
 8005b86:	d034      	beq.n	8005bf2 <HAL_TIM_Base_Init+0x82>
 8005b88:	f5a2 427c 	sub.w	r2, r2, #64512	@ 0xfc00
 8005b8c:	4293      	cmp	r3, r2
 8005b8e:	d030      	beq.n	8005bf2 <HAL_TIM_Base_Init+0x82>
 8005b90:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8005b94:	4293      	cmp	r3, r2
 8005b96:	d02c      	beq.n	8005bf2 <HAL_TIM_Base_Init+0x82>
 8005b98:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8005b9c:	4293      	cmp	r3, r2
 8005b9e:	d028      	beq.n	8005bf2 <HAL_TIM_Base_Init+0x82>
 8005ba0:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8005ba4:	4293      	cmp	r3, r2
 8005ba6:	d024      	beq.n	8005bf2 <HAL_TIM_Base_Init+0x82>
 8005ba8:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8005bac:	4293      	cmp	r3, r2
 8005bae:	d020      	beq.n	8005bf2 <HAL_TIM_Base_Init+0x82>
 8005bb0:	f502 4270 	add.w	r2, r2, #61440	@ 0xf000
 8005bb4:	4293      	cmp	r3, r2
 8005bb6:	d01c      	beq.n	8005bf2 <HAL_TIM_Base_Init+0x82>
 8005bb8:	f5a2 426c 	sub.w	r2, r2, #60416	@ 0xec00
 8005bbc:	4293      	cmp	r3, r2
 8005bbe:	d018      	beq.n	8005bf2 <HAL_TIM_Base_Init+0x82>
 8005bc0:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8005bc4:	4293      	cmp	r3, r2
 8005bc6:	d014      	beq.n	8005bf2 <HAL_TIM_Base_Init+0x82>
 8005bc8:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8005bcc:	4293      	cmp	r3, r2
 8005bce:	d010      	beq.n	8005bf2 <HAL_TIM_Base_Init+0x82>
 8005bd0:	f502 3290 	add.w	r2, r2, #73728	@ 0x12000
 8005bd4:	4293      	cmp	r3, r2
 8005bd6:	d00c      	beq.n	8005bf2 <HAL_TIM_Base_Init+0x82>
 8005bd8:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8005bdc:	4293      	cmp	r3, r2
 8005bde:	d008      	beq.n	8005bf2 <HAL_TIM_Base_Init+0x82>
 8005be0:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8005be4:	4293      	cmp	r3, r2
 8005be6:	d004      	beq.n	8005bf2 <HAL_TIM_Base_Init+0x82>
 8005be8:	f44f 718b 	mov.w	r1, #278	@ 0x116
 8005bec:	483d      	ldr	r0, [pc, #244]	@ (8005ce4 <HAL_TIM_Base_Init+0x174>)
 8005bee:	f7fa ff71 	bl	8000ad4 <assert_failed>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
 8005bf2:	68a3      	ldr	r3, [r4, #8]
 8005bf4:	2b00      	cmp	r3, #0
 8005bf6:	bf18      	it	ne
 8005bf8:	2b10      	cmpne	r3, #16
 8005bfa:	d005      	beq.n	8005c08 <HAL_TIM_Base_Init+0x98>
 8005bfc:	2b20      	cmp	r3, #32
 8005bfe:	d003      	beq.n	8005c08 <HAL_TIM_Base_Init+0x98>
 8005c00:	2b40      	cmp	r3, #64	@ 0x40
 8005c02:	d001      	beq.n	8005c08 <HAL_TIM_Base_Init+0x98>
 8005c04:	2b60      	cmp	r3, #96	@ 0x60
 8005c06:	d145      	bne.n	8005c94 <HAL_TIM_Base_Init+0x124>
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
 8005c08:	6923      	ldr	r3, [r4, #16]
 8005c0a:	2b00      	cmp	r3, #0
 8005c0c:	bf18      	it	ne
 8005c0e:	f5b3 7f80 	cmpne.w	r3, #256	@ 0x100
 8005c12:	d002      	beq.n	8005c1a <HAL_TIM_Base_Init+0xaa>
 8005c14:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8005c18:	d142      	bne.n	8005ca0 <HAL_TIM_Base_Init+0x130>
  assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
 8005c1a:	6823      	ldr	r3, [r4, #0]
 8005c1c:	4a32      	ldr	r2, [pc, #200]	@ (8005ce8 <HAL_TIM_Base_Init+0x178>)
 8005c1e:	4293      	cmp	r3, r2
 8005c20:	bf18      	it	ne
 8005c22:	f1b3 4f80 	cmpne.w	r3, #1073741824	@ 0x40000000
 8005c26:	d041      	beq.n	8005cac <HAL_TIM_Base_Init+0x13c>
 8005c28:	68e3      	ldr	r3, [r4, #12]
 8005c2a:	3b01      	subs	r3, #1
 8005c2c:	f64f 72fe 	movw	r2, #65534	@ 0xfffe
 8005c30:	4293      	cmp	r3, r2
 8005c32:	bf8c      	ite	hi
 8005c34:	2300      	movhi	r3, #0
 8005c36:	2301      	movls	r3, #1
 8005c38:	2b00      	cmp	r3, #0
 8005c3a:	d03c      	beq.n	8005cb6 <HAL_TIM_Base_Init+0x146>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
 8005c3c:	69a3      	ldr	r3, [r4, #24]
 8005c3e:	2b00      	cmp	r3, #0
 8005c40:	bf18      	it	ne
 8005c42:	2b80      	cmpne	r3, #128	@ 0x80
 8005c44:	d13d      	bne.n	8005cc2 <HAL_TIM_Base_Init+0x152>
  if (htim->State == HAL_TIM_STATE_RESET)
 8005c46:	f894 303d 	ldrb.w	r3, [r4, #61]	@ 0x3d
 8005c4a:	2b00      	cmp	r3, #0
 8005c4c:	d03f      	beq.n	8005cce <HAL_TIM_Base_Init+0x15e>
  htim->State = HAL_TIM_STATE_BUSY;
 8005c4e:	2302      	movs	r3, #2
 8005c50:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8005c54:	4621      	mov	r1, r4
 8005c56:	f851 0b04 	ldr.w	r0, [r1], #4
 8005c5a:	f7ff ff07 	bl	8005a6c <TIM_Base_SetConfig>
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8005c5e:	2301      	movs	r3, #1
 8005c60:	f884 3048 	strb.w	r3, [r4, #72]	@ 0x48
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8005c64:	f884 303e 	strb.w	r3, [r4, #62]	@ 0x3e
 8005c68:	f884 303f 	strb.w	r3, [r4, #63]	@ 0x3f
 8005c6c:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
 8005c70:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
 8005c74:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 8005c78:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8005c7c:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
 8005c80:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
 8005c84:	f884 3046 	strb.w	r3, [r4, #70]	@ 0x46
 8005c88:	f884 3047 	strb.w	r3, [r4, #71]	@ 0x47
  htim->State = HAL_TIM_STATE_READY;
 8005c8c:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  return HAL_OK;
 8005c90:	2000      	movs	r0, #0
}
 8005c92:	bd10      	pop	{r4, pc}
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
 8005c94:	f240 1117 	movw	r1, #279	@ 0x117
 8005c98:	4812      	ldr	r0, [pc, #72]	@ (8005ce4 <HAL_TIM_Base_Init+0x174>)
 8005c9a:	f7fa ff1b 	bl	8000ad4 <assert_failed>
 8005c9e:	e7b3      	b.n	8005c08 <HAL_TIM_Base_Init+0x98>
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
 8005ca0:	f44f 718c 	mov.w	r1, #280	@ 0x118
 8005ca4:	480f      	ldr	r0, [pc, #60]	@ (8005ce4 <HAL_TIM_Base_Init+0x174>)
 8005ca6:	f7fa ff15 	bl	8000ad4 <assert_failed>
 8005caa:	e7b6      	b.n	8005c1a <HAL_TIM_Base_Init+0xaa>
  assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
 8005cac:	68e3      	ldr	r3, [r4, #12]
 8005cae:	3b00      	subs	r3, #0
 8005cb0:	bf18      	it	ne
 8005cb2:	2301      	movne	r3, #1
 8005cb4:	e7c0      	b.n	8005c38 <HAL_TIM_Base_Init+0xc8>
 8005cb6:	f240 1119 	movw	r1, #281	@ 0x119
 8005cba:	480a      	ldr	r0, [pc, #40]	@ (8005ce4 <HAL_TIM_Base_Init+0x174>)
 8005cbc:	f7fa ff0a 	bl	8000ad4 <assert_failed>
 8005cc0:	e7bc      	b.n	8005c3c <HAL_TIM_Base_Init+0xcc>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
 8005cc2:	f44f 718d 	mov.w	r1, #282	@ 0x11a
 8005cc6:	4807      	ldr	r0, [pc, #28]	@ (8005ce4 <HAL_TIM_Base_Init+0x174>)
 8005cc8:	f7fa ff04 	bl	8000ad4 <assert_failed>
 8005ccc:	e7bb      	b.n	8005c46 <HAL_TIM_Base_Init+0xd6>
    htim->Lock = HAL_UNLOCKED;
 8005cce:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
    HAL_TIM_Base_MspInit(htim);
 8005cd2:	4620      	mov	r0, r4
 8005cd4:	f7ff fd6e 	bl	80057b4 <HAL_TIM_Base_MspInit>
 8005cd8:	e7b9      	b.n	8005c4e <HAL_TIM_Base_Init+0xde>
    return HAL_ERROR;
 8005cda:	2001      	movs	r0, #1
}
 8005cdc:	4770      	bx	lr
 8005cde:	bf00      	nop
 8005ce0:	40010000 	.word	0x40010000
 8005ce4:	08015624 	.word	0x08015624
 8005ce8:	40000c00 	.word	0x40000c00

08005cec <HAL_TIMEx_CommutCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 8005cec:	4770      	bx	lr

08005cee <HAL_TIMEx_BreakCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 8005cee:	4770      	bx	lr

08005cf0 <HAL_TIMEx_Break2Callback>:
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
 8005cf0:	4770      	bx	lr
	...

08005cf4 <UART_EndRxTransfer>:
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8005cf4:	6802      	ldr	r2, [r0, #0]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005cf6:	e852 3f00 	ldrex	r3, [r2]
 8005cfa:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005cfe:	e842 3100 	strex	r1, r3, [r2]
 8005d02:	2900      	cmp	r1, #0
 8005d04:	d1f6      	bne.n	8005cf4 <UART_EndRxTransfer>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8005d06:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005d08:	f102 0308 	add.w	r3, r2, #8
 8005d0c:	e853 1f00 	ldrex	r1, [r3]
 8005d10:	4b0d      	ldr	r3, [pc, #52]	@ (8005d48 <UART_EndRxTransfer+0x54>)
 8005d12:	400b      	ands	r3, r1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005d14:	3208      	adds	r2, #8
 8005d16:	e842 3100 	strex	r1, r3, [r2]
 8005d1a:	2900      	cmp	r1, #0
 8005d1c:	d1f3      	bne.n	8005d06 <UART_EndRxTransfer+0x12>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8005d1e:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
 8005d20:	2b01      	cmp	r3, #1
 8005d22:	d006      	beq.n	8005d32 <UART_EndRxTransfer+0x3e>
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8005d24:	2320      	movs	r3, #32
 8005d26:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8005d2a:	2300      	movs	r3, #0
 8005d2c:	66c3      	str	r3, [r0, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 8005d2e:	6743      	str	r3, [r0, #116]	@ 0x74
}
 8005d30:	4770      	bx	lr
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8005d32:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005d34:	e852 3f00 	ldrex	r3, [r2]
 8005d38:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005d3c:	e842 3100 	strex	r1, r3, [r2]
 8005d40:	2900      	cmp	r1, #0
 8005d42:	d1f6      	bne.n	8005d32 <UART_EndRxTransfer+0x3e>
 8005d44:	e7ee      	b.n	8005d24 <UART_EndRxTransfer+0x30>
 8005d46:	bf00      	nop
 8005d48:	effffffe 	.word	0xeffffffe

08005d4c <UART_SetConfig>:
{
 8005d4c:	b570      	push	{r4, r5, r6, lr}
 8005d4e:	b086      	sub	sp, #24
 8005d50:	4604      	mov	r4, r0
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
 8005d52:	6842      	ldr	r2, [r0, #4]
 8005d54:	4b88      	ldr	r3, [pc, #544]	@ (8005f78 <UART_SetConfig+0x22c>)
 8005d56:	429a      	cmp	r2, r3
 8005d58:	f200 809c 	bhi.w	8005e94 <UART_SetConfig+0x148>
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
 8005d5c:	68a3      	ldr	r3, [r4, #8]
 8005d5e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8005d62:	bf18      	it	ne
 8005d64:	2b00      	cmpne	r3, #0
 8005d66:	d003      	beq.n	8005d70 <UART_SetConfig+0x24>
 8005d68:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8005d6c:	f040 8098 	bne.w	8005ea0 <UART_SetConfig+0x154>
  if (UART_INSTANCE_LOWPOWER(huart))
 8005d70:	6822      	ldr	r2, [r4, #0]
 8005d72:	4b82      	ldr	r3, [pc, #520]	@ (8005f7c <UART_SetConfig+0x230>)
 8005d74:	429a      	cmp	r2, r3
 8005d76:	f000 8099 	beq.w	8005eac <UART_SetConfig+0x160>
    assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
 8005d7a:	68e3      	ldr	r3, [r4, #12]
 8005d7c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8005d80:	bf18      	it	ne
 8005d82:	2b00      	cmpne	r3, #0
 8005d84:	d006      	beq.n	8005d94 <UART_SetConfig+0x48>
 8005d86:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8005d8a:	d003      	beq.n	8005d94 <UART_SetConfig+0x48>
 8005d8c:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8005d90:	f040 8099 	bne.w	8005ec6 <UART_SetConfig+0x17a>
    assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
 8005d94:	6a23      	ldr	r3, [r4, #32]
 8005d96:	2b00      	cmp	r3, #0
 8005d98:	bf18      	it	ne
 8005d9a:	f5b3 6f00 	cmpne.w	r3, #2048	@ 0x800
 8005d9e:	f040 8098 	bne.w	8005ed2 <UART_SetConfig+0x186>
  assert_param(IS_UART_PARITY(huart->Init.Parity));
 8005da2:	6923      	ldr	r3, [r4, #16]
 8005da4:	2b00      	cmp	r3, #0
 8005da6:	bf18      	it	ne
 8005da8:	f5b3 6f80 	cmpne.w	r3, #1024	@ 0x400
 8005dac:	d003      	beq.n	8005db6 <UART_SetConfig+0x6a>
 8005dae:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
 8005db2:	f040 8094 	bne.w	8005ede <UART_SetConfig+0x192>
  assert_param(IS_UART_MODE(huart->Init.Mode));
 8005db6:	6963      	ldr	r3, [r4, #20]
 8005db8:	f033 020c 	bics.w	r2, r3, #12
 8005dbc:	d100      	bne.n	8005dc0 <UART_SetConfig+0x74>
 8005dbe:	b923      	cbnz	r3, 8005dca <UART_SetConfig+0x7e>
 8005dc0:	f640 31d9 	movw	r1, #3033	@ 0xbd9
 8005dc4:	486e      	ldr	r0, [pc, #440]	@ (8005f80 <UART_SetConfig+0x234>)
 8005dc6:	f7fa fe85 	bl	8000ad4 <assert_failed>
  assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
 8005dca:	69a3      	ldr	r3, [r4, #24]
 8005dcc:	2b00      	cmp	r3, #0
 8005dce:	bf18      	it	ne
 8005dd0:	f5b3 7f80 	cmpne.w	r3, #256	@ 0x100
 8005dd4:	d006      	beq.n	8005de4 <UART_SetConfig+0x98>
 8005dd6:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8005dda:	d003      	beq.n	8005de4 <UART_SetConfig+0x98>
 8005ddc:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 8005de0:	f040 8083 	bne.w	8005eea <UART_SetConfig+0x19e>
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
 8005de4:	69e3      	ldr	r3, [r4, #28]
 8005de6:	2b00      	cmp	r3, #0
 8005de8:	bf18      	it	ne
 8005dea:	f5b3 4f00 	cmpne.w	r3, #32768	@ 0x8000
 8005dee:	f040 8082 	bne.w	8005ef6 <UART_SetConfig+0x1aa>
  assert_param(IS_UART_PRESCALER(huart->Init.ClockPrescaler));
 8005df2:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8005df4:	2b0b      	cmp	r3, #11
 8005df6:	f200 8084 	bhi.w	8005f02 <UART_SetConfig+0x1b6>
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8005dfa:	68a3      	ldr	r3, [r4, #8]
 8005dfc:	6922      	ldr	r2, [r4, #16]
 8005dfe:	4313      	orrs	r3, r2
 8005e00:	6962      	ldr	r2, [r4, #20]
 8005e02:	4313      	orrs	r3, r2
 8005e04:	69e2      	ldr	r2, [r4, #28]
 8005e06:	4313      	orrs	r3, r2
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8005e08:	6821      	ldr	r1, [r4, #0]
 8005e0a:	6808      	ldr	r0, [r1, #0]
 8005e0c:	4a5d      	ldr	r2, [pc, #372]	@ (8005f84 <UART_SetConfig+0x238>)
 8005e0e:	4002      	ands	r2, r0
 8005e10:	431a      	orrs	r2, r3
 8005e12:	600a      	str	r2, [r1, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8005e14:	6822      	ldr	r2, [r4, #0]
 8005e16:	6853      	ldr	r3, [r2, #4]
 8005e18:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
 8005e1c:	68e1      	ldr	r1, [r4, #12]
 8005e1e:	430b      	orrs	r3, r1
 8005e20:	6053      	str	r3, [r2, #4]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 8005e22:	69a1      	ldr	r1, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8005e24:	6822      	ldr	r2, [r4, #0]
 8005e26:	4b55      	ldr	r3, [pc, #340]	@ (8005f7c <UART_SetConfig+0x230>)
 8005e28:	429a      	cmp	r2, r3
 8005e2a:	d001      	beq.n	8005e30 <UART_SetConfig+0xe4>
    tmpreg |= huart->Init.OneBitSampling;
 8005e2c:	6a23      	ldr	r3, [r4, #32]
 8005e2e:	4319      	orrs	r1, r3
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8005e30:	6890      	ldr	r0, [r2, #8]
 8005e32:	4b55      	ldr	r3, [pc, #340]	@ (8005f88 <UART_SetConfig+0x23c>)
 8005e34:	4003      	ands	r3, r0
 8005e36:	430b      	orrs	r3, r1
 8005e38:	6093      	str	r3, [r2, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8005e3a:	6822      	ldr	r2, [r4, #0]
 8005e3c:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 8005e3e:	f023 030f 	bic.w	r3, r3, #15
 8005e42:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 8005e44:	430b      	orrs	r3, r1
 8005e46:	62d3      	str	r3, [r2, #44]	@ 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 8005e48:	6823      	ldr	r3, [r4, #0]
 8005e4a:	4a50      	ldr	r2, [pc, #320]	@ (8005f8c <UART_SetConfig+0x240>)
 8005e4c:	4293      	cmp	r3, r2
 8005e4e:	d05e      	beq.n	8005f0e <UART_SetConfig+0x1c2>
 8005e50:	4a4f      	ldr	r2, [pc, #316]	@ (8005f90 <UART_SetConfig+0x244>)
 8005e52:	4293      	cmp	r3, r2
 8005e54:	f000 80e7 	beq.w	8006026 <UART_SetConfig+0x2da>
 8005e58:	4a4e      	ldr	r2, [pc, #312]	@ (8005f94 <UART_SetConfig+0x248>)
 8005e5a:	4293      	cmp	r3, r2
 8005e5c:	f000 80fa 	beq.w	8006054 <UART_SetConfig+0x308>
 8005e60:	4a4d      	ldr	r2, [pc, #308]	@ (8005f98 <UART_SetConfig+0x24c>)
 8005e62:	4293      	cmp	r3, r2
 8005e64:	f000 810d 	beq.w	8006082 <UART_SetConfig+0x336>
 8005e68:	4a4c      	ldr	r2, [pc, #304]	@ (8005f9c <UART_SetConfig+0x250>)
 8005e6a:	4293      	cmp	r3, r2
 8005e6c:	f000 8120 	beq.w	80060b0 <UART_SetConfig+0x364>
 8005e70:	4a4b      	ldr	r2, [pc, #300]	@ (8005fa0 <UART_SetConfig+0x254>)
 8005e72:	4293      	cmp	r3, r2
 8005e74:	f000 8133 	beq.w	80060de <UART_SetConfig+0x392>
 8005e78:	4a4a      	ldr	r2, [pc, #296]	@ (8005fa4 <UART_SetConfig+0x258>)
 8005e7a:	4293      	cmp	r3, r2
 8005e7c:	f000 8158 	beq.w	8006130 <UART_SetConfig+0x3e4>
 8005e80:	4a49      	ldr	r2, [pc, #292]	@ (8005fa8 <UART_SetConfig+0x25c>)
 8005e82:	4293      	cmp	r3, r2
 8005e84:	f000 816b 	beq.w	800615e <UART_SetConfig+0x412>
 8005e88:	4a3c      	ldr	r2, [pc, #240]	@ (8005f7c <UART_SetConfig+0x230>)
 8005e8a:	4293      	cmp	r3, r2
 8005e8c:	f000 8182 	beq.w	8006194 <UART_SetConfig+0x448>
 8005e90:	2280      	movs	r2, #128	@ 0x80
 8005e92:	e08e      	b.n	8005fb2 <UART_SetConfig+0x266>
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
 8005e94:	f640 31cc 	movw	r1, #3020	@ 0xbcc
 8005e98:	4839      	ldr	r0, [pc, #228]	@ (8005f80 <UART_SetConfig+0x234>)
 8005e9a:	f7fa fe1b 	bl	8000ad4 <assert_failed>
 8005e9e:	e75d      	b.n	8005d5c <UART_SetConfig+0x10>
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
 8005ea0:	f640 31cd 	movw	r1, #3021	@ 0xbcd
 8005ea4:	4836      	ldr	r0, [pc, #216]	@ (8005f80 <UART_SetConfig+0x234>)
 8005ea6:	f7fa fe15 	bl	8000ad4 <assert_failed>
 8005eaa:	e761      	b.n	8005d70 <UART_SetConfig+0x24>
    assert_param(IS_LPUART_STOPBITS(huart->Init.StopBits));
 8005eac:	68e3      	ldr	r3, [r4, #12]
 8005eae:	2b00      	cmp	r3, #0
 8005eb0:	bf18      	it	ne
 8005eb2:	f5b3 5f00 	cmpne.w	r3, #8192	@ 0x2000
 8005eb6:	f43f af74 	beq.w	8005da2 <UART_SetConfig+0x56>
 8005eba:	f44f 613d 	mov.w	r1, #3024	@ 0xbd0
 8005ebe:	4830      	ldr	r0, [pc, #192]	@ (8005f80 <UART_SetConfig+0x234>)
 8005ec0:	f7fa fe08 	bl	8000ad4 <assert_failed>
 8005ec4:	e76d      	b.n	8005da2 <UART_SetConfig+0x56>
    assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
 8005ec6:	f640 31d4 	movw	r1, #3028	@ 0xbd4
 8005eca:	482d      	ldr	r0, [pc, #180]	@ (8005f80 <UART_SetConfig+0x234>)
 8005ecc:	f7fa fe02 	bl	8000ad4 <assert_failed>
 8005ed0:	e760      	b.n	8005d94 <UART_SetConfig+0x48>
    assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
 8005ed2:	f640 31d5 	movw	r1, #3029	@ 0xbd5
 8005ed6:	482a      	ldr	r0, [pc, #168]	@ (8005f80 <UART_SetConfig+0x234>)
 8005ed8:	f7fa fdfc 	bl	8000ad4 <assert_failed>
 8005edc:	e761      	b.n	8005da2 <UART_SetConfig+0x56>
  assert_param(IS_UART_PARITY(huart->Init.Parity));
 8005ede:	f640 31d8 	movw	r1, #3032	@ 0xbd8
 8005ee2:	4827      	ldr	r0, [pc, #156]	@ (8005f80 <UART_SetConfig+0x234>)
 8005ee4:	f7fa fdf6 	bl	8000ad4 <assert_failed>
 8005ee8:	e765      	b.n	8005db6 <UART_SetConfig+0x6a>
  assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
 8005eea:	f640 31da 	movw	r1, #3034	@ 0xbda
 8005eee:	4824      	ldr	r0, [pc, #144]	@ (8005f80 <UART_SetConfig+0x234>)
 8005ef0:	f7fa fdf0 	bl	8000ad4 <assert_failed>
 8005ef4:	e776      	b.n	8005de4 <UART_SetConfig+0x98>
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
 8005ef6:	f640 31db 	movw	r1, #3035	@ 0xbdb
 8005efa:	4821      	ldr	r0, [pc, #132]	@ (8005f80 <UART_SetConfig+0x234>)
 8005efc:	f7fa fdea 	bl	8000ad4 <assert_failed>
 8005f00:	e777      	b.n	8005df2 <UART_SetConfig+0xa6>
  assert_param(IS_UART_PRESCALER(huart->Init.ClockPrescaler));
 8005f02:	f640 31dc 	movw	r1, #3036	@ 0xbdc
 8005f06:	481e      	ldr	r0, [pc, #120]	@ (8005f80 <UART_SetConfig+0x234>)
 8005f08:	f7fa fde4 	bl	8000ad4 <assert_failed>
 8005f0c:	e775      	b.n	8005dfa <UART_SetConfig+0xae>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8005f0e:	4a27      	ldr	r2, [pc, #156]	@ (8005fac <UART_SetConfig+0x260>)
 8005f10:	6d52      	ldr	r2, [r2, #84]	@ 0x54
 8005f12:	f002 0238 	and.w	r2, r2, #56	@ 0x38
 8005f16:	2a28      	cmp	r2, #40	@ 0x28
 8005f18:	f200 8083 	bhi.w	8006022 <UART_SetConfig+0x2d6>
 8005f1c:	e8df f012 	tbh	[pc, r2, lsl #1]
 8005f20:	00810029 	.word	0x00810029
 8005f24:	00810081 	.word	0x00810081
 8005f28:	00810081 	.word	0x00810081
 8005f2c:	00810081 	.word	0x00810081
 8005f30:	00810152 	.word	0x00810152
 8005f34:	00810081 	.word	0x00810081
 8005f38:	00810081 	.word	0x00810081
 8005f3c:	00810081 	.word	0x00810081
 8005f40:	00810048 	.word	0x00810048
 8005f44:	00810081 	.word	0x00810081
 8005f48:	00810081 	.word	0x00810081
 8005f4c:	00810081 	.word	0x00810081
 8005f50:	0081007b 	.word	0x0081007b
 8005f54:	00810081 	.word	0x00810081
 8005f58:	00810081 	.word	0x00810081
 8005f5c:	00810081 	.word	0x00810081
 8005f60:	0081007d 	.word	0x0081007d
 8005f64:	00810081 	.word	0x00810081
 8005f68:	00810081 	.word	0x00810081
 8005f6c:	00810081 	.word	0x00810081
 8005f70:	007f      	.short	0x007f
 8005f72:	2201      	movs	r2, #1
 8005f74:	e01d      	b.n	8005fb2 <UART_SetConfig+0x266>
 8005f76:	bf00      	nop
 8005f78:	00bebc20 	.word	0x00bebc20
 8005f7c:	58000c00 	.word	0x58000c00
 8005f80:	0801565c 	.word	0x0801565c
 8005f84:	cfff69f3 	.word	0xcfff69f3
 8005f88:	11fff4ff 	.word	0x11fff4ff
 8005f8c:	40011000 	.word	0x40011000
 8005f90:	40004400 	.word	0x40004400
 8005f94:	40004800 	.word	0x40004800
 8005f98:	40004c00 	.word	0x40004c00
 8005f9c:	40005000 	.word	0x40005000
 8005fa0:	40011400 	.word	0x40011400
 8005fa4:	40007800 	.word	0x40007800
 8005fa8:	40007c00 	.word	0x40007c00
 8005fac:	58024400 	.word	0x58024400
 8005fb0:	2208      	movs	r2, #8
  if (UART_INSTANCE_LOWPOWER(huart))
 8005fb2:	4976      	ldr	r1, [pc, #472]	@ (800618c <UART_SetConfig+0x440>)
 8005fb4:	428b      	cmp	r3, r1
 8005fb6:	f000 8117 	beq.w	80061e8 <UART_SetConfig+0x49c>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8005fba:	69e0      	ldr	r0, [r4, #28]
 8005fbc:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 8005fc0:	f000 818d 	beq.w	80062de <UART_SetConfig+0x592>
    switch (clocksource)
 8005fc4:	2a20      	cmp	r2, #32
 8005fc6:	f200 81e4 	bhi.w	8006392 <UART_SetConfig+0x646>
 8005fca:	2a20      	cmp	r2, #32
 8005fcc:	f200 8231 	bhi.w	8006432 <UART_SetConfig+0x6e6>
 8005fd0:	e8df f012 	tbh	[pc, r2, lsl #1]
 8005fd4:	020001e6 	.word	0x020001e6
 8005fd8:	022f022f 	.word	0x022f022f
 8005fdc:	022f0203 	.word	0x022f0203
 8005fe0:	022f022f 	.word	0x022f022f
 8005fe4:	022f0208 	.word	0x022f0208
 8005fe8:	022f022f 	.word	0x022f022f
 8005fec:	022f022f 	.word	0x022f022f
 8005ff0:	022f022f 	.word	0x022f022f
 8005ff4:	022f020d 	.word	0x022f020d
 8005ff8:	022f022f 	.word	0x022f022f
 8005ffc:	022f022f 	.word	0x022f022f
 8006000:	022f022f 	.word	0x022f022f
 8006004:	022f022f 	.word	0x022f022f
 8006008:	022f022f 	.word	0x022f022f
 800600c:	022f022f 	.word	0x022f022f
 8006010:	022f022f 	.word	0x022f022f
 8006014:	0219      	.short	0x0219
  UART_GETCLOCKSOURCE(huart, clocksource);
 8006016:	2210      	movs	r2, #16
 8006018:	e7cb      	b.n	8005fb2 <UART_SetConfig+0x266>
 800601a:	2220      	movs	r2, #32
 800601c:	e7c9      	b.n	8005fb2 <UART_SetConfig+0x266>
 800601e:	2240      	movs	r2, #64	@ 0x40
 8006020:	e7c7      	b.n	8005fb2 <UART_SetConfig+0x266>
 8006022:	2280      	movs	r2, #128	@ 0x80
 8006024:	e7c5      	b.n	8005fb2 <UART_SetConfig+0x266>
 8006026:	4a5a      	ldr	r2, [pc, #360]	@ (8006190 <UART_SetConfig+0x444>)
 8006028:	6d52      	ldr	r2, [r2, #84]	@ 0x54
 800602a:	f002 0207 	and.w	r2, r2, #7
 800602e:	2a05      	cmp	r2, #5
 8006030:	d80e      	bhi.n	8006050 <UART_SetConfig+0x304>
 8006032:	e8df f002 	tbb	[pc, r2]
 8006036:	c903      	.short	0xc903
 8006038:	0b090705 	.word	0x0b090705
 800603c:	2200      	movs	r2, #0
 800603e:	e7b8      	b.n	8005fb2 <UART_SetConfig+0x266>
 8006040:	2208      	movs	r2, #8
 8006042:	e7b6      	b.n	8005fb2 <UART_SetConfig+0x266>
 8006044:	2210      	movs	r2, #16
 8006046:	e7b4      	b.n	8005fb2 <UART_SetConfig+0x266>
 8006048:	2220      	movs	r2, #32
 800604a:	e7b2      	b.n	8005fb2 <UART_SetConfig+0x266>
 800604c:	2240      	movs	r2, #64	@ 0x40
 800604e:	e7b0      	b.n	8005fb2 <UART_SetConfig+0x266>
 8006050:	2280      	movs	r2, #128	@ 0x80
 8006052:	e7ae      	b.n	8005fb2 <UART_SetConfig+0x266>
 8006054:	4a4e      	ldr	r2, [pc, #312]	@ (8006190 <UART_SetConfig+0x444>)
 8006056:	6d52      	ldr	r2, [r2, #84]	@ 0x54
 8006058:	f002 0207 	and.w	r2, r2, #7
 800605c:	2a05      	cmp	r2, #5
 800605e:	d80e      	bhi.n	800607e <UART_SetConfig+0x332>
 8006060:	e8df f002 	tbb	[pc, r2]
 8006064:	0705b403 	.word	0x0705b403
 8006068:	0b09      	.short	0x0b09
 800606a:	2200      	movs	r2, #0
 800606c:	e7a1      	b.n	8005fb2 <UART_SetConfig+0x266>
 800606e:	2208      	movs	r2, #8
 8006070:	e79f      	b.n	8005fb2 <UART_SetConfig+0x266>
 8006072:	2210      	movs	r2, #16
 8006074:	e79d      	b.n	8005fb2 <UART_SetConfig+0x266>
 8006076:	2220      	movs	r2, #32
 8006078:	e79b      	b.n	8005fb2 <UART_SetConfig+0x266>
 800607a:	2240      	movs	r2, #64	@ 0x40
 800607c:	e799      	b.n	8005fb2 <UART_SetConfig+0x266>
 800607e:	2280      	movs	r2, #128	@ 0x80
 8006080:	e797      	b.n	8005fb2 <UART_SetConfig+0x266>
 8006082:	4a43      	ldr	r2, [pc, #268]	@ (8006190 <UART_SetConfig+0x444>)
 8006084:	6d52      	ldr	r2, [r2, #84]	@ 0x54
 8006086:	f002 0207 	and.w	r2, r2, #7
 800608a:	2a05      	cmp	r2, #5
 800608c:	d80e      	bhi.n	80060ac <UART_SetConfig+0x360>
 800608e:	e8df f002 	tbb	[pc, r2]
 8006092:	9f03      	.short	0x9f03
 8006094:	0b090705 	.word	0x0b090705
 8006098:	2200      	movs	r2, #0
 800609a:	e78a      	b.n	8005fb2 <UART_SetConfig+0x266>
 800609c:	2208      	movs	r2, #8
 800609e:	e788      	b.n	8005fb2 <UART_SetConfig+0x266>
 80060a0:	2210      	movs	r2, #16
 80060a2:	e786      	b.n	8005fb2 <UART_SetConfig+0x266>
 80060a4:	2220      	movs	r2, #32
 80060a6:	e784      	b.n	8005fb2 <UART_SetConfig+0x266>
 80060a8:	2240      	movs	r2, #64	@ 0x40
 80060aa:	e782      	b.n	8005fb2 <UART_SetConfig+0x266>
 80060ac:	2280      	movs	r2, #128	@ 0x80
 80060ae:	e780      	b.n	8005fb2 <UART_SetConfig+0x266>
 80060b0:	4a37      	ldr	r2, [pc, #220]	@ (8006190 <UART_SetConfig+0x444>)
 80060b2:	6d52      	ldr	r2, [r2, #84]	@ 0x54
 80060b4:	f002 0207 	and.w	r2, r2, #7
 80060b8:	2a05      	cmp	r2, #5
 80060ba:	d80e      	bhi.n	80060da <UART_SetConfig+0x38e>
 80060bc:	e8df f002 	tbb	[pc, r2]
 80060c0:	07058a03 	.word	0x07058a03
 80060c4:	0b09      	.short	0x0b09
 80060c6:	2200      	movs	r2, #0
 80060c8:	e773      	b.n	8005fb2 <UART_SetConfig+0x266>
 80060ca:	2208      	movs	r2, #8
 80060cc:	e771      	b.n	8005fb2 <UART_SetConfig+0x266>
 80060ce:	2210      	movs	r2, #16
 80060d0:	e76f      	b.n	8005fb2 <UART_SetConfig+0x266>
 80060d2:	2220      	movs	r2, #32
 80060d4:	e76d      	b.n	8005fb2 <UART_SetConfig+0x266>
 80060d6:	2240      	movs	r2, #64	@ 0x40
 80060d8:	e76b      	b.n	8005fb2 <UART_SetConfig+0x266>
 80060da:	2280      	movs	r2, #128	@ 0x80
 80060dc:	e769      	b.n	8005fb2 <UART_SetConfig+0x266>
 80060de:	4a2c      	ldr	r2, [pc, #176]	@ (8006190 <UART_SetConfig+0x444>)
 80060e0:	6d52      	ldr	r2, [r2, #84]	@ 0x54
 80060e2:	f002 0238 	and.w	r2, r2, #56	@ 0x38
 80060e6:	2a28      	cmp	r2, #40	@ 0x28
 80060e8:	d820      	bhi.n	800612c <UART_SetConfig+0x3e0>
 80060ea:	e8df f002 	tbb	[pc, r2]
 80060ee:	1f15      	.short	0x1f15
 80060f0:	1f1f1f1f 	.word	0x1f1f1f1f
 80060f4:	1f751f1f 	.word	0x1f751f1f
 80060f8:	1f1f1f1f 	.word	0x1f1f1f1f
 80060fc:	1f171f1f 	.word	0x1f171f1f
 8006100:	1f1f1f1f 	.word	0x1f1f1f1f
 8006104:	1f191f1f 	.word	0x1f191f1f
 8006108:	1f1f1f1f 	.word	0x1f1f1f1f
 800610c:	1f1b1f1f 	.word	0x1f1b1f1f
 8006110:	1f1f1f1f 	.word	0x1f1f1f1f
 8006114:	1f1f      	.short	0x1f1f
 8006116:	1d          	.byte	0x1d
 8006117:	00          	.byte	0x00
 8006118:	2201      	movs	r2, #1
 800611a:	e74a      	b.n	8005fb2 <UART_SetConfig+0x266>
 800611c:	2208      	movs	r2, #8
 800611e:	e748      	b.n	8005fb2 <UART_SetConfig+0x266>
 8006120:	2210      	movs	r2, #16
 8006122:	e746      	b.n	8005fb2 <UART_SetConfig+0x266>
 8006124:	2220      	movs	r2, #32
 8006126:	e744      	b.n	8005fb2 <UART_SetConfig+0x266>
 8006128:	2240      	movs	r2, #64	@ 0x40
 800612a:	e742      	b.n	8005fb2 <UART_SetConfig+0x266>
 800612c:	2280      	movs	r2, #128	@ 0x80
 800612e:	e740      	b.n	8005fb2 <UART_SetConfig+0x266>
 8006130:	4a17      	ldr	r2, [pc, #92]	@ (8006190 <UART_SetConfig+0x444>)
 8006132:	6d52      	ldr	r2, [r2, #84]	@ 0x54
 8006134:	f002 0207 	and.w	r2, r2, #7
 8006138:	2a05      	cmp	r2, #5
 800613a:	d80e      	bhi.n	800615a <UART_SetConfig+0x40e>
 800613c:	e8df f002 	tbb	[pc, r2]
 8006140:	07054e03 	.word	0x07054e03
 8006144:	0b09      	.short	0x0b09
 8006146:	2200      	movs	r2, #0
 8006148:	e733      	b.n	8005fb2 <UART_SetConfig+0x266>
 800614a:	2208      	movs	r2, #8
 800614c:	e731      	b.n	8005fb2 <UART_SetConfig+0x266>
 800614e:	2210      	movs	r2, #16
 8006150:	e72f      	b.n	8005fb2 <UART_SetConfig+0x266>
 8006152:	2220      	movs	r2, #32
 8006154:	e72d      	b.n	8005fb2 <UART_SetConfig+0x266>
 8006156:	2240      	movs	r2, #64	@ 0x40
 8006158:	e72b      	b.n	8005fb2 <UART_SetConfig+0x266>
 800615a:	2280      	movs	r2, #128	@ 0x80
 800615c:	e729      	b.n	8005fb2 <UART_SetConfig+0x266>
 800615e:	4a0c      	ldr	r2, [pc, #48]	@ (8006190 <UART_SetConfig+0x444>)
 8006160:	6d52      	ldr	r2, [r2, #84]	@ 0x54
 8006162:	f002 0207 	and.w	r2, r2, #7
 8006166:	2a05      	cmp	r2, #5
 8006168:	d80e      	bhi.n	8006188 <UART_SetConfig+0x43c>
 800616a:	e8df f002 	tbb	[pc, r2]
 800616e:	3903      	.short	0x3903
 8006170:	0b090705 	.word	0x0b090705
 8006174:	2200      	movs	r2, #0
 8006176:	e71c      	b.n	8005fb2 <UART_SetConfig+0x266>
 8006178:	2208      	movs	r2, #8
 800617a:	e71a      	b.n	8005fb2 <UART_SetConfig+0x266>
 800617c:	2210      	movs	r2, #16
 800617e:	e718      	b.n	8005fb2 <UART_SetConfig+0x266>
 8006180:	2220      	movs	r2, #32
 8006182:	e716      	b.n	8005fb2 <UART_SetConfig+0x266>
 8006184:	2240      	movs	r2, #64	@ 0x40
 8006186:	e714      	b.n	8005fb2 <UART_SetConfig+0x266>
 8006188:	2280      	movs	r2, #128	@ 0x80
 800618a:	e712      	b.n	8005fb2 <UART_SetConfig+0x266>
 800618c:	58000c00 	.word	0x58000c00
 8006190:	58024400 	.word	0x58024400
 8006194:	f502 320e 	add.w	r2, r2, #145408	@ 0x23800
 8006198:	6d92      	ldr	r2, [r2, #88]	@ 0x58
 800619a:	f002 0207 	and.w	r2, r2, #7
 800619e:	2a05      	cmp	r2, #5
 80061a0:	d80e      	bhi.n	80061c0 <UART_SetConfig+0x474>
 80061a2:	e8df f002 	tbb	[pc, r2]
 80061a6:	1f03      	.short	0x1f03
 80061a8:	0b090705 	.word	0x0b090705
 80061ac:	2202      	movs	r2, #2
 80061ae:	e700      	b.n	8005fb2 <UART_SetConfig+0x266>
 80061b0:	2208      	movs	r2, #8
 80061b2:	e6fe      	b.n	8005fb2 <UART_SetConfig+0x266>
 80061b4:	2210      	movs	r2, #16
 80061b6:	e6fc      	b.n	8005fb2 <UART_SetConfig+0x266>
 80061b8:	2220      	movs	r2, #32
 80061ba:	e6fa      	b.n	8005fb2 <UART_SetConfig+0x266>
 80061bc:	2240      	movs	r2, #64	@ 0x40
 80061be:	e6f8      	b.n	8005fb2 <UART_SetConfig+0x266>
 80061c0:	2280      	movs	r2, #128	@ 0x80
 80061c2:	e6f6      	b.n	8005fb2 <UART_SetConfig+0x266>
 80061c4:	2204      	movs	r2, #4
 80061c6:	e6f4      	b.n	8005fb2 <UART_SetConfig+0x266>
 80061c8:	2204      	movs	r2, #4
 80061ca:	e6f2      	b.n	8005fb2 <UART_SetConfig+0x266>
 80061cc:	2204      	movs	r2, #4
 80061ce:	e6f0      	b.n	8005fb2 <UART_SetConfig+0x266>
 80061d0:	2204      	movs	r2, #4
 80061d2:	e6ee      	b.n	8005fb2 <UART_SetConfig+0x266>
 80061d4:	2204      	movs	r2, #4
 80061d6:	e6ec      	b.n	8005fb2 <UART_SetConfig+0x266>
 80061d8:	2204      	movs	r2, #4
 80061da:	e6ea      	b.n	8005fb2 <UART_SetConfig+0x266>
 80061dc:	2204      	movs	r2, #4
 80061de:	e6e8      	b.n	8005fb2 <UART_SetConfig+0x266>
 80061e0:	2204      	movs	r2, #4
 80061e2:	e6e6      	b.n	8005fb2 <UART_SetConfig+0x266>
 80061e4:	2204      	movs	r2, #4
 80061e6:	e6e4      	b.n	8005fb2 <UART_SetConfig+0x266>
    switch (clocksource)
 80061e8:	2a20      	cmp	r2, #32
 80061ea:	d827      	bhi.n	800623c <UART_SetConfig+0x4f0>
 80061ec:	2a02      	cmp	r2, #2
 80061ee:	f0c0 810e 	bcc.w	800640e <UART_SetConfig+0x6c2>
 80061f2:	3a02      	subs	r2, #2
 80061f4:	2a1e      	cmp	r2, #30
 80061f6:	f200 810c 	bhi.w	8006412 <UART_SetConfig+0x6c6>
 80061fa:	e8df f012 	tbh	[pc, r2, lsl #1]
 80061fe:	0026      	.short	0x0026
 8006200:	0056010a 	.word	0x0056010a
 8006204:	010a010a 	.word	0x010a010a
 8006208:	005b010a 	.word	0x005b010a
 800620c:	010a010a 	.word	0x010a010a
 8006210:	010a010a 	.word	0x010a010a
 8006214:	010a010a 	.word	0x010a010a
 8006218:	0060010a 	.word	0x0060010a
 800621c:	010a010a 	.word	0x010a010a
 8006220:	010a010a 	.word	0x010a010a
 8006224:	010a010a 	.word	0x010a010a
 8006228:	010a010a 	.word	0x010a010a
 800622c:	010a010a 	.word	0x010a010a
 8006230:	010a010a 	.word	0x010a010a
 8006234:	010a010a 	.word	0x010a010a
 8006238:	006c010a 	.word	0x006c010a
 800623c:	2a40      	cmp	r2, #64	@ 0x40
 800623e:	d102      	bne.n	8006246 <UART_SetConfig+0x4fa>
        pclk = (uint32_t) LSE_VALUE;
 8006240:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 8006244:	e006      	b.n	8006254 <UART_SetConfig+0x508>
    switch (clocksource)
 8006246:	2001      	movs	r0, #1
 8006248:	e0f4      	b.n	8006434 <UART_SetConfig+0x6e8>
        pclk = HAL_RCCEx_GetD3PCLK1Freq();
 800624a:	f7fe fe8d 	bl	8004f68 <HAL_RCCEx_GetD3PCLK1Freq>
    if (pclk != 0U)
 800624e:	2800      	cmp	r0, #0
 8006250:	f000 80e1 	beq.w	8006416 <UART_SetConfig+0x6ca>
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8006254:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 8006256:	4b7e      	ldr	r3, [pc, #504]	@ (8006450 <UART_SetConfig+0x704>)
 8006258:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 800625c:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8006260:	6865      	ldr	r5, [r4, #4]
 8006262:	eb05 0145 	add.w	r1, r5, r5, lsl #1
 8006266:	4299      	cmp	r1, r3
 8006268:	f200 80d7 	bhi.w	800641a <UART_SetConfig+0x6ce>
 800626c:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
 8006270:	f200 80d5 	bhi.w	800641e <UART_SetConfig+0x6d2>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8006274:	2600      	movs	r6, #0
 8006276:	4633      	mov	r3, r6
 8006278:	4631      	mov	r1, r6
 800627a:	f7fa f889 	bl	8000390 <__aeabi_uldivmod>
 800627e:	0209      	lsls	r1, r1, #8
 8006280:	ea41 6110 	orr.w	r1, r1, r0, lsr #24
 8006284:	0200      	lsls	r0, r0, #8
 8006286:	086b      	lsrs	r3, r5, #1
 8006288:	18c0      	adds	r0, r0, r3
 800628a:	462a      	mov	r2, r5
 800628c:	4633      	mov	r3, r6
 800628e:	f141 0100 	adc.w	r1, r1, #0
 8006292:	f7fa f87d 	bl	8000390 <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 8006296:	f5a0 7240 	sub.w	r2, r0, #768	@ 0x300
 800629a:	4b6e      	ldr	r3, [pc, #440]	@ (8006454 <UART_SetConfig+0x708>)
 800629c:	429a      	cmp	r2, r3
 800629e:	f200 80c0 	bhi.w	8006422 <UART_SetConfig+0x6d6>
          huart->Instance->BRR = usartdiv;
 80062a2:	6823      	ldr	r3, [r4, #0]
 80062a4:	60d8      	str	r0, [r3, #12]
 80062a6:	4630      	mov	r0, r6
 80062a8:	e0c4      	b.n	8006434 <UART_SetConfig+0x6e8>
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 80062aa:	a803      	add	r0, sp, #12
 80062ac:	f7fe fe6e 	bl	8004f8c <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 80062b0:	9804      	ldr	r0, [sp, #16]
        break;
 80062b2:	e7cc      	b.n	800624e <UART_SetConfig+0x502>
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 80062b4:	4668      	mov	r0, sp
 80062b6:	f7fe ff69 	bl	800518c <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 80062ba:	9801      	ldr	r0, [sp, #4]
        break;
 80062bc:	e7c7      	b.n	800624e <UART_SetConfig+0x502>
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 80062be:	4b66      	ldr	r3, [pc, #408]	@ (8006458 <UART_SetConfig+0x70c>)
 80062c0:	681b      	ldr	r3, [r3, #0]
 80062c2:	f013 0f20 	tst.w	r3, #32
 80062c6:	d008      	beq.n	80062da <UART_SetConfig+0x58e>
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 80062c8:	4b63      	ldr	r3, [pc, #396]	@ (8006458 <UART_SetConfig+0x70c>)
 80062ca:	681b      	ldr	r3, [r3, #0]
 80062cc:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 80062d0:	4862      	ldr	r0, [pc, #392]	@ (800645c <UART_SetConfig+0x710>)
 80062d2:	40d8      	lsrs	r0, r3
    if (pclk != 0U)
 80062d4:	e7be      	b.n	8006254 <UART_SetConfig+0x508>
    switch (clocksource)
 80062d6:	4862      	ldr	r0, [pc, #392]	@ (8006460 <UART_SetConfig+0x714>)
 80062d8:	e7bc      	b.n	8006254 <UART_SetConfig+0x508>
          pclk = (uint32_t) HSI_VALUE;
 80062da:	4860      	ldr	r0, [pc, #384]	@ (800645c <UART_SetConfig+0x710>)
 80062dc:	e7ba      	b.n	8006254 <UART_SetConfig+0x508>
    switch (clocksource)
 80062de:	2a20      	cmp	r2, #32
 80062e0:	d815      	bhi.n	800630e <UART_SetConfig+0x5c2>
 80062e2:	2a20      	cmp	r2, #32
 80062e4:	f200 809f 	bhi.w	8006426 <UART_SetConfig+0x6da>
 80062e8:	e8df f002 	tbb	[pc, r2]
 80062ec:	9d9d3615 	.word	0x9d9d3615
 80062f0:	9d9d9d39 	.word	0x9d9d9d39
 80062f4:	9d9d9d3e 	.word	0x9d9d9d3e
 80062f8:	9d9d9d9d 	.word	0x9d9d9d9d
 80062fc:	9d9d9d43 	.word	0x9d9d9d43
 8006300:	9d9d9d9d 	.word	0x9d9d9d9d
 8006304:	9d9d9d9d 	.word	0x9d9d9d9d
 8006308:	9d9d9d9d 	.word	0x9d9d9d9d
 800630c:	4f          	.byte	0x4f
 800630d:	00          	.byte	0x00
 800630e:	2a40      	cmp	r2, #64	@ 0x40
 8006310:	d006      	beq.n	8006320 <UART_SetConfig+0x5d4>
 8006312:	2001      	movs	r0, #1
 8006314:	e08e      	b.n	8006434 <UART_SetConfig+0x6e8>
        pclk = HAL_RCC_GetPCLK1Freq();
 8006316:	f7fd fd1d 	bl	8003d54 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 800631a:	2800      	cmp	r0, #0
 800631c:	f000 8085 	beq.w	800642a <UART_SetConfig+0x6de>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8006320:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 8006322:	4b4b      	ldr	r3, [pc, #300]	@ (8006450 <UART_SetConfig+0x704>)
 8006324:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8006328:	fbb0 f0f3 	udiv	r0, r0, r3
 800632c:	6862      	ldr	r2, [r4, #4]
 800632e:	0853      	lsrs	r3, r2, #1
 8006330:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 8006334:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8006338:	f1a3 0110 	sub.w	r1, r3, #16
 800633c:	f64f 72ef 	movw	r2, #65519	@ 0xffef
 8006340:	4291      	cmp	r1, r2
 8006342:	d874      	bhi.n	800642e <UART_SetConfig+0x6e2>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8006344:	b29a      	uxth	r2, r3
 8006346:	f022 020f 	bic.w	r2, r2, #15
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800634a:	f3c3 0342 	ubfx	r3, r3, #1, #3
 800634e:	4313      	orrs	r3, r2
        huart->Instance->BRR = brrtemp;
 8006350:	6822      	ldr	r2, [r4, #0]
 8006352:	60d3      	str	r3, [r2, #12]
 8006354:	2000      	movs	r0, #0
 8006356:	e06d      	b.n	8006434 <UART_SetConfig+0x6e8>
        pclk = HAL_RCC_GetPCLK2Freq();
 8006358:	f7fd fd0e 	bl	8003d78 <HAL_RCC_GetPCLK2Freq>
        break;
 800635c:	e7dd      	b.n	800631a <UART_SetConfig+0x5ce>
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800635e:	a803      	add	r0, sp, #12
 8006360:	f7fe fe14 	bl	8004f8c <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 8006364:	9804      	ldr	r0, [sp, #16]
        break;
 8006366:	e7d8      	b.n	800631a <UART_SetConfig+0x5ce>
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8006368:	4668      	mov	r0, sp
 800636a:	f7fe ff0f 	bl	800518c <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 800636e:	9801      	ldr	r0, [sp, #4]
        break;
 8006370:	e7d3      	b.n	800631a <UART_SetConfig+0x5ce>
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8006372:	4b39      	ldr	r3, [pc, #228]	@ (8006458 <UART_SetConfig+0x70c>)
 8006374:	681b      	ldr	r3, [r3, #0]
 8006376:	f013 0f20 	tst.w	r3, #32
 800637a:	d008      	beq.n	800638e <UART_SetConfig+0x642>
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 800637c:	4b36      	ldr	r3, [pc, #216]	@ (8006458 <UART_SetConfig+0x70c>)
 800637e:	681b      	ldr	r3, [r3, #0]
 8006380:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 8006384:	4835      	ldr	r0, [pc, #212]	@ (800645c <UART_SetConfig+0x710>)
 8006386:	40d8      	lsrs	r0, r3
    if (pclk != 0U)
 8006388:	e7ca      	b.n	8006320 <UART_SetConfig+0x5d4>
    switch (clocksource)
 800638a:	4835      	ldr	r0, [pc, #212]	@ (8006460 <UART_SetConfig+0x714>)
 800638c:	e7c8      	b.n	8006320 <UART_SetConfig+0x5d4>
          pclk = (uint32_t) HSI_VALUE;
 800638e:	4833      	ldr	r0, [pc, #204]	@ (800645c <UART_SetConfig+0x710>)
 8006390:	e7c6      	b.n	8006320 <UART_SetConfig+0x5d4>
    switch (clocksource)
 8006392:	2a40      	cmp	r2, #64	@ 0x40
 8006394:	d102      	bne.n	800639c <UART_SetConfig+0x650>
        pclk = (uint32_t) LSE_VALUE;
 8006396:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 800639a:	e005      	b.n	80063a8 <UART_SetConfig+0x65c>
    switch (clocksource)
 800639c:	2001      	movs	r0, #1
 800639e:	e049      	b.n	8006434 <UART_SetConfig+0x6e8>
        pclk = HAL_RCC_GetPCLK1Freq();
 80063a0:	f7fd fcd8 	bl	8003d54 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 80063a4:	2800      	cmp	r0, #0
 80063a6:	d04f      	beq.n	8006448 <UART_SetConfig+0x6fc>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80063a8:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 80063aa:	4b29      	ldr	r3, [pc, #164]	@ (8006450 <UART_SetConfig+0x704>)
 80063ac:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 80063b0:	fbb0 f0f3 	udiv	r0, r0, r3
 80063b4:	6863      	ldr	r3, [r4, #4]
 80063b6:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 80063ba:	fbb0 f0f3 	udiv	r0, r0, r3
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80063be:	f1a0 0210 	sub.w	r2, r0, #16
 80063c2:	f64f 73ef 	movw	r3, #65519	@ 0xffef
 80063c6:	429a      	cmp	r2, r3
 80063c8:	d840      	bhi.n	800644c <UART_SetConfig+0x700>
        huart->Instance->BRR = (uint16_t)usartdiv;
 80063ca:	6823      	ldr	r3, [r4, #0]
 80063cc:	b280      	uxth	r0, r0
 80063ce:	60d8      	str	r0, [r3, #12]
 80063d0:	2000      	movs	r0, #0
 80063d2:	e02f      	b.n	8006434 <UART_SetConfig+0x6e8>
        pclk = HAL_RCC_GetPCLK2Freq();
 80063d4:	f7fd fcd0 	bl	8003d78 <HAL_RCC_GetPCLK2Freq>
        break;
 80063d8:	e7e4      	b.n	80063a4 <UART_SetConfig+0x658>
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 80063da:	a803      	add	r0, sp, #12
 80063dc:	f7fe fdd6 	bl	8004f8c <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 80063e0:	9804      	ldr	r0, [sp, #16]
        break;
 80063e2:	e7df      	b.n	80063a4 <UART_SetConfig+0x658>
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 80063e4:	4668      	mov	r0, sp
 80063e6:	f7fe fed1 	bl	800518c <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 80063ea:	9801      	ldr	r0, [sp, #4]
        break;
 80063ec:	e7da      	b.n	80063a4 <UART_SetConfig+0x658>
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 80063ee:	4b1a      	ldr	r3, [pc, #104]	@ (8006458 <UART_SetConfig+0x70c>)
 80063f0:	681b      	ldr	r3, [r3, #0]
 80063f2:	f013 0f20 	tst.w	r3, #32
 80063f6:	d008      	beq.n	800640a <UART_SetConfig+0x6be>
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 80063f8:	4b17      	ldr	r3, [pc, #92]	@ (8006458 <UART_SetConfig+0x70c>)
 80063fa:	681b      	ldr	r3, [r3, #0]
 80063fc:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 8006400:	4816      	ldr	r0, [pc, #88]	@ (800645c <UART_SetConfig+0x710>)
 8006402:	40d8      	lsrs	r0, r3
    if (pclk != 0U)
 8006404:	e7d0      	b.n	80063a8 <UART_SetConfig+0x65c>
    switch (clocksource)
 8006406:	4816      	ldr	r0, [pc, #88]	@ (8006460 <UART_SetConfig+0x714>)
 8006408:	e7ce      	b.n	80063a8 <UART_SetConfig+0x65c>
          pclk = (uint32_t) HSI_VALUE;
 800640a:	4814      	ldr	r0, [pc, #80]	@ (800645c <UART_SetConfig+0x710>)
 800640c:	e7cc      	b.n	80063a8 <UART_SetConfig+0x65c>
    switch (clocksource)
 800640e:	2001      	movs	r0, #1
 8006410:	e010      	b.n	8006434 <UART_SetConfig+0x6e8>
 8006412:	2001      	movs	r0, #1
 8006414:	e00e      	b.n	8006434 <UART_SetConfig+0x6e8>
 8006416:	2000      	movs	r0, #0
 8006418:	e00c      	b.n	8006434 <UART_SetConfig+0x6e8>
        ret = HAL_ERROR;
 800641a:	2001      	movs	r0, #1
 800641c:	e00a      	b.n	8006434 <UART_SetConfig+0x6e8>
 800641e:	2001      	movs	r0, #1
 8006420:	e008      	b.n	8006434 <UART_SetConfig+0x6e8>
          ret = HAL_ERROR;
 8006422:	2001      	movs	r0, #1
 8006424:	e006      	b.n	8006434 <UART_SetConfig+0x6e8>
    switch (clocksource)
 8006426:	2001      	movs	r0, #1
 8006428:	e004      	b.n	8006434 <UART_SetConfig+0x6e8>
 800642a:	2000      	movs	r0, #0
 800642c:	e002      	b.n	8006434 <UART_SetConfig+0x6e8>
        ret = HAL_ERROR;
 800642e:	2001      	movs	r0, #1
 8006430:	e000      	b.n	8006434 <UART_SetConfig+0x6e8>
    switch (clocksource)
 8006432:	2001      	movs	r0, #1
  huart->NbTxDataToProcess = 1;
 8006434:	2301      	movs	r3, #1
 8006436:	f8a4 306a 	strh.w	r3, [r4, #106]	@ 0x6a
  huart->NbRxDataToProcess = 1;
 800643a:	f8a4 3068 	strh.w	r3, [r4, #104]	@ 0x68
  huart->RxISR = NULL;
 800643e:	2300      	movs	r3, #0
 8006440:	6763      	str	r3, [r4, #116]	@ 0x74
  huart->TxISR = NULL;
 8006442:	67a3      	str	r3, [r4, #120]	@ 0x78
}
 8006444:	b006      	add	sp, #24
 8006446:	bd70      	pop	{r4, r5, r6, pc}
 8006448:	2000      	movs	r0, #0
 800644a:	e7f3      	b.n	8006434 <UART_SetConfig+0x6e8>
        ret = HAL_ERROR;
 800644c:	2001      	movs	r0, #1
 800644e:	e7f1      	b.n	8006434 <UART_SetConfig+0x6e8>
 8006450:	08018db4 	.word	0x08018db4
 8006454:	000ffcff 	.word	0x000ffcff
 8006458:	58024400 	.word	0x58024400
 800645c:	03d09000 	.word	0x03d09000
 8006460:	003d0900 	.word	0x003d0900

08006464 <UART_AdvFeatureConfig>:
{
 8006464:	b510      	push	{r4, lr}
 8006466:	4604      	mov	r4, r0
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
 8006468:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 800646a:	2bff      	cmp	r3, #255	@ 0xff
 800646c:	f200 80b6 	bhi.w	80065dc <UART_AdvFeatureConfig+0x178>
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8006470:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 8006472:	f013 0f01 	tst.w	r3, #1
 8006476:	d00d      	beq.n	8006494 <UART_AdvFeatureConfig+0x30>
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
 8006478:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 800647a:	2b00      	cmp	r3, #0
 800647c:	bf18      	it	ne
 800647e:	f5b3 3f00 	cmpne.w	r3, #131072	@ 0x20000
 8006482:	f040 80b1 	bne.w	80065e8 <UART_AdvFeatureConfig+0x184>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8006486:	6822      	ldr	r2, [r4, #0]
 8006488:	6853      	ldr	r3, [r2, #4]
 800648a:	f423 3300 	bic.w	r3, r3, #131072	@ 0x20000
 800648e:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 8006490:	430b      	orrs	r3, r1
 8006492:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 8006494:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 8006496:	f013 0f02 	tst.w	r3, #2
 800649a:	d00d      	beq.n	80064b8 <UART_AdvFeatureConfig+0x54>
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
 800649c:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 800649e:	2b00      	cmp	r3, #0
 80064a0:	bf18      	it	ne
 80064a2:	f5b3 3f80 	cmpne.w	r3, #65536	@ 0x10000
 80064a6:	f040 80a5 	bne.w	80065f4 <UART_AdvFeatureConfig+0x190>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 80064aa:	6822      	ldr	r2, [r4, #0]
 80064ac:	6853      	ldr	r3, [r2, #4]
 80064ae:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 80064b2:	6b21      	ldr	r1, [r4, #48]	@ 0x30
 80064b4:	430b      	orrs	r3, r1
 80064b6:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 80064b8:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 80064ba:	f013 0f04 	tst.w	r3, #4
 80064be:	d00d      	beq.n	80064dc <UART_AdvFeatureConfig+0x78>
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
 80064c0:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 80064c2:	2b00      	cmp	r3, #0
 80064c4:	bf18      	it	ne
 80064c6:	f5b3 2f80 	cmpne.w	r3, #262144	@ 0x40000
 80064ca:	f040 8099 	bne.w	8006600 <UART_AdvFeatureConfig+0x19c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 80064ce:	6822      	ldr	r2, [r4, #0]
 80064d0:	6853      	ldr	r3, [r2, #4]
 80064d2:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 80064d6:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 80064d8:	430b      	orrs	r3, r1
 80064da:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 80064dc:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 80064de:	f013 0f08 	tst.w	r3, #8
 80064e2:	d00d      	beq.n	8006500 <UART_AdvFeatureConfig+0x9c>
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
 80064e4:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 80064e6:	2b00      	cmp	r3, #0
 80064e8:	bf18      	it	ne
 80064ea:	f5b3 4f00 	cmpne.w	r3, #32768	@ 0x8000
 80064ee:	f040 808d 	bne.w	800660c <UART_AdvFeatureConfig+0x1a8>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 80064f2:	6822      	ldr	r2, [r4, #0]
 80064f4:	6853      	ldr	r3, [r2, #4]
 80064f6:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 80064fa:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 80064fc:	430b      	orrs	r3, r1
 80064fe:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8006500:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 8006502:	f013 0f10 	tst.w	r3, #16
 8006506:	d00d      	beq.n	8006524 <UART_AdvFeatureConfig+0xc0>
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
 8006508:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 800650a:	2b00      	cmp	r3, #0
 800650c:	bf18      	it	ne
 800650e:	f5b3 5f80 	cmpne.w	r3, #4096	@ 0x1000
 8006512:	f040 8081 	bne.w	8006618 <UART_AdvFeatureConfig+0x1b4>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8006516:	6822      	ldr	r2, [r4, #0]
 8006518:	6893      	ldr	r3, [r2, #8]
 800651a:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 800651e:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
 8006520:	430b      	orrs	r3, r1
 8006522:	6093      	str	r3, [r2, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8006524:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 8006526:	f013 0f20 	tst.w	r3, #32
 800652a:	d00c      	beq.n	8006546 <UART_AdvFeatureConfig+0xe2>
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
 800652c:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 800652e:	2b00      	cmp	r3, #0
 8006530:	bf18      	it	ne
 8006532:	f5b3 5f00 	cmpne.w	r3, #8192	@ 0x2000
 8006536:	d175      	bne.n	8006624 <UART_AdvFeatureConfig+0x1c0>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 8006538:	6822      	ldr	r2, [r4, #0]
 800653a:	6893      	ldr	r3, [r2, #8]
 800653c:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 8006540:	6c21      	ldr	r1, [r4, #64]	@ 0x40
 8006542:	430b      	orrs	r3, r1
 8006544:	6093      	str	r3, [r2, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8006546:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 8006548:	f013 0f40 	tst.w	r3, #64	@ 0x40
 800654c:	d034      	beq.n	80065b8 <UART_AdvFeatureConfig+0x154>
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
 800654e:	6823      	ldr	r3, [r4, #0]
 8006550:	494a      	ldr	r1, [pc, #296]	@ (800667c <UART_AdvFeatureConfig+0x218>)
 8006552:	4a4b      	ldr	r2, [pc, #300]	@ (8006680 <UART_AdvFeatureConfig+0x21c>)
 8006554:	428b      	cmp	r3, r1
 8006556:	bf18      	it	ne
 8006558:	4293      	cmpne	r3, r2
 800655a:	d01c      	beq.n	8006596 <UART_AdvFeatureConfig+0x132>
 800655c:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8006560:	4293      	cmp	r3, r2
 8006562:	d018      	beq.n	8006596 <UART_AdvFeatureConfig+0x132>
 8006564:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8006568:	4293      	cmp	r3, r2
 800656a:	d014      	beq.n	8006596 <UART_AdvFeatureConfig+0x132>
 800656c:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8006570:	4293      	cmp	r3, r2
 8006572:	d010      	beq.n	8006596 <UART_AdvFeatureConfig+0x132>
 8006574:	f502 4244 	add.w	r2, r2, #50176	@ 0xc400
 8006578:	4293      	cmp	r3, r2
 800657a:	d00c      	beq.n	8006596 <UART_AdvFeatureConfig+0x132>
 800657c:	f5a2 421c 	sub.w	r2, r2, #39936	@ 0x9c00
 8006580:	4293      	cmp	r3, r2
 8006582:	d008      	beq.n	8006596 <UART_AdvFeatureConfig+0x132>
 8006584:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8006588:	4293      	cmp	r3, r2
 800658a:	d004      	beq.n	8006596 <UART_AdvFeatureConfig+0x132>
 800658c:	f640 41f9 	movw	r1, #3321	@ 0xcf9
 8006590:	483c      	ldr	r0, [pc, #240]	@ (8006684 <UART_AdvFeatureConfig+0x220>)
 8006592:	f7fa fa9f 	bl	8000ad4 <assert_failed>
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
 8006596:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 8006598:	2b00      	cmp	r3, #0
 800659a:	bf18      	it	ne
 800659c:	f5b3 1f80 	cmpne.w	r3, #1048576	@ 0x100000
 80065a0:	d146      	bne.n	8006630 <UART_AdvFeatureConfig+0x1cc>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80065a2:	6822      	ldr	r2, [r4, #0]
 80065a4:	6853      	ldr	r3, [r2, #4]
 80065a6:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
 80065aa:	6c61      	ldr	r1, [r4, #68]	@ 0x44
 80065ac:	430b      	orrs	r3, r1
 80065ae:	6053      	str	r3, [r2, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 80065b0:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 80065b2:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 80065b6:	d041      	beq.n	800663c <UART_AdvFeatureConfig+0x1d8>
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 80065b8:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 80065ba:	f013 0f80 	tst.w	r3, #128	@ 0x80
 80065be:	d00c      	beq.n	80065da <UART_AdvFeatureConfig+0x176>
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
 80065c0:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 80065c2:	2b00      	cmp	r3, #0
 80065c4:	bf18      	it	ne
 80065c6:	f5b3 2f00 	cmpne.w	r3, #524288	@ 0x80000
 80065ca:	d151      	bne.n	8006670 <UART_AdvFeatureConfig+0x20c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 80065cc:	6822      	ldr	r2, [r4, #0]
 80065ce:	6853      	ldr	r3, [r2, #4]
 80065d0:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
 80065d4:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
 80065d6:	430b      	orrs	r3, r1
 80065d8:	6053      	str	r3, [r2, #4]
}
 80065da:	bd10      	pop	{r4, pc}
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
 80065dc:	f640 41ca 	movw	r1, #3274	@ 0xcca
 80065e0:	4828      	ldr	r0, [pc, #160]	@ (8006684 <UART_AdvFeatureConfig+0x220>)
 80065e2:	f7fa fa77 	bl	8000ad4 <assert_failed>
 80065e6:	e743      	b.n	8006470 <UART_AdvFeatureConfig+0xc>
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
 80065e8:	f640 41cf 	movw	r1, #3279	@ 0xccf
 80065ec:	4825      	ldr	r0, [pc, #148]	@ (8006684 <UART_AdvFeatureConfig+0x220>)
 80065ee:	f7fa fa71 	bl	8000ad4 <assert_failed>
 80065f2:	e748      	b.n	8006486 <UART_AdvFeatureConfig+0x22>
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
 80065f4:	f640 41d6 	movw	r1, #3286	@ 0xcd6
 80065f8:	4822      	ldr	r0, [pc, #136]	@ (8006684 <UART_AdvFeatureConfig+0x220>)
 80065fa:	f7fa fa6b 	bl	8000ad4 <assert_failed>
 80065fe:	e754      	b.n	80064aa <UART_AdvFeatureConfig+0x46>
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
 8006600:	f640 41dd 	movw	r1, #3293	@ 0xcdd
 8006604:	481f      	ldr	r0, [pc, #124]	@ (8006684 <UART_AdvFeatureConfig+0x220>)
 8006606:	f7fa fa65 	bl	8000ad4 <assert_failed>
 800660a:	e760      	b.n	80064ce <UART_AdvFeatureConfig+0x6a>
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
 800660c:	f640 41e4 	movw	r1, #3300	@ 0xce4
 8006610:	481c      	ldr	r0, [pc, #112]	@ (8006684 <UART_AdvFeatureConfig+0x220>)
 8006612:	f7fa fa5f 	bl	8000ad4 <assert_failed>
 8006616:	e76c      	b.n	80064f2 <UART_AdvFeatureConfig+0x8e>
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
 8006618:	f640 41eb 	movw	r1, #3307	@ 0xceb
 800661c:	4819      	ldr	r0, [pc, #100]	@ (8006684 <UART_AdvFeatureConfig+0x220>)
 800661e:	f7fa fa59 	bl	8000ad4 <assert_failed>
 8006622:	e778      	b.n	8006516 <UART_AdvFeatureConfig+0xb2>
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
 8006624:	f640 41f2 	movw	r1, #3314	@ 0xcf2
 8006628:	4816      	ldr	r0, [pc, #88]	@ (8006684 <UART_AdvFeatureConfig+0x220>)
 800662a:	f7fa fa53 	bl	8000ad4 <assert_failed>
 800662e:	e783      	b.n	8006538 <UART_AdvFeatureConfig+0xd4>
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
 8006630:	f640 41fa 	movw	r1, #3322	@ 0xcfa
 8006634:	4813      	ldr	r0, [pc, #76]	@ (8006684 <UART_AdvFeatureConfig+0x220>)
 8006636:	f7fa fa4d 	bl	8000ad4 <assert_failed>
 800663a:	e7b2      	b.n	80065a2 <UART_AdvFeatureConfig+0x13e>
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
 800663c:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 800663e:	2b00      	cmp	r3, #0
 8006640:	bf18      	it	ne
 8006642:	f5b3 1f00 	cmpne.w	r3, #2097152	@ 0x200000
 8006646:	d005      	beq.n	8006654 <UART_AdvFeatureConfig+0x1f0>
 8006648:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 800664c:	d002      	beq.n	8006654 <UART_AdvFeatureConfig+0x1f0>
 800664e:	f5b3 0fc0 	cmp.w	r3, #6291456	@ 0x600000
 8006652:	d107      	bne.n	8006664 <UART_AdvFeatureConfig+0x200>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8006654:	6822      	ldr	r2, [r4, #0]
 8006656:	6853      	ldr	r3, [r2, #4]
 8006658:	f423 03c0 	bic.w	r3, r3, #6291456	@ 0x600000
 800665c:	6ca1      	ldr	r1, [r4, #72]	@ 0x48
 800665e:	430b      	orrs	r3, r1
 8006660:	6053      	str	r3, [r2, #4]
 8006662:	e7a9      	b.n	80065b8 <UART_AdvFeatureConfig+0x154>
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
 8006664:	f640 41ff 	movw	r1, #3327	@ 0xcff
 8006668:	4806      	ldr	r0, [pc, #24]	@ (8006684 <UART_AdvFeatureConfig+0x220>)
 800666a:	f7fa fa33 	bl	8000ad4 <assert_failed>
 800666e:	e7f1      	b.n	8006654 <UART_AdvFeatureConfig+0x1f0>
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
 8006670:	f640 5107 	movw	r1, #3335	@ 0xd07
 8006674:	4803      	ldr	r0, [pc, #12]	@ (8006684 <UART_AdvFeatureConfig+0x220>)
 8006676:	f7fa fa2d 	bl	8000ad4 <assert_failed>
 800667a:	e7a7      	b.n	80065cc <UART_AdvFeatureConfig+0x168>
 800667c:	40011000 	.word	0x40011000
 8006680:	40004400 	.word	0x40004400
 8006684:	0801565c 	.word	0x0801565c

08006688 <UART_WaitOnFlagUntilTimeout>:
{
 8006688:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800668c:	4605      	mov	r5, r0
 800668e:	460f      	mov	r7, r1
 8006690:	4616      	mov	r6, r2
 8006692:	4699      	mov	r9, r3
 8006694:	f8dd 8020 	ldr.w	r8, [sp, #32]
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8006698:	682b      	ldr	r3, [r5, #0]
 800669a:	69dc      	ldr	r4, [r3, #28]
 800669c:	ea37 0404 	bics.w	r4, r7, r4
 80066a0:	bf0c      	ite	eq
 80066a2:	2401      	moveq	r4, #1
 80066a4:	2400      	movne	r4, #0
 80066a6:	42b4      	cmp	r4, r6
 80066a8:	d132      	bne.n	8006710 <UART_WaitOnFlagUntilTimeout+0x88>
    if (Timeout != HAL_MAX_DELAY)
 80066aa:	f1b8 3fff 	cmp.w	r8, #4294967295
 80066ae:	d0f3      	beq.n	8006698 <UART_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80066b0:	f7fa fea2 	bl	80013f8 <HAL_GetTick>
 80066b4:	eba0 0009 	sub.w	r0, r0, r9
 80066b8:	4540      	cmp	r0, r8
 80066ba:	d82c      	bhi.n	8006716 <UART_WaitOnFlagUntilTimeout+0x8e>
 80066bc:	f1b8 0f00 	cmp.w	r8, #0
 80066c0:	d02b      	beq.n	800671a <UART_WaitOnFlagUntilTimeout+0x92>
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 80066c2:	682b      	ldr	r3, [r5, #0]
 80066c4:	681a      	ldr	r2, [r3, #0]
 80066c6:	f012 0f04 	tst.w	r2, #4
 80066ca:	d0e5      	beq.n	8006698 <UART_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
 80066cc:	69da      	ldr	r2, [r3, #28]
 80066ce:	f012 0f08 	tst.w	r2, #8
 80066d2:	d111      	bne.n	80066f8 <UART_WaitOnFlagUntilTimeout+0x70>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 80066d4:	69da      	ldr	r2, [r3, #28]
 80066d6:	f412 6f00 	tst.w	r2, #2048	@ 0x800
 80066da:	d0dd      	beq.n	8006698 <UART_WaitOnFlagUntilTimeout+0x10>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 80066dc:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 80066e0:	621a      	str	r2, [r3, #32]
          UART_EndRxTransfer(huart);
 80066e2:	4628      	mov	r0, r5
 80066e4:	f7ff fb06 	bl	8005cf4 <UART_EndRxTransfer>
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 80066e8:	2320      	movs	r3, #32
 80066ea:	f8c5 3090 	str.w	r3, [r5, #144]	@ 0x90
          __HAL_UNLOCK(huart);
 80066ee:	2300      	movs	r3, #0
 80066f0:	f885 3084 	strb.w	r3, [r5, #132]	@ 0x84
          return HAL_TIMEOUT;
 80066f4:	2003      	movs	r0, #3
 80066f6:	e00c      	b.n	8006712 <UART_WaitOnFlagUntilTimeout+0x8a>
           __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 80066f8:	2408      	movs	r4, #8
 80066fa:	621c      	str	r4, [r3, #32]
           UART_EndRxTransfer(huart);
 80066fc:	4628      	mov	r0, r5
 80066fe:	f7ff faf9 	bl	8005cf4 <UART_EndRxTransfer>
           huart->ErrorCode = HAL_UART_ERROR_ORE;
 8006702:	f8c5 4090 	str.w	r4, [r5, #144]	@ 0x90
           __HAL_UNLOCK(huart);
 8006706:	2300      	movs	r3, #0
 8006708:	f885 3084 	strb.w	r3, [r5, #132]	@ 0x84
           return HAL_ERROR;
 800670c:	2001      	movs	r0, #1
 800670e:	e000      	b.n	8006712 <UART_WaitOnFlagUntilTimeout+0x8a>
  return HAL_OK;
 8006710:	2000      	movs	r0, #0
}
 8006712:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return HAL_TIMEOUT;
 8006716:	2003      	movs	r0, #3
 8006718:	e7fb      	b.n	8006712 <UART_WaitOnFlagUntilTimeout+0x8a>
 800671a:	2003      	movs	r0, #3
 800671c:	e7f9      	b.n	8006712 <UART_WaitOnFlagUntilTimeout+0x8a>

0800671e <HAL_UART_Transmit>:
{
 800671e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006722:	b082      	sub	sp, #8
 8006724:	461e      	mov	r6, r3
  if (huart->gState == HAL_UART_STATE_READY)
 8006726:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
 800672a:	2b20      	cmp	r3, #32
 800672c:	d15b      	bne.n	80067e6 <HAL_UART_Transmit+0xc8>
 800672e:	4604      	mov	r4, r0
 8006730:	460d      	mov	r5, r1
 8006732:	4690      	mov	r8, r2
    if ((pData == NULL) || (Size == 0U))
 8006734:	2a00      	cmp	r2, #0
 8006736:	bf18      	it	ne
 8006738:	2900      	cmpne	r1, #0
 800673a:	d101      	bne.n	8006740 <HAL_UART_Transmit+0x22>
      return  HAL_ERROR;
 800673c:	2001      	movs	r0, #1
 800673e:	e053      	b.n	80067e8 <HAL_UART_Transmit+0xca>
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8006740:	2300      	movs	r3, #0
 8006742:	f8c0 3090 	str.w	r3, [r0, #144]	@ 0x90
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8006746:	2321      	movs	r3, #33	@ 0x21
 8006748:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
    tickstart = HAL_GetTick();
 800674c:	f7fa fe54 	bl	80013f8 <HAL_GetTick>
 8006750:	4607      	mov	r7, r0
    huart->TxXferSize  = Size;
 8006752:	f8a4 8054 	strh.w	r8, [r4, #84]	@ 0x54
    huart->TxXferCount = Size;
 8006756:	f8a4 8056 	strh.w	r8, [r4, #86]	@ 0x56
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800675a:	68a3      	ldr	r3, [r4, #8]
 800675c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8006760:	d002      	beq.n	8006768 <HAL_UART_Transmit+0x4a>
      pdata16bits = NULL;
 8006762:	f04f 0800 	mov.w	r8, #0
 8006766:	e016      	b.n	8006796 <HAL_UART_Transmit+0x78>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8006768:	6923      	ldr	r3, [r4, #16]
 800676a:	b343      	cbz	r3, 80067be <HAL_UART_Transmit+0xa0>
      pdata16bits = NULL;
 800676c:	f04f 0800 	mov.w	r8, #0
 8006770:	e011      	b.n	8006796 <HAL_UART_Transmit+0x78>
        huart->gState = HAL_UART_STATE_READY;
 8006772:	2320      	movs	r3, #32
 8006774:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
        return HAL_TIMEOUT;
 8006778:	2003      	movs	r0, #3
 800677a:	e035      	b.n	80067e8 <HAL_UART_Transmit+0xca>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 800677c:	f838 3b02 	ldrh.w	r3, [r8], #2
 8006780:	6822      	ldr	r2, [r4, #0]
 8006782:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8006786:	6293      	str	r3, [r2, #40]	@ 0x28
      huart->TxXferCount--;
 8006788:	f8b4 2056 	ldrh.w	r2, [r4, #86]	@ 0x56
 800678c:	b292      	uxth	r2, r2
 800678e:	3a01      	subs	r2, #1
 8006790:	b292      	uxth	r2, r2
 8006792:	f8a4 2056 	strh.w	r2, [r4, #86]	@ 0x56
    while (huart->TxXferCount > 0U)
 8006796:	f8b4 3056 	ldrh.w	r3, [r4, #86]	@ 0x56
 800679a:	b29b      	uxth	r3, r3
 800679c:	b193      	cbz	r3, 80067c4 <HAL_UART_Transmit+0xa6>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 800679e:	9600      	str	r6, [sp, #0]
 80067a0:	463b      	mov	r3, r7
 80067a2:	2200      	movs	r2, #0
 80067a4:	2180      	movs	r1, #128	@ 0x80
 80067a6:	4620      	mov	r0, r4
 80067a8:	f7ff ff6e 	bl	8006688 <UART_WaitOnFlagUntilTimeout>
 80067ac:	2800      	cmp	r0, #0
 80067ae:	d1e0      	bne.n	8006772 <HAL_UART_Transmit+0x54>
      if (pdata8bits == NULL)
 80067b0:	2d00      	cmp	r5, #0
 80067b2:	d0e3      	beq.n	800677c <HAL_UART_Transmit+0x5e>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 80067b4:	f815 2b01 	ldrb.w	r2, [r5], #1
 80067b8:	6823      	ldr	r3, [r4, #0]
 80067ba:	629a      	str	r2, [r3, #40]	@ 0x28
        pdata8bits++;
 80067bc:	e7e4      	b.n	8006788 <HAL_UART_Transmit+0x6a>
      pdata16bits = (const uint16_t *) pData;
 80067be:	46a8      	mov	r8, r5
      pdata8bits  = NULL;
 80067c0:	2500      	movs	r5, #0
 80067c2:	e7e8      	b.n	8006796 <HAL_UART_Transmit+0x78>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 80067c4:	9600      	str	r6, [sp, #0]
 80067c6:	463b      	mov	r3, r7
 80067c8:	2200      	movs	r2, #0
 80067ca:	2140      	movs	r1, #64	@ 0x40
 80067cc:	4620      	mov	r0, r4
 80067ce:	f7ff ff5b 	bl	8006688 <UART_WaitOnFlagUntilTimeout>
 80067d2:	b918      	cbnz	r0, 80067dc <HAL_UART_Transmit+0xbe>
    huart->gState = HAL_UART_STATE_READY;
 80067d4:	2320      	movs	r3, #32
 80067d6:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
    return HAL_OK;
 80067da:	e005      	b.n	80067e8 <HAL_UART_Transmit+0xca>
      huart->gState = HAL_UART_STATE_READY;
 80067dc:	2320      	movs	r3, #32
 80067de:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
      return HAL_TIMEOUT;
 80067e2:	2003      	movs	r0, #3
 80067e4:	e000      	b.n	80067e8 <HAL_UART_Transmit+0xca>
    return HAL_BUSY;
 80067e6:	2002      	movs	r0, #2
}
 80067e8:	b002      	add	sp, #8
 80067ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080067ee <UART_CheckIdleState>:
{
 80067ee:	b530      	push	{r4, r5, lr}
 80067f0:	b083      	sub	sp, #12
 80067f2:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80067f4:	2300      	movs	r3, #0
 80067f6:	f8c0 3090 	str.w	r3, [r0, #144]	@ 0x90
  tickstart = HAL_GetTick();
 80067fa:	f7fa fdfd 	bl	80013f8 <HAL_GetTick>
 80067fe:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8006800:	6822      	ldr	r2, [r4, #0]
 8006802:	6812      	ldr	r2, [r2, #0]
 8006804:	f012 0f08 	tst.w	r2, #8
 8006808:	d110      	bne.n	800682c <UART_CheckIdleState+0x3e>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 800680a:	6823      	ldr	r3, [r4, #0]
 800680c:	681b      	ldr	r3, [r3, #0]
 800680e:	f013 0f04 	tst.w	r3, #4
 8006812:	d128      	bne.n	8006866 <UART_CheckIdleState+0x78>
  huart->gState = HAL_UART_STATE_READY;
 8006814:	2320      	movs	r3, #32
 8006816:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
 800681a:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800681e:	2000      	movs	r0, #0
 8006820:	66e0      	str	r0, [r4, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 8006822:	6720      	str	r0, [r4, #112]	@ 0x70
  __HAL_UNLOCK(huart);
 8006824:	f884 0084 	strb.w	r0, [r4, #132]	@ 0x84
}
 8006828:	b003      	add	sp, #12
 800682a:	bd30      	pop	{r4, r5, pc}
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800682c:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
 8006830:	9300      	str	r3, [sp, #0]
 8006832:	4603      	mov	r3, r0
 8006834:	2200      	movs	r2, #0
 8006836:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
 800683a:	4620      	mov	r0, r4
 800683c:	f7ff ff24 	bl	8006688 <UART_WaitOnFlagUntilTimeout>
 8006840:	2800      	cmp	r0, #0
 8006842:	d0e2      	beq.n	800680a <UART_CheckIdleState+0x1c>
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
 8006844:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006846:	e852 3f00 	ldrex	r3, [r2]
 800684a:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800684e:	e842 3100 	strex	r1, r3, [r2]
 8006852:	2900      	cmp	r1, #0
 8006854:	d1f6      	bne.n	8006844 <UART_CheckIdleState+0x56>
      huart->gState = HAL_UART_STATE_READY;
 8006856:	2320      	movs	r3, #32
 8006858:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
      __HAL_UNLOCK(huart);
 800685c:	2300      	movs	r3, #0
 800685e:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
      return HAL_TIMEOUT;
 8006862:	2003      	movs	r0, #3
 8006864:	e7e0      	b.n	8006828 <UART_CheckIdleState+0x3a>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8006866:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
 800686a:	9300      	str	r3, [sp, #0]
 800686c:	462b      	mov	r3, r5
 800686e:	2200      	movs	r2, #0
 8006870:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
 8006874:	4620      	mov	r0, r4
 8006876:	f7ff ff07 	bl	8006688 <UART_WaitOnFlagUntilTimeout>
 800687a:	2800      	cmp	r0, #0
 800687c:	d0ca      	beq.n	8006814 <UART_CheckIdleState+0x26>
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 800687e:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006880:	e852 3f00 	ldrex	r3, [r2]
 8006884:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006888:	e842 3100 	strex	r1, r3, [r2]
 800688c:	2900      	cmp	r1, #0
 800688e:	d1f6      	bne.n	800687e <UART_CheckIdleState+0x90>
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8006890:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006892:	f102 0308 	add.w	r3, r2, #8
 8006896:	e853 3f00 	ldrex	r3, [r3]
 800689a:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800689e:	3208      	adds	r2, #8
 80068a0:	e842 3100 	strex	r1, r3, [r2]
 80068a4:	2900      	cmp	r1, #0
 80068a6:	d1f3      	bne.n	8006890 <UART_CheckIdleState+0xa2>
      huart->RxState = HAL_UART_STATE_READY;
 80068a8:	2320      	movs	r3, #32
 80068aa:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
      __HAL_UNLOCK(huart);
 80068ae:	2300      	movs	r3, #0
 80068b0:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
      return HAL_TIMEOUT;
 80068b4:	2003      	movs	r0, #3
 80068b6:	e7b7      	b.n	8006828 <UART_CheckIdleState+0x3a>

080068b8 <HAL_UART_Init>:
  if (huart == NULL)
 80068b8:	2800      	cmp	r0, #0
 80068ba:	f000 8085 	beq.w	80069c8 <HAL_UART_Init+0x110>
{
 80068be:	b510      	push	{r4, lr}
 80068c0:	4604      	mov	r4, r0
  if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
 80068c2:	6983      	ldr	r3, [r0, #24]
 80068c4:	2b00      	cmp	r3, #0
 80068c6:	d04d      	beq.n	8006964 <HAL_UART_Init+0xac>
    assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
 80068c8:	6803      	ldr	r3, [r0, #0]
 80068ca:	4940      	ldr	r1, [pc, #256]	@ (80069cc <HAL_UART_Init+0x114>)
 80068cc:	4a40      	ldr	r2, [pc, #256]	@ (80069d0 <HAL_UART_Init+0x118>)
 80068ce:	428b      	cmp	r3, r1
 80068d0:	bf18      	it	ne
 80068d2:	4293      	cmpne	r3, r2
 80068d4:	d01f      	beq.n	8006916 <HAL_UART_Init+0x5e>
 80068d6:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 80068da:	4293      	cmp	r3, r2
 80068dc:	d01b      	beq.n	8006916 <HAL_UART_Init+0x5e>
 80068de:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 80068e2:	4293      	cmp	r3, r2
 80068e4:	d017      	beq.n	8006916 <HAL_UART_Init+0x5e>
 80068e6:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 80068ea:	4293      	cmp	r3, r2
 80068ec:	d013      	beq.n	8006916 <HAL_UART_Init+0x5e>
 80068ee:	f502 4244 	add.w	r2, r2, #50176	@ 0xc400
 80068f2:	4293      	cmp	r3, r2
 80068f4:	d00f      	beq.n	8006916 <HAL_UART_Init+0x5e>
 80068f6:	f5a2 421c 	sub.w	r2, r2, #39936	@ 0x9c00
 80068fa:	4293      	cmp	r3, r2
 80068fc:	d00b      	beq.n	8006916 <HAL_UART_Init+0x5e>
 80068fe:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8006902:	4293      	cmp	r3, r2
 8006904:	d007      	beq.n	8006916 <HAL_UART_Init+0x5e>
 8006906:	4a33      	ldr	r2, [pc, #204]	@ (80069d4 <HAL_UART_Init+0x11c>)
 8006908:	4293      	cmp	r3, r2
 800690a:	d004      	beq.n	8006916 <HAL_UART_Init+0x5e>
 800690c:	f44f 719f 	mov.w	r1, #318	@ 0x13e
 8006910:	4831      	ldr	r0, [pc, #196]	@ (80069d8 <HAL_UART_Init+0x120>)
 8006912:	f7fa f8df 	bl	8000ad4 <assert_failed>
  if (huart->gState == HAL_UART_STATE_RESET)
 8006916:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
 800691a:	2b00      	cmp	r3, #0
 800691c:	d04a      	beq.n	80069b4 <HAL_UART_Init+0xfc>
  huart->gState = HAL_UART_STATE_BUSY;
 800691e:	2324      	movs	r3, #36	@ 0x24
 8006920:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UART_DISABLE(huart);
 8006924:	6822      	ldr	r2, [r4, #0]
 8006926:	6813      	ldr	r3, [r2, #0]
 8006928:	f023 0301 	bic.w	r3, r3, #1
 800692c:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 800692e:	4620      	mov	r0, r4
 8006930:	f7ff fa0c 	bl	8005d4c <UART_SetConfig>
 8006934:	2801      	cmp	r0, #1
 8006936:	d014      	beq.n	8006962 <HAL_UART_Init+0xaa>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8006938:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 800693a:	2b00      	cmp	r3, #0
 800693c:	d140      	bne.n	80069c0 <HAL_UART_Init+0x108>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800693e:	6822      	ldr	r2, [r4, #0]
 8006940:	6853      	ldr	r3, [r2, #4]
 8006942:	f423 4390 	bic.w	r3, r3, #18432	@ 0x4800
 8006946:	6053      	str	r3, [r2, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8006948:	6822      	ldr	r2, [r4, #0]
 800694a:	6893      	ldr	r3, [r2, #8]
 800694c:	f023 032a 	bic.w	r3, r3, #42	@ 0x2a
 8006950:	6093      	str	r3, [r2, #8]
  __HAL_UART_ENABLE(huart);
 8006952:	6822      	ldr	r2, [r4, #0]
 8006954:	6813      	ldr	r3, [r2, #0]
 8006956:	f043 0301 	orr.w	r3, r3, #1
 800695a:	6013      	str	r3, [r2, #0]
  return (UART_CheckIdleState(huart));
 800695c:	4620      	mov	r0, r4
 800695e:	f7ff ff46 	bl	80067ee <UART_CheckIdleState>
}
 8006962:	bd10      	pop	{r4, pc}
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
 8006964:	6803      	ldr	r3, [r0, #0]
 8006966:	4919      	ldr	r1, [pc, #100]	@ (80069cc <HAL_UART_Init+0x114>)
 8006968:	4a19      	ldr	r2, [pc, #100]	@ (80069d0 <HAL_UART_Init+0x118>)
 800696a:	428b      	cmp	r3, r1
 800696c:	bf18      	it	ne
 800696e:	4293      	cmpne	r3, r2
 8006970:	d0d1      	beq.n	8006916 <HAL_UART_Init+0x5e>
 8006972:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8006976:	4293      	cmp	r3, r2
 8006978:	d0cd      	beq.n	8006916 <HAL_UART_Init+0x5e>
 800697a:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 800697e:	4293      	cmp	r3, r2
 8006980:	d0c9      	beq.n	8006916 <HAL_UART_Init+0x5e>
 8006982:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8006986:	4293      	cmp	r3, r2
 8006988:	d0c5      	beq.n	8006916 <HAL_UART_Init+0x5e>
 800698a:	f502 4244 	add.w	r2, r2, #50176	@ 0xc400
 800698e:	4293      	cmp	r3, r2
 8006990:	d0c1      	beq.n	8006916 <HAL_UART_Init+0x5e>
 8006992:	f5a2 421c 	sub.w	r2, r2, #39936	@ 0x9c00
 8006996:	4293      	cmp	r3, r2
 8006998:	d0bd      	beq.n	8006916 <HAL_UART_Init+0x5e>
 800699a:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 800699e:	4293      	cmp	r3, r2
 80069a0:	d0b9      	beq.n	8006916 <HAL_UART_Init+0x5e>
 80069a2:	4a0c      	ldr	r2, [pc, #48]	@ (80069d4 <HAL_UART_Init+0x11c>)
 80069a4:	4293      	cmp	r3, r2
 80069a6:	d0b6      	beq.n	8006916 <HAL_UART_Init+0x5e>
 80069a8:	f240 1143 	movw	r1, #323	@ 0x143
 80069ac:	480a      	ldr	r0, [pc, #40]	@ (80069d8 <HAL_UART_Init+0x120>)
 80069ae:	f7fa f891 	bl	8000ad4 <assert_failed>
 80069b2:	e7b0      	b.n	8006916 <HAL_UART_Init+0x5e>
    huart->Lock = HAL_UNLOCKED;
 80069b4:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
    HAL_UART_MspInit(huart);
 80069b8:	4620      	mov	r0, r4
 80069ba:	f7fa fb85 	bl	80010c8 <HAL_UART_MspInit>
 80069be:	e7ae      	b.n	800691e <HAL_UART_Init+0x66>
    UART_AdvFeatureConfig(huart);
 80069c0:	4620      	mov	r0, r4
 80069c2:	f7ff fd4f 	bl	8006464 <UART_AdvFeatureConfig>
 80069c6:	e7ba      	b.n	800693e <HAL_UART_Init+0x86>
    return HAL_ERROR;
 80069c8:	2001      	movs	r0, #1
}
 80069ca:	4770      	bx	lr
 80069cc:	40011000 	.word	0x40011000
 80069d0:	40004400 	.word	0x40004400
 80069d4:	58000c00 	.word	0x58000c00
 80069d8:	0801565c 	.word	0x0801565c

080069dc <UARTEx_SetNbDataToProcess>:
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 80069dc:	6e43      	ldr	r3, [r0, #100]	@ 0x64
 80069de:	b92b      	cbnz	r3, 80069ec <UARTEx_SetNbDataToProcess+0x10>
  {
    huart->NbTxDataToProcess = 1U;
 80069e0:	2301      	movs	r3, #1
 80069e2:	f8a0 306a 	strh.w	r3, [r0, #106]	@ 0x6a
    huart->NbRxDataToProcess = 1U;
 80069e6:	f8a0 3068 	strh.w	r3, [r0, #104]	@ 0x68
 80069ea:	4770      	bx	lr
{
 80069ec:	b430      	push	{r4, r5}
  }
  else
  {
    rx_fifo_depth = RX_FIFO_DEPTH;
    tx_fifo_depth = TX_FIFO_DEPTH;
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 80069ee:	6803      	ldr	r3, [r0, #0]
 80069f0:	689a      	ldr	r2, [r3, #8]
 80069f2:	f3c2 6242 	ubfx	r2, r2, #25, #3
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 80069f6:	6899      	ldr	r1, [r3, #8]
 80069f8:	0f49      	lsrs	r1, r1, #29
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 80069fa:	4d09      	ldr	r5, [pc, #36]	@ (8006a20 <UARTEx_SetNbDataToProcess+0x44>)
 80069fc:	5c6b      	ldrb	r3, [r5, r1]
 80069fe:	011b      	lsls	r3, r3, #4
                               (uint16_t)denominator[tx_fifo_threshold];
 8006a00:	4c08      	ldr	r4, [pc, #32]	@ (8006a24 <UARTEx_SetNbDataToProcess+0x48>)
 8006a02:	5c61      	ldrb	r1, [r4, r1]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8006a04:	fb93 f3f1 	sdiv	r3, r3, r1
 8006a08:	f8a0 306a 	strh.w	r3, [r0, #106]	@ 0x6a
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8006a0c:	5cab      	ldrb	r3, [r5, r2]
 8006a0e:	011b      	lsls	r3, r3, #4
                               (uint16_t)denominator[rx_fifo_threshold];
 8006a10:	5ca2      	ldrb	r2, [r4, r2]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8006a12:	fb93 f3f2 	sdiv	r3, r3, r2
 8006a16:	f8a0 3068 	strh.w	r3, [r0, #104]	@ 0x68
  }
}
 8006a1a:	bc30      	pop	{r4, r5}
 8006a1c:	4770      	bx	lr
 8006a1e:	bf00      	nop
 8006a20:	08018dd4 	.word	0x08018dd4
 8006a24:	08018dcc 	.word	0x08018dcc

08006a28 <HAL_UARTEx_DisableFifoMode>:
{
 8006a28:	b510      	push	{r4, lr}
 8006a2a:	4604      	mov	r4, r0
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
 8006a2c:	6803      	ldr	r3, [r0, #0]
 8006a2e:	4920      	ldr	r1, [pc, #128]	@ (8006ab0 <HAL_UARTEx_DisableFifoMode+0x88>)
 8006a30:	4a20      	ldr	r2, [pc, #128]	@ (8006ab4 <HAL_UARTEx_DisableFifoMode+0x8c>)
 8006a32:	428b      	cmp	r3, r1
 8006a34:	bf18      	it	ne
 8006a36:	4293      	cmpne	r3, r2
 8006a38:	d01c      	beq.n	8006a74 <HAL_UARTEx_DisableFifoMode+0x4c>
 8006a3a:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8006a3e:	4293      	cmp	r3, r2
 8006a40:	d018      	beq.n	8006a74 <HAL_UARTEx_DisableFifoMode+0x4c>
 8006a42:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8006a46:	4293      	cmp	r3, r2
 8006a48:	d014      	beq.n	8006a74 <HAL_UARTEx_DisableFifoMode+0x4c>
 8006a4a:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8006a4e:	4293      	cmp	r3, r2
 8006a50:	d010      	beq.n	8006a74 <HAL_UARTEx_DisableFifoMode+0x4c>
 8006a52:	f502 4244 	add.w	r2, r2, #50176	@ 0xc400
 8006a56:	4293      	cmp	r3, r2
 8006a58:	d00c      	beq.n	8006a74 <HAL_UARTEx_DisableFifoMode+0x4c>
 8006a5a:	f5a2 421c 	sub.w	r2, r2, #39936	@ 0x9c00
 8006a5e:	4293      	cmp	r3, r2
 8006a60:	d008      	beq.n	8006a74 <HAL_UARTEx_DisableFifoMode+0x4c>
 8006a62:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8006a66:	4293      	cmp	r3, r2
 8006a68:	d004      	beq.n	8006a74 <HAL_UARTEx_DisableFifoMode+0x4c>
 8006a6a:	f44f 710d 	mov.w	r1, #564	@ 0x234
 8006a6e:	4812      	ldr	r0, [pc, #72]	@ (8006ab8 <HAL_UARTEx_DisableFifoMode+0x90>)
 8006a70:	f7fa f830 	bl	8000ad4 <assert_failed>
  __HAL_LOCK(huart);
 8006a74:	f894 3084 	ldrb.w	r3, [r4, #132]	@ 0x84
 8006a78:	2b01      	cmp	r3, #1
 8006a7a:	d017      	beq.n	8006aac <HAL_UARTEx_DisableFifoMode+0x84>
 8006a7c:	2301      	movs	r3, #1
 8006a7e:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
  huart->gState = HAL_UART_STATE_BUSY;
 8006a82:	2324      	movs	r3, #36	@ 0x24
 8006a84:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8006a88:	6822      	ldr	r2, [r4, #0]
 8006a8a:	6813      	ldr	r3, [r2, #0]
  __HAL_UART_DISABLE(huart);
 8006a8c:	6811      	ldr	r1, [r2, #0]
 8006a8e:	f021 0101 	bic.w	r1, r1, #1
 8006a92:	6011      	str	r1, [r2, #0]
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
 8006a94:	f023 5300 	bic.w	r3, r3, #536870912	@ 0x20000000
  huart->FifoMode = UART_FIFOMODE_DISABLE;
 8006a98:	2000      	movs	r0, #0
 8006a9a:	6660      	str	r0, [r4, #100]	@ 0x64
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8006a9c:	6822      	ldr	r2, [r4, #0]
 8006a9e:	6013      	str	r3, [r2, #0]
  huart->gState = HAL_UART_STATE_READY;
 8006aa0:	2320      	movs	r3, #32
 8006aa2:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UNLOCK(huart);
 8006aa6:	f884 0084 	strb.w	r0, [r4, #132]	@ 0x84
}
 8006aaa:	bd10      	pop	{r4, pc}
  __HAL_LOCK(huart);
 8006aac:	2002      	movs	r0, #2
 8006aae:	e7fc      	b.n	8006aaa <HAL_UARTEx_DisableFifoMode+0x82>
 8006ab0:	40011000 	.word	0x40011000
 8006ab4:	40004400 	.word	0x40004400
 8006ab8:	08015698 	.word	0x08015698

08006abc <HAL_UARTEx_SetTxFifoThreshold>:
{
 8006abc:	b570      	push	{r4, r5, r6, lr}
 8006abe:	4604      	mov	r4, r0
 8006ac0:	460d      	mov	r5, r1
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
 8006ac2:	6803      	ldr	r3, [r0, #0]
 8006ac4:	4930      	ldr	r1, [pc, #192]	@ (8006b88 <HAL_UARTEx_SetTxFifoThreshold+0xcc>)
 8006ac6:	4a31      	ldr	r2, [pc, #196]	@ (8006b8c <HAL_UARTEx_SetTxFifoThreshold+0xd0>)
 8006ac8:	428b      	cmp	r3, r1
 8006aca:	bf18      	it	ne
 8006acc:	4293      	cmpne	r3, r2
 8006ace:	d01c      	beq.n	8006b0a <HAL_UARTEx_SetTxFifoThreshold+0x4e>
 8006ad0:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8006ad4:	4293      	cmp	r3, r2
 8006ad6:	d018      	beq.n	8006b0a <HAL_UARTEx_SetTxFifoThreshold+0x4e>
 8006ad8:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8006adc:	4293      	cmp	r3, r2
 8006ade:	d014      	beq.n	8006b0a <HAL_UARTEx_SetTxFifoThreshold+0x4e>
 8006ae0:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8006ae4:	4293      	cmp	r3, r2
 8006ae6:	d010      	beq.n	8006b0a <HAL_UARTEx_SetTxFifoThreshold+0x4e>
 8006ae8:	f502 4244 	add.w	r2, r2, #50176	@ 0xc400
 8006aec:	4293      	cmp	r3, r2
 8006aee:	d00c      	beq.n	8006b0a <HAL_UARTEx_SetTxFifoThreshold+0x4e>
 8006af0:	f5a2 421c 	sub.w	r2, r2, #39936	@ 0x9c00
 8006af4:	4293      	cmp	r3, r2
 8006af6:	d008      	beq.n	8006b0a <HAL_UARTEx_SetTxFifoThreshold+0x4e>
 8006af8:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8006afc:	4293      	cmp	r3, r2
 8006afe:	d004      	beq.n	8006b0a <HAL_UARTEx_SetTxFifoThreshold+0x4e>
 8006b00:	f240 2162 	movw	r1, #610	@ 0x262
 8006b04:	4822      	ldr	r0, [pc, #136]	@ (8006b90 <HAL_UARTEx_SetTxFifoThreshold+0xd4>)
 8006b06:	f7f9 ffe5 	bl	8000ad4 <assert_failed>
  assert_param(IS_UART_TXFIFO_THRESHOLD(Threshold));
 8006b0a:	2d00      	cmp	r5, #0
 8006b0c:	bf18      	it	ne
 8006b0e:	f1b5 5f00 	cmpne.w	r5, #536870912	@ 0x20000000
 8006b12:	d00f      	beq.n	8006b34 <HAL_UARTEx_SetTxFifoThreshold+0x78>
 8006b14:	f1b5 43c0 	subs.w	r3, r5, #1610612736	@ 0x60000000
 8006b18:	bf18      	it	ne
 8006b1a:	2301      	movne	r3, #1
 8006b1c:	f1b5 4f80 	cmp.w	r5, #1073741824	@ 0x40000000
 8006b20:	d008      	beq.n	8006b34 <HAL_UARTEx_SetTxFifoThreshold+0x78>
 8006b22:	b13b      	cbz	r3, 8006b34 <HAL_UARTEx_SetTxFifoThreshold+0x78>
 8006b24:	f1b5 4320 	subs.w	r3, r5, #2684354560	@ 0xa0000000
 8006b28:	bf18      	it	ne
 8006b2a:	2301      	movne	r3, #1
 8006b2c:	f1b5 4f00 	cmp.w	r5, #2147483648	@ 0x80000000
 8006b30:	d000      	beq.n	8006b34 <HAL_UARTEx_SetTxFifoThreshold+0x78>
 8006b32:	bb0b      	cbnz	r3, 8006b78 <HAL_UARTEx_SetTxFifoThreshold+0xbc>
  __HAL_LOCK(huart);
 8006b34:	f894 3084 	ldrb.w	r3, [r4, #132]	@ 0x84
 8006b38:	2b01      	cmp	r3, #1
 8006b3a:	d023      	beq.n	8006b84 <HAL_UARTEx_SetTxFifoThreshold+0xc8>
 8006b3c:	2301      	movs	r3, #1
 8006b3e:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
  huart->gState = HAL_UART_STATE_BUSY;
 8006b42:	2324      	movs	r3, #36	@ 0x24
 8006b44:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8006b48:	6823      	ldr	r3, [r4, #0]
 8006b4a:	681e      	ldr	r6, [r3, #0]
  __HAL_UART_DISABLE(huart);
 8006b4c:	681a      	ldr	r2, [r3, #0]
 8006b4e:	f022 0201 	bic.w	r2, r2, #1
 8006b52:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 8006b54:	6822      	ldr	r2, [r4, #0]
 8006b56:	6893      	ldr	r3, [r2, #8]
 8006b58:	f023 4360 	bic.w	r3, r3, #3758096384	@ 0xe0000000
 8006b5c:	432b      	orrs	r3, r5
 8006b5e:	6093      	str	r3, [r2, #8]
  UARTEx_SetNbDataToProcess(huart);
 8006b60:	4620      	mov	r0, r4
 8006b62:	f7ff ff3b 	bl	80069dc <UARTEx_SetNbDataToProcess>
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8006b66:	6823      	ldr	r3, [r4, #0]
 8006b68:	601e      	str	r6, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 8006b6a:	2320      	movs	r3, #32
 8006b6c:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UNLOCK(huart);
 8006b70:	2000      	movs	r0, #0
 8006b72:	f884 0084 	strb.w	r0, [r4, #132]	@ 0x84
}
 8006b76:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_UART_TXFIFO_THRESHOLD(Threshold));
 8006b78:	f240 2163 	movw	r1, #611	@ 0x263
 8006b7c:	4804      	ldr	r0, [pc, #16]	@ (8006b90 <HAL_UARTEx_SetTxFifoThreshold+0xd4>)
 8006b7e:	f7f9 ffa9 	bl	8000ad4 <assert_failed>
 8006b82:	e7d7      	b.n	8006b34 <HAL_UARTEx_SetTxFifoThreshold+0x78>
  __HAL_LOCK(huart);
 8006b84:	2002      	movs	r0, #2
 8006b86:	e7f6      	b.n	8006b76 <HAL_UARTEx_SetTxFifoThreshold+0xba>
 8006b88:	40011000 	.word	0x40011000
 8006b8c:	40004400 	.word	0x40004400
 8006b90:	08015698 	.word	0x08015698

08006b94 <HAL_UARTEx_SetRxFifoThreshold>:
{
 8006b94:	b570      	push	{r4, r5, r6, lr}
 8006b96:	4604      	mov	r4, r0
 8006b98:	460d      	mov	r5, r1
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
 8006b9a:	6803      	ldr	r3, [r0, #0]
 8006b9c:	4930      	ldr	r1, [pc, #192]	@ (8006c60 <HAL_UARTEx_SetRxFifoThreshold+0xcc>)
 8006b9e:	4a31      	ldr	r2, [pc, #196]	@ (8006c64 <HAL_UARTEx_SetRxFifoThreshold+0xd0>)
 8006ba0:	428b      	cmp	r3, r1
 8006ba2:	bf18      	it	ne
 8006ba4:	4293      	cmpne	r3, r2
 8006ba6:	d01c      	beq.n	8006be2 <HAL_UARTEx_SetRxFifoThreshold+0x4e>
 8006ba8:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8006bac:	4293      	cmp	r3, r2
 8006bae:	d018      	beq.n	8006be2 <HAL_UARTEx_SetRxFifoThreshold+0x4e>
 8006bb0:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8006bb4:	4293      	cmp	r3, r2
 8006bb6:	d014      	beq.n	8006be2 <HAL_UARTEx_SetRxFifoThreshold+0x4e>
 8006bb8:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8006bbc:	4293      	cmp	r3, r2
 8006bbe:	d010      	beq.n	8006be2 <HAL_UARTEx_SetRxFifoThreshold+0x4e>
 8006bc0:	f502 4244 	add.w	r2, r2, #50176	@ 0xc400
 8006bc4:	4293      	cmp	r3, r2
 8006bc6:	d00c      	beq.n	8006be2 <HAL_UARTEx_SetRxFifoThreshold+0x4e>
 8006bc8:	f5a2 421c 	sub.w	r2, r2, #39936	@ 0x9c00
 8006bcc:	4293      	cmp	r3, r2
 8006bce:	d008      	beq.n	8006be2 <HAL_UARTEx_SetRxFifoThreshold+0x4e>
 8006bd0:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8006bd4:	4293      	cmp	r3, r2
 8006bd6:	d004      	beq.n	8006be2 <HAL_UARTEx_SetRxFifoThreshold+0x4e>
 8006bd8:	f240 2193 	movw	r1, #659	@ 0x293
 8006bdc:	4822      	ldr	r0, [pc, #136]	@ (8006c68 <HAL_UARTEx_SetRxFifoThreshold+0xd4>)
 8006bde:	f7f9 ff79 	bl	8000ad4 <assert_failed>
  assert_param(IS_UART_RXFIFO_THRESHOLD(Threshold));
 8006be2:	2d00      	cmp	r5, #0
 8006be4:	bf18      	it	ne
 8006be6:	f1b5 7f00 	cmpne.w	r5, #33554432	@ 0x2000000
 8006bea:	d00f      	beq.n	8006c0c <HAL_UARTEx_SetRxFifoThreshold+0x78>
 8006bec:	f1b5 63c0 	subs.w	r3, r5, #100663296	@ 0x6000000
 8006bf0:	bf18      	it	ne
 8006bf2:	2301      	movne	r3, #1
 8006bf4:	f1b5 6f80 	cmp.w	r5, #67108864	@ 0x4000000
 8006bf8:	d008      	beq.n	8006c0c <HAL_UARTEx_SetRxFifoThreshold+0x78>
 8006bfa:	b13b      	cbz	r3, 8006c0c <HAL_UARTEx_SetRxFifoThreshold+0x78>
 8006bfc:	f1b5 6320 	subs.w	r3, r5, #167772160	@ 0xa000000
 8006c00:	bf18      	it	ne
 8006c02:	2301      	movne	r3, #1
 8006c04:	f1b5 6f00 	cmp.w	r5, #134217728	@ 0x8000000
 8006c08:	d000      	beq.n	8006c0c <HAL_UARTEx_SetRxFifoThreshold+0x78>
 8006c0a:	bb0b      	cbnz	r3, 8006c50 <HAL_UARTEx_SetRxFifoThreshold+0xbc>
  __HAL_LOCK(huart);
 8006c0c:	f894 3084 	ldrb.w	r3, [r4, #132]	@ 0x84
 8006c10:	2b01      	cmp	r3, #1
 8006c12:	d023      	beq.n	8006c5c <HAL_UARTEx_SetRxFifoThreshold+0xc8>
 8006c14:	2301      	movs	r3, #1
 8006c16:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
  huart->gState = HAL_UART_STATE_BUSY;
 8006c1a:	2324      	movs	r3, #36	@ 0x24
 8006c1c:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8006c20:	6823      	ldr	r3, [r4, #0]
 8006c22:	681e      	ldr	r6, [r3, #0]
  __HAL_UART_DISABLE(huart);
 8006c24:	681a      	ldr	r2, [r3, #0]
 8006c26:	f022 0201 	bic.w	r2, r2, #1
 8006c2a:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 8006c2c:	6822      	ldr	r2, [r4, #0]
 8006c2e:	6893      	ldr	r3, [r2, #8]
 8006c30:	f023 6360 	bic.w	r3, r3, #234881024	@ 0xe000000
 8006c34:	432b      	orrs	r3, r5
 8006c36:	6093      	str	r3, [r2, #8]
  UARTEx_SetNbDataToProcess(huart);
 8006c38:	4620      	mov	r0, r4
 8006c3a:	f7ff fecf 	bl	80069dc <UARTEx_SetNbDataToProcess>
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8006c3e:	6823      	ldr	r3, [r4, #0]
 8006c40:	601e      	str	r6, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 8006c42:	2320      	movs	r3, #32
 8006c44:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UNLOCK(huart);
 8006c48:	2000      	movs	r0, #0
 8006c4a:	f884 0084 	strb.w	r0, [r4, #132]	@ 0x84
}
 8006c4e:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_UART_RXFIFO_THRESHOLD(Threshold));
 8006c50:	f44f 7125 	mov.w	r1, #660	@ 0x294
 8006c54:	4804      	ldr	r0, [pc, #16]	@ (8006c68 <HAL_UARTEx_SetRxFifoThreshold+0xd4>)
 8006c56:	f7f9 ff3d 	bl	8000ad4 <assert_failed>
 8006c5a:	e7d7      	b.n	8006c0c <HAL_UARTEx_SetRxFifoThreshold+0x78>
  __HAL_LOCK(huart);
 8006c5c:	2002      	movs	r0, #2
 8006c5e:	e7f6      	b.n	8006c4e <HAL_UARTEx_SetRxFifoThreshold+0xba>
 8006c60:	40011000 	.word	0x40011000
 8006c64:	40004400 	.word	0x40004400
 8006c68:	08015698 	.word	0x08015698

08006c6c <makeFreeRtosPriority>:
/* Convert from CMSIS type osPriority to FreeRTOS priority number */
static unsigned portBASE_TYPE makeFreeRtosPriority (osPriority priority)
{
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
  
  if (priority != osPriorityError) {
 8006c6c:	2884      	cmp	r0, #132	@ 0x84
 8006c6e:	d001      	beq.n	8006c74 <makeFreeRtosPriority+0x8>
    fpriority += (priority - osPriorityIdle);
 8006c70:	3003      	adds	r0, #3
 8006c72:	4770      	bx	lr
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 8006c74:	2000      	movs	r0, #0
  }
  
  return fpriority;
}
 8006c76:	4770      	bx	lr

08006c78 <inHandlerMode>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8006c78:	f3ef 8005 	mrs	r0, IPSR

/* Determine whether we are in thread mode or handler mode. */
static int inHandlerMode (void)
{
  return __get_IPSR() != 0;
}
 8006c7c:	3800      	subs	r0, #0
 8006c7e:	bf18      	it	ne
 8006c80:	2001      	movne	r0, #1
 8006c82:	4770      	bx	lr

08006c84 <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 8006c84:	b508      	push	{r3, lr}
  vTaskStartScheduler();
 8006c86:	f001 fa87 	bl	8008198 <vTaskStartScheduler>
  
  return osOK;
}
 8006c8a:	2000      	movs	r0, #0
 8006c8c:	bd08      	pop	{r3, pc}

08006c8e <osKernelSysTick>:
* @param  None
* @retval None
* @note   MUST REMAIN UNCHANGED: \b osKernelSysTick shall be consistent in every CMSIS-RTOS.
*/
uint32_t osKernelSysTick(void)
{
 8006c8e:	b508      	push	{r3, lr}
  if (inHandlerMode()) {
 8006c90:	f7ff fff2 	bl	8006c78 <inHandlerMode>
 8006c94:	b110      	cbz	r0, 8006c9c <osKernelSysTick+0xe>
    return xTaskGetTickCountFromISR();
 8006c96:	f001 fac7 	bl	8008228 <xTaskGetTickCountFromISR>
  }
  else {
    return xTaskGetTickCount();
  }
}
 8006c9a:	bd08      	pop	{r3, pc}
    return xTaskGetTickCount();
 8006c9c:	f001 fabe 	bl	800821c <xTaskGetTickCount>
 8006ca0:	e7fb      	b.n	8006c9a <osKernelSysTick+0xc>

08006ca2 <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 8006ca2:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8006ca6:	b087      	sub	sp, #28
 8006ca8:	460e      	mov	r6, r1
  TaskHandle_t handle;
  
#if( configSUPPORT_STATIC_ALLOCATION == 1 ) &&  ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
  if((thread_def->buffer != NULL) && (thread_def->controlblock != NULL)) {
 8006caa:	6944      	ldr	r4, [r0, #20]
 8006cac:	b1c4      	cbz	r4, 8006ce0 <osThreadCreate+0x3e>
 8006cae:	6985      	ldr	r5, [r0, #24]
 8006cb0:	b1b5      	cbz	r5, 8006ce0 <osThreadCreate+0x3e>
    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8006cb2:	6847      	ldr	r7, [r0, #4]
 8006cb4:	f8d0 8000 	ldr.w	r8, [r0]
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
 8006cb8:	f8d0 9010 	ldr.w	r9, [r0, #16]
    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8006cbc:	f9b0 0008 	ldrsh.w	r0, [r0, #8]
 8006cc0:	f7ff ffd4 	bl	8006c6c <makeFreeRtosPriority>
 8006cc4:	9502      	str	r5, [sp, #8]
 8006cc6:	9401      	str	r4, [sp, #4]
 8006cc8:	9000      	str	r0, [sp, #0]
 8006cca:	4633      	mov	r3, r6
 8006ccc:	464a      	mov	r2, r9
 8006cce:	4641      	mov	r1, r8
 8006cd0:	4638      	mov	r0, r7
 8006cd2:	f001 f93e 	bl	8007f52 <xTaskCreateStatic>
 8006cd6:	9005      	str	r0, [sp, #20]
                   &handle) != pdPASS)  {
    return NULL;
  }     
#endif
  
  return handle;
 8006cd8:	9805      	ldr	r0, [sp, #20]
}
 8006cda:	b007      	add	sp, #28
 8006cdc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8006ce0:	6844      	ldr	r4, [r0, #4]
 8006ce2:	6805      	ldr	r5, [r0, #0]
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
 8006ce4:	6907      	ldr	r7, [r0, #16]
    if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8006ce6:	f9b0 0008 	ldrsh.w	r0, [r0, #8]
 8006cea:	f7ff ffbf 	bl	8006c6c <makeFreeRtosPriority>
 8006cee:	ab05      	add	r3, sp, #20
 8006cf0:	9301      	str	r3, [sp, #4]
 8006cf2:	9000      	str	r0, [sp, #0]
 8006cf4:	4633      	mov	r3, r6
 8006cf6:	b2ba      	uxth	r2, r7
 8006cf8:	4629      	mov	r1, r5
 8006cfa:	4620      	mov	r0, r4
 8006cfc:	f001 f964 	bl	8007fc8 <xTaskCreate>
 8006d00:	2801      	cmp	r0, #1
 8006d02:	d0e9      	beq.n	8006cd8 <osThreadCreate+0x36>
      return NULL;
 8006d04:	2000      	movs	r0, #0
 8006d06:	e7e8      	b.n	8006cda <osThreadCreate+0x38>

08006d08 <osThreadTerminate>:
* @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osThreadTerminate shall be consistent in every CMSIS-RTOS.
*/
osStatus osThreadTerminate (osThreadId thread_id)
{
 8006d08:	b508      	push	{r3, lr}
#if (INCLUDE_vTaskDelete == 1)
  vTaskDelete(thread_id);
 8006d0a:	f001 f98f 	bl	800802c <vTaskDelete>
  return osOK;
#else
  return osErrorOS;
#endif
}
 8006d0e:	2000      	movs	r0, #0
 8006d10:	bd08      	pop	{r3, pc}

08006d12 <osMutexCreate>:
* @param  mutex_def     mutex definition referenced with \ref osMutex.
* @retval  mutex ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osMutexCreate shall be consistent in every CMSIS-RTOS.
*/
osMutexId osMutexCreate (const osMutexDef_t *mutex_def)
{
 8006d12:	b508      	push	{r3, lr}
#if ( configUSE_MUTEXES == 1)

#if( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

  if (mutex_def->controlblock != NULL) {
 8006d14:	6841      	ldr	r1, [r0, #4]
 8006d16:	b119      	cbz	r1, 8006d20 <osMutexCreate+0xe>
    return xSemaphoreCreateMutexStatic( mutex_def->controlblock );
 8006d18:	2001      	movs	r0, #1
 8006d1a:	f000 fc73 	bl	8007604 <xQueueCreateMutexStatic>
    return xSemaphoreCreateMutex(); 
#endif
#else
  return NULL;
#endif
}
 8006d1e:	bd08      	pop	{r3, pc}
    return xSemaphoreCreateMutex(); 
 8006d20:	2001      	movs	r0, #1
 8006d22:	f000 fc64 	bl	80075ee <xQueueCreateMutex>
 8006d26:	e7fa      	b.n	8006d1e <osMutexCreate+0xc>

08006d28 <osMutexWait>:
* @param millisec      timeout value or 0 in case of no time-out.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMutexWait shall be consistent in every CMSIS-RTOS.
*/
osStatus osMutexWait (osMutexId mutex_id, uint32_t millisec)
{
 8006d28:	b530      	push	{r4, r5, lr}
 8006d2a:	b083      	sub	sp, #12
  TickType_t ticks;
  portBASE_TYPE taskWoken = pdFALSE;  
 8006d2c:	2300      	movs	r3, #0
 8006d2e:	9301      	str	r3, [sp, #4]
  
  
  if (mutex_id == NULL) {
 8006d30:	b310      	cbz	r0, 8006d78 <osMutexWait+0x50>
 8006d32:	460c      	mov	r4, r1
 8006d34:	4605      	mov	r5, r0
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 8006d36:	f7ff ff9f 	bl	8006c78 <inHandlerMode>
 8006d3a:	b1a0      	cbz	r0, 8006d66 <osMutexWait+0x3e>
    if (xSemaphoreTakeFromISR(mutex_id, &taskWoken) != pdTRUE) {
 8006d3c:	aa01      	add	r2, sp, #4
 8006d3e:	2100      	movs	r1, #0
 8006d40:	4628      	mov	r0, r5
 8006d42:	f000 feb0 	bl	8007aa6 <xQueueReceiveFromISR>
 8006d46:	2801      	cmp	r0, #1
 8006d48:	d118      	bne.n	8006d7c <osMutexWait+0x54>
      return osErrorOS;
    }
	portEND_SWITCHING_ISR(taskWoken);
 8006d4a:	9b01      	ldr	r3, [sp, #4]
 8006d4c:	b1c3      	cbz	r3, 8006d80 <osMutexWait+0x58>
 8006d4e:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8006d52:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8006d56:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8006d5a:	f3bf 8f4f 	dsb	sy
 8006d5e:	f3bf 8f6f 	isb	sy
  } 
  else if (xSemaphoreTake(mutex_id, ticks) != pdTRUE) {
    return osErrorOS;
  }
  
  return osOK;
 8006d62:	2000      	movs	r0, #0
 8006d64:	e006      	b.n	8006d74 <osMutexWait+0x4c>
  else if (xSemaphoreTake(mutex_id, ticks) != pdTRUE) {
 8006d66:	4621      	mov	r1, r4
 8006d68:	4628      	mov	r0, r5
 8006d6a:	f000 fdc9 	bl	8007900 <xQueueSemaphoreTake>
 8006d6e:	2801      	cmp	r0, #1
 8006d70:	d108      	bne.n	8006d84 <osMutexWait+0x5c>
  return osOK;
 8006d72:	2000      	movs	r0, #0
}
 8006d74:	b003      	add	sp, #12
 8006d76:	bd30      	pop	{r4, r5, pc}
    return osErrorParameter;
 8006d78:	2080      	movs	r0, #128	@ 0x80
 8006d7a:	e7fb      	b.n	8006d74 <osMutexWait+0x4c>
      return osErrorOS;
 8006d7c:	20ff      	movs	r0, #255	@ 0xff
 8006d7e:	e7f9      	b.n	8006d74 <osMutexWait+0x4c>
  return osOK;
 8006d80:	2000      	movs	r0, #0
 8006d82:	e7f7      	b.n	8006d74 <osMutexWait+0x4c>
    return osErrorOS;
 8006d84:	20ff      	movs	r0, #255	@ 0xff
 8006d86:	e7f5      	b.n	8006d74 <osMutexWait+0x4c>

08006d88 <osMutexRelease>:
* @param mutex_id      mutex ID obtained by \ref osMutexCreate.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMutexRelease shall be consistent in every CMSIS-RTOS.
*/
osStatus osMutexRelease (osMutexId mutex_id)
{
 8006d88:	b510      	push	{r4, lr}
 8006d8a:	b082      	sub	sp, #8
 8006d8c:	4604      	mov	r4, r0
  osStatus result = osOK;
  portBASE_TYPE taskWoken = pdFALSE;
 8006d8e:	2300      	movs	r3, #0
 8006d90:	9301      	str	r3, [sp, #4]
  
  if (inHandlerMode()) {
 8006d92:	f7ff ff71 	bl	8006c78 <inHandlerMode>
 8006d96:	b198      	cbz	r0, 8006dc0 <osMutexRelease+0x38>
    if (xSemaphoreGiveFromISR(mutex_id, &taskWoken) != pdTRUE) {
 8006d98:	a901      	add	r1, sp, #4
 8006d9a:	4620      	mov	r0, r4
 8006d9c:	f000 fca8 	bl	80076f0 <xQueueGiveFromISR>
 8006da0:	2801      	cmp	r0, #1
 8006da2:	d11a      	bne.n	8006dda <osMutexRelease+0x52>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 8006da4:	9b01      	ldr	r3, [sp, #4]
 8006da6:	b1d3      	cbz	r3, 8006dde <osMutexRelease+0x56>
 8006da8:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8006dac:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8006db0:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8006db4:	f3bf 8f4f 	dsb	sy
 8006db8:	f3bf 8f6f 	isb	sy
  osStatus result = osOK;
 8006dbc:	2000      	movs	r0, #0
 8006dbe:	e008      	b.n	8006dd2 <osMutexRelease+0x4a>
  }
  else if (xSemaphoreGive(mutex_id) != pdTRUE) 
 8006dc0:	2300      	movs	r3, #0
 8006dc2:	461a      	mov	r2, r3
 8006dc4:	4619      	mov	r1, r3
 8006dc6:	4620      	mov	r0, r4
 8006dc8:	f000 fb41 	bl	800744e <xQueueGenericSend>
 8006dcc:	2801      	cmp	r0, #1
 8006dce:	d002      	beq.n	8006dd6 <osMutexRelease+0x4e>
  {
    result = osErrorOS;
 8006dd0:	20ff      	movs	r0, #255	@ 0xff
  }
  return result;
}
 8006dd2:	b002      	add	sp, #8
 8006dd4:	bd10      	pop	{r4, pc}
  osStatus result = osOK;
 8006dd6:	2000      	movs	r0, #0
 8006dd8:	e7fb      	b.n	8006dd2 <osMutexRelease+0x4a>
      return osErrorOS;
 8006dda:	20ff      	movs	r0, #255	@ 0xff
 8006ddc:	e7f9      	b.n	8006dd2 <osMutexRelease+0x4a>
  osStatus result = osOK;
 8006dde:	2000      	movs	r0, #0
 8006de0:	e7f7      	b.n	8006dd2 <osMutexRelease+0x4a>

08006de2 <osSemaphoreCreate>:
* @param count         number of available resources.
* @retval  semaphore ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreCreate shall be consistent in every CMSIS-RTOS.
*/
osSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count)
{ 
 8006de2:	b510      	push	{r4, lr}
 8006de4:	b082      	sub	sp, #8
#if( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

  osSemaphoreId sema;
  
  if (semaphore_def->controlblock != NULL){
 8006de6:	6842      	ldr	r2, [r0, #4]
 8006de8:	b192      	cbz	r2, 8006e10 <osSemaphoreCreate+0x2e>
    if (count == 1) {
 8006dea:	2901      	cmp	r1, #1
 8006dec:	d006      	beq.n	8006dfc <osSemaphoreCreate+0x1a>
      return xSemaphoreCreateBinaryStatic( semaphore_def->controlblock );
    }
    else {
#if (configUSE_COUNTING_SEMAPHORES == 1 )
      return xSemaphoreCreateCountingStatic( count, count, semaphore_def->controlblock );
 8006dee:	4608      	mov	r0, r1
 8006df0:	f000 faec 	bl	80073cc <xQueueCreateCountingSemaphoreStatic>
 8006df4:	4604      	mov	r4, r0
#else
    return NULL;
#endif
  }
#endif
}
 8006df6:	4620      	mov	r0, r4
 8006df8:	b002      	add	sp, #8
 8006dfa:	bd10      	pop	{r4, pc}
      return xSemaphoreCreateBinaryStatic( semaphore_def->controlblock );
 8006dfc:	2303      	movs	r3, #3
 8006dfe:	9300      	str	r3, [sp, #0]
 8006e00:	4613      	mov	r3, r2
 8006e02:	2200      	movs	r2, #0
 8006e04:	4611      	mov	r1, r2
 8006e06:	2001      	movs	r0, #1
 8006e08:	f000 fa69 	bl	80072de <xQueueGenericCreateStatic>
 8006e0c:	4604      	mov	r4, r0
 8006e0e:	e7f2      	b.n	8006df6 <osSemaphoreCreate+0x14>
    if (count == 1) {
 8006e10:	2901      	cmp	r1, #1
 8006e12:	d004      	beq.n	8006e1e <osSemaphoreCreate+0x3c>
      return xSemaphoreCreateCounting(count, count);
 8006e14:	4608      	mov	r0, r1
 8006e16:	f000 fafc 	bl	8007412 <xQueueCreateCountingSemaphore>
 8006e1a:	4604      	mov	r4, r0
 8006e1c:	e7eb      	b.n	8006df6 <osSemaphoreCreate+0x14>
      vSemaphoreCreateBinary(sema);
 8006e1e:	2203      	movs	r2, #3
 8006e20:	2100      	movs	r1, #0
 8006e22:	2001      	movs	r0, #1
 8006e24:	f000 faae 	bl	8007384 <xQueueGenericCreate>
 8006e28:	4604      	mov	r4, r0
 8006e2a:	2800      	cmp	r0, #0
 8006e2c:	d0e3      	beq.n	8006df6 <osSemaphoreCreate+0x14>
 8006e2e:	2300      	movs	r3, #0
 8006e30:	461a      	mov	r2, r3
 8006e32:	4619      	mov	r1, r3
 8006e34:	f000 fb0b 	bl	800744e <xQueueGenericSend>
      return sema;
 8006e38:	e7dd      	b.n	8006df6 <osSemaphoreCreate+0x14>

08006e3a <osSemaphoreWait>:
* @param  millisec      timeout value or 0 in case of no time-out.
* @retval  number of available tokens, or -1 in case of incorrect parameters.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreWait shall be consistent in every CMSIS-RTOS.
*/
int32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec)
{
 8006e3a:	b570      	push	{r4, r5, r6, lr}
 8006e3c:	b082      	sub	sp, #8
  TickType_t ticks;
  portBASE_TYPE taskWoken = pdFALSE;  
 8006e3e:	2300      	movs	r3, #0
 8006e40:	9301      	str	r3, [sp, #4]
  
  
  if (semaphore_id == NULL) {
 8006e42:	b318      	cbz	r0, 8006e8c <osSemaphoreWait+0x52>
 8006e44:	460c      	mov	r4, r1
 8006e46:	4606      	mov	r6, r0
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 8006e48:	f7ff ff16 	bl	8006c78 <inHandlerMode>
 8006e4c:	4605      	mov	r5, r0
 8006e4e:	b1a0      	cbz	r0, 8006e7a <osSemaphoreWait+0x40>
    if (xSemaphoreTakeFromISR(semaphore_id, &taskWoken) != pdTRUE) {
 8006e50:	aa01      	add	r2, sp, #4
 8006e52:	2100      	movs	r1, #0
 8006e54:	4630      	mov	r0, r6
 8006e56:	f000 fe26 	bl	8007aa6 <xQueueReceiveFromISR>
 8006e5a:	2801      	cmp	r0, #1
 8006e5c:	d118      	bne.n	8006e90 <osSemaphoreWait+0x56>
      return osErrorOS;
    }
	portEND_SWITCHING_ISR(taskWoken);
 8006e5e:	9d01      	ldr	r5, [sp, #4]
 8006e60:	b18d      	cbz	r5, 8006e86 <osSemaphoreWait+0x4c>
 8006e62:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8006e66:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8006e6a:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8006e6e:	f3bf 8f4f 	dsb	sy
 8006e72:	f3bf 8f6f 	isb	sy
  }  
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
    return osErrorOS;
  }
  
  return osOK;
 8006e76:	2500      	movs	r5, #0
 8006e78:	e005      	b.n	8006e86 <osSemaphoreWait+0x4c>
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
 8006e7a:	4621      	mov	r1, r4
 8006e7c:	4630      	mov	r0, r6
 8006e7e:	f000 fd3f 	bl	8007900 <xQueueSemaphoreTake>
 8006e82:	2801      	cmp	r0, #1
 8006e84:	d106      	bne.n	8006e94 <osSemaphoreWait+0x5a>
}
 8006e86:	4628      	mov	r0, r5
 8006e88:	b002      	add	sp, #8
 8006e8a:	bd70      	pop	{r4, r5, r6, pc}
    return osErrorParameter;
 8006e8c:	2580      	movs	r5, #128	@ 0x80
 8006e8e:	e7fa      	b.n	8006e86 <osSemaphoreWait+0x4c>
      return osErrorOS;
 8006e90:	25ff      	movs	r5, #255	@ 0xff
 8006e92:	e7f8      	b.n	8006e86 <osSemaphoreWait+0x4c>
    return osErrorOS;
 8006e94:	25ff      	movs	r5, #255	@ 0xff
 8006e96:	e7f6      	b.n	8006e86 <osSemaphoreWait+0x4c>

08006e98 <osSemaphoreRelease>:
* @param  semaphore_id  semaphore object referenced with \ref osSemaphore.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreRelease shall be consistent in every CMSIS-RTOS.
*/
osStatus osSemaphoreRelease (osSemaphoreId semaphore_id)
{
 8006e98:	b510      	push	{r4, lr}
 8006e9a:	b082      	sub	sp, #8
 8006e9c:	4604      	mov	r4, r0
  osStatus result = osOK;
  portBASE_TYPE taskWoken = pdFALSE;
 8006e9e:	2300      	movs	r3, #0
 8006ea0:	9301      	str	r3, [sp, #4]
  
  
  if (inHandlerMode()) {
 8006ea2:	f7ff fee9 	bl	8006c78 <inHandlerMode>
 8006ea6:	b198      	cbz	r0, 8006ed0 <osSemaphoreRelease+0x38>
    if (xSemaphoreGiveFromISR(semaphore_id, &taskWoken) != pdTRUE) {
 8006ea8:	a901      	add	r1, sp, #4
 8006eaa:	4620      	mov	r0, r4
 8006eac:	f000 fc20 	bl	80076f0 <xQueueGiveFromISR>
 8006eb0:	2801      	cmp	r0, #1
 8006eb2:	d11a      	bne.n	8006eea <osSemaphoreRelease+0x52>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 8006eb4:	9b01      	ldr	r3, [sp, #4]
 8006eb6:	b1d3      	cbz	r3, 8006eee <osSemaphoreRelease+0x56>
 8006eb8:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8006ebc:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8006ec0:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8006ec4:	f3bf 8f4f 	dsb	sy
 8006ec8:	f3bf 8f6f 	isb	sy
  osStatus result = osOK;
 8006ecc:	2000      	movs	r0, #0
 8006ece:	e008      	b.n	8006ee2 <osSemaphoreRelease+0x4a>
  }
  else {
    if (xSemaphoreGive(semaphore_id) != pdTRUE) {
 8006ed0:	2300      	movs	r3, #0
 8006ed2:	461a      	mov	r2, r3
 8006ed4:	4619      	mov	r1, r3
 8006ed6:	4620      	mov	r0, r4
 8006ed8:	f000 fab9 	bl	800744e <xQueueGenericSend>
 8006edc:	2801      	cmp	r0, #1
 8006ede:	d002      	beq.n	8006ee6 <osSemaphoreRelease+0x4e>
      result = osErrorOS;
 8006ee0:	20ff      	movs	r0, #255	@ 0xff
    }
  }
  
  return result;
}
 8006ee2:	b002      	add	sp, #8
 8006ee4:	bd10      	pop	{r4, pc}
  osStatus result = osOK;
 8006ee6:	2000      	movs	r0, #0
 8006ee8:	e7fb      	b.n	8006ee2 <osSemaphoreRelease+0x4a>
      return osErrorOS;
 8006eea:	20ff      	movs	r0, #255	@ 0xff
 8006eec:	e7f9      	b.n	8006ee2 <osSemaphoreRelease+0x4a>
  osStatus result = osOK;
 8006eee:	2000      	movs	r0, #0
 8006ef0:	e7f7      	b.n	8006ee2 <osSemaphoreRelease+0x4a>

08006ef2 <osSemaphoreDelete>:
* @param  semaphore_id  semaphore object referenced with \ref osSemaphore.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreDelete shall be consistent in every CMSIS-RTOS.
*/
osStatus osSemaphoreDelete (osSemaphoreId semaphore_id)
{
 8006ef2:	b510      	push	{r4, lr}
 8006ef4:	4604      	mov	r4, r0
  if (inHandlerMode()) {
 8006ef6:	f7ff febf 	bl	8006c78 <inHandlerMode>
 8006efa:	b920      	cbnz	r0, 8006f06 <osSemaphoreDelete+0x14>
    return osErrorISR;
  }

  vSemaphoreDelete(semaphore_id);
 8006efc:	4620      	mov	r0, r4
 8006efe:	f000 fe5f 	bl	8007bc0 <vQueueDelete>

  return osOK; 
 8006f02:	2000      	movs	r0, #0
}
 8006f04:	bd10      	pop	{r4, pc}
    return osErrorISR;
 8006f06:	2082      	movs	r0, #130	@ 0x82
 8006f08:	e7fc      	b.n	8006f04 <osSemaphoreDelete+0x12>

08006f0a <osMessageCreate>:
* @param  thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
* @retval  message queue ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osMessageCreate shall be consistent in every CMSIS-RTOS.
*/
osMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id)
{
 8006f0a:	b500      	push	{lr}
 8006f0c:	b083      	sub	sp, #12
  (void) thread_id;
  
#if( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

  if ((queue_def->buffer != NULL) && (queue_def->controlblock != NULL)) {
 8006f0e:	6882      	ldr	r2, [r0, #8]
 8006f10:	b142      	cbz	r2, 8006f24 <osMessageCreate+0x1a>
 8006f12:	68c3      	ldr	r3, [r0, #12]
 8006f14:	b133      	cbz	r3, 8006f24 <osMessageCreate+0x1a>
    return xQueueCreateStatic(queue_def->queue_sz, queue_def->item_sz, queue_def->buffer, queue_def->controlblock);
 8006f16:	2100      	movs	r1, #0
 8006f18:	9100      	str	r1, [sp, #0]
 8006f1a:	6841      	ldr	r1, [r0, #4]
 8006f1c:	6800      	ldr	r0, [r0, #0]
 8006f1e:	f000 f9de 	bl	80072de <xQueueGenericCreateStatic>
 8006f22:	e004      	b.n	8006f2e <osMessageCreate+0x24>
  }
  else {
    return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
 8006f24:	2200      	movs	r2, #0
 8006f26:	6841      	ldr	r1, [r0, #4]
 8006f28:	6800      	ldr	r0, [r0, #0]
 8006f2a:	f000 fa2b 	bl	8007384 <xQueueGenericCreate>
#elif ( configSUPPORT_STATIC_ALLOCATION == 1 )
  return xQueueCreateStatic(queue_def->queue_sz, queue_def->item_sz, queue_def->buffer, queue_def->controlblock);
#else  
  return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
#endif
}
 8006f2e:	b003      	add	sp, #12
 8006f30:	f85d fb04 	ldr.w	pc, [sp], #4

08006f34 <osMessagePut>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMessagePut shall be consistent in every CMSIS-RTOS.
*/
osStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec)
{
 8006f34:	b530      	push	{r4, r5, lr}
 8006f36:	b085      	sub	sp, #20
 8006f38:	4604      	mov	r4, r0
 8006f3a:	9101      	str	r1, [sp, #4]
  portBASE_TYPE taskWoken = pdFALSE;
 8006f3c:	2300      	movs	r3, #0
 8006f3e:	9303      	str	r3, [sp, #12]
  TickType_t ticks;
  
  ticks = millisec / portTICK_PERIOD_MS;
  if (ticks == 0) {
 8006f40:	4615      	mov	r5, r2
 8006f42:	b902      	cbnz	r2, 8006f46 <osMessagePut+0x12>
    ticks = 1;
 8006f44:	2501      	movs	r5, #1
  }
  
  if (inHandlerMode()) {
 8006f46:	f7ff fe97 	bl	8006c78 <inHandlerMode>
 8006f4a:	b1a8      	cbz	r0, 8006f78 <osMessagePut+0x44>
    if (xQueueSendFromISR(queue_id, &info, &taskWoken) != pdTRUE) {
 8006f4c:	2300      	movs	r3, #0
 8006f4e:	aa03      	add	r2, sp, #12
 8006f50:	a901      	add	r1, sp, #4
 8006f52:	4620      	mov	r0, r4
 8006f54:	f000 fb65 	bl	8007622 <xQueueGenericSendFromISR>
 8006f58:	2801      	cmp	r0, #1
 8006f5a:	d118      	bne.n	8006f8e <osMessagePut+0x5a>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 8006f5c:	9b03      	ldr	r3, [sp, #12]
 8006f5e:	b1c3      	cbz	r3, 8006f92 <osMessagePut+0x5e>
 8006f60:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8006f64:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8006f68:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8006f6c:	f3bf 8f4f 	dsb	sy
 8006f70:	f3bf 8f6f 	isb	sy
    if (xQueueSend(queue_id, &info, ticks) != pdTRUE) {
      return osErrorOS;
    }
  }
  
  return osOK;
 8006f74:	2000      	movs	r0, #0
 8006f76:	e008      	b.n	8006f8a <osMessagePut+0x56>
    if (xQueueSend(queue_id, &info, ticks) != pdTRUE) {
 8006f78:	2300      	movs	r3, #0
 8006f7a:	462a      	mov	r2, r5
 8006f7c:	a901      	add	r1, sp, #4
 8006f7e:	4620      	mov	r0, r4
 8006f80:	f000 fa65 	bl	800744e <xQueueGenericSend>
 8006f84:	2801      	cmp	r0, #1
 8006f86:	d106      	bne.n	8006f96 <osMessagePut+0x62>
  return osOK;
 8006f88:	2000      	movs	r0, #0
}
 8006f8a:	b005      	add	sp, #20
 8006f8c:	bd30      	pop	{r4, r5, pc}
      return osErrorOS;
 8006f8e:	20ff      	movs	r0, #255	@ 0xff
 8006f90:	e7fb      	b.n	8006f8a <osMessagePut+0x56>
  return osOK;
 8006f92:	2000      	movs	r0, #0
 8006f94:	e7f9      	b.n	8006f8a <osMessagePut+0x56>
      return osErrorOS;
 8006f96:	20ff      	movs	r0, #255	@ 0xff
 8006f98:	e7f7      	b.n	8006f8a <osMessagePut+0x56>

08006f9a <osMessageGet>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval event information that includes status code.
* @note   MUST REMAIN UNCHANGED: \b osMessageGet shall be consistent in every CMSIS-RTOS.
*/
osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec)
{
 8006f9a:	b570      	push	{r4, r5, r6, lr}
 8006f9c:	b084      	sub	sp, #16
 8006f9e:	4604      	mov	r4, r0
  portBASE_TYPE taskWoken;
  TickType_t ticks;
  osEvent event;
  
  event.def.message_id = queue_id;
 8006fa0:	9102      	str	r1, [sp, #8]
  event.value.v = 0;
 8006fa2:	2300      	movs	r3, #0
 8006fa4:	9301      	str	r3, [sp, #4]
  
  if (queue_id == NULL) {
 8006fa6:	b1e1      	cbz	r1, 8006fe2 <osMessageGet+0x48>
 8006fa8:	460d      	mov	r5, r1
 8006faa:	4616      	mov	r6, r2
    event.status = osErrorParameter;
    return event;
  }
  
  taskWoken = pdFALSE;
 8006fac:	2300      	movs	r3, #0
 8006fae:	9303      	str	r3, [sp, #12]
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 8006fb0:	f7ff fe62 	bl	8006c78 <inHandlerMode>
 8006fb4:	b300      	cbz	r0, 8006ff8 <osMessageGet+0x5e>
    if (xQueueReceiveFromISR(queue_id, &event.value.v, &taskWoken) == pdTRUE) {
 8006fb6:	aa03      	add	r2, sp, #12
 8006fb8:	a901      	add	r1, sp, #4
 8006fba:	4628      	mov	r0, r5
 8006fbc:	f000 fd73 	bl	8007aa6 <xQueueReceiveFromISR>
 8006fc0:	2801      	cmp	r0, #1
 8006fc2:	d016      	beq.n	8006ff2 <osMessageGet+0x58>
      /* We have mail */
      event.status = osEventMessage;
    }
    else {
      event.status = osOK;
 8006fc4:	2300      	movs	r3, #0
 8006fc6:	9300      	str	r3, [sp, #0]
    }
    portEND_SWITCHING_ISR(taskWoken);
 8006fc8:	9b03      	ldr	r3, [sp, #12]
 8006fca:	b1fb      	cbz	r3, 800700c <osMessageGet+0x72>
 8006fcc:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8006fd0:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8006fd4:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8006fd8:	f3bf 8f4f 	dsb	sy
 8006fdc:	f3bf 8f6f 	isb	sy
 8006fe0:	e014      	b.n	800700c <osMessageGet+0x72>
    event.status = osErrorParameter;
 8006fe2:	2380      	movs	r3, #128	@ 0x80
 8006fe4:	9300      	str	r3, [sp, #0]
    return event;
 8006fe6:	466b      	mov	r3, sp
 8006fe8:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8006fec:	e884 0007 	stmia.w	r4, {r0, r1, r2}
 8006ff0:	e011      	b.n	8007016 <osMessageGet+0x7c>
      event.status = osEventMessage;
 8006ff2:	2310      	movs	r3, #16
 8006ff4:	9300      	str	r3, [sp, #0]
 8006ff6:	e7e7      	b.n	8006fc8 <osMessageGet+0x2e>
  }
  else {
    if (xQueueReceive(queue_id, &event.value.v, ticks) == pdTRUE) {
 8006ff8:	4632      	mov	r2, r6
 8006ffa:	a901      	add	r1, sp, #4
 8006ffc:	4628      	mov	r0, r5
 8006ffe:	f000 fbd0 	bl	80077a2 <xQueueReceive>
 8007002:	2801      	cmp	r0, #1
 8007004:	d00a      	beq.n	800701c <osMessageGet+0x82>
      /* We have mail */
      event.status = osEventMessage;
    }
    else {
      event.status = (ticks == 0) ? osOK : osEventTimeout;
 8007006:	b106      	cbz	r6, 800700a <osMessageGet+0x70>
 8007008:	2640      	movs	r6, #64	@ 0x40
 800700a:	9600      	str	r6, [sp, #0]
    }
  }
  
  return event;
 800700c:	466b      	mov	r3, sp
 800700e:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8007012:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 8007016:	4620      	mov	r0, r4
 8007018:	b004      	add	sp, #16
 800701a:	bd70      	pop	{r4, r5, r6, pc}
      event.status = osEventMessage;
 800701c:	2310      	movs	r3, #16
 800701e:	9300      	str	r3, [sp, #0]
 8007020:	e7f4      	b.n	800700c <osMessageGet+0x72>

08007022 <osThreadList>:
* @param   buffer   A buffer into which the above mentioned details
*          will be written
* @retval  status code that indicates the execution status of the function.
*/
osStatus osThreadList (uint8_t *buffer)
{
 8007022:	b508      	push	{r3, lr}
#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
  vTaskList((char *)buffer);
 8007024:	f001 fcf4 	bl	8008a10 <vTaskList>
#endif
  return osOK;
}
 8007028:	2000      	movs	r0, #0
 800702a:	bd08      	pop	{r3, pc}

0800702c <osMessageWaiting>:
* @brief  Get the number of messaged stored in a queue.
* @param  queue_id  message queue ID obtained with \ref osMessageCreate.
* @retval number of messages stored in a queue.
*/
uint32_t osMessageWaiting(osMessageQId queue_id)
{
 800702c:	b510      	push	{r4, lr}
 800702e:	4604      	mov	r4, r0
  if (inHandlerMode()) {
 8007030:	f7ff fe22 	bl	8006c78 <inHandlerMode>
 8007034:	b118      	cbz	r0, 800703e <osMessageWaiting+0x12>
    return uxQueueMessagesWaitingFromISR(queue_id);
 8007036:	4620      	mov	r0, r4
 8007038:	f000 fd9f 	bl	8007b7a <uxQueueMessagesWaitingFromISR>
  }
  else
  {
    return uxQueueMessagesWaiting(queue_id);
  }
}
 800703c:	bd10      	pop	{r4, pc}
    return uxQueueMessagesWaiting(queue_id);
 800703e:	4620      	mov	r0, r4
 8007040:	f000 fd88 	bl	8007b54 <uxQueueMessagesWaiting>
 8007044:	e7fa      	b.n	800703c <osMessageWaiting+0x10>

08007046 <osMessageDelete>:
* @brief Delete a Message Queue
* @param  queue_id  message queue ID obtained with \ref osMessageCreate.
* @retval  status code that indicates the execution status of the function.
*/
osStatus osMessageDelete (osMessageQId queue_id)
{
 8007046:	b510      	push	{r4, lr}
 8007048:	4604      	mov	r4, r0
  if (inHandlerMode()) {
 800704a:	f7ff fe15 	bl	8006c78 <inHandlerMode>
 800704e:	b920      	cbnz	r0, 800705a <osMessageDelete+0x14>
    return osErrorISR;
  }

  vQueueDelete(queue_id);
 8007050:	4620      	mov	r0, r4
 8007052:	f000 fdb5 	bl	8007bc0 <vQueueDelete>

  return osOK; 
 8007056:	2000      	movs	r0, #0
}
 8007058:	bd10      	pop	{r4, pc}
    return osErrorISR;
 800705a:	2082      	movs	r0, #130	@ 0x82
 800705c:	e7fc      	b.n	8007058 <osMessageDelete+0x12>

0800705e <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800705e:	f100 0308 	add.w	r3, r0, #8
 8007062:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8007064:	f04f 32ff 	mov.w	r2, #4294967295
 8007068:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800706a:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800706c:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800706e:	2300      	movs	r3, #0
 8007070:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 8007072:	4770      	bx	lr

08007074 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 8007074:	2300      	movs	r3, #0
 8007076:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8007078:	4770      	bx	lr

0800707a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 800707a:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 800707c:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800707e:	689a      	ldr	r2, [r3, #8]
 8007080:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8007082:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8007084:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
 8007086:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8007088:	6803      	ldr	r3, [r0, #0]
 800708a:	3301      	adds	r3, #1
 800708c:	6003      	str	r3, [r0, #0]
}
 800708e:	4770      	bx	lr

08007090 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8007090:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8007092:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8007094:	f1b5 3fff 	cmp.w	r5, #4294967295
 8007098:	d011      	beq.n	80070be <vListInsert+0x2e>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 800709a:	f100 0308 	add.w	r3, r0, #8
 800709e:	461c      	mov	r4, r3
 80070a0:	685b      	ldr	r3, [r3, #4]
 80070a2:	681a      	ldr	r2, [r3, #0]
 80070a4:	42aa      	cmp	r2, r5
 80070a6:	d9fa      	bls.n	800709e <vListInsert+0xe>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 80070a8:	6863      	ldr	r3, [r4, #4]
 80070aa:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 80070ac:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 80070ae:	608c      	str	r4, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 80070b0:	6061      	str	r1, [r4, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
 80070b2:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 80070b4:	6803      	ldr	r3, [r0, #0]
 80070b6:	3301      	adds	r3, #1
 80070b8:	6003      	str	r3, [r0, #0]
}
 80070ba:	bc30      	pop	{r4, r5}
 80070bc:	4770      	bx	lr
		pxIterator = pxList->xListEnd.pxPrevious;
 80070be:	6904      	ldr	r4, [r0, #16]
 80070c0:	e7f2      	b.n	80070a8 <vListInsert+0x18>

080070c2 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 80070c2:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 80070c4:	6841      	ldr	r1, [r0, #4]
 80070c6:	6882      	ldr	r2, [r0, #8]
 80070c8:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 80070ca:	6841      	ldr	r1, [r0, #4]
 80070cc:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 80070ce:	685a      	ldr	r2, [r3, #4]
 80070d0:	4282      	cmp	r2, r0
 80070d2:	d006      	beq.n	80070e2 <uxListRemove+0x20>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 80070d4:	2200      	movs	r2, #0
 80070d6:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 80070d8:	681a      	ldr	r2, [r3, #0]
 80070da:	3a01      	subs	r2, #1
 80070dc:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 80070de:	6818      	ldr	r0, [r3, #0]
}
 80070e0:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 80070e2:	6882      	ldr	r2, [r0, #8]
 80070e4:	605a      	str	r2, [r3, #4]
 80070e6:	e7f5      	b.n	80070d4 <uxListRemove+0x12>

080070e8 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
 80070e8:	4603      	mov	r3, r0
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 80070ea:	6a40      	ldr	r0, [r0, #36]	@ 0x24
 80070ec:	b118      	cbz	r0, 80070f6 <prvGetDisinheritPriorityAfterTimeout+0xe>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 80070ee:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80070f0:	6818      	ldr	r0, [r3, #0]
 80070f2:	f1c0 0007 	rsb	r0, r0, #7
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
		}

		return uxHighestPriorityOfWaitingTasks;
	}
 80070f6:	4770      	bx	lr

080070f8 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
 80070f8:	b510      	push	{r4, lr}
 80070fa:	4604      	mov	r4, r0
BaseType_t xReturn;

	taskENTER_CRITICAL();
 80070fc:	f001 fd5a 	bl	8008bb4 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8007100:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 8007102:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8007104:	429a      	cmp	r2, r3
 8007106:	d004      	beq.n	8007112 <prvIsQueueFull+0x1a>
		{
			xReturn = pdTRUE;
		}
		else
		{
			xReturn = pdFALSE;
 8007108:	2400      	movs	r4, #0
		}
	}
	taskEXIT_CRITICAL();
 800710a:	f001 fd75 	bl	8008bf8 <vPortExitCritical>

	return xReturn;
}
 800710e:	4620      	mov	r0, r4
 8007110:	bd10      	pop	{r4, pc}
			xReturn = pdTRUE;
 8007112:	2401      	movs	r4, #1
 8007114:	e7f9      	b.n	800710a <prvIsQueueFull+0x12>

08007116 <prvIsQueueEmpty>:
{
 8007116:	b510      	push	{r4, lr}
 8007118:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 800711a:	f001 fd4b 	bl	8008bb4 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 800711e:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8007120:	b923      	cbnz	r3, 800712c <prvIsQueueEmpty+0x16>
			xReturn = pdTRUE;
 8007122:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
 8007124:	f001 fd68 	bl	8008bf8 <vPortExitCritical>
}
 8007128:	4620      	mov	r0, r4
 800712a:	bd10      	pop	{r4, pc}
			xReturn = pdFALSE;
 800712c:	2400      	movs	r4, #0
 800712e:	e7f9      	b.n	8007124 <prvIsQueueEmpty+0xe>

08007130 <prvCopyDataToQueue>:
{
 8007130:	b570      	push	{r4, r5, r6, lr}
 8007132:	4604      	mov	r4, r0
 8007134:	4615      	mov	r5, r2
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8007136:	6b86      	ldr	r6, [r0, #56]	@ 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8007138:	6c02      	ldr	r2, [r0, #64]	@ 0x40
 800713a:	b95a      	cbnz	r2, 8007154 <prvCopyDataToQueue+0x24>
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800713c:	6803      	ldr	r3, [r0, #0]
 800713e:	b11b      	cbz	r3, 8007148 <prvCopyDataToQueue+0x18>
BaseType_t xReturn = pdFALSE;
 8007140:	2000      	movs	r0, #0
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8007142:	3601      	adds	r6, #1
 8007144:	63a6      	str	r6, [r4, #56]	@ 0x38
}
 8007146:	bd70      	pop	{r4, r5, r6, pc}
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 8007148:	6880      	ldr	r0, [r0, #8]
 800714a:	f001 fbaf 	bl	80088ac <xTaskPriorityDisinherit>
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
 800714e:	2300      	movs	r3, #0
 8007150:	60a3      	str	r3, [r4, #8]
 8007152:	e7f6      	b.n	8007142 <prvCopyDataToQueue+0x12>
	else if( xPosition == queueSEND_TO_BACK )
 8007154:	b96d      	cbnz	r5, 8007172 <prvCopyDataToQueue+0x42>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 8007156:	6840      	ldr	r0, [r0, #4]
 8007158:	f00d f953 	bl	8014402 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 800715c:	6863      	ldr	r3, [r4, #4]
 800715e:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 8007160:	4413      	add	r3, r2
 8007162:	6063      	str	r3, [r4, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8007164:	68a2      	ldr	r2, [r4, #8]
 8007166:	4293      	cmp	r3, r2
 8007168:	d319      	bcc.n	800719e <prvCopyDataToQueue+0x6e>
			pxQueue->pcWriteTo = pxQueue->pcHead;
 800716a:	6823      	ldr	r3, [r4, #0]
 800716c:	6063      	str	r3, [r4, #4]
BaseType_t xReturn = pdFALSE;
 800716e:	4628      	mov	r0, r5
 8007170:	e7e7      	b.n	8007142 <prvCopyDataToQueue+0x12>
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 8007172:	68c0      	ldr	r0, [r0, #12]
 8007174:	f00d f945 	bl	8014402 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 8007178:	68e3      	ldr	r3, [r4, #12]
 800717a:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 800717c:	4251      	negs	r1, r2
 800717e:	1a9b      	subs	r3, r3, r2
 8007180:	60e3      	str	r3, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8007182:	6822      	ldr	r2, [r4, #0]
 8007184:	4293      	cmp	r3, r2
 8007186:	d202      	bcs.n	800718e <prvCopyDataToQueue+0x5e>
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 8007188:	68a3      	ldr	r3, [r4, #8]
 800718a:	440b      	add	r3, r1
 800718c:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
 800718e:	2d02      	cmp	r5, #2
 8007190:	d001      	beq.n	8007196 <prvCopyDataToQueue+0x66>
BaseType_t xReturn = pdFALSE;
 8007192:	2000      	movs	r0, #0
 8007194:	e7d5      	b.n	8007142 <prvCopyDataToQueue+0x12>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8007196:	b126      	cbz	r6, 80071a2 <prvCopyDataToQueue+0x72>
				--uxMessagesWaiting;
 8007198:	3e01      	subs	r6, #1
BaseType_t xReturn = pdFALSE;
 800719a:	2000      	movs	r0, #0
 800719c:	e7d1      	b.n	8007142 <prvCopyDataToQueue+0x12>
 800719e:	4628      	mov	r0, r5
 80071a0:	e7cf      	b.n	8007142 <prvCopyDataToQueue+0x12>
 80071a2:	2000      	movs	r0, #0
 80071a4:	e7cd      	b.n	8007142 <prvCopyDataToQueue+0x12>

080071a6 <prvCopyDataFromQueue>:
{
 80071a6:	4603      	mov	r3, r0
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 80071a8:	6c02      	ldr	r2, [r0, #64]	@ 0x40
 80071aa:	b16a      	cbz	r2, 80071c8 <prvCopyDataFromQueue+0x22>
{
 80071ac:	b510      	push	{r4, lr}
 80071ae:	4608      	mov	r0, r1
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 80071b0:	68d9      	ldr	r1, [r3, #12]
 80071b2:	4411      	add	r1, r2
 80071b4:	60d9      	str	r1, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 80071b6:	689c      	ldr	r4, [r3, #8]
 80071b8:	42a1      	cmp	r1, r4
 80071ba:	d301      	bcc.n	80071c0 <prvCopyDataFromQueue+0x1a>
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 80071bc:	6819      	ldr	r1, [r3, #0]
 80071be:	60d9      	str	r1, [r3, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 80071c0:	68d9      	ldr	r1, [r3, #12]
 80071c2:	f00d f91e 	bl	8014402 <memcpy>
}
 80071c6:	bd10      	pop	{r4, pc}
 80071c8:	4770      	bx	lr

080071ca <prvUnlockQueue>:
{
 80071ca:	b538      	push	{r3, r4, r5, lr}
 80071cc:	4605      	mov	r5, r0
	taskENTER_CRITICAL();
 80071ce:	f001 fcf1 	bl	8008bb4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 80071d2:	f895 4045 	ldrb.w	r4, [r5, #69]	@ 0x45
 80071d6:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
 80071d8:	e001      	b.n	80071de <prvUnlockQueue+0x14>
			--cTxLock;
 80071da:	3c01      	subs	r4, #1
 80071dc:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
 80071de:	2c00      	cmp	r4, #0
 80071e0:	dd0a      	ble.n	80071f8 <prvUnlockQueue+0x2e>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80071e2:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
 80071e4:	b143      	cbz	r3, 80071f8 <prvUnlockQueue+0x2e>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80071e6:	f105 0024 	add.w	r0, r5, #36	@ 0x24
 80071ea:	f001 f99b 	bl	8008524 <xTaskRemoveFromEventList>
 80071ee:	2800      	cmp	r0, #0
 80071f0:	d0f3      	beq.n	80071da <prvUnlockQueue+0x10>
						vTaskMissedYield();
 80071f2:	f001 fa2b 	bl	800864c <vTaskMissedYield>
 80071f6:	e7f0      	b.n	80071da <prvUnlockQueue+0x10>
		pxQueue->cTxLock = queueUNLOCKED;
 80071f8:	23ff      	movs	r3, #255	@ 0xff
 80071fa:	f885 3045 	strb.w	r3, [r5, #69]	@ 0x45
	taskEXIT_CRITICAL();
 80071fe:	f001 fcfb 	bl	8008bf8 <vPortExitCritical>
	taskENTER_CRITICAL();
 8007202:	f001 fcd7 	bl	8008bb4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8007206:	f895 4044 	ldrb.w	r4, [r5, #68]	@ 0x44
 800720a:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800720c:	e001      	b.n	8007212 <prvUnlockQueue+0x48>
				--cRxLock;
 800720e:	3c01      	subs	r4, #1
 8007210:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8007212:	2c00      	cmp	r4, #0
 8007214:	dd0a      	ble.n	800722c <prvUnlockQueue+0x62>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8007216:	692b      	ldr	r3, [r5, #16]
 8007218:	b143      	cbz	r3, 800722c <prvUnlockQueue+0x62>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800721a:	f105 0010 	add.w	r0, r5, #16
 800721e:	f001 f981 	bl	8008524 <xTaskRemoveFromEventList>
 8007222:	2800      	cmp	r0, #0
 8007224:	d0f3      	beq.n	800720e <prvUnlockQueue+0x44>
					vTaskMissedYield();
 8007226:	f001 fa11 	bl	800864c <vTaskMissedYield>
 800722a:	e7f0      	b.n	800720e <prvUnlockQueue+0x44>
		pxQueue->cRxLock = queueUNLOCKED;
 800722c:	23ff      	movs	r3, #255	@ 0xff
 800722e:	f885 3044 	strb.w	r3, [r5, #68]	@ 0x44
	taskEXIT_CRITICAL();
 8007232:	f001 fce1 	bl	8008bf8 <vPortExitCritical>
}
 8007236:	bd38      	pop	{r3, r4, r5, pc}

08007238 <xQueueGenericReset>:
{
 8007238:	b538      	push	{r3, r4, r5, lr}
	configASSERT( pxQueue );
 800723a:	b1e0      	cbz	r0, 8007276 <xQueueGenericReset+0x3e>
 800723c:	460d      	mov	r5, r1
 800723e:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 8007240:	f001 fcb8 	bl	8008bb4 <vPortEnterCritical>
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8007244:	6823      	ldr	r3, [r4, #0]
 8007246:	6be2      	ldr	r2, [r4, #60]	@ 0x3c
 8007248:	6c21      	ldr	r1, [r4, #64]	@ 0x40
 800724a:	fb01 3002 	mla	r0, r1, r2, r3
 800724e:	60a0      	str	r0, [r4, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8007250:	2000      	movs	r0, #0
 8007252:	63a0      	str	r0, [r4, #56]	@ 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8007254:	6063      	str	r3, [r4, #4]
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8007256:	3a01      	subs	r2, #1
 8007258:	fb02 3301 	mla	r3, r2, r1, r3
 800725c:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 800725e:	23ff      	movs	r3, #255	@ 0xff
 8007260:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 8007264:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
		if( xNewQueue == pdFALSE )
 8007268:	b9fd      	cbnz	r5, 80072aa <xQueueGenericReset+0x72>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800726a:	6923      	ldr	r3, [r4, #16]
 800726c:	b963      	cbnz	r3, 8007288 <xQueueGenericReset+0x50>
	taskEXIT_CRITICAL();
 800726e:	f001 fcc3 	bl	8008bf8 <vPortExitCritical>
}
 8007272:	2001      	movs	r0, #1
 8007274:	bd38      	pop	{r3, r4, r5, pc}

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8007276:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800727a:	f383 8811 	msr	BASEPRI, r3
 800727e:	f3bf 8f6f 	isb	sy
 8007282:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 8007286:	e7fe      	b.n	8007286 <xQueueGenericReset+0x4e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8007288:	f104 0010 	add.w	r0, r4, #16
 800728c:	f001 f94a 	bl	8008524 <xTaskRemoveFromEventList>
 8007290:	2800      	cmp	r0, #0
 8007292:	d0ec      	beq.n	800726e <xQueueGenericReset+0x36>
					queueYIELD_IF_USING_PREEMPTION();
 8007294:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8007298:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800729c:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 80072a0:	f3bf 8f4f 	dsb	sy
 80072a4:	f3bf 8f6f 	isb	sy
 80072a8:	e7e1      	b.n	800726e <xQueueGenericReset+0x36>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 80072aa:	f104 0010 	add.w	r0, r4, #16
 80072ae:	f7ff fed6 	bl	800705e <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 80072b2:	f104 0024 	add.w	r0, r4, #36	@ 0x24
 80072b6:	f7ff fed2 	bl	800705e <vListInitialise>
 80072ba:	e7d8      	b.n	800726e <xQueueGenericReset+0x36>

080072bc <prvInitialiseNewQueue>:
{
 80072bc:	b538      	push	{r3, r4, r5, lr}
 80072be:	461d      	mov	r5, r3
 80072c0:	9c04      	ldr	r4, [sp, #16]
	if( uxItemSize == ( UBaseType_t ) 0 )
 80072c2:	460b      	mov	r3, r1
 80072c4:	b949      	cbnz	r1, 80072da <prvInitialiseNewQueue+0x1e>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 80072c6:	6024      	str	r4, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
 80072c8:	63e0      	str	r0, [r4, #60]	@ 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 80072ca:	6423      	str	r3, [r4, #64]	@ 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 80072cc:	2101      	movs	r1, #1
 80072ce:	4620      	mov	r0, r4
 80072d0:	f7ff ffb2 	bl	8007238 <xQueueGenericReset>
		pxNewQueue->ucQueueType = ucQueueType;
 80072d4:	f884 504c 	strb.w	r5, [r4, #76]	@ 0x4c
}
 80072d8:	bd38      	pop	{r3, r4, r5, pc}
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 80072da:	6022      	str	r2, [r4, #0]
 80072dc:	e7f4      	b.n	80072c8 <prvInitialiseNewQueue+0xc>

080072de <xQueueGenericCreateStatic>:
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 80072de:	b940      	cbnz	r0, 80072f2 <xQueueGenericCreateStatic+0x14>
 80072e0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80072e4:	f383 8811 	msr	BASEPRI, r3
 80072e8:	f3bf 8f6f 	isb	sy
 80072ec:	f3bf 8f4f 	dsb	sy
 80072f0:	e7fe      	b.n	80072f0 <xQueueGenericCreateStatic+0x12>
	{
 80072f2:	b510      	push	{r4, lr}
 80072f4:	b084      	sub	sp, #16
 80072f6:	461c      	mov	r4, r3
		configASSERT( pxStaticQueue != NULL );
 80072f8:	b183      	cbz	r3, 800731c <xQueueGenericCreateStatic+0x3e>
		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 80072fa:	1e0b      	subs	r3, r1, #0
 80072fc:	bf18      	it	ne
 80072fe:	2301      	movne	r3, #1
 8007300:	2a00      	cmp	r2, #0
 8007302:	bf08      	it	eq
 8007304:	f043 0301 	orreq.w	r3, r3, #1
 8007308:	b98b      	cbnz	r3, 800732e <xQueueGenericCreateStatic+0x50>
 800730a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800730e:	f383 8811 	msr	BASEPRI, r3
 8007312:	f3bf 8f6f 	isb	sy
 8007316:	f3bf 8f4f 	dsb	sy
 800731a:	e7fe      	b.n	800731a <xQueueGenericCreateStatic+0x3c>
 800731c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007320:	f383 8811 	msr	BASEPRI, r3
 8007324:	f3bf 8f6f 	isb	sy
 8007328:	f3bf 8f4f 	dsb	sy
		configASSERT( pxStaticQueue != NULL );
 800732c:	e7fe      	b.n	800732c <xQueueGenericCreateStatic+0x4e>
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 800732e:	fab1 f381 	clz	r3, r1
 8007332:	095b      	lsrs	r3, r3, #5
 8007334:	2a00      	cmp	r2, #0
 8007336:	bf18      	it	ne
 8007338:	f043 0301 	orrne.w	r3, r3, #1
 800733c:	b943      	cbnz	r3, 8007350 <xQueueGenericCreateStatic+0x72>
 800733e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007342:	f383 8811 	msr	BASEPRI, r3
 8007346:	f3bf 8f6f 	isb	sy
 800734a:	f3bf 8f4f 	dsb	sy
 800734e:	e7fe      	b.n	800734e <xQueueGenericCreateStatic+0x70>
			volatile size_t xSize = sizeof( StaticQueue_t );
 8007350:	2350      	movs	r3, #80	@ 0x50
 8007352:	9303      	str	r3, [sp, #12]
			configASSERT( xSize == sizeof( Queue_t ) );
 8007354:	9b03      	ldr	r3, [sp, #12]
 8007356:	2b50      	cmp	r3, #80	@ 0x50
 8007358:	d008      	beq.n	800736c <xQueueGenericCreateStatic+0x8e>
 800735a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800735e:	f383 8811 	msr	BASEPRI, r3
 8007362:	f3bf 8f6f 	isb	sy
 8007366:	f3bf 8f4f 	dsb	sy
 800736a:	e7fe      	b.n	800736a <xQueueGenericCreateStatic+0x8c>
			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 800736c:	9b03      	ldr	r3, [sp, #12]
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 800736e:	2301      	movs	r3, #1
 8007370:	f884 3046 	strb.w	r3, [r4, #70]	@ 0x46
			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 8007374:	9400      	str	r4, [sp, #0]
 8007376:	f89d 3018 	ldrb.w	r3, [sp, #24]
 800737a:	f7ff ff9f 	bl	80072bc <prvInitialiseNewQueue>
	}
 800737e:	4620      	mov	r0, r4
 8007380:	b004      	add	sp, #16
 8007382:	bd10      	pop	{r4, pc}

08007384 <xQueueGenericCreate>:
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8007384:	b940      	cbnz	r0, 8007398 <xQueueGenericCreate+0x14>
 8007386:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800738a:	f383 8811 	msr	BASEPRI, r3
 800738e:	f3bf 8f6f 	isb	sy
 8007392:	f3bf 8f4f 	dsb	sy
 8007396:	e7fe      	b.n	8007396 <xQueueGenericCreate+0x12>
	{
 8007398:	b5f0      	push	{r4, r5, r6, r7, lr}
 800739a:	b083      	sub	sp, #12
 800739c:	460d      	mov	r5, r1
 800739e:	4614      	mov	r4, r2
 80073a0:	4606      	mov	r6, r0
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80073a2:	fb01 f000 	mul.w	r0, r1, r0
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 80073a6:	3050      	adds	r0, #80	@ 0x50
 80073a8:	f001 fdbc 	bl	8008f24 <pvPortMalloc>
		if( pxNewQueue != NULL )
 80073ac:	4607      	mov	r7, r0
 80073ae:	b150      	cbz	r0, 80073c6 <xQueueGenericCreate+0x42>
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 80073b0:	2300      	movs	r3, #0
 80073b2:	f880 3046 	strb.w	r3, [r0, #70]	@ 0x46
			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 80073b6:	9000      	str	r0, [sp, #0]
 80073b8:	4623      	mov	r3, r4
 80073ba:	f100 0250 	add.w	r2, r0, #80	@ 0x50
 80073be:	4629      	mov	r1, r5
 80073c0:	4630      	mov	r0, r6
 80073c2:	f7ff ff7b 	bl	80072bc <prvInitialiseNewQueue>
	}
 80073c6:	4638      	mov	r0, r7
 80073c8:	b003      	add	sp, #12
 80073ca:	bdf0      	pop	{r4, r5, r6, r7, pc}

080073cc <xQueueCreateCountingSemaphoreStatic>:
		configASSERT( uxMaxCount != 0 );
 80073cc:	b940      	cbnz	r0, 80073e0 <xQueueCreateCountingSemaphoreStatic+0x14>
 80073ce:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80073d2:	f383 8811 	msr	BASEPRI, r3
 80073d6:	f3bf 8f6f 	isb	sy
 80073da:	f3bf 8f4f 	dsb	sy
 80073de:	e7fe      	b.n	80073de <xQueueCreateCountingSemaphoreStatic+0x12>
	{
 80073e0:	b510      	push	{r4, lr}
 80073e2:	b082      	sub	sp, #8
 80073e4:	460c      	mov	r4, r1
		configASSERT( uxInitialCount <= uxMaxCount );
 80073e6:	4288      	cmp	r0, r1
 80073e8:	d208      	bcs.n	80073fc <xQueueCreateCountingSemaphoreStatic+0x30>
 80073ea:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80073ee:	f383 8811 	msr	BASEPRI, r3
 80073f2:	f3bf 8f6f 	isb	sy
 80073f6:	f3bf 8f4f 	dsb	sy
 80073fa:	e7fe      	b.n	80073fa <xQueueCreateCountingSemaphoreStatic+0x2e>
		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 80073fc:	2302      	movs	r3, #2
 80073fe:	9300      	str	r3, [sp, #0]
 8007400:	4613      	mov	r3, r2
 8007402:	2200      	movs	r2, #0
 8007404:	4611      	mov	r1, r2
 8007406:	f7ff ff6a 	bl	80072de <xQueueGenericCreateStatic>
		if( xHandle != NULL )
 800740a:	b100      	cbz	r0, 800740e <xQueueCreateCountingSemaphoreStatic+0x42>
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 800740c:	6384      	str	r4, [r0, #56]	@ 0x38
	}
 800740e:	b002      	add	sp, #8
 8007410:	bd10      	pop	{r4, pc}

08007412 <xQueueCreateCountingSemaphore>:
		configASSERT( uxMaxCount != 0 );
 8007412:	b940      	cbnz	r0, 8007426 <xQueueCreateCountingSemaphore+0x14>
 8007414:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007418:	f383 8811 	msr	BASEPRI, r3
 800741c:	f3bf 8f6f 	isb	sy
 8007420:	f3bf 8f4f 	dsb	sy
 8007424:	e7fe      	b.n	8007424 <xQueueCreateCountingSemaphore+0x12>
	{
 8007426:	b510      	push	{r4, lr}
 8007428:	460c      	mov	r4, r1
		configASSERT( uxInitialCount <= uxMaxCount );
 800742a:	4288      	cmp	r0, r1
 800742c:	d208      	bcs.n	8007440 <xQueueCreateCountingSemaphore+0x2e>
 800742e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007432:	f383 8811 	msr	BASEPRI, r3
 8007436:	f3bf 8f6f 	isb	sy
 800743a:	f3bf 8f4f 	dsb	sy
 800743e:	e7fe      	b.n	800743e <xQueueCreateCountingSemaphore+0x2c>
		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 8007440:	2202      	movs	r2, #2
 8007442:	2100      	movs	r1, #0
 8007444:	f7ff ff9e 	bl	8007384 <xQueueGenericCreate>
		if( xHandle != NULL )
 8007448:	b100      	cbz	r0, 800744c <xQueueCreateCountingSemaphore+0x3a>
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 800744a:	6384      	str	r4, [r0, #56]	@ 0x38
	}
 800744c:	bd10      	pop	{r4, pc}

0800744e <xQueueGenericSend>:
{
 800744e:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007450:	b085      	sub	sp, #20
 8007452:	9201      	str	r2, [sp, #4]
	configASSERT( pxQueue );
 8007454:	b188      	cbz	r0, 800747a <xQueueGenericSend+0x2c>
 8007456:	460f      	mov	r7, r1
 8007458:	461d      	mov	r5, r3
 800745a:	4604      	mov	r4, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800745c:	b1b1      	cbz	r1, 800748c <xQueueGenericSend+0x3e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800745e:	2d02      	cmp	r5, #2
 8007460:	d120      	bne.n	80074a4 <xQueueGenericSend+0x56>
 8007462:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8007464:	2b01      	cmp	r3, #1
 8007466:	d01d      	beq.n	80074a4 <xQueueGenericSend+0x56>
 8007468:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800746c:	f383 8811 	msr	BASEPRI, r3
 8007470:	f3bf 8f6f 	isb	sy
 8007474:	f3bf 8f4f 	dsb	sy
 8007478:	e7fe      	b.n	8007478 <xQueueGenericSend+0x2a>
 800747a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800747e:	f383 8811 	msr	BASEPRI, r3
 8007482:	f3bf 8f6f 	isb	sy
 8007486:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 800748a:	e7fe      	b.n	800748a <xQueueGenericSend+0x3c>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800748c:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 800748e:	2b00      	cmp	r3, #0
 8007490:	d0e5      	beq.n	800745e <xQueueGenericSend+0x10>
 8007492:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007496:	f383 8811 	msr	BASEPRI, r3
 800749a:	f3bf 8f6f 	isb	sy
 800749e:	f3bf 8f4f 	dsb	sy
 80074a2:	e7fe      	b.n	80074a2 <xQueueGenericSend+0x54>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80074a4:	f001 f99c 	bl	80087e0 <xTaskGetSchedulerState>
 80074a8:	4606      	mov	r6, r0
 80074aa:	b958      	cbnz	r0, 80074c4 <xQueueGenericSend+0x76>
 80074ac:	9b01      	ldr	r3, [sp, #4]
 80074ae:	2b00      	cmp	r3, #0
 80074b0:	d048      	beq.n	8007544 <xQueueGenericSend+0xf6>
 80074b2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80074b6:	f383 8811 	msr	BASEPRI, r3
 80074ba:	f3bf 8f6f 	isb	sy
 80074be:	f3bf 8f4f 	dsb	sy
 80074c2:	e7fe      	b.n	80074c2 <xQueueGenericSend+0x74>
 80074c4:	2600      	movs	r6, #0
 80074c6:	e03d      	b.n	8007544 <xQueueGenericSend+0xf6>
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80074c8:	462a      	mov	r2, r5
 80074ca:	4639      	mov	r1, r7
 80074cc:	4620      	mov	r0, r4
 80074ce:	f7ff fe2f 	bl	8007130 <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80074d2:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 80074d4:	b97b      	cbnz	r3, 80074f6 <xQueueGenericSend+0xa8>
					else if( xYieldRequired != pdFALSE )
 80074d6:	b148      	cbz	r0, 80074ec <xQueueGenericSend+0x9e>
						queueYIELD_IF_USING_PREEMPTION();
 80074d8:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 80074dc:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80074e0:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 80074e4:	f3bf 8f4f 	dsb	sy
 80074e8:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 80074ec:	f001 fb84 	bl	8008bf8 <vPortExitCritical>
				return pdPASS;
 80074f0:	2001      	movs	r0, #1
}
 80074f2:	b005      	add	sp, #20
 80074f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80074f6:	f104 0024 	add.w	r0, r4, #36	@ 0x24
 80074fa:	f001 f813 	bl	8008524 <xTaskRemoveFromEventList>
 80074fe:	2800      	cmp	r0, #0
 8007500:	d0f4      	beq.n	80074ec <xQueueGenericSend+0x9e>
							queueYIELD_IF_USING_PREEMPTION();
 8007502:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8007506:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800750a:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 800750e:	f3bf 8f4f 	dsb	sy
 8007512:	f3bf 8f6f 	isb	sy
 8007516:	e7e9      	b.n	80074ec <xQueueGenericSend+0x9e>
					taskEXIT_CRITICAL();
 8007518:	f001 fb6e 	bl	8008bf8 <vPortExitCritical>
					return errQUEUE_FULL;
 800751c:	2000      	movs	r0, #0
 800751e:	e7e8      	b.n	80074f2 <xQueueGenericSend+0xa4>
					vTaskInternalSetTimeOutState( &xTimeOut );
 8007520:	a802      	add	r0, sp, #8
 8007522:	f001 f845 	bl	80085b0 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 8007526:	2601      	movs	r6, #1
 8007528:	e019      	b.n	800755e <xQueueGenericSend+0x110>
		prvLockQueue( pxQueue );
 800752a:	2300      	movs	r3, #0
 800752c:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
 8007530:	e021      	b.n	8007576 <xQueueGenericSend+0x128>
 8007532:	2300      	movs	r3, #0
 8007534:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
 8007538:	e023      	b.n	8007582 <xQueueGenericSend+0x134>
				prvUnlockQueue( pxQueue );
 800753a:	4620      	mov	r0, r4
 800753c:	f7ff fe45 	bl	80071ca <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8007540:	f000 ff06 	bl	8008350 <xTaskResumeAll>
		taskENTER_CRITICAL();
 8007544:	f001 fb36 	bl	8008bb4 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8007548:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 800754a:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 800754c:	429a      	cmp	r2, r3
 800754e:	d3bb      	bcc.n	80074c8 <xQueueGenericSend+0x7a>
 8007550:	2d02      	cmp	r5, #2
 8007552:	d0b9      	beq.n	80074c8 <xQueueGenericSend+0x7a>
				if( xTicksToWait == ( TickType_t ) 0 )
 8007554:	9b01      	ldr	r3, [sp, #4]
 8007556:	2b00      	cmp	r3, #0
 8007558:	d0de      	beq.n	8007518 <xQueueGenericSend+0xca>
				else if( xEntryTimeSet == pdFALSE )
 800755a:	2e00      	cmp	r6, #0
 800755c:	d0e0      	beq.n	8007520 <xQueueGenericSend+0xd2>
		taskEXIT_CRITICAL();
 800755e:	f001 fb4b 	bl	8008bf8 <vPortExitCritical>
		vTaskSuspendAll();
 8007562:	f000 fe53 	bl	800820c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8007566:	f001 fb25 	bl	8008bb4 <vPortEnterCritical>
 800756a:	f894 2044 	ldrb.w	r2, [r4, #68]	@ 0x44
 800756e:	b252      	sxtb	r2, r2
 8007570:	f1b2 3fff 	cmp.w	r2, #4294967295
 8007574:	d0d9      	beq.n	800752a <xQueueGenericSend+0xdc>
 8007576:	f894 2045 	ldrb.w	r2, [r4, #69]	@ 0x45
 800757a:	b252      	sxtb	r2, r2
 800757c:	f1b2 3fff 	cmp.w	r2, #4294967295
 8007580:	d0d7      	beq.n	8007532 <xQueueGenericSend+0xe4>
 8007582:	f001 fb39 	bl	8008bf8 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8007586:	a901      	add	r1, sp, #4
 8007588:	a802      	add	r0, sp, #8
 800758a:	f001 f81d 	bl	80085c8 <xTaskCheckForTimeOut>
 800758e:	b9d8      	cbnz	r0, 80075c8 <xQueueGenericSend+0x17a>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 8007590:	4620      	mov	r0, r4
 8007592:	f7ff fdb1 	bl	80070f8 <prvIsQueueFull>
 8007596:	2800      	cmp	r0, #0
 8007598:	d0cf      	beq.n	800753a <xQueueGenericSend+0xec>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 800759a:	9901      	ldr	r1, [sp, #4]
 800759c:	f104 0010 	add.w	r0, r4, #16
 80075a0:	f000 ffa8 	bl	80084f4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 80075a4:	4620      	mov	r0, r4
 80075a6:	f7ff fe10 	bl	80071ca <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 80075aa:	f000 fed1 	bl	8008350 <xTaskResumeAll>
 80075ae:	2800      	cmp	r0, #0
 80075b0:	d1c8      	bne.n	8007544 <xQueueGenericSend+0xf6>
					portYIELD_WITHIN_API();
 80075b2:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 80075b6:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80075ba:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 80075be:	f3bf 8f4f 	dsb	sy
 80075c2:	f3bf 8f6f 	isb	sy
 80075c6:	e7bd      	b.n	8007544 <xQueueGenericSend+0xf6>
			prvUnlockQueue( pxQueue );
 80075c8:	4620      	mov	r0, r4
 80075ca:	f7ff fdfe 	bl	80071ca <prvUnlockQueue>
			( void ) xTaskResumeAll();
 80075ce:	f000 febf 	bl	8008350 <xTaskResumeAll>
			return errQUEUE_FULL;
 80075d2:	2000      	movs	r0, #0
 80075d4:	e78d      	b.n	80074f2 <xQueueGenericSend+0xa4>

080075d6 <prvInitialiseMutex>:
		if( pxNewQueue != NULL )
 80075d6:	b148      	cbz	r0, 80075ec <prvInitialiseMutex+0x16>
	{
 80075d8:	b508      	push	{r3, lr}
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 80075da:	2100      	movs	r1, #0
 80075dc:	6081      	str	r1, [r0, #8]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 80075de:	6001      	str	r1, [r0, #0]
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 80075e0:	60c1      	str	r1, [r0, #12]
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 80075e2:	460b      	mov	r3, r1
 80075e4:	460a      	mov	r2, r1
 80075e6:	f7ff ff32 	bl	800744e <xQueueGenericSend>
	}
 80075ea:	bd08      	pop	{r3, pc}
 80075ec:	4770      	bx	lr

080075ee <xQueueCreateMutex>:
	{
 80075ee:	b510      	push	{r4, lr}
 80075f0:	4602      	mov	r2, r0
		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 80075f2:	2100      	movs	r1, #0
 80075f4:	2001      	movs	r0, #1
 80075f6:	f7ff fec5 	bl	8007384 <xQueueGenericCreate>
 80075fa:	4604      	mov	r4, r0
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 80075fc:	f7ff ffeb 	bl	80075d6 <prvInitialiseMutex>
	}
 8007600:	4620      	mov	r0, r4
 8007602:	bd10      	pop	{r4, pc}

08007604 <xQueueCreateMutexStatic>:
	{
 8007604:	b510      	push	{r4, lr}
 8007606:	b082      	sub	sp, #8
 8007608:	460b      	mov	r3, r1
		xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
 800760a:	9000      	str	r0, [sp, #0]
 800760c:	2200      	movs	r2, #0
 800760e:	4611      	mov	r1, r2
 8007610:	2001      	movs	r0, #1
 8007612:	f7ff fe64 	bl	80072de <xQueueGenericCreateStatic>
 8007616:	4604      	mov	r4, r0
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 8007618:	f7ff ffdd 	bl	80075d6 <prvInitialiseMutex>
	}
 800761c:	4620      	mov	r0, r4
 800761e:	b002      	add	sp, #8
 8007620:	bd10      	pop	{r4, pc}

08007622 <xQueueGenericSendFromISR>:
{
 8007622:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( pxQueue );
 8007626:	b190      	cbz	r0, 800764e <xQueueGenericSendFromISR+0x2c>
 8007628:	460f      	mov	r7, r1
 800762a:	4616      	mov	r6, r2
 800762c:	461c      	mov	r4, r3
 800762e:	4605      	mov	r5, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8007630:	b1b1      	cbz	r1, 8007660 <xQueueGenericSendFromISR+0x3e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8007632:	2c02      	cmp	r4, #2
 8007634:	d120      	bne.n	8007678 <xQueueGenericSendFromISR+0x56>
 8007636:	6beb      	ldr	r3, [r5, #60]	@ 0x3c
 8007638:	2b01      	cmp	r3, #1
 800763a:	d01d      	beq.n	8007678 <xQueueGenericSendFromISR+0x56>
 800763c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007640:	f383 8811 	msr	BASEPRI, r3
 8007644:	f3bf 8f6f 	isb	sy
 8007648:	f3bf 8f4f 	dsb	sy
 800764c:	e7fe      	b.n	800764c <xQueueGenericSendFromISR+0x2a>
 800764e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007652:	f383 8811 	msr	BASEPRI, r3
 8007656:	f3bf 8f6f 	isb	sy
 800765a:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 800765e:	e7fe      	b.n	800765e <xQueueGenericSendFromISR+0x3c>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8007660:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 8007662:	2b00      	cmp	r3, #0
 8007664:	d0e5      	beq.n	8007632 <xQueueGenericSendFromISR+0x10>
 8007666:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800766a:	f383 8811 	msr	BASEPRI, r3
 800766e:	f3bf 8f6f 	isb	sy
 8007672:	f3bf 8f4f 	dsb	sy
 8007676:	e7fe      	b.n	8007676 <xQueueGenericSendFromISR+0x54>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8007678:	f001 fbc2 	bl	8008e00 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
 800767c:	f3ef 8811 	mrs	r8, BASEPRI
 8007680:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007684:	f383 8811 	msr	BASEPRI, r3
 8007688:	f3bf 8f6f 	isb	sy
 800768c:	f3bf 8f4f 	dsb	sy
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8007690:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 8007692:	6beb      	ldr	r3, [r5, #60]	@ 0x3c
 8007694:	429a      	cmp	r2, r3
 8007696:	d306      	bcc.n	80076a6 <xQueueGenericSendFromISR+0x84>
 8007698:	2c02      	cmp	r4, #2
 800769a:	d004      	beq.n	80076a6 <xQueueGenericSendFromISR+0x84>
			xReturn = errQUEUE_FULL;
 800769c:	2000      	movs	r0, #0
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 800769e:	f388 8811 	msr	BASEPRI, r8
}
 80076a2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			const int8_t cTxLock = pxQueue->cTxLock;
 80076a6:	f895 9045 	ldrb.w	r9, [r5, #69]	@ 0x45
 80076aa:	fa4f f989 	sxtb.w	r9, r9
			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 80076ae:	6bab      	ldr	r3, [r5, #56]	@ 0x38
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80076b0:	4622      	mov	r2, r4
 80076b2:	4639      	mov	r1, r7
 80076b4:	4628      	mov	r0, r5
 80076b6:	f7ff fd3b 	bl	8007130 <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
 80076ba:	f1b9 3fff 	cmp.w	r9, #4294967295
 80076be:	d006      	beq.n	80076ce <xQueueGenericSendFromISR+0xac>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 80076c0:	f109 0301 	add.w	r3, r9, #1
 80076c4:	b25b      	sxtb	r3, r3
 80076c6:	f885 3045 	strb.w	r3, [r5, #69]	@ 0x45
			xReturn = pdPASS;
 80076ca:	2001      	movs	r0, #1
 80076cc:	e7e7      	b.n	800769e <xQueueGenericSendFromISR+0x7c>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80076ce:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
 80076d0:	b90b      	cbnz	r3, 80076d6 <xQueueGenericSendFromISR+0xb4>
			xReturn = pdPASS;
 80076d2:	2001      	movs	r0, #1
 80076d4:	e7e3      	b.n	800769e <xQueueGenericSendFromISR+0x7c>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80076d6:	f105 0024 	add.w	r0, r5, #36	@ 0x24
 80076da:	f000 ff23 	bl	8008524 <xTaskRemoveFromEventList>
 80076de:	b118      	cbz	r0, 80076e8 <xQueueGenericSendFromISR+0xc6>
							if( pxHigherPriorityTaskWoken != NULL )
 80076e0:	b126      	cbz	r6, 80076ec <xQueueGenericSendFromISR+0xca>
								*pxHigherPriorityTaskWoken = pdTRUE;
 80076e2:	2001      	movs	r0, #1
 80076e4:	6030      	str	r0, [r6, #0]
 80076e6:	e7da      	b.n	800769e <xQueueGenericSendFromISR+0x7c>
			xReturn = pdPASS;
 80076e8:	2001      	movs	r0, #1
 80076ea:	e7d8      	b.n	800769e <xQueueGenericSendFromISR+0x7c>
 80076ec:	2001      	movs	r0, #1
 80076ee:	e7d6      	b.n	800769e <xQueueGenericSendFromISR+0x7c>

080076f0 <xQueueGiveFromISR>:
	configASSERT( pxQueue );
 80076f0:	b168      	cbz	r0, 800770e <xQueueGiveFromISR+0x1e>
{
 80076f2:	b570      	push	{r4, r5, r6, lr}
 80076f4:	460c      	mov	r4, r1
 80076f6:	4605      	mov	r5, r0
	configASSERT( pxQueue->uxItemSize == 0 );
 80076f8:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 80076fa:	b18b      	cbz	r3, 8007720 <xQueueGiveFromISR+0x30>
	__asm volatile
 80076fc:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007700:	f383 8811 	msr	BASEPRI, r3
 8007704:	f3bf 8f6f 	isb	sy
 8007708:	f3bf 8f4f 	dsb	sy
 800770c:	e7fe      	b.n	800770c <xQueueGiveFromISR+0x1c>
 800770e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007712:	f383 8811 	msr	BASEPRI, r3
 8007716:	f3bf 8f6f 	isb	sy
 800771a:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 800771e:	e7fe      	b.n	800771e <xQueueGiveFromISR+0x2e>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
 8007720:	6803      	ldr	r3, [r0, #0]
 8007722:	b1eb      	cbz	r3, 8007760 <xQueueGiveFromISR+0x70>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8007724:	f001 fb6c 	bl	8008e00 <vPortValidateInterruptPriority>
	__asm volatile
 8007728:	f3ef 8611 	mrs	r6, BASEPRI
 800772c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007730:	f383 8811 	msr	BASEPRI, r3
 8007734:	f3bf 8f6f 	isb	sy
 8007738:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800773c:	6baa      	ldr	r2, [r5, #56]	@ 0x38
		if( uxMessagesWaiting < pxQueue->uxLength )
 800773e:	6beb      	ldr	r3, [r5, #60]	@ 0x3c
 8007740:	4293      	cmp	r3, r2
 8007742:	d926      	bls.n	8007792 <xQueueGiveFromISR+0xa2>
			const int8_t cTxLock = pxQueue->cTxLock;
 8007744:	f895 3045 	ldrb.w	r3, [r5, #69]	@ 0x45
 8007748:	b25b      	sxtb	r3, r3
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 800774a:	3201      	adds	r2, #1
 800774c:	63aa      	str	r2, [r5, #56]	@ 0x38
			if( cTxLock == queueUNLOCKED )
 800774e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007752:	d011      	beq.n	8007778 <xQueueGiveFromISR+0x88>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8007754:	3301      	adds	r3, #1
 8007756:	b25b      	sxtb	r3, r3
 8007758:	f885 3045 	strb.w	r3, [r5, #69]	@ 0x45
			xReturn = pdPASS;
 800775c:	2001      	movs	r0, #1
 800775e:	e019      	b.n	8007794 <xQueueGiveFromISR+0xa4>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
 8007760:	6883      	ldr	r3, [r0, #8]
 8007762:	2b00      	cmp	r3, #0
 8007764:	d0de      	beq.n	8007724 <xQueueGiveFromISR+0x34>
	__asm volatile
 8007766:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800776a:	f383 8811 	msr	BASEPRI, r3
 800776e:	f3bf 8f6f 	isb	sy
 8007772:	f3bf 8f4f 	dsb	sy
 8007776:	e7fe      	b.n	8007776 <xQueueGiveFromISR+0x86>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8007778:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
 800777a:	b90b      	cbnz	r3, 8007780 <xQueueGiveFromISR+0x90>
			xReturn = pdPASS;
 800777c:	2001      	movs	r0, #1
 800777e:	e009      	b.n	8007794 <xQueueGiveFromISR+0xa4>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8007780:	f105 0024 	add.w	r0, r5, #36	@ 0x24
 8007784:	f000 fece 	bl	8008524 <xTaskRemoveFromEventList>
 8007788:	b138      	cbz	r0, 800779a <xQueueGiveFromISR+0xaa>
							if( pxHigherPriorityTaskWoken != NULL )
 800778a:	b144      	cbz	r4, 800779e <xQueueGiveFromISR+0xae>
								*pxHigherPriorityTaskWoken = pdTRUE;
 800778c:	2001      	movs	r0, #1
 800778e:	6020      	str	r0, [r4, #0]
 8007790:	e000      	b.n	8007794 <xQueueGiveFromISR+0xa4>
			xReturn = errQUEUE_FULL;
 8007792:	2000      	movs	r0, #0
	__asm volatile
 8007794:	f386 8811 	msr	BASEPRI, r6
}
 8007798:	bd70      	pop	{r4, r5, r6, pc}
			xReturn = pdPASS;
 800779a:	2001      	movs	r0, #1
 800779c:	e7fa      	b.n	8007794 <xQueueGiveFromISR+0xa4>
 800779e:	2001      	movs	r0, #1
 80077a0:	e7f8      	b.n	8007794 <xQueueGiveFromISR+0xa4>

080077a2 <xQueueReceive>:
{
 80077a2:	b5f0      	push	{r4, r5, r6, r7, lr}
 80077a4:	b085      	sub	sp, #20
 80077a6:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
 80077a8:	b190      	cbz	r0, 80077d0 <xQueueReceive+0x2e>
 80077aa:	460f      	mov	r7, r1
 80077ac:	4604      	mov	r4, r0
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80077ae:	b1c1      	cbz	r1, 80077e2 <xQueueReceive+0x40>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80077b0:	f001 f816 	bl	80087e0 <xTaskGetSchedulerState>
 80077b4:	4606      	mov	r6, r0
 80077b6:	bb00      	cbnz	r0, 80077fa <xQueueReceive+0x58>
 80077b8:	9b01      	ldr	r3, [sp, #4]
 80077ba:	2b00      	cmp	r3, #0
 80077bc:	d05e      	beq.n	800787c <xQueueReceive+0xda>
	__asm volatile
 80077be:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80077c2:	f383 8811 	msr	BASEPRI, r3
 80077c6:	f3bf 8f6f 	isb	sy
 80077ca:	f3bf 8f4f 	dsb	sy
 80077ce:	e7fe      	b.n	80077ce <xQueueReceive+0x2c>
 80077d0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80077d4:	f383 8811 	msr	BASEPRI, r3
 80077d8:	f3bf 8f6f 	isb	sy
 80077dc:	f3bf 8f4f 	dsb	sy
	configASSERT( ( pxQueue ) );
 80077e0:	e7fe      	b.n	80077e0 <xQueueReceive+0x3e>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80077e2:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 80077e4:	2b00      	cmp	r3, #0
 80077e6:	d0e3      	beq.n	80077b0 <xQueueReceive+0xe>
 80077e8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80077ec:	f383 8811 	msr	BASEPRI, r3
 80077f0:	f3bf 8f6f 	isb	sy
 80077f4:	f3bf 8f4f 	dsb	sy
 80077f8:	e7fe      	b.n	80077f8 <xQueueReceive+0x56>
 80077fa:	2600      	movs	r6, #0
 80077fc:	e03e      	b.n	800787c <xQueueReceive+0xda>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 80077fe:	4639      	mov	r1, r7
 8007800:	4620      	mov	r0, r4
 8007802:	f7ff fcd0 	bl	80071a6 <prvCopyDataFromQueue>
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8007806:	3d01      	subs	r5, #1
 8007808:	63a5      	str	r5, [r4, #56]	@ 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800780a:	6923      	ldr	r3, [r4, #16]
 800780c:	b923      	cbnz	r3, 8007818 <xQueueReceive+0x76>
				taskEXIT_CRITICAL();
 800780e:	f001 f9f3 	bl	8008bf8 <vPortExitCritical>
				return pdPASS;
 8007812:	2001      	movs	r0, #1
}
 8007814:	b005      	add	sp, #20
 8007816:	bdf0      	pop	{r4, r5, r6, r7, pc}
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8007818:	f104 0010 	add.w	r0, r4, #16
 800781c:	f000 fe82 	bl	8008524 <xTaskRemoveFromEventList>
 8007820:	2800      	cmp	r0, #0
 8007822:	d0f4      	beq.n	800780e <xQueueReceive+0x6c>
						queueYIELD_IF_USING_PREEMPTION();
 8007824:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8007828:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800782c:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8007830:	f3bf 8f4f 	dsb	sy
 8007834:	f3bf 8f6f 	isb	sy
 8007838:	e7e9      	b.n	800780e <xQueueReceive+0x6c>
					taskEXIT_CRITICAL();
 800783a:	f001 f9dd 	bl	8008bf8 <vPortExitCritical>
					return errQUEUE_EMPTY;
 800783e:	2000      	movs	r0, #0
 8007840:	e7e8      	b.n	8007814 <xQueueReceive+0x72>
					vTaskInternalSetTimeOutState( &xTimeOut );
 8007842:	a802      	add	r0, sp, #8
 8007844:	f000 feb4 	bl	80085b0 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 8007848:	2601      	movs	r6, #1
 800784a:	e021      	b.n	8007890 <xQueueReceive+0xee>
		prvLockQueue( pxQueue );
 800784c:	2300      	movs	r3, #0
 800784e:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
 8007852:	e029      	b.n	80078a8 <xQueueReceive+0x106>
 8007854:	2300      	movs	r3, #0
 8007856:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
 800785a:	e02b      	b.n	80078b4 <xQueueReceive+0x112>
				prvUnlockQueue( pxQueue );
 800785c:	4620      	mov	r0, r4
 800785e:	f7ff fcb4 	bl	80071ca <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8007862:	f000 fd75 	bl	8008350 <xTaskResumeAll>
 8007866:	e009      	b.n	800787c <xQueueReceive+0xda>
			prvUnlockQueue( pxQueue );
 8007868:	4620      	mov	r0, r4
 800786a:	f7ff fcae 	bl	80071ca <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800786e:	f000 fd6f 	bl	8008350 <xTaskResumeAll>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8007872:	4620      	mov	r0, r4
 8007874:	f7ff fc4f 	bl	8007116 <prvIsQueueEmpty>
 8007878:	2800      	cmp	r0, #0
 800787a:	d13f      	bne.n	80078fc <xQueueReceive+0x15a>
		taskENTER_CRITICAL();
 800787c:	f001 f99a 	bl	8008bb4 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8007880:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8007882:	2d00      	cmp	r5, #0
 8007884:	d1bb      	bne.n	80077fe <xQueueReceive+0x5c>
				if( xTicksToWait == ( TickType_t ) 0 )
 8007886:	9b01      	ldr	r3, [sp, #4]
 8007888:	2b00      	cmp	r3, #0
 800788a:	d0d6      	beq.n	800783a <xQueueReceive+0x98>
				else if( xEntryTimeSet == pdFALSE )
 800788c:	2e00      	cmp	r6, #0
 800788e:	d0d8      	beq.n	8007842 <xQueueReceive+0xa0>
		taskEXIT_CRITICAL();
 8007890:	f001 f9b2 	bl	8008bf8 <vPortExitCritical>
		vTaskSuspendAll();
 8007894:	f000 fcba 	bl	800820c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8007898:	f001 f98c 	bl	8008bb4 <vPortEnterCritical>
 800789c:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 80078a0:	b25b      	sxtb	r3, r3
 80078a2:	f1b3 3fff 	cmp.w	r3, #4294967295
 80078a6:	d0d1      	beq.n	800784c <xQueueReceive+0xaa>
 80078a8:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 80078ac:	b25b      	sxtb	r3, r3
 80078ae:	f1b3 3fff 	cmp.w	r3, #4294967295
 80078b2:	d0cf      	beq.n	8007854 <xQueueReceive+0xb2>
 80078b4:	f001 f9a0 	bl	8008bf8 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80078b8:	a901      	add	r1, sp, #4
 80078ba:	a802      	add	r0, sp, #8
 80078bc:	f000 fe84 	bl	80085c8 <xTaskCheckForTimeOut>
 80078c0:	2800      	cmp	r0, #0
 80078c2:	d1d1      	bne.n	8007868 <xQueueReceive+0xc6>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 80078c4:	4620      	mov	r0, r4
 80078c6:	f7ff fc26 	bl	8007116 <prvIsQueueEmpty>
 80078ca:	2800      	cmp	r0, #0
 80078cc:	d0c6      	beq.n	800785c <xQueueReceive+0xba>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 80078ce:	9901      	ldr	r1, [sp, #4]
 80078d0:	f104 0024 	add.w	r0, r4, #36	@ 0x24
 80078d4:	f000 fe0e 	bl	80084f4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 80078d8:	4620      	mov	r0, r4
 80078da:	f7ff fc76 	bl	80071ca <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 80078de:	f000 fd37 	bl	8008350 <xTaskResumeAll>
 80078e2:	2800      	cmp	r0, #0
 80078e4:	d1ca      	bne.n	800787c <xQueueReceive+0xda>
					portYIELD_WITHIN_API();
 80078e6:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 80078ea:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80078ee:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 80078f2:	f3bf 8f4f 	dsb	sy
 80078f6:	f3bf 8f6f 	isb	sy
 80078fa:	e7bf      	b.n	800787c <xQueueReceive+0xda>
				return errQUEUE_EMPTY;
 80078fc:	2000      	movs	r0, #0
 80078fe:	e789      	b.n	8007814 <xQueueReceive+0x72>

08007900 <xQueueSemaphoreTake>:
{
 8007900:	b570      	push	{r4, r5, r6, lr}
 8007902:	b084      	sub	sp, #16
 8007904:	9101      	str	r1, [sp, #4]
	configASSERT( ( pxQueue ) );
 8007906:	b158      	cbz	r0, 8007920 <xQueueSemaphoreTake+0x20>
 8007908:	4604      	mov	r4, r0
	configASSERT( pxQueue->uxItemSize == 0 );
 800790a:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 800790c:	b18b      	cbz	r3, 8007932 <xQueueSemaphoreTake+0x32>
 800790e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007912:	f383 8811 	msr	BASEPRI, r3
 8007916:	f3bf 8f6f 	isb	sy
 800791a:	f3bf 8f4f 	dsb	sy
 800791e:	e7fe      	b.n	800791e <xQueueSemaphoreTake+0x1e>
 8007920:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007924:	f383 8811 	msr	BASEPRI, r3
 8007928:	f3bf 8f6f 	isb	sy
 800792c:	f3bf 8f4f 	dsb	sy
	configASSERT( ( pxQueue ) );
 8007930:	e7fe      	b.n	8007930 <xQueueSemaphoreTake+0x30>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8007932:	f000 ff55 	bl	80087e0 <xTaskGetSchedulerState>
 8007936:	4605      	mov	r5, r0
 8007938:	b950      	cbnz	r0, 8007950 <xQueueSemaphoreTake+0x50>
 800793a:	9b01      	ldr	r3, [sp, #4]
 800793c:	b15b      	cbz	r3, 8007956 <xQueueSemaphoreTake+0x56>
 800793e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007942:	f383 8811 	msr	BASEPRI, r3
 8007946:	f3bf 8f6f 	isb	sy
 800794a:	f3bf 8f4f 	dsb	sy
 800794e:	e7fe      	b.n	800794e <xQueueSemaphoreTake+0x4e>
 8007950:	2600      	movs	r6, #0
 8007952:	4635      	mov	r5, r6
 8007954:	e055      	b.n	8007a02 <xQueueSemaphoreTake+0x102>
 8007956:	4606      	mov	r6, r0
 8007958:	e053      	b.n	8007a02 <xQueueSemaphoreTake+0x102>
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 800795a:	3b01      	subs	r3, #1
 800795c:	63a3      	str	r3, [r4, #56]	@ 0x38
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800795e:	6823      	ldr	r3, [r4, #0]
 8007960:	b13b      	cbz	r3, 8007972 <xQueueSemaphoreTake+0x72>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8007962:	6923      	ldr	r3, [r4, #16]
 8007964:	b94b      	cbnz	r3, 800797a <xQueueSemaphoreTake+0x7a>
				taskEXIT_CRITICAL();
 8007966:	f001 f947 	bl	8008bf8 <vPortExitCritical>
				return pdPASS;
 800796a:	2601      	movs	r6, #1
}
 800796c:	4630      	mov	r0, r6
 800796e:	b004      	add	sp, #16
 8007970:	bd70      	pop	{r4, r5, r6, pc}
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 8007972:	f001 f8ab 	bl	8008acc <pvTaskIncrementMutexHeldCount>
 8007976:	60a0      	str	r0, [r4, #8]
 8007978:	e7f3      	b.n	8007962 <xQueueSemaphoreTake+0x62>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800797a:	f104 0010 	add.w	r0, r4, #16
 800797e:	f000 fdd1 	bl	8008524 <xTaskRemoveFromEventList>
 8007982:	2800      	cmp	r0, #0
 8007984:	d0ef      	beq.n	8007966 <xQueueSemaphoreTake+0x66>
						queueYIELD_IF_USING_PREEMPTION();
 8007986:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 800798a:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800798e:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8007992:	f3bf 8f4f 	dsb	sy
 8007996:	f3bf 8f6f 	isb	sy
 800799a:	e7e4      	b.n	8007966 <xQueueSemaphoreTake+0x66>
						configASSERT( xInheritanceOccurred == pdFALSE );
 800799c:	b146      	cbz	r6, 80079b0 <xQueueSemaphoreTake+0xb0>
 800799e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80079a2:	f383 8811 	msr	BASEPRI, r3
 80079a6:	f3bf 8f6f 	isb	sy
 80079aa:	f3bf 8f4f 	dsb	sy
 80079ae:	e7fe      	b.n	80079ae <xQueueSemaphoreTake+0xae>
					taskEXIT_CRITICAL();
 80079b0:	f001 f922 	bl	8008bf8 <vPortExitCritical>
					return errQUEUE_EMPTY;
 80079b4:	e7da      	b.n	800796c <xQueueSemaphoreTake+0x6c>
					vTaskInternalSetTimeOutState( &xTimeOut );
 80079b6:	a802      	add	r0, sp, #8
 80079b8:	f000 fdfa 	bl	80085b0 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 80079bc:	2501      	movs	r5, #1
 80079be:	e02a      	b.n	8007a16 <xQueueSemaphoreTake+0x116>
		prvLockQueue( pxQueue );
 80079c0:	2300      	movs	r3, #0
 80079c2:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
 80079c6:	e032      	b.n	8007a2e <xQueueSemaphoreTake+0x12e>
 80079c8:	2300      	movs	r3, #0
 80079ca:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
 80079ce:	e034      	b.n	8007a3a <xQueueSemaphoreTake+0x13a>
						taskENTER_CRITICAL();
 80079d0:	f001 f8f0 	bl	8008bb4 <vPortEnterCritical>
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 80079d4:	68a0      	ldr	r0, [r4, #8]
 80079d6:	f000 ff13 	bl	8008800 <xTaskPriorityInherit>
 80079da:	4606      	mov	r6, r0
						taskEXIT_CRITICAL();
 80079dc:	f001 f90c 	bl	8008bf8 <vPortExitCritical>
 80079e0:	e03b      	b.n	8007a5a <xQueueSemaphoreTake+0x15a>
				prvUnlockQueue( pxQueue );
 80079e2:	4620      	mov	r0, r4
 80079e4:	f7ff fbf1 	bl	80071ca <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80079e8:	f000 fcb2 	bl	8008350 <xTaskResumeAll>
 80079ec:	e009      	b.n	8007a02 <xQueueSemaphoreTake+0x102>
			prvUnlockQueue( pxQueue );
 80079ee:	4620      	mov	r0, r4
 80079f0:	f7ff fbeb 	bl	80071ca <prvUnlockQueue>
			( void ) xTaskResumeAll();
 80079f4:	f000 fcac 	bl	8008350 <xTaskResumeAll>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 80079f8:	4620      	mov	r0, r4
 80079fa:	f7ff fb8c 	bl	8007116 <prvIsQueueEmpty>
 80079fe:	2800      	cmp	r0, #0
 8007a00:	d142      	bne.n	8007a88 <xQueueSemaphoreTake+0x188>
		taskENTER_CRITICAL();
 8007a02:	f001 f8d7 	bl	8008bb4 <vPortEnterCritical>
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 8007a06:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 8007a08:	2b00      	cmp	r3, #0
 8007a0a:	d1a6      	bne.n	800795a <xQueueSemaphoreTake+0x5a>
				if( xTicksToWait == ( TickType_t ) 0 )
 8007a0c:	9b01      	ldr	r3, [sp, #4]
 8007a0e:	2b00      	cmp	r3, #0
 8007a10:	d0c4      	beq.n	800799c <xQueueSemaphoreTake+0x9c>
				else if( xEntryTimeSet == pdFALSE )
 8007a12:	2d00      	cmp	r5, #0
 8007a14:	d0cf      	beq.n	80079b6 <xQueueSemaphoreTake+0xb6>
		taskEXIT_CRITICAL();
 8007a16:	f001 f8ef 	bl	8008bf8 <vPortExitCritical>
		vTaskSuspendAll();
 8007a1a:	f000 fbf7 	bl	800820c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8007a1e:	f001 f8c9 	bl	8008bb4 <vPortEnterCritical>
 8007a22:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 8007a26:	b25b      	sxtb	r3, r3
 8007a28:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007a2c:	d0c8      	beq.n	80079c0 <xQueueSemaphoreTake+0xc0>
 8007a2e:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 8007a32:	b25b      	sxtb	r3, r3
 8007a34:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007a38:	d0c6      	beq.n	80079c8 <xQueueSemaphoreTake+0xc8>
 8007a3a:	f001 f8dd 	bl	8008bf8 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8007a3e:	a901      	add	r1, sp, #4
 8007a40:	a802      	add	r0, sp, #8
 8007a42:	f000 fdc1 	bl	80085c8 <xTaskCheckForTimeOut>
 8007a46:	2800      	cmp	r0, #0
 8007a48:	d1d1      	bne.n	80079ee <xQueueSemaphoreTake+0xee>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8007a4a:	4620      	mov	r0, r4
 8007a4c:	f7ff fb63 	bl	8007116 <prvIsQueueEmpty>
 8007a50:	2800      	cmp	r0, #0
 8007a52:	d0c6      	beq.n	80079e2 <xQueueSemaphoreTake+0xe2>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8007a54:	6823      	ldr	r3, [r4, #0]
 8007a56:	2b00      	cmp	r3, #0
 8007a58:	d0ba      	beq.n	80079d0 <xQueueSemaphoreTake+0xd0>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8007a5a:	9901      	ldr	r1, [sp, #4]
 8007a5c:	f104 0024 	add.w	r0, r4, #36	@ 0x24
 8007a60:	f000 fd48 	bl	80084f4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8007a64:	4620      	mov	r0, r4
 8007a66:	f7ff fbb0 	bl	80071ca <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8007a6a:	f000 fc71 	bl	8008350 <xTaskResumeAll>
 8007a6e:	2800      	cmp	r0, #0
 8007a70:	d1c7      	bne.n	8007a02 <xQueueSemaphoreTake+0x102>
					portYIELD_WITHIN_API();
 8007a72:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8007a76:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8007a7a:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8007a7e:	f3bf 8f4f 	dsb	sy
 8007a82:	f3bf 8f6f 	isb	sy
 8007a86:	e7bc      	b.n	8007a02 <xQueueSemaphoreTake+0x102>
					if( xInheritanceOccurred != pdFALSE )
 8007a88:	b90e      	cbnz	r6, 8007a8e <xQueueSemaphoreTake+0x18e>
				return errQUEUE_EMPTY;
 8007a8a:	2600      	movs	r6, #0
 8007a8c:	e76e      	b.n	800796c <xQueueSemaphoreTake+0x6c>
						taskENTER_CRITICAL();
 8007a8e:	f001 f891 	bl	8008bb4 <vPortEnterCritical>
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 8007a92:	4620      	mov	r0, r4
 8007a94:	f7ff fb28 	bl	80070e8 <prvGetDisinheritPriorityAfterTimeout>
 8007a98:	4601      	mov	r1, r0
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 8007a9a:	68a0      	ldr	r0, [r4, #8]
 8007a9c:	f000 ff5e 	bl	800895c <vTaskPriorityDisinheritAfterTimeout>
						taskEXIT_CRITICAL();
 8007aa0:	f001 f8aa 	bl	8008bf8 <vPortExitCritical>
 8007aa4:	e7f1      	b.n	8007a8a <xQueueSemaphoreTake+0x18a>

08007aa6 <xQueueReceiveFromISR>:
{
 8007aa6:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( pxQueue );
 8007aaa:	b1b0      	cbz	r0, 8007ada <xQueueReceiveFromISR+0x34>
 8007aac:	460d      	mov	r5, r1
 8007aae:	4690      	mov	r8, r2
 8007ab0:	4604      	mov	r4, r0
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8007ab2:	b1d9      	cbz	r1, 8007aec <xQueueReceiveFromISR+0x46>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8007ab4:	f001 f9a4 	bl	8008e00 <vPortValidateInterruptPriority>
	__asm volatile
 8007ab8:	f3ef 8711 	mrs	r7, BASEPRI
 8007abc:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007ac0:	f383 8811 	msr	BASEPRI, r3
 8007ac4:	f3bf 8f6f 	isb	sy
 8007ac8:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8007acc:	6ba6      	ldr	r6, [r4, #56]	@ 0x38
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8007ace:	b9ce      	cbnz	r6, 8007b04 <xQueueReceiveFromISR+0x5e>
			xReturn = pdFAIL;
 8007ad0:	2000      	movs	r0, #0
	__asm volatile
 8007ad2:	f387 8811 	msr	BASEPRI, r7
}
 8007ad6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	__asm volatile
 8007ada:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007ade:	f383 8811 	msr	BASEPRI, r3
 8007ae2:	f3bf 8f6f 	isb	sy
 8007ae6:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 8007aea:	e7fe      	b.n	8007aea <xQueueReceiveFromISR+0x44>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8007aec:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 8007aee:	2b00      	cmp	r3, #0
 8007af0:	d0e0      	beq.n	8007ab4 <xQueueReceiveFromISR+0xe>
 8007af2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007af6:	f383 8811 	msr	BASEPRI, r3
 8007afa:	f3bf 8f6f 	isb	sy
 8007afe:	f3bf 8f4f 	dsb	sy
 8007b02:	e7fe      	b.n	8007b02 <xQueueReceiveFromISR+0x5c>
			const int8_t cRxLock = pxQueue->cRxLock;
 8007b04:	f894 9044 	ldrb.w	r9, [r4, #68]	@ 0x44
 8007b08:	fa4f f989 	sxtb.w	r9, r9
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 8007b0c:	4629      	mov	r1, r5
 8007b0e:	4620      	mov	r0, r4
 8007b10:	f7ff fb49 	bl	80071a6 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8007b14:	1e73      	subs	r3, r6, #1
 8007b16:	63a3      	str	r3, [r4, #56]	@ 0x38
			if( cRxLock == queueUNLOCKED )
 8007b18:	f1b9 3fff 	cmp.w	r9, #4294967295
 8007b1c:	d006      	beq.n	8007b2c <xQueueReceiveFromISR+0x86>
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 8007b1e:	f109 0301 	add.w	r3, r9, #1
 8007b22:	b25b      	sxtb	r3, r3
 8007b24:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
			xReturn = pdPASS;
 8007b28:	2001      	movs	r0, #1
 8007b2a:	e7d2      	b.n	8007ad2 <xQueueReceiveFromISR+0x2c>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8007b2c:	6923      	ldr	r3, [r4, #16]
 8007b2e:	b90b      	cbnz	r3, 8007b34 <xQueueReceiveFromISR+0x8e>
			xReturn = pdPASS;
 8007b30:	2001      	movs	r0, #1
 8007b32:	e7ce      	b.n	8007ad2 <xQueueReceiveFromISR+0x2c>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8007b34:	f104 0010 	add.w	r0, r4, #16
 8007b38:	f000 fcf4 	bl	8008524 <xTaskRemoveFromEventList>
 8007b3c:	b130      	cbz	r0, 8007b4c <xQueueReceiveFromISR+0xa6>
						if( pxHigherPriorityTaskWoken != NULL )
 8007b3e:	f1b8 0f00 	cmp.w	r8, #0
 8007b42:	d005      	beq.n	8007b50 <xQueueReceiveFromISR+0xaa>
							*pxHigherPriorityTaskWoken = pdTRUE;
 8007b44:	2001      	movs	r0, #1
 8007b46:	f8c8 0000 	str.w	r0, [r8]
 8007b4a:	e7c2      	b.n	8007ad2 <xQueueReceiveFromISR+0x2c>
			xReturn = pdPASS;
 8007b4c:	2001      	movs	r0, #1
 8007b4e:	e7c0      	b.n	8007ad2 <xQueueReceiveFromISR+0x2c>
 8007b50:	2001      	movs	r0, #1
 8007b52:	e7be      	b.n	8007ad2 <xQueueReceiveFromISR+0x2c>

08007b54 <uxQueueMessagesWaiting>:
	configASSERT( xQueue );
 8007b54:	b140      	cbz	r0, 8007b68 <uxQueueMessagesWaiting+0x14>
{
 8007b56:	b510      	push	{r4, lr}
 8007b58:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 8007b5a:	f001 f82b 	bl	8008bb4 <vPortEnterCritical>
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 8007b5e:	6ba4      	ldr	r4, [r4, #56]	@ 0x38
	taskEXIT_CRITICAL();
 8007b60:	f001 f84a 	bl	8008bf8 <vPortExitCritical>
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 8007b64:	4620      	mov	r0, r4
 8007b66:	bd10      	pop	{r4, pc}
 8007b68:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007b6c:	f383 8811 	msr	BASEPRI, r3
 8007b70:	f3bf 8f6f 	isb	sy
 8007b74:	f3bf 8f4f 	dsb	sy
	configASSERT( xQueue );
 8007b78:	e7fe      	b.n	8007b78 <uxQueueMessagesWaiting+0x24>

08007b7a <uxQueueMessagesWaitingFromISR>:
	configASSERT( pxQueue );
 8007b7a:	b108      	cbz	r0, 8007b80 <uxQueueMessagesWaitingFromISR+0x6>
	uxReturn = pxQueue->uxMessagesWaiting;
 8007b7c:	6b80      	ldr	r0, [r0, #56]	@ 0x38
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 8007b7e:	4770      	bx	lr
 8007b80:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007b84:	f383 8811 	msr	BASEPRI, r3
 8007b88:	f3bf 8f6f 	isb	sy
 8007b8c:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 8007b90:	e7fe      	b.n	8007b90 <uxQueueMessagesWaitingFromISR+0x16>
	...

08007b94 <vQueueUnregisterQueue>:
	{
	UBaseType_t ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8007b94:	2300      	movs	r3, #0
 8007b96:	2b07      	cmp	r3, #7
 8007b98:	d80f      	bhi.n	8007bba <vQueueUnregisterQueue+0x26>
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
 8007b9a:	4a08      	ldr	r2, [pc, #32]	@ (8007bbc <vQueueUnregisterQueue+0x28>)
 8007b9c:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 8007ba0:	6852      	ldr	r2, [r2, #4]
 8007ba2:	4282      	cmp	r2, r0
 8007ba4:	d001      	beq.n	8007baa <vQueueUnregisterQueue+0x16>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8007ba6:	3301      	adds	r3, #1
 8007ba8:	e7f5      	b.n	8007b96 <vQueueUnregisterQueue+0x2>
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
 8007baa:	4a04      	ldr	r2, [pc, #16]	@ (8007bbc <vQueueUnregisterQueue+0x28>)
 8007bac:	2100      	movs	r1, #0
 8007bae:	f842 1033 	str.w	r1, [r2, r3, lsl #3]

				/* Set the handle to NULL to ensure the same queue handle cannot
				appear in the registry twice if it is added, removed, then
				added again. */
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 8007bb2:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 8007bb6:	6051      	str	r1, [r2, #4]
				break;
 8007bb8:	4770      	bx	lr
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 8007bba:	4770      	bx	lr
 8007bbc:	24003708 	.word	0x24003708

08007bc0 <vQueueDelete>:
	configASSERT( pxQueue );
 8007bc0:	b138      	cbz	r0, 8007bd2 <vQueueDelete+0x12>
{
 8007bc2:	b510      	push	{r4, lr}
 8007bc4:	4604      	mov	r4, r0
		vQueueUnregisterQueue( pxQueue );
 8007bc6:	f7ff ffe5 	bl	8007b94 <vQueueUnregisterQueue>
		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
 8007bca:	f894 3046 	ldrb.w	r3, [r4, #70]	@ 0x46
 8007bce:	b14b      	cbz	r3, 8007be4 <vQueueDelete+0x24>
}
 8007bd0:	bd10      	pop	{r4, pc}
 8007bd2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007bd6:	f383 8811 	msr	BASEPRI, r3
 8007bda:	f3bf 8f6f 	isb	sy
 8007bde:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 8007be2:	e7fe      	b.n	8007be2 <vQueueDelete+0x22>
			vPortFree( pxQueue );
 8007be4:	4620      	mov	r0, r4
 8007be6:	f001 fa1f 	bl	8009028 <vPortFree>
}
 8007bea:	e7f1      	b.n	8007bd0 <vQueueDelete+0x10>

08007bec <prvTaskCheckFreeStackSpace>:

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;
 8007bec:	2300      	movs	r3, #0

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 8007bee:	e001      	b.n	8007bf4 <prvTaskCheckFreeStackSpace+0x8>
		{
			pucStackByte -= portSTACK_GROWTH;
 8007bf0:	3001      	adds	r0, #1
			ulCount++;
 8007bf2:	3301      	adds	r3, #1
		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 8007bf4:	7802      	ldrb	r2, [r0, #0]
 8007bf6:	2aa5      	cmp	r2, #165	@ 0xa5
 8007bf8:	d0fa      	beq.n	8007bf0 <prvTaskCheckFreeStackSpace+0x4>
		}

		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */

		return ( configSTACK_DEPTH_TYPE ) ulCount;
	}
 8007bfa:	f3c3 008f 	ubfx	r0, r3, #2, #16
 8007bfe:	4770      	bx	lr

08007c00 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8007c00:	4b08      	ldr	r3, [pc, #32]	@ (8007c24 <prvResetNextTaskUnblockTime+0x24>)
 8007c02:	681b      	ldr	r3, [r3, #0]
 8007c04:	681b      	ldr	r3, [r3, #0]
 8007c06:	b923      	cbnz	r3, 8007c12 <prvResetNextTaskUnblockTime+0x12>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 8007c08:	4b07      	ldr	r3, [pc, #28]	@ (8007c28 <prvResetNextTaskUnblockTime+0x28>)
 8007c0a:	f04f 32ff 	mov.w	r2, #4294967295
 8007c0e:	601a      	str	r2, [r3, #0]
 8007c10:	4770      	bx	lr
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8007c12:	4b04      	ldr	r3, [pc, #16]	@ (8007c24 <prvResetNextTaskUnblockTime+0x24>)
 8007c14:	681b      	ldr	r3, [r3, #0]
 8007c16:	68db      	ldr	r3, [r3, #12]
 8007c18:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8007c1a:	685a      	ldr	r2, [r3, #4]
 8007c1c:	4b02      	ldr	r3, [pc, #8]	@ (8007c28 <prvResetNextTaskUnblockTime+0x28>)
 8007c1e:	601a      	str	r2, [r3, #0]
	}
}
 8007c20:	4770      	bx	lr
 8007c22:	bf00      	nop
 8007c24:	240037bc 	.word	0x240037bc
 8007c28:	24003750 	.word	0x24003750

08007c2c <prvInitialiseNewTask>:
{
 8007c2c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8007c30:	4680      	mov	r8, r0
 8007c32:	460d      	mov	r5, r1
 8007c34:	4617      	mov	r7, r2
 8007c36:	4699      	mov	r9, r3
 8007c38:	9e08      	ldr	r6, [sp, #32]
 8007c3a:	f8dd a024 	ldr.w	sl, [sp, #36]	@ 0x24
 8007c3e:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8007c40:	0092      	lsls	r2, r2, #2
 8007c42:	21a5      	movs	r1, #165	@ 0xa5
 8007c44:	6b20      	ldr	r0, [r4, #48]	@ 0x30
 8007c46:	f00c fb37 	bl	80142b8 <memset>
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 8007c4a:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 8007c4c:	f06f 4240 	mvn.w	r2, #3221225472	@ 0xc0000000
 8007c50:	443a      	add	r2, r7
 8007c52:	eb03 0782 	add.w	r7, r3, r2, lsl #2
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 8007c56:	f027 0707 	bic.w	r7, r7, #7
	if( pcName != NULL )
 8007c5a:	b3a5      	cbz	r5, 8007cc6 <prvInitialiseNewTask+0x9a>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8007c5c:	f04f 0c00 	mov.w	ip, #0
 8007c60:	f1bc 0f0b 	cmp.w	ip, #11
 8007c64:	d809      	bhi.n	8007c7a <prvInitialiseNewTask+0x4e>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007c66:	f815 300c 	ldrb.w	r3, [r5, ip]
 8007c6a:	eb04 020c 	add.w	r2, r4, ip
 8007c6e:	f882 3034 	strb.w	r3, [r2, #52]	@ 0x34
			if( pcName[ x ] == ( char ) 0x00 )
 8007c72:	b113      	cbz	r3, 8007c7a <prvInitialiseNewTask+0x4e>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8007c74:	f10c 0c01 	add.w	ip, ip, #1
 8007c78:	e7f2      	b.n	8007c60 <prvInitialiseNewTask+0x34>
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8007c7a:	2300      	movs	r3, #0
 8007c7c:	f884 303f 	strb.w	r3, [r4, #63]	@ 0x3f
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 8007c80:	2e06      	cmp	r6, #6
 8007c82:	d900      	bls.n	8007c86 <prvInitialiseNewTask+0x5a>
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 8007c84:	2606      	movs	r6, #6
	pxNewTCB->uxPriority = uxPriority;
 8007c86:	62e6      	str	r6, [r4, #44]	@ 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 8007c88:	64a6      	str	r6, [r4, #72]	@ 0x48
		pxNewTCB->uxMutexesHeld = 0;
 8007c8a:	2500      	movs	r5, #0
 8007c8c:	64e5      	str	r5, [r4, #76]	@ 0x4c
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8007c8e:	1d20      	adds	r0, r4, #4
 8007c90:	f7ff f9f0 	bl	8007074 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8007c94:	f104 0018 	add.w	r0, r4, #24
 8007c98:	f7ff f9ec 	bl	8007074 <vListInitialiseItem>
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8007c9c:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8007c9e:	f1c6 0607 	rsb	r6, r6, #7
 8007ca2:	61a6      	str	r6, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8007ca4:	6264      	str	r4, [r4, #36]	@ 0x24
		pxNewTCB->ulNotifiedValue = 0;
 8007ca6:	6525      	str	r5, [r4, #80]	@ 0x50
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8007ca8:	f884 5054 	strb.w	r5, [r4, #84]	@ 0x54
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8007cac:	464a      	mov	r2, r9
 8007cae:	4641      	mov	r1, r8
 8007cb0:	4638      	mov	r0, r7
 8007cb2:	f000 ff57 	bl	8008b64 <pxPortInitialiseStack>
 8007cb6:	6020      	str	r0, [r4, #0]
	if( pxCreatedTask != NULL )
 8007cb8:	f1ba 0f00 	cmp.w	sl, #0
 8007cbc:	d001      	beq.n	8007cc2 <prvInitialiseNewTask+0x96>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8007cbe:	f8ca 4000 	str.w	r4, [sl]
}
 8007cc2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 8007cc6:	2300      	movs	r3, #0
 8007cc8:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
 8007ccc:	e7d8      	b.n	8007c80 <prvInitialiseNewTask+0x54>
	...

08007cd0 <prvInitialiseTaskLists>:
{
 8007cd0:	b538      	push	{r3, r4, r5, lr}
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8007cd2:	2400      	movs	r4, #0
 8007cd4:	e007      	b.n	8007ce6 <prvInitialiseTaskLists+0x16>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8007cd6:	eb04 0284 	add.w	r2, r4, r4, lsl #2
 8007cda:	0093      	lsls	r3, r2, #2
 8007cdc:	480e      	ldr	r0, [pc, #56]	@ (8007d18 <prvInitialiseTaskLists+0x48>)
 8007cde:	4418      	add	r0, r3
 8007ce0:	f7ff f9bd 	bl	800705e <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8007ce4:	3401      	adds	r4, #1
 8007ce6:	2c06      	cmp	r4, #6
 8007ce8:	d9f5      	bls.n	8007cd6 <prvInitialiseTaskLists+0x6>
	vListInitialise( &xDelayedTaskList1 );
 8007cea:	4d0c      	ldr	r5, [pc, #48]	@ (8007d1c <prvInitialiseTaskLists+0x4c>)
 8007cec:	4628      	mov	r0, r5
 8007cee:	f7ff f9b6 	bl	800705e <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8007cf2:	4c0b      	ldr	r4, [pc, #44]	@ (8007d20 <prvInitialiseTaskLists+0x50>)
 8007cf4:	4620      	mov	r0, r4
 8007cf6:	f7ff f9b2 	bl	800705e <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8007cfa:	480a      	ldr	r0, [pc, #40]	@ (8007d24 <prvInitialiseTaskLists+0x54>)
 8007cfc:	f7ff f9af 	bl	800705e <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 8007d00:	4809      	ldr	r0, [pc, #36]	@ (8007d28 <prvInitialiseTaskLists+0x58>)
 8007d02:	f7ff f9ac 	bl	800705e <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 8007d06:	4809      	ldr	r0, [pc, #36]	@ (8007d2c <prvInitialiseTaskLists+0x5c>)
 8007d08:	f7ff f9a9 	bl	800705e <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 8007d0c:	4b08      	ldr	r3, [pc, #32]	@ (8007d30 <prvInitialiseTaskLists+0x60>)
 8007d0e:	601d      	str	r5, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8007d10:	4b08      	ldr	r3, [pc, #32]	@ (8007d34 <prvInitialiseTaskLists+0x64>)
 8007d12:	601c      	str	r4, [r3, #0]
}
 8007d14:	bd38      	pop	{r3, r4, r5, pc}
 8007d16:	bf00      	nop
 8007d18:	240037e8 	.word	0x240037e8
 8007d1c:	240037d4 	.word	0x240037d4
 8007d20:	240037c0 	.word	0x240037c0
 8007d24:	240037a4 	.word	0x240037a4
 8007d28:	24003790 	.word	0x24003790
 8007d2c:	24003778 	.word	0x24003778
 8007d30:	240037bc 	.word	0x240037bc
 8007d34:	240037b8 	.word	0x240037b8

08007d38 <prvAddNewTaskToReadyList>:
{
 8007d38:	b510      	push	{r4, lr}
 8007d3a:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 8007d3c:	f000 ff3a 	bl	8008bb4 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 8007d40:	4a22      	ldr	r2, [pc, #136]	@ (8007dcc <prvAddNewTaskToReadyList+0x94>)
 8007d42:	6813      	ldr	r3, [r2, #0]
 8007d44:	3301      	adds	r3, #1
 8007d46:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 8007d48:	4b21      	ldr	r3, [pc, #132]	@ (8007dd0 <prvAddNewTaskToReadyList+0x98>)
 8007d4a:	681b      	ldr	r3, [r3, #0]
 8007d4c:	b15b      	cbz	r3, 8007d66 <prvAddNewTaskToReadyList+0x2e>
			if( xSchedulerRunning == pdFALSE )
 8007d4e:	4b21      	ldr	r3, [pc, #132]	@ (8007dd4 <prvAddNewTaskToReadyList+0x9c>)
 8007d50:	681b      	ldr	r3, [r3, #0]
 8007d52:	b96b      	cbnz	r3, 8007d70 <prvAddNewTaskToReadyList+0x38>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8007d54:	4b1e      	ldr	r3, [pc, #120]	@ (8007dd0 <prvAddNewTaskToReadyList+0x98>)
 8007d56:	681b      	ldr	r3, [r3, #0]
 8007d58:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8007d5a:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 8007d5c:	429a      	cmp	r2, r3
 8007d5e:	d807      	bhi.n	8007d70 <prvAddNewTaskToReadyList+0x38>
					pxCurrentTCB = pxNewTCB;
 8007d60:	4b1b      	ldr	r3, [pc, #108]	@ (8007dd0 <prvAddNewTaskToReadyList+0x98>)
 8007d62:	601c      	str	r4, [r3, #0]
 8007d64:	e004      	b.n	8007d70 <prvAddNewTaskToReadyList+0x38>
			pxCurrentTCB = pxNewTCB;
 8007d66:	4b1a      	ldr	r3, [pc, #104]	@ (8007dd0 <prvAddNewTaskToReadyList+0x98>)
 8007d68:	601c      	str	r4, [r3, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8007d6a:	6813      	ldr	r3, [r2, #0]
 8007d6c:	2b01      	cmp	r3, #1
 8007d6e:	d029      	beq.n	8007dc4 <prvAddNewTaskToReadyList+0x8c>
		uxTaskNumber++;
 8007d70:	4a19      	ldr	r2, [pc, #100]	@ (8007dd8 <prvAddNewTaskToReadyList+0xa0>)
 8007d72:	6813      	ldr	r3, [r2, #0]
 8007d74:	3301      	adds	r3, #1
 8007d76:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 8007d78:	6423      	str	r3, [r4, #64]	@ 0x40
		prvAddTaskToReadyList( pxNewTCB );
 8007d7a:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 8007d7c:	2301      	movs	r3, #1
 8007d7e:	4083      	lsls	r3, r0
 8007d80:	4a16      	ldr	r2, [pc, #88]	@ (8007ddc <prvAddNewTaskToReadyList+0xa4>)
 8007d82:	6811      	ldr	r1, [r2, #0]
 8007d84:	430b      	orrs	r3, r1
 8007d86:	6013      	str	r3, [r2, #0]
 8007d88:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8007d8c:	1d21      	adds	r1, r4, #4
 8007d8e:	4b14      	ldr	r3, [pc, #80]	@ (8007de0 <prvAddNewTaskToReadyList+0xa8>)
 8007d90:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8007d94:	f7ff f971 	bl	800707a <vListInsertEnd>
	taskEXIT_CRITICAL();
 8007d98:	f000 ff2e 	bl	8008bf8 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 8007d9c:	4b0d      	ldr	r3, [pc, #52]	@ (8007dd4 <prvAddNewTaskToReadyList+0x9c>)
 8007d9e:	681b      	ldr	r3, [r3, #0]
 8007da0:	b17b      	cbz	r3, 8007dc2 <prvAddNewTaskToReadyList+0x8a>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8007da2:	4b0b      	ldr	r3, [pc, #44]	@ (8007dd0 <prvAddNewTaskToReadyList+0x98>)
 8007da4:	681b      	ldr	r3, [r3, #0]
 8007da6:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8007da8:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 8007daa:	429a      	cmp	r2, r3
 8007dac:	d209      	bcs.n	8007dc2 <prvAddNewTaskToReadyList+0x8a>
			taskYIELD_IF_USING_PREEMPTION();
 8007dae:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8007db2:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8007db6:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8007dba:	f3bf 8f4f 	dsb	sy
 8007dbe:	f3bf 8f6f 	isb	sy
}
 8007dc2:	bd10      	pop	{r4, pc}
				prvInitialiseTaskLists();
 8007dc4:	f7ff ff84 	bl	8007cd0 <prvInitialiseTaskLists>
 8007dc8:	e7d2      	b.n	8007d70 <prvAddNewTaskToReadyList+0x38>
 8007dca:	bf00      	nop
 8007dcc:	24003770 	.word	0x24003770
 8007dd0:	24003874 	.word	0x24003874
 8007dd4:	24003764 	.word	0x24003764
 8007dd8:	24003754 	.word	0x24003754
 8007ddc:	24003768 	.word	0x24003768
 8007de0:	240037e8 	.word	0x240037e8

08007de4 <prvDeleteTCB>:
	{
 8007de4:	b510      	push	{r4, lr}
 8007de6:	4604      	mov	r4, r0
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 8007de8:	f890 3055 	ldrb.w	r3, [r0, #85]	@ 0x55
 8007dec:	b163      	cbz	r3, 8007e08 <prvDeleteTCB+0x24>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 8007dee:	2b01      	cmp	r3, #1
 8007df0:	d011      	beq.n	8007e16 <prvDeleteTCB+0x32>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
 8007df2:	2b02      	cmp	r3, #2
 8007df4:	d00e      	beq.n	8007e14 <prvDeleteTCB+0x30>
 8007df6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007dfa:	f383 8811 	msr	BASEPRI, r3
 8007dfe:	f3bf 8f6f 	isb	sy
 8007e02:	f3bf 8f4f 	dsb	sy
 8007e06:	e7fe      	b.n	8007e06 <prvDeleteTCB+0x22>
				vPortFree( pxTCB->pxStack );
 8007e08:	6b00      	ldr	r0, [r0, #48]	@ 0x30
 8007e0a:	f001 f90d 	bl	8009028 <vPortFree>
				vPortFree( pxTCB );
 8007e0e:	4620      	mov	r0, r4
 8007e10:	f001 f90a 	bl	8009028 <vPortFree>
	}
 8007e14:	bd10      	pop	{r4, pc}
				vPortFree( pxTCB );
 8007e16:	f001 f907 	bl	8009028 <vPortFree>
 8007e1a:	e7fb      	b.n	8007e14 <prvDeleteTCB+0x30>

08007e1c <prvCheckTasksWaitingTermination>:
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8007e1c:	4b0f      	ldr	r3, [pc, #60]	@ (8007e5c <prvCheckTasksWaitingTermination+0x40>)
 8007e1e:	681b      	ldr	r3, [r3, #0]
 8007e20:	b1d3      	cbz	r3, 8007e58 <prvCheckTasksWaitingTermination+0x3c>
{
 8007e22:	b510      	push	{r4, lr}
			taskENTER_CRITICAL();
 8007e24:	f000 fec6 	bl	8008bb4 <vPortEnterCritical>
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8007e28:	4b0d      	ldr	r3, [pc, #52]	@ (8007e60 <prvCheckTasksWaitingTermination+0x44>)
 8007e2a:	68db      	ldr	r3, [r3, #12]
 8007e2c:	68dc      	ldr	r4, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8007e2e:	1d20      	adds	r0, r4, #4
 8007e30:	f7ff f947 	bl	80070c2 <uxListRemove>
				--uxCurrentNumberOfTasks;
 8007e34:	4a0b      	ldr	r2, [pc, #44]	@ (8007e64 <prvCheckTasksWaitingTermination+0x48>)
 8007e36:	6813      	ldr	r3, [r2, #0]
 8007e38:	3b01      	subs	r3, #1
 8007e3a:	6013      	str	r3, [r2, #0]
				--uxDeletedTasksWaitingCleanUp;
 8007e3c:	4a07      	ldr	r2, [pc, #28]	@ (8007e5c <prvCheckTasksWaitingTermination+0x40>)
 8007e3e:	6813      	ldr	r3, [r2, #0]
 8007e40:	3b01      	subs	r3, #1
 8007e42:	6013      	str	r3, [r2, #0]
			taskEXIT_CRITICAL();
 8007e44:	f000 fed8 	bl	8008bf8 <vPortExitCritical>
			prvDeleteTCB( pxTCB );
 8007e48:	4620      	mov	r0, r4
 8007e4a:	f7ff ffcb 	bl	8007de4 <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8007e4e:	4b03      	ldr	r3, [pc, #12]	@ (8007e5c <prvCheckTasksWaitingTermination+0x40>)
 8007e50:	681b      	ldr	r3, [r3, #0]
 8007e52:	2b00      	cmp	r3, #0
 8007e54:	d1e6      	bne.n	8007e24 <prvCheckTasksWaitingTermination+0x8>
}
 8007e56:	bd10      	pop	{r4, pc}
 8007e58:	4770      	bx	lr
 8007e5a:	bf00      	nop
 8007e5c:	2400378c 	.word	0x2400378c
 8007e60:	24003790 	.word	0x24003790
 8007e64:	24003770 	.word	0x24003770

08007e68 <prvIdleTask>:
{
 8007e68:	b508      	push	{r3, lr}
		prvCheckTasksWaitingTermination();
 8007e6a:	f7ff ffd7 	bl	8007e1c <prvCheckTasksWaitingTermination>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8007e6e:	4b07      	ldr	r3, [pc, #28]	@ (8007e8c <prvIdleTask+0x24>)
 8007e70:	681b      	ldr	r3, [r3, #0]
 8007e72:	2b01      	cmp	r3, #1
 8007e74:	d9f9      	bls.n	8007e6a <prvIdleTask+0x2>
				taskYIELD();
 8007e76:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8007e7a:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8007e7e:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8007e82:	f3bf 8f4f 	dsb	sy
 8007e86:	f3bf 8f6f 	isb	sy
 8007e8a:	e7ee      	b.n	8007e6a <prvIdleTask+0x2>
 8007e8c:	240037e8 	.word	0x240037e8

08007e90 <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8007e90:	b570      	push	{r4, r5, r6, lr}
 8007e92:	4604      	mov	r4, r0
 8007e94:	460d      	mov	r5, r1
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 8007e96:	4b1f      	ldr	r3, [pc, #124]	@ (8007f14 <prvAddCurrentTaskToDelayedList+0x84>)
 8007e98:	681e      	ldr	r6, [r3, #0]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8007e9a:	4b1f      	ldr	r3, [pc, #124]	@ (8007f18 <prvAddCurrentTaskToDelayedList+0x88>)
 8007e9c:	6818      	ldr	r0, [r3, #0]
 8007e9e:	3004      	adds	r0, #4
 8007ea0:	f7ff f90f 	bl	80070c2 <uxListRemove>
 8007ea4:	b948      	cbnz	r0, 8007eba <prvAddCurrentTaskToDelayedList+0x2a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
 8007ea6:	4b1c      	ldr	r3, [pc, #112]	@ (8007f18 <prvAddCurrentTaskToDelayedList+0x88>)
 8007ea8:	681b      	ldr	r3, [r3, #0]
 8007eaa:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8007eac:	2201      	movs	r2, #1
 8007eae:	409a      	lsls	r2, r3
 8007eb0:	491a      	ldr	r1, [pc, #104]	@ (8007f1c <prvAddCurrentTaskToDelayedList+0x8c>)
 8007eb2:	680b      	ldr	r3, [r1, #0]
 8007eb4:	ea23 0302 	bic.w	r3, r3, r2
 8007eb8:	600b      	str	r3, [r1, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8007eba:	f1b4 3fff 	cmp.w	r4, #4294967295
 8007ebe:	bf14      	ite	ne
 8007ec0:	2300      	movne	r3, #0
 8007ec2:	2301      	moveq	r3, #1
 8007ec4:	2d00      	cmp	r5, #0
 8007ec6:	bf08      	it	eq
 8007ec8:	2300      	moveq	r3, #0
 8007eca:	b96b      	cbnz	r3, 8007ee8 <prvAddCurrentTaskToDelayedList+0x58>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
 8007ecc:	4434      	add	r4, r6

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8007ece:	4b12      	ldr	r3, [pc, #72]	@ (8007f18 <prvAddCurrentTaskToDelayedList+0x88>)
 8007ed0:	681b      	ldr	r3, [r3, #0]
 8007ed2:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
 8007ed4:	42a6      	cmp	r6, r4
 8007ed6:	d90e      	bls.n	8007ef6 <prvAddCurrentTaskToDelayedList+0x66>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8007ed8:	4b11      	ldr	r3, [pc, #68]	@ (8007f20 <prvAddCurrentTaskToDelayedList+0x90>)
 8007eda:	6818      	ldr	r0, [r3, #0]
 8007edc:	4b0e      	ldr	r3, [pc, #56]	@ (8007f18 <prvAddCurrentTaskToDelayedList+0x88>)
 8007ede:	6819      	ldr	r1, [r3, #0]
 8007ee0:	3104      	adds	r1, #4
 8007ee2:	f7ff f8d5 	bl	8007090 <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8007ee6:	bd70      	pop	{r4, r5, r6, pc}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8007ee8:	4b0b      	ldr	r3, [pc, #44]	@ (8007f18 <prvAddCurrentTaskToDelayedList+0x88>)
 8007eea:	6819      	ldr	r1, [r3, #0]
 8007eec:	3104      	adds	r1, #4
 8007eee:	480d      	ldr	r0, [pc, #52]	@ (8007f24 <prvAddCurrentTaskToDelayedList+0x94>)
 8007ef0:	f7ff f8c3 	bl	800707a <vListInsertEnd>
 8007ef4:	e7f7      	b.n	8007ee6 <prvAddCurrentTaskToDelayedList+0x56>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8007ef6:	4b0c      	ldr	r3, [pc, #48]	@ (8007f28 <prvAddCurrentTaskToDelayedList+0x98>)
 8007ef8:	6818      	ldr	r0, [r3, #0]
 8007efa:	4b07      	ldr	r3, [pc, #28]	@ (8007f18 <prvAddCurrentTaskToDelayedList+0x88>)
 8007efc:	6819      	ldr	r1, [r3, #0]
 8007efe:	3104      	adds	r1, #4
 8007f00:	f7ff f8c6 	bl	8007090 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 8007f04:	4b09      	ldr	r3, [pc, #36]	@ (8007f2c <prvAddCurrentTaskToDelayedList+0x9c>)
 8007f06:	681b      	ldr	r3, [r3, #0]
 8007f08:	42a3      	cmp	r3, r4
 8007f0a:	d9ec      	bls.n	8007ee6 <prvAddCurrentTaskToDelayedList+0x56>
					xNextTaskUnblockTime = xTimeToWake;
 8007f0c:	4b07      	ldr	r3, [pc, #28]	@ (8007f2c <prvAddCurrentTaskToDelayedList+0x9c>)
 8007f0e:	601c      	str	r4, [r3, #0]
}
 8007f10:	e7e9      	b.n	8007ee6 <prvAddCurrentTaskToDelayedList+0x56>
 8007f12:	bf00      	nop
 8007f14:	2400376c 	.word	0x2400376c
 8007f18:	24003874 	.word	0x24003874
 8007f1c:	24003768 	.word	0x24003768
 8007f20:	240037b8 	.word	0x240037b8
 8007f24:	24003778 	.word	0x24003778
 8007f28:	240037bc 	.word	0x240037bc
 8007f2c:	24003750 	.word	0x24003750

08007f30 <prvWriteNameToBuffer>:
	{
 8007f30:	b510      	push	{r4, lr}
 8007f32:	4604      	mov	r4, r0
		strcpy( pcBuffer, pcTaskName );
 8007f34:	f00c fa5d 	bl	80143f2 <strcpy>
		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
 8007f38:	4620      	mov	r0, r4
 8007f3a:	f7f8 f9d1 	bl	80002e0 <strlen>
 8007f3e:	e002      	b.n	8007f46 <prvWriteNameToBuffer+0x16>
			pcBuffer[ x ] = ' ';
 8007f40:	2320      	movs	r3, #32
 8007f42:	5423      	strb	r3, [r4, r0]
		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
 8007f44:	3001      	adds	r0, #1
 8007f46:	280a      	cmp	r0, #10
 8007f48:	d9fa      	bls.n	8007f40 <prvWriteNameToBuffer+0x10>
		pcBuffer[ x ] = ( char ) 0x00;
 8007f4a:	2300      	movs	r3, #0
 8007f4c:	5423      	strb	r3, [r4, r0]
	}
 8007f4e:	4420      	add	r0, r4
 8007f50:	bd10      	pop	{r4, pc}

08007f52 <xTaskCreateStatic>:
	{
 8007f52:	b530      	push	{r4, r5, lr}
 8007f54:	b087      	sub	sp, #28
 8007f56:	9c0b      	ldr	r4, [sp, #44]	@ 0x2c
		configASSERT( puxStackBuffer != NULL );
 8007f58:	b17c      	cbz	r4, 8007f7a <xTaskCreateStatic+0x28>
		configASSERT( pxTaskBuffer != NULL );
 8007f5a:	9d0c      	ldr	r5, [sp, #48]	@ 0x30
 8007f5c:	b1b5      	cbz	r5, 8007f8c <xTaskCreateStatic+0x3a>
			volatile size_t xSize = sizeof( StaticTask_t );
 8007f5e:	255c      	movs	r5, #92	@ 0x5c
 8007f60:	9504      	str	r5, [sp, #16]
			configASSERT( xSize == sizeof( TCB_t ) );
 8007f62:	9d04      	ldr	r5, [sp, #16]
 8007f64:	2d5c      	cmp	r5, #92	@ 0x5c
 8007f66:	d01a      	beq.n	8007f9e <xTaskCreateStatic+0x4c>
 8007f68:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007f6c:	f383 8811 	msr	BASEPRI, r3
 8007f70:	f3bf 8f6f 	isb	sy
 8007f74:	f3bf 8f4f 	dsb	sy
 8007f78:	e7fe      	b.n	8007f78 <xTaskCreateStatic+0x26>
 8007f7a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007f7e:	f383 8811 	msr	BASEPRI, r3
 8007f82:	f3bf 8f6f 	isb	sy
 8007f86:	f3bf 8f4f 	dsb	sy
		configASSERT( puxStackBuffer != NULL );
 8007f8a:	e7fe      	b.n	8007f8a <xTaskCreateStatic+0x38>
 8007f8c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007f90:	f383 8811 	msr	BASEPRI, r3
 8007f94:	f3bf 8f6f 	isb	sy
 8007f98:	f3bf 8f4f 	dsb	sy
		configASSERT( pxTaskBuffer != NULL );
 8007f9c:	e7fe      	b.n	8007f9c <xTaskCreateStatic+0x4a>
			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 8007f9e:	9d04      	ldr	r5, [sp, #16]
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 8007fa0:	9d0c      	ldr	r5, [sp, #48]	@ 0x30
 8007fa2:	632c      	str	r4, [r5, #48]	@ 0x30
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 8007fa4:	2402      	movs	r4, #2
 8007fa6:	f885 4055 	strb.w	r4, [r5, #85]	@ 0x55
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 8007faa:	2400      	movs	r4, #0
 8007fac:	9403      	str	r4, [sp, #12]
 8007fae:	9502      	str	r5, [sp, #8]
 8007fb0:	ac05      	add	r4, sp, #20
 8007fb2:	9401      	str	r4, [sp, #4]
 8007fb4:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
 8007fb6:	9400      	str	r4, [sp, #0]
 8007fb8:	f7ff fe38 	bl	8007c2c <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 8007fbc:	980c      	ldr	r0, [sp, #48]	@ 0x30
 8007fbe:	f7ff febb 	bl	8007d38 <prvAddNewTaskToReadyList>
	}
 8007fc2:	9805      	ldr	r0, [sp, #20]
 8007fc4:	b007      	add	sp, #28
 8007fc6:	bd30      	pop	{r4, r5, pc}

08007fc8 <xTaskCreate>:
	{
 8007fc8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8007fcc:	b085      	sub	sp, #20
 8007fce:	4607      	mov	r7, r0
 8007fd0:	4688      	mov	r8, r1
 8007fd2:	4614      	mov	r4, r2
 8007fd4:	461e      	mov	r6, r3
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8007fd6:	0090      	lsls	r0, r2, #2
 8007fd8:	f000 ffa4 	bl	8008f24 <pvPortMalloc>
			if( pxStack != NULL )
 8007fdc:	b308      	cbz	r0, 8008022 <xTaskCreate+0x5a>
 8007fde:	4681      	mov	r9, r0
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 8007fe0:	205c      	movs	r0, #92	@ 0x5c
 8007fe2:	f000 ff9f 	bl	8008f24 <pvPortMalloc>
				if( pxNewTCB != NULL )
 8007fe6:	4605      	mov	r5, r0
 8007fe8:	b1a8      	cbz	r0, 8008016 <xTaskCreate+0x4e>
					pxNewTCB->pxStack = pxStack;
 8007fea:	f8c0 9030 	str.w	r9, [r0, #48]	@ 0x30
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 8007fee:	2300      	movs	r3, #0
 8007ff0:	f880 3055 	strb.w	r3, [r0, #85]	@ 0x55
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 8007ff4:	9303      	str	r3, [sp, #12]
 8007ff6:	9002      	str	r0, [sp, #8]
 8007ff8:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8007ffa:	9301      	str	r3, [sp, #4]
 8007ffc:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8007ffe:	9300      	str	r3, [sp, #0]
 8008000:	4633      	mov	r3, r6
 8008002:	4622      	mov	r2, r4
 8008004:	4641      	mov	r1, r8
 8008006:	4638      	mov	r0, r7
 8008008:	f7ff fe10 	bl	8007c2c <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 800800c:	4628      	mov	r0, r5
 800800e:	f7ff fe93 	bl	8007d38 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 8008012:	2001      	movs	r0, #1
 8008014:	e007      	b.n	8008026 <xTaskCreate+0x5e>
					vPortFree( pxStack );
 8008016:	4648      	mov	r0, r9
 8008018:	f001 f806 	bl	8009028 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 800801c:	f04f 30ff 	mov.w	r0, #4294967295
 8008020:	e001      	b.n	8008026 <xTaskCreate+0x5e>
 8008022:	f04f 30ff 	mov.w	r0, #4294967295
	}
 8008026:	b005      	add	sp, #20
 8008028:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800802c <vTaskDelete>:
	{
 800802c:	b538      	push	{r3, r4, r5, lr}
 800802e:	4604      	mov	r4, r0
		taskENTER_CRITICAL();
 8008030:	f000 fdc0 	bl	8008bb4 <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 8008034:	2c00      	cmp	r4, #0
 8008036:	d034      	beq.n	80080a2 <vTaskDelete+0x76>
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8008038:	1d25      	adds	r5, r4, #4
 800803a:	4628      	mov	r0, r5
 800803c:	f7ff f841 	bl	80070c2 <uxListRemove>
 8008040:	b970      	cbnz	r0, 8008060 <vTaskDelete+0x34>
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8008042:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 8008044:	eb02 0382 	add.w	r3, r2, r2, lsl #2
 8008048:	009b      	lsls	r3, r3, #2
 800804a:	4927      	ldr	r1, [pc, #156]	@ (80080e8 <vTaskDelete+0xbc>)
 800804c:	58cb      	ldr	r3, [r1, r3]
 800804e:	b93b      	cbnz	r3, 8008060 <vTaskDelete+0x34>
 8008050:	2301      	movs	r3, #1
 8008052:	fa03 f202 	lsl.w	r2, r3, r2
 8008056:	4925      	ldr	r1, [pc, #148]	@ (80080ec <vTaskDelete+0xc0>)
 8008058:	680b      	ldr	r3, [r1, #0]
 800805a:	ea23 0302 	bic.w	r3, r3, r2
 800805e:	600b      	str	r3, [r1, #0]
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8008060:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 8008062:	b11b      	cbz	r3, 800806c <vTaskDelete+0x40>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8008064:	f104 0018 	add.w	r0, r4, #24
 8008068:	f7ff f82b 	bl	80070c2 <uxListRemove>
			uxTaskNumber++;
 800806c:	4a20      	ldr	r2, [pc, #128]	@ (80080f0 <vTaskDelete+0xc4>)
 800806e:	6813      	ldr	r3, [r2, #0]
 8008070:	3301      	adds	r3, #1
 8008072:	6013      	str	r3, [r2, #0]
			if( pxTCB == pxCurrentTCB )
 8008074:	4b1f      	ldr	r3, [pc, #124]	@ (80080f4 <vTaskDelete+0xc8>)
 8008076:	681b      	ldr	r3, [r3, #0]
 8008078:	42a3      	cmp	r3, r4
 800807a:	d015      	beq.n	80080a8 <vTaskDelete+0x7c>
				--uxCurrentNumberOfTasks;
 800807c:	4a1e      	ldr	r2, [pc, #120]	@ (80080f8 <vTaskDelete+0xcc>)
 800807e:	6813      	ldr	r3, [r2, #0]
 8008080:	3b01      	subs	r3, #1
 8008082:	6013      	str	r3, [r2, #0]
				prvDeleteTCB( pxTCB );
 8008084:	4620      	mov	r0, r4
 8008086:	f7ff fead 	bl	8007de4 <prvDeleteTCB>
				prvResetNextTaskUnblockTime();
 800808a:	f7ff fdb9 	bl	8007c00 <prvResetNextTaskUnblockTime>
		taskEXIT_CRITICAL();
 800808e:	f000 fdb3 	bl	8008bf8 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
 8008092:	4b1a      	ldr	r3, [pc, #104]	@ (80080fc <vTaskDelete+0xd0>)
 8008094:	681b      	ldr	r3, [r3, #0]
 8008096:	b11b      	cbz	r3, 80080a0 <vTaskDelete+0x74>
			if( pxTCB == pxCurrentTCB )
 8008098:	4b16      	ldr	r3, [pc, #88]	@ (80080f4 <vTaskDelete+0xc8>)
 800809a:	681b      	ldr	r3, [r3, #0]
 800809c:	42a3      	cmp	r3, r4
 800809e:	d00c      	beq.n	80080ba <vTaskDelete+0x8e>
	}
 80080a0:	bd38      	pop	{r3, r4, r5, pc}
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 80080a2:	4b14      	ldr	r3, [pc, #80]	@ (80080f4 <vTaskDelete+0xc8>)
 80080a4:	681c      	ldr	r4, [r3, #0]
 80080a6:	e7c7      	b.n	8008038 <vTaskDelete+0xc>
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 80080a8:	4629      	mov	r1, r5
 80080aa:	4815      	ldr	r0, [pc, #84]	@ (8008100 <vTaskDelete+0xd4>)
 80080ac:	f7fe ffe5 	bl	800707a <vListInsertEnd>
				++uxDeletedTasksWaitingCleanUp;
 80080b0:	4a14      	ldr	r2, [pc, #80]	@ (8008104 <vTaskDelete+0xd8>)
 80080b2:	6813      	ldr	r3, [r2, #0]
 80080b4:	3301      	adds	r3, #1
 80080b6:	6013      	str	r3, [r2, #0]
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
 80080b8:	e7e9      	b.n	800808e <vTaskDelete+0x62>
				configASSERT( uxSchedulerSuspended == 0 );
 80080ba:	4b13      	ldr	r3, [pc, #76]	@ (8008108 <vTaskDelete+0xdc>)
 80080bc:	681b      	ldr	r3, [r3, #0]
 80080be:	b143      	cbz	r3, 80080d2 <vTaskDelete+0xa6>
 80080c0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80080c4:	f383 8811 	msr	BASEPRI, r3
 80080c8:	f3bf 8f6f 	isb	sy
 80080cc:	f3bf 8f4f 	dsb	sy
 80080d0:	e7fe      	b.n	80080d0 <vTaskDelete+0xa4>
				portYIELD_WITHIN_API();
 80080d2:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 80080d6:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80080da:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 80080de:	f3bf 8f4f 	dsb	sy
 80080e2:	f3bf 8f6f 	isb	sy
	}
 80080e6:	e7db      	b.n	80080a0 <vTaskDelete+0x74>
 80080e8:	240037e8 	.word	0x240037e8
 80080ec:	24003768 	.word	0x24003768
 80080f0:	24003754 	.word	0x24003754
 80080f4:	24003874 	.word	0x24003874
 80080f8:	24003770 	.word	0x24003770
 80080fc:	24003764 	.word	0x24003764
 8008100:	24003790 	.word	0x24003790
 8008104:	2400378c 	.word	0x2400378c
 8008108:	24003748 	.word	0x24003748

0800810c <eTaskGetState>:
	{
 800810c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		configASSERT( pxTCB );
 800810e:	b1d0      	cbz	r0, 8008146 <eTaskGetState+0x3a>
 8008110:	4604      	mov	r4, r0
		if( pxTCB == pxCurrentTCB )
 8008112:	4b1c      	ldr	r3, [pc, #112]	@ (8008184 <eTaskGetState+0x78>)
 8008114:	681b      	ldr	r3, [r3, #0]
 8008116:	4283      	cmp	r3, r0
 8008118:	d02d      	beq.n	8008176 <eTaskGetState+0x6a>
			taskENTER_CRITICAL();
 800811a:	f000 fd4b 	bl	8008bb4 <vPortEnterCritical>
				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
 800811e:	6965      	ldr	r5, [r4, #20]
				pxDelayedList = pxDelayedTaskList;
 8008120:	4b19      	ldr	r3, [pc, #100]	@ (8008188 <eTaskGetState+0x7c>)
 8008122:	681f      	ldr	r7, [r3, #0]
				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
 8008124:	4b19      	ldr	r3, [pc, #100]	@ (800818c <eTaskGetState+0x80>)
 8008126:	681e      	ldr	r6, [r3, #0]
			taskEXIT_CRITICAL();
 8008128:	f000 fd66 	bl	8008bf8 <vPortExitCritical>
			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
 800812c:	42b5      	cmp	r5, r6
 800812e:	bf18      	it	ne
 8008130:	42bd      	cmpne	r5, r7
 8008132:	d022      	beq.n	800817a <eTaskGetState+0x6e>
				else if( pxStateList == &xSuspendedTaskList )
 8008134:	4b16      	ldr	r3, [pc, #88]	@ (8008190 <eTaskGetState+0x84>)
 8008136:	429d      	cmp	r5, r3
 8008138:	d00e      	beq.n	8008158 <eTaskGetState+0x4c>
				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
 800813a:	4b16      	ldr	r3, [pc, #88]	@ (8008194 <eTaskGetState+0x88>)
 800813c:	429d      	cmp	r5, r3
 800813e:	d01e      	beq.n	800817e <eTaskGetState+0x72>
 8008140:	b1bd      	cbz	r5, 8008172 <eTaskGetState+0x66>
				eReturn = eReady;
 8008142:	2001      	movs	r0, #1
 8008144:	e018      	b.n	8008178 <eTaskGetState+0x6c>
 8008146:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800814a:	f383 8811 	msr	BASEPRI, r3
 800814e:	f3bf 8f6f 	isb	sy
 8008152:	f3bf 8f4f 	dsb	sy
		configASSERT( pxTCB );
 8008156:	e7fe      	b.n	8008156 <eTaskGetState+0x4a>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
 8008158:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 800815a:	b10b      	cbz	r3, 8008160 <eTaskGetState+0x54>
						eReturn = eBlocked;
 800815c:	2002      	movs	r0, #2
 800815e:	e00b      	b.n	8008178 <eTaskGetState+0x6c>
							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 8008160:	f894 3054 	ldrb.w	r3, [r4, #84]	@ 0x54
 8008164:	b2db      	uxtb	r3, r3
 8008166:	2b01      	cmp	r3, #1
 8008168:	d001      	beq.n	800816e <eTaskGetState+0x62>
								eReturn = eSuspended;
 800816a:	2003      	movs	r0, #3
 800816c:	e004      	b.n	8008178 <eTaskGetState+0x6c>
								eReturn = eBlocked;
 800816e:	2002      	movs	r0, #2
 8008170:	e002      	b.n	8008178 <eTaskGetState+0x6c>
					eReturn = eDeleted;
 8008172:	2004      	movs	r0, #4
 8008174:	e000      	b.n	8008178 <eTaskGetState+0x6c>
			eReturn = eRunning;
 8008176:	2000      	movs	r0, #0
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 8008178:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				eReturn = eBlocked;
 800817a:	2002      	movs	r0, #2
 800817c:	e7fc      	b.n	8008178 <eTaskGetState+0x6c>
					eReturn = eDeleted;
 800817e:	2004      	movs	r0, #4
 8008180:	e7fa      	b.n	8008178 <eTaskGetState+0x6c>
 8008182:	bf00      	nop
 8008184:	24003874 	.word	0x24003874
 8008188:	240037bc 	.word	0x240037bc
 800818c:	240037b8 	.word	0x240037b8
 8008190:	24003778 	.word	0x24003778
 8008194:	24003790 	.word	0x24003790

08008198 <vTaskStartScheduler>:
{
 8008198:	b510      	push	{r4, lr}
 800819a:	b088      	sub	sp, #32
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
 800819c:	2400      	movs	r4, #0
 800819e:	9405      	str	r4, [sp, #20]
		StackType_t *pxIdleTaskStackBuffer = NULL;
 80081a0:	9406      	str	r4, [sp, #24]
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 80081a2:	aa07      	add	r2, sp, #28
 80081a4:	a906      	add	r1, sp, #24
 80081a6:	a805      	add	r0, sp, #20
 80081a8:	f7f8 faca 	bl	8000740 <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
 80081ac:	9b05      	ldr	r3, [sp, #20]
 80081ae:	9302      	str	r3, [sp, #8]
 80081b0:	9b06      	ldr	r3, [sp, #24]
 80081b2:	9301      	str	r3, [sp, #4]
 80081b4:	9400      	str	r4, [sp, #0]
 80081b6:	4623      	mov	r3, r4
 80081b8:	9a07      	ldr	r2, [sp, #28]
 80081ba:	490e      	ldr	r1, [pc, #56]	@ (80081f4 <vTaskStartScheduler+0x5c>)
 80081bc:	480e      	ldr	r0, [pc, #56]	@ (80081f8 <vTaskStartScheduler+0x60>)
 80081be:	f7ff fec8 	bl	8007f52 <xTaskCreateStatic>
 80081c2:	4b0e      	ldr	r3, [pc, #56]	@ (80081fc <vTaskStartScheduler+0x64>)
 80081c4:	6018      	str	r0, [r3, #0]
		if( xIdleTaskHandle != NULL )
 80081c6:	b190      	cbz	r0, 80081ee <vTaskStartScheduler+0x56>
 80081c8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80081cc:	f383 8811 	msr	BASEPRI, r3
 80081d0:	f3bf 8f6f 	isb	sy
 80081d4:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 80081d8:	4b09      	ldr	r3, [pc, #36]	@ (8008200 <vTaskStartScheduler+0x68>)
 80081da:	f04f 32ff 	mov.w	r2, #4294967295
 80081de:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 80081e0:	4b08      	ldr	r3, [pc, #32]	@ (8008204 <vTaskStartScheduler+0x6c>)
 80081e2:	2201      	movs	r2, #1
 80081e4:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 80081e6:	4b08      	ldr	r3, [pc, #32]	@ (8008208 <vTaskStartScheduler+0x70>)
 80081e8:	601c      	str	r4, [r3, #0]
		if( xPortStartScheduler() != pdFALSE )
 80081ea:	f000 fd7d 	bl	8008ce8 <xPortStartScheduler>
}
 80081ee:	b008      	add	sp, #32
 80081f0:	bd10      	pop	{r4, pc}
 80081f2:	bf00      	nop
 80081f4:	080156d4 	.word	0x080156d4
 80081f8:	08007e69 	.word	0x08007e69
 80081fc:	2400374c 	.word	0x2400374c
 8008200:	24003750 	.word	0x24003750
 8008204:	24003764 	.word	0x24003764
 8008208:	2400376c 	.word	0x2400376c

0800820c <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 800820c:	4a02      	ldr	r2, [pc, #8]	@ (8008218 <vTaskSuspendAll+0xc>)
 800820e:	6813      	ldr	r3, [r2, #0]
 8008210:	3301      	adds	r3, #1
 8008212:	6013      	str	r3, [r2, #0]
}
 8008214:	4770      	bx	lr
 8008216:	bf00      	nop
 8008218:	24003748 	.word	0x24003748

0800821c <xTaskGetTickCount>:
		xTicks = xTickCount;
 800821c:	4b01      	ldr	r3, [pc, #4]	@ (8008224 <xTaskGetTickCount+0x8>)
 800821e:	6818      	ldr	r0, [r3, #0]
}
 8008220:	4770      	bx	lr
 8008222:	bf00      	nop
 8008224:	2400376c 	.word	0x2400376c

08008228 <xTaskGetTickCountFromISR>:
{
 8008228:	b508      	push	{r3, lr}
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800822a:	f000 fde9 	bl	8008e00 <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 800822e:	4b01      	ldr	r3, [pc, #4]	@ (8008234 <xTaskGetTickCountFromISR+0xc>)
 8008230:	6818      	ldr	r0, [r3, #0]
}
 8008232:	bd08      	pop	{r3, pc}
 8008234:	2400376c 	.word	0x2400376c

08008238 <xTaskIncrementTick>:
{
 8008238:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800823a:	4b3a      	ldr	r3, [pc, #232]	@ (8008324 <xTaskIncrementTick+0xec>)
 800823c:	681b      	ldr	r3, [r3, #0]
 800823e:	2b00      	cmp	r3, #0
 8008240:	d169      	bne.n	8008316 <xTaskIncrementTick+0xde>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8008242:	4b39      	ldr	r3, [pc, #228]	@ (8008328 <xTaskIncrementTick+0xf0>)
 8008244:	681d      	ldr	r5, [r3, #0]
 8008246:	3501      	adds	r5, #1
		xTickCount = xConstTickCount;
 8008248:	601d      	str	r5, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 800824a:	b9c5      	cbnz	r5, 800827e <xTaskIncrementTick+0x46>
			taskSWITCH_DELAYED_LISTS();
 800824c:	4b37      	ldr	r3, [pc, #220]	@ (800832c <xTaskIncrementTick+0xf4>)
 800824e:	681b      	ldr	r3, [r3, #0]
 8008250:	681b      	ldr	r3, [r3, #0]
 8008252:	b143      	cbz	r3, 8008266 <xTaskIncrementTick+0x2e>
 8008254:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008258:	f383 8811 	msr	BASEPRI, r3
 800825c:	f3bf 8f6f 	isb	sy
 8008260:	f3bf 8f4f 	dsb	sy
 8008264:	e7fe      	b.n	8008264 <xTaskIncrementTick+0x2c>
 8008266:	4a31      	ldr	r2, [pc, #196]	@ (800832c <xTaskIncrementTick+0xf4>)
 8008268:	6811      	ldr	r1, [r2, #0]
 800826a:	4b31      	ldr	r3, [pc, #196]	@ (8008330 <xTaskIncrementTick+0xf8>)
 800826c:	6818      	ldr	r0, [r3, #0]
 800826e:	6010      	str	r0, [r2, #0]
 8008270:	6019      	str	r1, [r3, #0]
 8008272:	4a30      	ldr	r2, [pc, #192]	@ (8008334 <xTaskIncrementTick+0xfc>)
 8008274:	6813      	ldr	r3, [r2, #0]
 8008276:	3301      	adds	r3, #1
 8008278:	6013      	str	r3, [r2, #0]
 800827a:	f7ff fcc1 	bl	8007c00 <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 800827e:	4b2e      	ldr	r3, [pc, #184]	@ (8008338 <xTaskIncrementTick+0x100>)
 8008280:	681b      	ldr	r3, [r3, #0]
 8008282:	42ab      	cmp	r3, r5
 8008284:	d93d      	bls.n	8008302 <xTaskIncrementTick+0xca>
BaseType_t xSwitchRequired = pdFALSE;
 8008286:	2700      	movs	r7, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8008288:	4b2c      	ldr	r3, [pc, #176]	@ (800833c <xTaskIncrementTick+0x104>)
 800828a:	681b      	ldr	r3, [r3, #0]
 800828c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800828e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8008292:	009a      	lsls	r2, r3, #2
 8008294:	4b2a      	ldr	r3, [pc, #168]	@ (8008340 <xTaskIncrementTick+0x108>)
 8008296:	589b      	ldr	r3, [r3, r2]
 8008298:	2b01      	cmp	r3, #1
 800829a:	d900      	bls.n	800829e <xTaskIncrementTick+0x66>
				xSwitchRequired = pdTRUE;
 800829c:	2701      	movs	r7, #1
			if( xYieldPending != pdFALSE )
 800829e:	4b29      	ldr	r3, [pc, #164]	@ (8008344 <xTaskIncrementTick+0x10c>)
 80082a0:	681b      	ldr	r3, [r3, #0]
 80082a2:	2b00      	cmp	r3, #0
 80082a4:	d03c      	beq.n	8008320 <xTaskIncrementTick+0xe8>
				xSwitchRequired = pdTRUE;
 80082a6:	2701      	movs	r7, #1
	return xSwitchRequired;
 80082a8:	e03a      	b.n	8008320 <xTaskIncrementTick+0xe8>
							xSwitchRequired = pdTRUE;
 80082aa:	2701      	movs	r7, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80082ac:	4b1f      	ldr	r3, [pc, #124]	@ (800832c <xTaskIncrementTick+0xf4>)
 80082ae:	681b      	ldr	r3, [r3, #0]
 80082b0:	681b      	ldr	r3, [r3, #0]
 80082b2:	b343      	cbz	r3, 8008306 <xTaskIncrementTick+0xce>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80082b4:	4b1d      	ldr	r3, [pc, #116]	@ (800832c <xTaskIncrementTick+0xf4>)
 80082b6:	681b      	ldr	r3, [r3, #0]
 80082b8:	68db      	ldr	r3, [r3, #12]
 80082ba:	68dc      	ldr	r4, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 80082bc:	6863      	ldr	r3, [r4, #4]
					if( xConstTickCount < xItemValue )
 80082be:	429d      	cmp	r5, r3
 80082c0:	d326      	bcc.n	8008310 <xTaskIncrementTick+0xd8>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80082c2:	1d26      	adds	r6, r4, #4
 80082c4:	4630      	mov	r0, r6
 80082c6:	f7fe fefc 	bl	80070c2 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80082ca:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 80082cc:	b11b      	cbz	r3, 80082d6 <xTaskIncrementTick+0x9e>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80082ce:	f104 0018 	add.w	r0, r4, #24
 80082d2:	f7fe fef6 	bl	80070c2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 80082d6:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 80082d8:	2201      	movs	r2, #1
 80082da:	409a      	lsls	r2, r3
 80082dc:	491a      	ldr	r1, [pc, #104]	@ (8008348 <xTaskIncrementTick+0x110>)
 80082de:	6808      	ldr	r0, [r1, #0]
 80082e0:	4302      	orrs	r2, r0
 80082e2:	600a      	str	r2, [r1, #0]
 80082e4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80082e8:	009a      	lsls	r2, r3, #2
 80082ea:	4631      	mov	r1, r6
 80082ec:	4814      	ldr	r0, [pc, #80]	@ (8008340 <xTaskIncrementTick+0x108>)
 80082ee:	4410      	add	r0, r2
 80082f0:	f7fe fec3 	bl	800707a <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80082f4:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 80082f6:	4b11      	ldr	r3, [pc, #68]	@ (800833c <xTaskIncrementTick+0x104>)
 80082f8:	681b      	ldr	r3, [r3, #0]
 80082fa:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80082fc:	429a      	cmp	r2, r3
 80082fe:	d2d4      	bcs.n	80082aa <xTaskIncrementTick+0x72>
 8008300:	e7d4      	b.n	80082ac <xTaskIncrementTick+0x74>
BaseType_t xSwitchRequired = pdFALSE;
 8008302:	2700      	movs	r7, #0
 8008304:	e7d2      	b.n	80082ac <xTaskIncrementTick+0x74>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8008306:	4b0c      	ldr	r3, [pc, #48]	@ (8008338 <xTaskIncrementTick+0x100>)
 8008308:	f04f 32ff 	mov.w	r2, #4294967295
 800830c:	601a      	str	r2, [r3, #0]
					break;
 800830e:	e7bb      	b.n	8008288 <xTaskIncrementTick+0x50>
						xNextTaskUnblockTime = xItemValue;
 8008310:	4a09      	ldr	r2, [pc, #36]	@ (8008338 <xTaskIncrementTick+0x100>)
 8008312:	6013      	str	r3, [r2, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 8008314:	e7b8      	b.n	8008288 <xTaskIncrementTick+0x50>
		++xPendedTicks;
 8008316:	4a0d      	ldr	r2, [pc, #52]	@ (800834c <xTaskIncrementTick+0x114>)
 8008318:	6813      	ldr	r3, [r2, #0]
 800831a:	3301      	adds	r3, #1
 800831c:	6013      	str	r3, [r2, #0]
BaseType_t xSwitchRequired = pdFALSE;
 800831e:	2700      	movs	r7, #0
}
 8008320:	4638      	mov	r0, r7
 8008322:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008324:	24003748 	.word	0x24003748
 8008328:	2400376c 	.word	0x2400376c
 800832c:	240037bc 	.word	0x240037bc
 8008330:	240037b8 	.word	0x240037b8
 8008334:	24003758 	.word	0x24003758
 8008338:	24003750 	.word	0x24003750
 800833c:	24003874 	.word	0x24003874
 8008340:	240037e8 	.word	0x240037e8
 8008344:	2400375c 	.word	0x2400375c
 8008348:	24003768 	.word	0x24003768
 800834c:	24003760 	.word	0x24003760

08008350 <xTaskResumeAll>:
{
 8008350:	b538      	push	{r3, r4, r5, lr}
	configASSERT( uxSchedulerSuspended );
 8008352:	4b35      	ldr	r3, [pc, #212]	@ (8008428 <xTaskResumeAll+0xd8>)
 8008354:	681b      	ldr	r3, [r3, #0]
 8008356:	b943      	cbnz	r3, 800836a <xTaskResumeAll+0x1a>
 8008358:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800835c:	f383 8811 	msr	BASEPRI, r3
 8008360:	f3bf 8f6f 	isb	sy
 8008364:	f3bf 8f4f 	dsb	sy
 8008368:	e7fe      	b.n	8008368 <xTaskResumeAll+0x18>
	taskENTER_CRITICAL();
 800836a:	f000 fc23 	bl	8008bb4 <vPortEnterCritical>
		--uxSchedulerSuspended;
 800836e:	4b2e      	ldr	r3, [pc, #184]	@ (8008428 <xTaskResumeAll+0xd8>)
 8008370:	681a      	ldr	r2, [r3, #0]
 8008372:	3a01      	subs	r2, #1
 8008374:	601a      	str	r2, [r3, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8008376:	681b      	ldr	r3, [r3, #0]
 8008378:	2b00      	cmp	r3, #0
 800837a:	d14f      	bne.n	800841c <xTaskResumeAll+0xcc>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 800837c:	4b2b      	ldr	r3, [pc, #172]	@ (800842c <xTaskResumeAll+0xdc>)
 800837e:	681b      	ldr	r3, [r3, #0]
 8008380:	b90b      	cbnz	r3, 8008386 <xTaskResumeAll+0x36>
BaseType_t xAlreadyYielded = pdFALSE;
 8008382:	2400      	movs	r4, #0
 8008384:	e04b      	b.n	800841e <xTaskResumeAll+0xce>
TCB_t *pxTCB = NULL;
 8008386:	2400      	movs	r4, #0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8008388:	4b29      	ldr	r3, [pc, #164]	@ (8008430 <xTaskResumeAll+0xe0>)
 800838a:	681b      	ldr	r3, [r3, #0]
 800838c:	b31b      	cbz	r3, 80083d6 <xTaskResumeAll+0x86>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800838e:	4b28      	ldr	r3, [pc, #160]	@ (8008430 <xTaskResumeAll+0xe0>)
 8008390:	68db      	ldr	r3, [r3, #12]
 8008392:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8008394:	f104 0018 	add.w	r0, r4, #24
 8008398:	f7fe fe93 	bl	80070c2 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800839c:	1d25      	adds	r5, r4, #4
 800839e:	4628      	mov	r0, r5
 80083a0:	f7fe fe8f 	bl	80070c2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 80083a4:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 80083a6:	2301      	movs	r3, #1
 80083a8:	4083      	lsls	r3, r0
 80083aa:	4a22      	ldr	r2, [pc, #136]	@ (8008434 <xTaskResumeAll+0xe4>)
 80083ac:	6811      	ldr	r1, [r2, #0]
 80083ae:	430b      	orrs	r3, r1
 80083b0:	6013      	str	r3, [r2, #0]
 80083b2:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80083b6:	4629      	mov	r1, r5
 80083b8:	4b1f      	ldr	r3, [pc, #124]	@ (8008438 <xTaskResumeAll+0xe8>)
 80083ba:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 80083be:	f7fe fe5c 	bl	800707a <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80083c2:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 80083c4:	4b1d      	ldr	r3, [pc, #116]	@ (800843c <xTaskResumeAll+0xec>)
 80083c6:	681b      	ldr	r3, [r3, #0]
 80083c8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80083ca:	429a      	cmp	r2, r3
 80083cc:	d3dc      	bcc.n	8008388 <xTaskResumeAll+0x38>
						xYieldPending = pdTRUE;
 80083ce:	4b1c      	ldr	r3, [pc, #112]	@ (8008440 <xTaskResumeAll+0xf0>)
 80083d0:	2201      	movs	r2, #1
 80083d2:	601a      	str	r2, [r3, #0]
 80083d4:	e7d8      	b.n	8008388 <xTaskResumeAll+0x38>
				if( pxTCB != NULL )
 80083d6:	b10c      	cbz	r4, 80083dc <xTaskResumeAll+0x8c>
					prvResetNextTaskUnblockTime();
 80083d8:	f7ff fc12 	bl	8007c00 <prvResetNextTaskUnblockTime>
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 80083dc:	4b19      	ldr	r3, [pc, #100]	@ (8008444 <xTaskResumeAll+0xf4>)
 80083de:	681c      	ldr	r4, [r3, #0]
					if( xPendedCounts > ( TickType_t ) 0U )
 80083e0:	b984      	cbnz	r4, 8008404 <xTaskResumeAll+0xb4>
				if( xYieldPending != pdFALSE )
 80083e2:	4b17      	ldr	r3, [pc, #92]	@ (8008440 <xTaskResumeAll+0xf0>)
 80083e4:	681c      	ldr	r4, [r3, #0]
 80083e6:	b1d4      	cbz	r4, 800841e <xTaskResumeAll+0xce>
					taskYIELD_IF_USING_PREEMPTION();
 80083e8:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 80083ec:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80083f0:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 80083f4:	f3bf 8f4f 	dsb	sy
 80083f8:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 80083fc:	2401      	movs	r4, #1
 80083fe:	e00e      	b.n	800841e <xTaskResumeAll+0xce>
						} while( xPendedCounts > ( TickType_t ) 0U );
 8008400:	3c01      	subs	r4, #1
 8008402:	d007      	beq.n	8008414 <xTaskResumeAll+0xc4>
							if( xTaskIncrementTick() != pdFALSE )
 8008404:	f7ff ff18 	bl	8008238 <xTaskIncrementTick>
 8008408:	2800      	cmp	r0, #0
 800840a:	d0f9      	beq.n	8008400 <xTaskResumeAll+0xb0>
								xYieldPending = pdTRUE;
 800840c:	4b0c      	ldr	r3, [pc, #48]	@ (8008440 <xTaskResumeAll+0xf0>)
 800840e:	2201      	movs	r2, #1
 8008410:	601a      	str	r2, [r3, #0]
 8008412:	e7f5      	b.n	8008400 <xTaskResumeAll+0xb0>
						xPendedTicks = 0;
 8008414:	4b0b      	ldr	r3, [pc, #44]	@ (8008444 <xTaskResumeAll+0xf4>)
 8008416:	2200      	movs	r2, #0
 8008418:	601a      	str	r2, [r3, #0]
 800841a:	e7e2      	b.n	80083e2 <xTaskResumeAll+0x92>
BaseType_t xAlreadyYielded = pdFALSE;
 800841c:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 800841e:	f000 fbeb 	bl	8008bf8 <vPortExitCritical>
}
 8008422:	4620      	mov	r0, r4
 8008424:	bd38      	pop	{r3, r4, r5, pc}
 8008426:	bf00      	nop
 8008428:	24003748 	.word	0x24003748
 800842c:	24003770 	.word	0x24003770
 8008430:	240037a4 	.word	0x240037a4
 8008434:	24003768 	.word	0x24003768
 8008438:	240037e8 	.word	0x240037e8
 800843c:	24003874 	.word	0x24003874
 8008440:	2400375c 	.word	0x2400375c
 8008444:	24003760 	.word	0x24003760

08008448 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8008448:	4b24      	ldr	r3, [pc, #144]	@ (80084dc <vTaskSwitchContext+0x94>)
 800844a:	681b      	ldr	r3, [r3, #0]
 800844c:	b11b      	cbz	r3, 8008456 <vTaskSwitchContext+0xe>
		xYieldPending = pdTRUE;
 800844e:	4b24      	ldr	r3, [pc, #144]	@ (80084e0 <vTaskSwitchContext+0x98>)
 8008450:	2201      	movs	r2, #1
 8008452:	601a      	str	r2, [r3, #0]
 8008454:	4770      	bx	lr
		xYieldPending = pdFALSE;
 8008456:	4b22      	ldr	r3, [pc, #136]	@ (80084e0 <vTaskSwitchContext+0x98>)
 8008458:	2200      	movs	r2, #0
 800845a:	601a      	str	r2, [r3, #0]
			pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
 800845c:	4b21      	ldr	r3, [pc, #132]	@ (80084e4 <vTaskSwitchContext+0x9c>)
 800845e:	681b      	ldr	r3, [r3, #0]
 8008460:	4a21      	ldr	r2, [pc, #132]	@ (80084e8 <vTaskSwitchContext+0xa0>)
 8008462:	6812      	ldr	r2, [r2, #0]
 8008464:	659a      	str	r2, [r3, #88]	@ 0x58
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8008466:	4b21      	ldr	r3, [pc, #132]	@ (80084ec <vTaskSwitchContext+0xa4>)
 8008468:	681b      	ldr	r3, [r3, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 800846a:	fab3 f383 	clz	r3, r3
 800846e:	b2db      	uxtb	r3, r3
 8008470:	f1c3 031f 	rsb	r3, r3, #31
 8008474:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8008478:	008a      	lsls	r2, r1, #2
 800847a:	491d      	ldr	r1, [pc, #116]	@ (80084f0 <vTaskSwitchContext+0xa8>)
 800847c:	588a      	ldr	r2, [r1, r2]
 800847e:	b942      	cbnz	r2, 8008492 <vTaskSwitchContext+0x4a>
	__asm volatile
 8008480:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008484:	f383 8811 	msr	BASEPRI, r3
 8008488:	f3bf 8f6f 	isb	sy
 800848c:	f3bf 8f4f 	dsb	sy
 8008490:	e7fe      	b.n	8008490 <vTaskSwitchContext+0x48>
 8008492:	4817      	ldr	r0, [pc, #92]	@ (80084f0 <vTaskSwitchContext+0xa8>)
 8008494:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8008498:	008a      	lsls	r2, r1, #2
 800849a:	4402      	add	r2, r0
 800849c:	6851      	ldr	r1, [r2, #4]
 800849e:	6849      	ldr	r1, [r1, #4]
 80084a0:	6051      	str	r1, [r2, #4]
 80084a2:	eb03 0c83 	add.w	ip, r3, r3, lsl #2
 80084a6:	ea4f 028c 	mov.w	r2, ip, lsl #2
 80084aa:	3208      	adds	r2, #8
 80084ac:	4402      	add	r2, r0
 80084ae:	4291      	cmp	r1, r2
 80084b0:	d00d      	beq.n	80084ce <vTaskSwitchContext+0x86>
 80084b2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80084b6:	009a      	lsls	r2, r3, #2
 80084b8:	4b0d      	ldr	r3, [pc, #52]	@ (80084f0 <vTaskSwitchContext+0xa8>)
 80084ba:	4413      	add	r3, r2
 80084bc:	685b      	ldr	r3, [r3, #4]
 80084be:	68da      	ldr	r2, [r3, #12]
 80084c0:	4b08      	ldr	r3, [pc, #32]	@ (80084e4 <vTaskSwitchContext+0x9c>)
 80084c2:	601a      	str	r2, [r3, #0]
			FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
 80084c4:	681b      	ldr	r3, [r3, #0]
 80084c6:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 80084c8:	4b07      	ldr	r3, [pc, #28]	@ (80084e8 <vTaskSwitchContext+0xa0>)
 80084ca:	601a      	str	r2, [r3, #0]
}
 80084cc:	4770      	bx	lr
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80084ce:	6848      	ldr	r0, [r1, #4]
 80084d0:	4662      	mov	r2, ip
 80084d2:	0091      	lsls	r1, r2, #2
 80084d4:	4a06      	ldr	r2, [pc, #24]	@ (80084f0 <vTaskSwitchContext+0xa8>)
 80084d6:	440a      	add	r2, r1
 80084d8:	6050      	str	r0, [r2, #4]
 80084da:	e7ea      	b.n	80084b2 <vTaskSwitchContext+0x6a>
 80084dc:	24003748 	.word	0x24003748
 80084e0:	2400375c 	.word	0x2400375c
 80084e4:	24003874 	.word	0x24003874
 80084e8:	24003774 	.word	0x24003774
 80084ec:	24003768 	.word	0x24003768
 80084f0:	240037e8 	.word	0x240037e8

080084f4 <vTaskPlaceOnEventList>:
	configASSERT( pxEventList );
 80084f4:	b158      	cbz	r0, 800850e <vTaskPlaceOnEventList+0x1a>
{
 80084f6:	b510      	push	{r4, lr}
 80084f8:	460c      	mov	r4, r1
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80084fa:	4a09      	ldr	r2, [pc, #36]	@ (8008520 <vTaskPlaceOnEventList+0x2c>)
 80084fc:	6811      	ldr	r1, [r2, #0]
 80084fe:	3118      	adds	r1, #24
 8008500:	f7fe fdc6 	bl	8007090 <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8008504:	2101      	movs	r1, #1
 8008506:	4620      	mov	r0, r4
 8008508:	f7ff fcc2 	bl	8007e90 <prvAddCurrentTaskToDelayedList>
}
 800850c:	bd10      	pop	{r4, pc}
 800850e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008512:	f383 8811 	msr	BASEPRI, r3
 8008516:	f3bf 8f6f 	isb	sy
 800851a:	f3bf 8f4f 	dsb	sy
	configASSERT( pxEventList );
 800851e:	e7fe      	b.n	800851e <vTaskPlaceOnEventList+0x2a>
 8008520:	24003874 	.word	0x24003874

08008524 <xTaskRemoveFromEventList>:
{
 8008524:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8008526:	68c3      	ldr	r3, [r0, #12]
 8008528:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 800852a:	b324      	cbz	r4, 8008576 <xTaskRemoveFromEventList+0x52>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 800852c:	f104 0518 	add.w	r5, r4, #24
 8008530:	4628      	mov	r0, r5
 8008532:	f7fe fdc6 	bl	80070c2 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8008536:	4b18      	ldr	r3, [pc, #96]	@ (8008598 <xTaskRemoveFromEventList+0x74>)
 8008538:	681b      	ldr	r3, [r3, #0]
 800853a:	bb2b      	cbnz	r3, 8008588 <xTaskRemoveFromEventList+0x64>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 800853c:	1d25      	adds	r5, r4, #4
 800853e:	4628      	mov	r0, r5
 8008540:	f7fe fdbf 	bl	80070c2 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 8008544:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 8008546:	2301      	movs	r3, #1
 8008548:	4083      	lsls	r3, r0
 800854a:	4a14      	ldr	r2, [pc, #80]	@ (800859c <xTaskRemoveFromEventList+0x78>)
 800854c:	6811      	ldr	r1, [r2, #0]
 800854e:	430b      	orrs	r3, r1
 8008550:	6013      	str	r3, [r2, #0]
 8008552:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8008556:	4629      	mov	r1, r5
 8008558:	4b11      	ldr	r3, [pc, #68]	@ (80085a0 <xTaskRemoveFromEventList+0x7c>)
 800855a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800855e:	f7fe fd8c 	bl	800707a <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8008562:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 8008564:	4b0f      	ldr	r3, [pc, #60]	@ (80085a4 <xTaskRemoveFromEventList+0x80>)
 8008566:	681b      	ldr	r3, [r3, #0]
 8008568:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800856a:	429a      	cmp	r2, r3
 800856c:	d911      	bls.n	8008592 <xTaskRemoveFromEventList+0x6e>
		xYieldPending = pdTRUE;
 800856e:	2001      	movs	r0, #1
 8008570:	4b0d      	ldr	r3, [pc, #52]	@ (80085a8 <xTaskRemoveFromEventList+0x84>)
 8008572:	6018      	str	r0, [r3, #0]
}
 8008574:	bd38      	pop	{r3, r4, r5, pc}
 8008576:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800857a:	f383 8811 	msr	BASEPRI, r3
 800857e:	f3bf 8f6f 	isb	sy
 8008582:	f3bf 8f4f 	dsb	sy
	configASSERT( pxUnblockedTCB );
 8008586:	e7fe      	b.n	8008586 <xTaskRemoveFromEventList+0x62>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8008588:	4629      	mov	r1, r5
 800858a:	4808      	ldr	r0, [pc, #32]	@ (80085ac <xTaskRemoveFromEventList+0x88>)
 800858c:	f7fe fd75 	bl	800707a <vListInsertEnd>
 8008590:	e7e7      	b.n	8008562 <xTaskRemoveFromEventList+0x3e>
		xReturn = pdFALSE;
 8008592:	2000      	movs	r0, #0
	return xReturn;
 8008594:	e7ee      	b.n	8008574 <xTaskRemoveFromEventList+0x50>
 8008596:	bf00      	nop
 8008598:	24003748 	.word	0x24003748
 800859c:	24003768 	.word	0x24003768
 80085a0:	240037e8 	.word	0x240037e8
 80085a4:	24003874 	.word	0x24003874
 80085a8:	2400375c 	.word	0x2400375c
 80085ac:	240037a4 	.word	0x240037a4

080085b0 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 80085b0:	4b03      	ldr	r3, [pc, #12]	@ (80085c0 <vTaskInternalSetTimeOutState+0x10>)
 80085b2:	681b      	ldr	r3, [r3, #0]
 80085b4:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 80085b6:	4b03      	ldr	r3, [pc, #12]	@ (80085c4 <vTaskInternalSetTimeOutState+0x14>)
 80085b8:	681b      	ldr	r3, [r3, #0]
 80085ba:	6043      	str	r3, [r0, #4]
}
 80085bc:	4770      	bx	lr
 80085be:	bf00      	nop
 80085c0:	24003758 	.word	0x24003758
 80085c4:	2400376c 	.word	0x2400376c

080085c8 <xTaskCheckForTimeOut>:
{
 80085c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT( pxTimeOut );
 80085ca:	b1c8      	cbz	r0, 8008600 <xTaskCheckForTimeOut+0x38>
 80085cc:	460c      	mov	r4, r1
 80085ce:	4605      	mov	r5, r0
	configASSERT( pxTicksToWait );
 80085d0:	b1f9      	cbz	r1, 8008612 <xTaskCheckForTimeOut+0x4a>
	taskENTER_CRITICAL();
 80085d2:	f000 faef 	bl	8008bb4 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
 80085d6:	4b1b      	ldr	r3, [pc, #108]	@ (8008644 <xTaskCheckForTimeOut+0x7c>)
 80085d8:	6819      	ldr	r1, [r3, #0]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 80085da:	686b      	ldr	r3, [r5, #4]
 80085dc:	1ac8      	subs	r0, r1, r3
			if( *pxTicksToWait == portMAX_DELAY )
 80085de:	6822      	ldr	r2, [r4, #0]
 80085e0:	f1b2 3fff 	cmp.w	r2, #4294967295
 80085e4:	d026      	beq.n	8008634 <xTaskCheckForTimeOut+0x6c>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 80085e6:	4e18      	ldr	r6, [pc, #96]	@ (8008648 <xTaskCheckForTimeOut+0x80>)
 80085e8:	6836      	ldr	r6, [r6, #0]
 80085ea:	682f      	ldr	r7, [r5, #0]
 80085ec:	42b7      	cmp	r7, r6
 80085ee:	d001      	beq.n	80085f4 <xTaskCheckForTimeOut+0x2c>
 80085f0:	428b      	cmp	r3, r1
 80085f2:	d924      	bls.n	800863e <xTaskCheckForTimeOut+0x76>
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 80085f4:	4282      	cmp	r2, r0
 80085f6:	d815      	bhi.n	8008624 <xTaskCheckForTimeOut+0x5c>
			*pxTicksToWait = 0;
 80085f8:	2300      	movs	r3, #0
 80085fa:	6023      	str	r3, [r4, #0]
			xReturn = pdTRUE;
 80085fc:	2401      	movs	r4, #1
 80085fe:	e01a      	b.n	8008636 <xTaskCheckForTimeOut+0x6e>
 8008600:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008604:	f383 8811 	msr	BASEPRI, r3
 8008608:	f3bf 8f6f 	isb	sy
 800860c:	f3bf 8f4f 	dsb	sy
	configASSERT( pxTimeOut );
 8008610:	e7fe      	b.n	8008610 <xTaskCheckForTimeOut+0x48>
 8008612:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008616:	f383 8811 	msr	BASEPRI, r3
 800861a:	f3bf 8f6f 	isb	sy
 800861e:	f3bf 8f4f 	dsb	sy
	configASSERT( pxTicksToWait );
 8008622:	e7fe      	b.n	8008622 <xTaskCheckForTimeOut+0x5a>
			*pxTicksToWait -= xElapsedTime;
 8008624:	1a5b      	subs	r3, r3, r1
 8008626:	4413      	add	r3, r2
 8008628:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
 800862a:	4628      	mov	r0, r5
 800862c:	f7ff ffc0 	bl	80085b0 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
 8008630:	2400      	movs	r4, #0
 8008632:	e000      	b.n	8008636 <xTaskCheckForTimeOut+0x6e>
				xReturn = pdFALSE;
 8008634:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 8008636:	f000 fadf 	bl	8008bf8 <vPortExitCritical>
}
 800863a:	4620      	mov	r0, r4
 800863c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			xReturn = pdTRUE;
 800863e:	2401      	movs	r4, #1
 8008640:	e7f9      	b.n	8008636 <xTaskCheckForTimeOut+0x6e>
 8008642:	bf00      	nop
 8008644:	2400376c 	.word	0x2400376c
 8008648:	24003758 	.word	0x24003758

0800864c <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 800864c:	4b01      	ldr	r3, [pc, #4]	@ (8008654 <vTaskMissedYield+0x8>)
 800864e:	2201      	movs	r2, #1
 8008650:	601a      	str	r2, [r3, #0]
}
 8008652:	4770      	bx	lr
 8008654:	2400375c 	.word	0x2400375c

08008658 <vTaskGetInfo>:
	{
 8008658:	b570      	push	{r4, r5, r6, lr}
 800865a:	460c      	mov	r4, r1
 800865c:	4616      	mov	r6, r2
		pxTCB = prvGetTCBFromHandle( xTask );
 800865e:	4605      	mov	r5, r0
 8008660:	b1d0      	cbz	r0, 8008698 <vTaskGetInfo+0x40>
		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
 8008662:	6025      	str	r5, [r4, #0]
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
 8008664:	f105 0234 	add.w	r2, r5, #52	@ 0x34
 8008668:	6062      	str	r2, [r4, #4]
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
 800866a:	6aea      	ldr	r2, [r5, #44]	@ 0x2c
 800866c:	6122      	str	r2, [r4, #16]
		pxTaskStatus->pxStackBase = pxTCB->pxStack;
 800866e:	6b2a      	ldr	r2, [r5, #48]	@ 0x30
 8008670:	61e2      	str	r2, [r4, #28]
		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
 8008672:	6c2a      	ldr	r2, [r5, #64]	@ 0x40
 8008674:	60a2      	str	r2, [r4, #8]
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
 8008676:	6caa      	ldr	r2, [r5, #72]	@ 0x48
 8008678:	6162      	str	r2, [r4, #20]
			pxTaskStatus->ulRunTimeCounter = 0;
 800867a:	2200      	movs	r2, #0
 800867c:	61a2      	str	r2, [r4, #24]
		if( eState != eInvalid )
 800867e:	2b05      	cmp	r3, #5
 8008680:	d019      	beq.n	80086b6 <vTaskGetInfo+0x5e>
			if( pxTCB == pxCurrentTCB )
 8008682:	4a12      	ldr	r2, [pc, #72]	@ (80086cc <vTaskGetInfo+0x74>)
 8008684:	6812      	ldr	r2, [r2, #0]
 8008686:	42aa      	cmp	r2, r5
 8008688:	d009      	beq.n	800869e <vTaskGetInfo+0x46>
				pxTaskStatus->eCurrentState = eState;
 800868a:	7323      	strb	r3, [r4, #12]
					if( eState == eSuspended )
 800868c:	2b03      	cmp	r3, #3
 800868e:	d009      	beq.n	80086a4 <vTaskGetInfo+0x4c>
		if( xGetFreeStackSpace != pdFALSE )
 8008690:	b9b6      	cbnz	r6, 80086c0 <vTaskGetInfo+0x68>
			pxTaskStatus->usStackHighWaterMark = 0;
 8008692:	2300      	movs	r3, #0
 8008694:	8423      	strh	r3, [r4, #32]
	}
 8008696:	bd70      	pop	{r4, r5, r6, pc}
		pxTCB = prvGetTCBFromHandle( xTask );
 8008698:	4a0c      	ldr	r2, [pc, #48]	@ (80086cc <vTaskGetInfo+0x74>)
 800869a:	6815      	ldr	r5, [r2, #0]
 800869c:	e7e1      	b.n	8008662 <vTaskGetInfo+0xa>
				pxTaskStatus->eCurrentState = eRunning;
 800869e:	2300      	movs	r3, #0
 80086a0:	7323      	strb	r3, [r4, #12]
 80086a2:	e7f5      	b.n	8008690 <vTaskGetInfo+0x38>
						vTaskSuspendAll();
 80086a4:	f7ff fdb2 	bl	800820c <vTaskSuspendAll>
							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80086a8:	6aab      	ldr	r3, [r5, #40]	@ 0x28
 80086aa:	b10b      	cbz	r3, 80086b0 <vTaskGetInfo+0x58>
								pxTaskStatus->eCurrentState = eBlocked;
 80086ac:	2302      	movs	r3, #2
 80086ae:	7323      	strb	r3, [r4, #12]
						( void ) xTaskResumeAll();
 80086b0:	f7ff fe4e 	bl	8008350 <xTaskResumeAll>
 80086b4:	e7ec      	b.n	8008690 <vTaskGetInfo+0x38>
			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
 80086b6:	4628      	mov	r0, r5
 80086b8:	f7ff fd28 	bl	800810c <eTaskGetState>
 80086bc:	7320      	strb	r0, [r4, #12]
 80086be:	e7e7      	b.n	8008690 <vTaskGetInfo+0x38>
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
 80086c0:	6b28      	ldr	r0, [r5, #48]	@ 0x30
 80086c2:	f7ff fa93 	bl	8007bec <prvTaskCheckFreeStackSpace>
 80086c6:	8420      	strh	r0, [r4, #32]
 80086c8:	e7e5      	b.n	8008696 <vTaskGetInfo+0x3e>
 80086ca:	bf00      	nop
 80086cc:	24003874 	.word	0x24003874

080086d0 <prvListTasksWithinSingleList>:
	{
 80086d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 80086d4:	680c      	ldr	r4, [r1, #0]
 80086d6:	b33c      	cbz	r4, 8008728 <prvListTasksWithinSingleList+0x58>
 80086d8:	4607      	mov	r7, r0
 80086da:	460d      	mov	r5, r1
 80086dc:	4690      	mov	r8, r2
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80086de:	684b      	ldr	r3, [r1, #4]
 80086e0:	685b      	ldr	r3, [r3, #4]
 80086e2:	604b      	str	r3, [r1, #4]
 80086e4:	f101 0908 	add.w	r9, r1, #8
 80086e8:	454b      	cmp	r3, r9
 80086ea:	d004      	beq.n	80086f6 <prvListTasksWithinSingleList+0x26>
 80086ec:	686b      	ldr	r3, [r5, #4]
 80086ee:	f8d3 a00c 	ldr.w	sl, [r3, #12]
	UBaseType_t uxTask = 0;
 80086f2:	2400      	movs	r4, #0
 80086f4:	e010      	b.n	8008718 <prvListTasksWithinSingleList+0x48>
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80086f6:	685b      	ldr	r3, [r3, #4]
 80086f8:	604b      	str	r3, [r1, #4]
 80086fa:	e7f7      	b.n	80086ec <prvListTasksWithinSingleList+0x1c>
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80086fc:	686b      	ldr	r3, [r5, #4]
 80086fe:	68de      	ldr	r6, [r3, #12]
				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
 8008700:	eb04 01c4 	add.w	r1, r4, r4, lsl #3
 8008704:	4643      	mov	r3, r8
 8008706:	2201      	movs	r2, #1
 8008708:	eb07 0181 	add.w	r1, r7, r1, lsl #2
 800870c:	4630      	mov	r0, r6
 800870e:	f7ff ffa3 	bl	8008658 <vTaskGetInfo>
				uxTask++;
 8008712:	3401      	adds	r4, #1
			} while( pxNextTCB != pxFirstTCB );
 8008714:	45b2      	cmp	sl, r6
 8008716:	d007      	beq.n	8008728 <prvListTasksWithinSingleList+0x58>
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8008718:	686b      	ldr	r3, [r5, #4]
 800871a:	6859      	ldr	r1, [r3, #4]
 800871c:	6069      	str	r1, [r5, #4]
 800871e:	4589      	cmp	r9, r1
 8008720:	d1ec      	bne.n	80086fc <prvListTasksWithinSingleList+0x2c>
 8008722:	684b      	ldr	r3, [r1, #4]
 8008724:	606b      	str	r3, [r5, #4]
 8008726:	e7e9      	b.n	80086fc <prvListTasksWithinSingleList+0x2c>
	}
 8008728:	4620      	mov	r0, r4
 800872a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

08008730 <uxTaskGetSystemState>:
	{
 8008730:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008732:	4606      	mov	r6, r0
 8008734:	460c      	mov	r4, r1
 8008736:	4617      	mov	r7, r2
		vTaskSuspendAll();
 8008738:	f7ff fd68 	bl	800820c <vTaskSuspendAll>
			if( uxArraySize >= uxCurrentNumberOfTasks )
 800873c:	4b22      	ldr	r3, [pc, #136]	@ (80087c8 <uxTaskGetSystemState+0x98>)
 800873e:	681b      	ldr	r3, [r3, #0]
 8008740:	42a3      	cmp	r3, r4
 8008742:	d83b      	bhi.n	80087bc <uxTaskGetSystemState+0x8c>
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 8008744:	2507      	movs	r5, #7
 8008746:	2400      	movs	r4, #0
					uxQueue--;
 8008748:	3d01      	subs	r5, #1
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
 800874a:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800874e:	eb05 0185 	add.w	r1, r5, r5, lsl #2
 8008752:	2201      	movs	r2, #1
 8008754:	4b1d      	ldr	r3, [pc, #116]	@ (80087cc <uxTaskGetSystemState+0x9c>)
 8008756:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 800875a:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 800875e:	f7ff ffb7 	bl	80086d0 <prvListTasksWithinSingleList>
 8008762:	4404      	add	r4, r0
				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8008764:	2d00      	cmp	r5, #0
 8008766:	d1ef      	bne.n	8008748 <uxTaskGetSystemState+0x18>
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
 8008768:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800876c:	4b18      	ldr	r3, [pc, #96]	@ (80087d0 <uxTaskGetSystemState+0xa0>)
 800876e:	6819      	ldr	r1, [r3, #0]
 8008770:	2202      	movs	r2, #2
 8008772:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 8008776:	f7ff ffab 	bl	80086d0 <prvListTasksWithinSingleList>
 800877a:	4404      	add	r4, r0
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
 800877c:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 8008780:	4b14      	ldr	r3, [pc, #80]	@ (80087d4 <uxTaskGetSystemState+0xa4>)
 8008782:	6819      	ldr	r1, [r3, #0]
 8008784:	2202      	movs	r2, #2
 8008786:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 800878a:	f7ff ffa1 	bl	80086d0 <prvListTasksWithinSingleList>
 800878e:	4404      	add	r4, r0
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
 8008790:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 8008794:	2204      	movs	r2, #4
 8008796:	4910      	ldr	r1, [pc, #64]	@ (80087d8 <uxTaskGetSystemState+0xa8>)
 8008798:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 800879c:	f7ff ff98 	bl	80086d0 <prvListTasksWithinSingleList>
 80087a0:	4404      	add	r4, r0
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
 80087a2:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 80087a6:	2203      	movs	r2, #3
 80087a8:	490c      	ldr	r1, [pc, #48]	@ (80087dc <uxTaskGetSystemState+0xac>)
 80087aa:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 80087ae:	f7ff ff8f 	bl	80086d0 <prvListTasksWithinSingleList>
 80087b2:	4404      	add	r4, r0
					if( pulTotalRunTime != NULL )
 80087b4:	b11f      	cbz	r7, 80087be <uxTaskGetSystemState+0x8e>
						*pulTotalRunTime = 0;
 80087b6:	2300      	movs	r3, #0
 80087b8:	603b      	str	r3, [r7, #0]
 80087ba:	e000      	b.n	80087be <uxTaskGetSystemState+0x8e>
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 80087bc:	2400      	movs	r4, #0
		( void ) xTaskResumeAll();
 80087be:	f7ff fdc7 	bl	8008350 <xTaskResumeAll>
	}
 80087c2:	4620      	mov	r0, r4
 80087c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80087c6:	bf00      	nop
 80087c8:	24003770 	.word	0x24003770
 80087cc:	240037e8 	.word	0x240037e8
 80087d0:	240037bc 	.word	0x240037bc
 80087d4:	240037b8 	.word	0x240037b8
 80087d8:	24003790 	.word	0x24003790
 80087dc:	24003778 	.word	0x24003778

080087e0 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 80087e0:	4b05      	ldr	r3, [pc, #20]	@ (80087f8 <xTaskGetSchedulerState+0x18>)
 80087e2:	681b      	ldr	r3, [r3, #0]
 80087e4:	b133      	cbz	r3, 80087f4 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80087e6:	4b05      	ldr	r3, [pc, #20]	@ (80087fc <xTaskGetSchedulerState+0x1c>)
 80087e8:	681b      	ldr	r3, [r3, #0]
 80087ea:	b10b      	cbz	r3, 80087f0 <xTaskGetSchedulerState+0x10>
				xReturn = taskSCHEDULER_SUSPENDED;
 80087ec:	2000      	movs	r0, #0
	}
 80087ee:	4770      	bx	lr
				xReturn = taskSCHEDULER_RUNNING;
 80087f0:	2002      	movs	r0, #2
 80087f2:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 80087f4:	2001      	movs	r0, #1
 80087f6:	4770      	bx	lr
 80087f8:	24003764 	.word	0x24003764
 80087fc:	24003748 	.word	0x24003748

08008800 <xTaskPriorityInherit>:
		if( pxMutexHolder != NULL )
 8008800:	2800      	cmp	r0, #0
 8008802:	d048      	beq.n	8008896 <xTaskPriorityInherit+0x96>
	{
 8008804:	b538      	push	{r3, r4, r5, lr}
 8008806:	4604      	mov	r4, r0
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 8008808:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
 800880a:	4a25      	ldr	r2, [pc, #148]	@ (80088a0 <xTaskPriorityInherit+0xa0>)
 800880c:	6812      	ldr	r2, [r2, #0]
 800880e:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 8008810:	4293      	cmp	r3, r2
 8008812:	d238      	bcs.n	8008886 <xTaskPriorityInherit+0x86>
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8008814:	6982      	ldr	r2, [r0, #24]
 8008816:	2a00      	cmp	r2, #0
 8008818:	db05      	blt.n	8008826 <xTaskPriorityInherit+0x26>
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800881a:	4a21      	ldr	r2, [pc, #132]	@ (80088a0 <xTaskPriorityInherit+0xa0>)
 800881c:	6812      	ldr	r2, [r2, #0]
 800881e:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 8008820:	f1c2 0207 	rsb	r2, r2, #7
 8008824:	6182      	str	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 8008826:	6961      	ldr	r1, [r4, #20]
 8008828:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800882c:	4a1d      	ldr	r2, [pc, #116]	@ (80088a4 <xTaskPriorityInherit+0xa4>)
 800882e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8008832:	4299      	cmp	r1, r3
 8008834:	d005      	beq.n	8008842 <xTaskPriorityInherit+0x42>
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 8008836:	4b1a      	ldr	r3, [pc, #104]	@ (80088a0 <xTaskPriorityInherit+0xa0>)
 8008838:	681b      	ldr	r3, [r3, #0]
 800883a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800883c:	62e3      	str	r3, [r4, #44]	@ 0x2c
				xReturn = pdTRUE;
 800883e:	2001      	movs	r0, #1
	}
 8008840:	bd38      	pop	{r3, r4, r5, pc}
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8008842:	1d25      	adds	r5, r4, #4
 8008844:	4628      	mov	r0, r5
 8008846:	f7fe fc3c 	bl	80070c2 <uxListRemove>
 800884a:	b938      	cbnz	r0, 800885c <xTaskPriorityInherit+0x5c>
						portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
 800884c:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 800884e:	2201      	movs	r2, #1
 8008850:	409a      	lsls	r2, r3
 8008852:	4915      	ldr	r1, [pc, #84]	@ (80088a8 <xTaskPriorityInherit+0xa8>)
 8008854:	680b      	ldr	r3, [r1, #0]
 8008856:	ea23 0302 	bic.w	r3, r3, r2
 800885a:	600b      	str	r3, [r1, #0]
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 800885c:	4b10      	ldr	r3, [pc, #64]	@ (80088a0 <xTaskPriorityInherit+0xa0>)
 800885e:	681b      	ldr	r3, [r3, #0]
 8008860:	6ad8      	ldr	r0, [r3, #44]	@ 0x2c
 8008862:	62e0      	str	r0, [r4, #44]	@ 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
 8008864:	2401      	movs	r4, #1
 8008866:	fa04 f300 	lsl.w	r3, r4, r0
 800886a:	4a0f      	ldr	r2, [pc, #60]	@ (80088a8 <xTaskPriorityInherit+0xa8>)
 800886c:	6811      	ldr	r1, [r2, #0]
 800886e:	430b      	orrs	r3, r1
 8008870:	6013      	str	r3, [r2, #0]
 8008872:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8008876:	4629      	mov	r1, r5
 8008878:	4b0a      	ldr	r3, [pc, #40]	@ (80088a4 <xTaskPriorityInherit+0xa4>)
 800887a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800887e:	f7fe fbfc 	bl	800707a <vListInsertEnd>
				xReturn = pdTRUE;
 8008882:	4620      	mov	r0, r4
 8008884:	e7dc      	b.n	8008840 <xTaskPriorityInherit+0x40>
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 8008886:	6c82      	ldr	r2, [r0, #72]	@ 0x48
 8008888:	4b05      	ldr	r3, [pc, #20]	@ (80088a0 <xTaskPriorityInherit+0xa0>)
 800888a:	681b      	ldr	r3, [r3, #0]
 800888c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800888e:	429a      	cmp	r2, r3
 8008890:	d303      	bcc.n	800889a <xTaskPriorityInherit+0x9a>
	BaseType_t xReturn = pdFALSE;
 8008892:	2000      	movs	r0, #0
 8008894:	e7d4      	b.n	8008840 <xTaskPriorityInherit+0x40>
 8008896:	2000      	movs	r0, #0
	}
 8008898:	4770      	bx	lr
					xReturn = pdTRUE;
 800889a:	2001      	movs	r0, #1
		return xReturn;
 800889c:	e7d0      	b.n	8008840 <xTaskPriorityInherit+0x40>
 800889e:	bf00      	nop
 80088a0:	24003874 	.word	0x24003874
 80088a4:	240037e8 	.word	0x240037e8
 80088a8:	24003768 	.word	0x24003768

080088ac <xTaskPriorityDisinherit>:
		if( pxMutexHolder != NULL )
 80088ac:	2800      	cmp	r0, #0
 80088ae:	d04b      	beq.n	8008948 <xTaskPriorityDisinherit+0x9c>
	{
 80088b0:	b538      	push	{r3, r4, r5, lr}
 80088b2:	4604      	mov	r4, r0
			configASSERT( pxTCB == pxCurrentTCB );
 80088b4:	4b26      	ldr	r3, [pc, #152]	@ (8008950 <xTaskPriorityDisinherit+0xa4>)
 80088b6:	681b      	ldr	r3, [r3, #0]
 80088b8:	4283      	cmp	r3, r0
 80088ba:	d008      	beq.n	80088ce <xTaskPriorityDisinherit+0x22>
 80088bc:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80088c0:	f383 8811 	msr	BASEPRI, r3
 80088c4:	f3bf 8f6f 	isb	sy
 80088c8:	f3bf 8f4f 	dsb	sy
 80088cc:	e7fe      	b.n	80088cc <xTaskPriorityDisinherit+0x20>
			configASSERT( pxTCB->uxMutexesHeld );
 80088ce:	6cc3      	ldr	r3, [r0, #76]	@ 0x4c
 80088d0:	b943      	cbnz	r3, 80088e4 <xTaskPriorityDisinherit+0x38>
 80088d2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80088d6:	f383 8811 	msr	BASEPRI, r3
 80088da:	f3bf 8f6f 	isb	sy
 80088de:	f3bf 8f4f 	dsb	sy
 80088e2:	e7fe      	b.n	80088e2 <xTaskPriorityDisinherit+0x36>
			( pxTCB->uxMutexesHeld )--;
 80088e4:	3b01      	subs	r3, #1
 80088e6:	64c3      	str	r3, [r0, #76]	@ 0x4c
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 80088e8:	6ac1      	ldr	r1, [r0, #44]	@ 0x2c
 80088ea:	6c82      	ldr	r2, [r0, #72]	@ 0x48
 80088ec:	4291      	cmp	r1, r2
 80088ee:	d02d      	beq.n	800894c <xTaskPriorityDisinherit+0xa0>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 80088f0:	b10b      	cbz	r3, 80088f6 <xTaskPriorityDisinherit+0x4a>
	BaseType_t xReturn = pdFALSE;
 80088f2:	2000      	movs	r0, #0
	}
 80088f4:	bd38      	pop	{r3, r4, r5, pc}
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80088f6:	1d05      	adds	r5, r0, #4
 80088f8:	4628      	mov	r0, r5
 80088fa:	f7fe fbe2 	bl	80070c2 <uxListRemove>
 80088fe:	b968      	cbnz	r0, 800891c <xTaskPriorityDisinherit+0x70>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8008900:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 8008902:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 8008906:	0092      	lsls	r2, r2, #2
 8008908:	4912      	ldr	r1, [pc, #72]	@ (8008954 <xTaskPriorityDisinherit+0xa8>)
 800890a:	588a      	ldr	r2, [r1, r2]
 800890c:	b932      	cbnz	r2, 800891c <xTaskPriorityDisinherit+0x70>
 800890e:	2201      	movs	r2, #1
 8008910:	409a      	lsls	r2, r3
 8008912:	4911      	ldr	r1, [pc, #68]	@ (8008958 <xTaskPriorityDisinherit+0xac>)
 8008914:	680b      	ldr	r3, [r1, #0]
 8008916:	ea23 0302 	bic.w	r3, r3, r2
 800891a:	600b      	str	r3, [r1, #0]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 800891c:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
 800891e:	62e0      	str	r0, [r4, #44]	@ 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8008920:	f1c0 0307 	rsb	r3, r0, #7
 8008924:	61a3      	str	r3, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 8008926:	2401      	movs	r4, #1
 8008928:	fa04 f300 	lsl.w	r3, r4, r0
 800892c:	4a0a      	ldr	r2, [pc, #40]	@ (8008958 <xTaskPriorityDisinherit+0xac>)
 800892e:	6811      	ldr	r1, [r2, #0]
 8008930:	430b      	orrs	r3, r1
 8008932:	6013      	str	r3, [r2, #0]
 8008934:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8008938:	4629      	mov	r1, r5
 800893a:	4b06      	ldr	r3, [pc, #24]	@ (8008954 <xTaskPriorityDisinherit+0xa8>)
 800893c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8008940:	f7fe fb9b 	bl	800707a <vListInsertEnd>
					xReturn = pdTRUE;
 8008944:	4620      	mov	r0, r4
 8008946:	e7d5      	b.n	80088f4 <xTaskPriorityDisinherit+0x48>
	BaseType_t xReturn = pdFALSE;
 8008948:	2000      	movs	r0, #0
	}
 800894a:	4770      	bx	lr
	BaseType_t xReturn = pdFALSE;
 800894c:	2000      	movs	r0, #0
 800894e:	e7d1      	b.n	80088f4 <xTaskPriorityDisinherit+0x48>
 8008950:	24003874 	.word	0x24003874
 8008954:	240037e8 	.word	0x240037e8
 8008958:	24003768 	.word	0x24003768

0800895c <vTaskPriorityDisinheritAfterTimeout>:
		if( pxMutexHolder != NULL )
 800895c:	2800      	cmp	r0, #0
 800895e:	d04f      	beq.n	8008a00 <vTaskPriorityDisinheritAfterTimeout+0xa4>
	{
 8008960:	b538      	push	{r3, r4, r5, lr}
 8008962:	4604      	mov	r4, r0
			configASSERT( pxTCB->uxMutexesHeld );
 8008964:	6cc3      	ldr	r3, [r0, #76]	@ 0x4c
 8008966:	b943      	cbnz	r3, 800897a <vTaskPriorityDisinheritAfterTimeout+0x1e>
 8008968:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800896c:	f383 8811 	msr	BASEPRI, r3
 8008970:	f3bf 8f6f 	isb	sy
 8008974:	f3bf 8f4f 	dsb	sy
 8008978:	e7fe      	b.n	8008978 <vTaskPriorityDisinheritAfterTimeout+0x1c>
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 800897a:	6c82      	ldr	r2, [r0, #72]	@ 0x48
 800897c:	428a      	cmp	r2, r1
 800897e:	d200      	bcs.n	8008982 <vTaskPriorityDisinheritAfterTimeout+0x26>
				uxPriorityToUse = uxHighestPriorityWaitingTask;
 8008980:	460a      	mov	r2, r1
			if( pxTCB->uxPriority != uxPriorityToUse )
 8008982:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 8008984:	4291      	cmp	r1, r2
 8008986:	d001      	beq.n	800898c <vTaskPriorityDisinheritAfterTimeout+0x30>
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 8008988:	2b01      	cmp	r3, #1
 800898a:	d000      	beq.n	800898e <vTaskPriorityDisinheritAfterTimeout+0x32>
	}
 800898c:	bd38      	pop	{r3, r4, r5, pc}
					configASSERT( pxTCB != pxCurrentTCB );
 800898e:	4b1d      	ldr	r3, [pc, #116]	@ (8008a04 <vTaskPriorityDisinheritAfterTimeout+0xa8>)
 8008990:	681b      	ldr	r3, [r3, #0]
 8008992:	42a3      	cmp	r3, r4
 8008994:	d02b      	beq.n	80089ee <vTaskPriorityDisinheritAfterTimeout+0x92>
					pxTCB->uxPriority = uxPriorityToUse;
 8008996:	62e2      	str	r2, [r4, #44]	@ 0x2c
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8008998:	69a3      	ldr	r3, [r4, #24]
 800899a:	2b00      	cmp	r3, #0
 800899c:	db02      	blt.n	80089a4 <vTaskPriorityDisinheritAfterTimeout+0x48>
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800899e:	f1c2 0207 	rsb	r2, r2, #7
 80089a2:	61a2      	str	r2, [r4, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 80089a4:	6962      	ldr	r2, [r4, #20]
 80089a6:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 80089aa:	4b17      	ldr	r3, [pc, #92]	@ (8008a08 <vTaskPriorityDisinheritAfterTimeout+0xac>)
 80089ac:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 80089b0:	429a      	cmp	r2, r3
 80089b2:	d1eb      	bne.n	800898c <vTaskPriorityDisinheritAfterTimeout+0x30>
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80089b4:	1d25      	adds	r5, r4, #4
 80089b6:	4628      	mov	r0, r5
 80089b8:	f7fe fb83 	bl	80070c2 <uxListRemove>
 80089bc:	b938      	cbnz	r0, 80089ce <vTaskPriorityDisinheritAfterTimeout+0x72>
							portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
 80089be:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 80089c0:	2201      	movs	r2, #1
 80089c2:	409a      	lsls	r2, r3
 80089c4:	4911      	ldr	r1, [pc, #68]	@ (8008a0c <vTaskPriorityDisinheritAfterTimeout+0xb0>)
 80089c6:	680b      	ldr	r3, [r1, #0]
 80089c8:	ea23 0302 	bic.w	r3, r3, r2
 80089cc:	600b      	str	r3, [r1, #0]
						prvAddTaskToReadyList( pxTCB );
 80089ce:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 80089d0:	2301      	movs	r3, #1
 80089d2:	4083      	lsls	r3, r0
 80089d4:	4a0d      	ldr	r2, [pc, #52]	@ (8008a0c <vTaskPriorityDisinheritAfterTimeout+0xb0>)
 80089d6:	6811      	ldr	r1, [r2, #0]
 80089d8:	430b      	orrs	r3, r1
 80089da:	6013      	str	r3, [r2, #0]
 80089dc:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80089e0:	4629      	mov	r1, r5
 80089e2:	4b09      	ldr	r3, [pc, #36]	@ (8008a08 <vTaskPriorityDisinheritAfterTimeout+0xac>)
 80089e4:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 80089e8:	f7fe fb47 	bl	800707a <vListInsertEnd>
	}
 80089ec:	e7ce      	b.n	800898c <vTaskPriorityDisinheritAfterTimeout+0x30>
 80089ee:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80089f2:	f383 8811 	msr	BASEPRI, r3
 80089f6:	f3bf 8f6f 	isb	sy
 80089fa:	f3bf 8f4f 	dsb	sy
					configASSERT( pxTCB != pxCurrentTCB );
 80089fe:	e7fe      	b.n	80089fe <vTaskPriorityDisinheritAfterTimeout+0xa2>
 8008a00:	4770      	bx	lr
 8008a02:	bf00      	nop
 8008a04:	24003874 	.word	0x24003874
 8008a08:	240037e8 	.word	0x240037e8
 8008a0c:	24003768 	.word	0x24003768

08008a10 <vTaskList>:
	{
 8008a10:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8008a14:	b083      	sub	sp, #12
 8008a16:	4606      	mov	r6, r0
		*pcWriteBuffer = ( char ) 0x00;
 8008a18:	2300      	movs	r3, #0
 8008a1a:	7003      	strb	r3, [r0, #0]
		uxArraySize = uxCurrentNumberOfTasks;
 8008a1c:	4b29      	ldr	r3, [pc, #164]	@ (8008ac4 <vTaskList+0xb4>)
 8008a1e:	681c      	ldr	r4, [r3, #0]
		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */
 8008a20:	6818      	ldr	r0, [r3, #0]
 8008a22:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
 8008a26:	0080      	lsls	r0, r0, #2
 8008a28:	f000 fa7c 	bl	8008f24 <pvPortMalloc>
		if( pxTaskStatusArray != NULL )
 8008a2c:	2800      	cmp	r0, #0
 8008a2e:	d045      	beq.n	8008abc <vTaskList+0xac>
 8008a30:	4680      	mov	r8, r0
			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
 8008a32:	2200      	movs	r2, #0
 8008a34:	4621      	mov	r1, r4
 8008a36:	f7ff fe7b 	bl	8008730 <uxTaskGetSystemState>
 8008a3a:	4607      	mov	r7, r0
			for( x = 0; x < uxArraySize; x++ )
 8008a3c:	2500      	movs	r5, #0
 8008a3e:	e014      	b.n	8008a6a <vTaskList+0x5a>
				switch( pxTaskStatusArray[ x ].eCurrentState )
 8008a40:	f04f 0958 	mov.w	r9, #88	@ 0x58
				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
 8008a44:	6861      	ldr	r1, [r4, #4]
 8008a46:	4630      	mov	r0, r6
 8008a48:	f7ff fa72 	bl	8007f30 <prvWriteNameToBuffer>
 8008a4c:	4606      	mov	r6, r0
				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
 8008a4e:	6923      	ldr	r3, [r4, #16]
 8008a50:	8c22      	ldrh	r2, [r4, #32]
 8008a52:	68a1      	ldr	r1, [r4, #8]
 8008a54:	9101      	str	r1, [sp, #4]
 8008a56:	9200      	str	r2, [sp, #0]
 8008a58:	464a      	mov	r2, r9
 8008a5a:	491b      	ldr	r1, [pc, #108]	@ (8008ac8 <vTaskList+0xb8>)
 8008a5c:	f00b fb08 	bl	8014070 <siprintf>
				pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
 8008a60:	4630      	mov	r0, r6
 8008a62:	f7f7 fc3d 	bl	80002e0 <strlen>
 8008a66:	4406      	add	r6, r0
			for( x = 0; x < uxArraySize; x++ )
 8008a68:	3501      	adds	r5, #1
 8008a6a:	42bd      	cmp	r5, r7
 8008a6c:	d223      	bcs.n	8008ab6 <vTaskList+0xa6>
				switch( pxTaskStatusArray[ x ].eCurrentState )
 8008a6e:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
 8008a72:	eb08 0484 	add.w	r4, r8, r4, lsl #2
 8008a76:	7b23      	ldrb	r3, [r4, #12]
 8008a78:	2b04      	cmp	r3, #4
 8008a7a:	d816      	bhi.n	8008aaa <vTaskList+0x9a>
 8008a7c:	a201      	add	r2, pc, #4	@ (adr r2, 8008a84 <vTaskList+0x74>)
 8008a7e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008a82:	bf00      	nop
 8008a84:	08008a41 	.word	0x08008a41
 8008a88:	08008ab1 	.word	0x08008ab1
 8008a8c:	08008a99 	.word	0x08008a99
 8008a90:	08008a9f 	.word	0x08008a9f
 8008a94:	08008aa5 	.word	0x08008aa5
					case eBlocked:		cStatus = tskBLOCKED_CHAR;
 8008a98:	f04f 0942 	mov.w	r9, #66	@ 0x42
										break;
 8008a9c:	e7d2      	b.n	8008a44 <vTaskList+0x34>
					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
 8008a9e:	f04f 0953 	mov.w	r9, #83	@ 0x53
										break;
 8008aa2:	e7cf      	b.n	8008a44 <vTaskList+0x34>
					case eDeleted:		cStatus = tskDELETED_CHAR;
 8008aa4:	f04f 0944 	mov.w	r9, #68	@ 0x44
										break;
 8008aa8:	e7cc      	b.n	8008a44 <vTaskList+0x34>
										cStatus = ( char ) 0x00;
 8008aaa:	f04f 0900 	mov.w	r9, #0
										break;
 8008aae:	e7c9      	b.n	8008a44 <vTaskList+0x34>
					case eReady:		cStatus = tskREADY_CHAR;
 8008ab0:	f04f 0952 	mov.w	r9, #82	@ 0x52
 8008ab4:	e7c6      	b.n	8008a44 <vTaskList+0x34>
			vPortFree( pxTaskStatusArray );
 8008ab6:	4640      	mov	r0, r8
 8008ab8:	f000 fab6 	bl	8009028 <vPortFree>
	}
 8008abc:	b003      	add	sp, #12
 8008abe:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8008ac2:	bf00      	nop
 8008ac4:	24003770 	.word	0x24003770
 8008ac8:	080156dc 	.word	0x080156dc

08008acc <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
 8008acc:	4b05      	ldr	r3, [pc, #20]	@ (8008ae4 <pvTaskIncrementMutexHeldCount+0x18>)
 8008ace:	681b      	ldr	r3, [r3, #0]
 8008ad0:	b123      	cbz	r3, 8008adc <pvTaskIncrementMutexHeldCount+0x10>
			( pxCurrentTCB->uxMutexesHeld )++;
 8008ad2:	4b04      	ldr	r3, [pc, #16]	@ (8008ae4 <pvTaskIncrementMutexHeldCount+0x18>)
 8008ad4:	681a      	ldr	r2, [r3, #0]
 8008ad6:	6cd3      	ldr	r3, [r2, #76]	@ 0x4c
 8008ad8:	3301      	adds	r3, #1
 8008ada:	64d3      	str	r3, [r2, #76]	@ 0x4c
		return pxCurrentTCB;
 8008adc:	4b01      	ldr	r3, [pc, #4]	@ (8008ae4 <pvTaskIncrementMutexHeldCount+0x18>)
 8008ade:	6818      	ldr	r0, [r3, #0]
	}
 8008ae0:	4770      	bx	lr
 8008ae2:	bf00      	nop
 8008ae4:	24003874 	.word	0x24003874

08008ae8 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 8008ae8:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
 8008aea:	2300      	movs	r3, #0
 8008aec:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 8008aee:	4b0d      	ldr	r3, [pc, #52]	@ (8008b24 <prvTaskExitError+0x3c>)
 8008af0:	681b      	ldr	r3, [r3, #0]
 8008af2:	f1b3 3fff 	cmp.w	r3, #4294967295
 8008af6:	d008      	beq.n	8008b0a <prvTaskExitError+0x22>
 8008af8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008afc:	f383 8811 	msr	BASEPRI, r3
 8008b00:	f3bf 8f6f 	isb	sy
 8008b04:	f3bf 8f4f 	dsb	sy
 8008b08:	e7fe      	b.n	8008b08 <prvTaskExitError+0x20>
 8008b0a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008b0e:	f383 8811 	msr	BASEPRI, r3
 8008b12:	f3bf 8f6f 	isb	sy
 8008b16:	f3bf 8f4f 	dsb	sy
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
 8008b1a:	9b01      	ldr	r3, [sp, #4]
 8008b1c:	2b00      	cmp	r3, #0
 8008b1e:	d0fc      	beq.n	8008b1a <prvTaskExitError+0x32>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
 8008b20:	b002      	add	sp, #8
 8008b22:	4770      	bx	lr
 8008b24:	24000010 	.word	0x24000010

08008b28 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
 8008b28:	4808      	ldr	r0, [pc, #32]	@ (8008b4c <prvPortStartFirstTask+0x24>)
 8008b2a:	6800      	ldr	r0, [r0, #0]
 8008b2c:	6800      	ldr	r0, [r0, #0]
 8008b2e:	f380 8808 	msr	MSP, r0
 8008b32:	f04f 0000 	mov.w	r0, #0
 8008b36:	f380 8814 	msr	CONTROL, r0
 8008b3a:	b662      	cpsie	i
 8008b3c:	b661      	cpsie	f
 8008b3e:	f3bf 8f4f 	dsb	sy
 8008b42:	f3bf 8f6f 	isb	sy
 8008b46:	df00      	svc	0
 8008b48:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
 8008b4a:	0000      	.short	0x0000
 8008b4c:	e000ed08 	.word	0xe000ed08

08008b50 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 8008b50:	f8df 000c 	ldr.w	r0, [pc, #12]	@ 8008b60 <vPortEnableVFP+0x10>
 8008b54:	6801      	ldr	r1, [r0, #0]
 8008b56:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 8008b5a:	6001      	str	r1, [r0, #0]
 8008b5c:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
 8008b5e:	0000      	.short	0x0000
 8008b60:	e000ed88 	.word	0xe000ed88

08008b64 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8008b64:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 8008b68:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 8008b6c:	f021 0101 	bic.w	r1, r1, #1
 8008b70:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8008b74:	4b05      	ldr	r3, [pc, #20]	@ (8008b8c <pxPortInitialiseStack+0x28>)
 8008b76:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8008b7a:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 8008b7e:	f06f 0302 	mvn.w	r3, #2
 8008b82:	f840 3c24 	str.w	r3, [r0, #-36]
}
 8008b86:	3844      	subs	r0, #68	@ 0x44
 8008b88:	4770      	bx	lr
 8008b8a:	bf00      	nop
 8008b8c:	08008ae9 	.word	0x08008ae9

08008b90 <SVC_Handler>:
	__asm volatile (
 8008b90:	4b07      	ldr	r3, [pc, #28]	@ (8008bb0 <pxCurrentTCBConst2>)
 8008b92:	6819      	ldr	r1, [r3, #0]
 8008b94:	6808      	ldr	r0, [r1, #0]
 8008b96:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008b9a:	f380 8809 	msr	PSP, r0
 8008b9e:	f3bf 8f6f 	isb	sy
 8008ba2:	f04f 0000 	mov.w	r0, #0
 8008ba6:	f380 8811 	msr	BASEPRI, r0
 8008baa:	4770      	bx	lr
 8008bac:	f3af 8000 	nop.w

08008bb0 <pxCurrentTCBConst2>:
 8008bb0:	24003874 	.word	0x24003874

08008bb4 <vPortEnterCritical>:
 8008bb4:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008bb8:	f383 8811 	msr	BASEPRI, r3
 8008bbc:	f3bf 8f6f 	isb	sy
 8008bc0:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
 8008bc4:	4a0b      	ldr	r2, [pc, #44]	@ (8008bf4 <vPortEnterCritical+0x40>)
 8008bc6:	6813      	ldr	r3, [r2, #0]
 8008bc8:	3301      	adds	r3, #1
 8008bca:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 8008bcc:	2b01      	cmp	r3, #1
 8008bce:	d000      	beq.n	8008bd2 <vPortEnterCritical+0x1e>
}
 8008bd0:	4770      	bx	lr
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8008bd2:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8008bd6:	f8d3 3d04 	ldr.w	r3, [r3, #3332]	@ 0xd04
 8008bda:	f013 0fff 	tst.w	r3, #255	@ 0xff
 8008bde:	d0f7      	beq.n	8008bd0 <vPortEnterCritical+0x1c>
 8008be0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008be4:	f383 8811 	msr	BASEPRI, r3
 8008be8:	f3bf 8f6f 	isb	sy
 8008bec:	f3bf 8f4f 	dsb	sy
 8008bf0:	e7fe      	b.n	8008bf0 <vPortEnterCritical+0x3c>
 8008bf2:	bf00      	nop
 8008bf4:	24000010 	.word	0x24000010

08008bf8 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 8008bf8:	4b09      	ldr	r3, [pc, #36]	@ (8008c20 <vPortExitCritical+0x28>)
 8008bfa:	681b      	ldr	r3, [r3, #0]
 8008bfc:	b943      	cbnz	r3, 8008c10 <vPortExitCritical+0x18>
 8008bfe:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008c02:	f383 8811 	msr	BASEPRI, r3
 8008c06:	f3bf 8f6f 	isb	sy
 8008c0a:	f3bf 8f4f 	dsb	sy
 8008c0e:	e7fe      	b.n	8008c0e <vPortExitCritical+0x16>
	uxCriticalNesting--;
 8008c10:	3b01      	subs	r3, #1
 8008c12:	4a03      	ldr	r2, [pc, #12]	@ (8008c20 <vPortExitCritical+0x28>)
 8008c14:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8008c16:	b90b      	cbnz	r3, 8008c1c <vPortExitCritical+0x24>
	__asm volatile
 8008c18:	f383 8811 	msr	BASEPRI, r3
}
 8008c1c:	4770      	bx	lr
 8008c1e:	bf00      	nop
 8008c20:	24000010 	.word	0x24000010
	...

08008c30 <PendSV_Handler>:
	__asm volatile
 8008c30:	f3ef 8009 	mrs	r0, PSP
 8008c34:	f3bf 8f6f 	isb	sy
 8008c38:	4b15      	ldr	r3, [pc, #84]	@ (8008c90 <pxCurrentTCBConst>)
 8008c3a:	681a      	ldr	r2, [r3, #0]
 8008c3c:	f01e 0f10 	tst.w	lr, #16
 8008c40:	bf08      	it	eq
 8008c42:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8008c46:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008c4a:	6010      	str	r0, [r2, #0]
 8008c4c:	e92d 0009 	stmdb	sp!, {r0, r3}
 8008c50:	f04f 0050 	mov.w	r0, #80	@ 0x50
 8008c54:	f380 8811 	msr	BASEPRI, r0
 8008c58:	f3bf 8f4f 	dsb	sy
 8008c5c:	f3bf 8f6f 	isb	sy
 8008c60:	f7ff fbf2 	bl	8008448 <vTaskSwitchContext>
 8008c64:	f04f 0000 	mov.w	r0, #0
 8008c68:	f380 8811 	msr	BASEPRI, r0
 8008c6c:	bc09      	pop	{r0, r3}
 8008c6e:	6819      	ldr	r1, [r3, #0]
 8008c70:	6808      	ldr	r0, [r1, #0]
 8008c72:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008c76:	f01e 0f10 	tst.w	lr, #16
 8008c7a:	bf08      	it	eq
 8008c7c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8008c80:	f380 8809 	msr	PSP, r0
 8008c84:	f3bf 8f6f 	isb	sy
 8008c88:	4770      	bx	lr
 8008c8a:	bf00      	nop
 8008c8c:	f3af 8000 	nop.w

08008c90 <pxCurrentTCBConst>:
 8008c90:	24003874 	.word	0x24003874

08008c94 <SysTick_Handler>:
{
 8008c94:	b508      	push	{r3, lr}
	__asm volatile
 8008c96:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008c9a:	f383 8811 	msr	BASEPRI, r3
 8008c9e:	f3bf 8f6f 	isb	sy
 8008ca2:	f3bf 8f4f 	dsb	sy
		if( xTaskIncrementTick() != pdFALSE )
 8008ca6:	f7ff fac7 	bl	8008238 <xTaskIncrementTick>
 8008caa:	b128      	cbz	r0, 8008cb8 <SysTick_Handler+0x24>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8008cac:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8008cb0:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8008cb4:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
	__asm volatile
 8008cb8:	2300      	movs	r3, #0
 8008cba:	f383 8811 	msr	BASEPRI, r3
}
 8008cbe:	bd08      	pop	{r3, pc}

08008cc0 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 8008cc0:	f04f 22e0 	mov.w	r2, #3758153728	@ 0xe000e000
 8008cc4:	2300      	movs	r3, #0
 8008cc6:	6113      	str	r3, [r2, #16]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8008cc8:	6193      	str	r3, [r2, #24]
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8008cca:	4b05      	ldr	r3, [pc, #20]	@ (8008ce0 <vPortSetupTimerInterrupt+0x20>)
 8008ccc:	681b      	ldr	r3, [r3, #0]
 8008cce:	4905      	ldr	r1, [pc, #20]	@ (8008ce4 <vPortSetupTimerInterrupt+0x24>)
 8008cd0:	fba1 1303 	umull	r1, r3, r1, r3
 8008cd4:	099b      	lsrs	r3, r3, #6
 8008cd6:	3b01      	subs	r3, #1
 8008cd8:	6153      	str	r3, [r2, #20]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8008cda:	2307      	movs	r3, #7
 8008cdc:	6113      	str	r3, [r2, #16]
}
 8008cde:	4770      	bx	lr
 8008ce0:	24000004 	.word	0x24000004
 8008ce4:	10624dd3 	.word	0x10624dd3

08008ce8 <xPortStartScheduler>:
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8008ce8:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8008cec:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	@ 0xd00
 8008cf0:	4b3d      	ldr	r3, [pc, #244]	@ (8008de8 <xPortStartScheduler+0x100>)
 8008cf2:	429a      	cmp	r2, r3
 8008cf4:	d01c      	beq.n	8008d30 <xPortStartScheduler+0x48>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8008cf6:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8008cfa:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	@ 0xd00
 8008cfe:	4b3b      	ldr	r3, [pc, #236]	@ (8008dec <xPortStartScheduler+0x104>)
 8008d00:	429a      	cmp	r2, r3
 8008d02:	d01e      	beq.n	8008d42 <xPortStartScheduler+0x5a>
{
 8008d04:	b530      	push	{r4, r5, lr}
 8008d06:	b083      	sub	sp, #12
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8008d08:	4b39      	ldr	r3, [pc, #228]	@ (8008df0 <xPortStartScheduler+0x108>)
 8008d0a:	781a      	ldrb	r2, [r3, #0]
 8008d0c:	b2d2      	uxtb	r2, r2
 8008d0e:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8008d10:	22ff      	movs	r2, #255	@ 0xff
 8008d12:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8008d14:	781b      	ldrb	r3, [r3, #0]
 8008d16:	b2db      	uxtb	r3, r3
 8008d18:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8008d1c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008d20:	f003 0350 	and.w	r3, r3, #80	@ 0x50
 8008d24:	4a33      	ldr	r2, [pc, #204]	@ (8008df4 <xPortStartScheduler+0x10c>)
 8008d26:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8008d28:	4b33      	ldr	r3, [pc, #204]	@ (8008df8 <xPortStartScheduler+0x110>)
 8008d2a:	2207      	movs	r2, #7
 8008d2c:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8008d2e:	e01b      	b.n	8008d68 <xPortStartScheduler+0x80>
	__asm volatile
 8008d30:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008d34:	f383 8811 	msr	BASEPRI, r3
 8008d38:	f3bf 8f6f 	isb	sy
 8008d3c:	f3bf 8f4f 	dsb	sy
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8008d40:	e7fe      	b.n	8008d40 <xPortStartScheduler+0x58>
 8008d42:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008d46:	f383 8811 	msr	BASEPRI, r3
 8008d4a:	f3bf 8f6f 	isb	sy
 8008d4e:	f3bf 8f4f 	dsb	sy
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8008d52:	e7fe      	b.n	8008d52 <xPortStartScheduler+0x6a>
			ulMaxPRIGROUPValue--;
 8008d54:	4a28      	ldr	r2, [pc, #160]	@ (8008df8 <xPortStartScheduler+0x110>)
 8008d56:	6813      	ldr	r3, [r2, #0]
 8008d58:	3b01      	subs	r3, #1
 8008d5a:	6013      	str	r3, [r2, #0]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 8008d5c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008d60:	005b      	lsls	r3, r3, #1
 8008d62:	b2db      	uxtb	r3, r3
 8008d64:	f88d 3003 	strb.w	r3, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8008d68:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008d6c:	f013 0f80 	tst.w	r3, #128	@ 0x80
 8008d70:	d1f0      	bne.n	8008d54 <xPortStartScheduler+0x6c>
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 8008d72:	4b21      	ldr	r3, [pc, #132]	@ (8008df8 <xPortStartScheduler+0x110>)
 8008d74:	681b      	ldr	r3, [r3, #0]
 8008d76:	2b03      	cmp	r3, #3
 8008d78:	d008      	beq.n	8008d8c <xPortStartScheduler+0xa4>
 8008d7a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008d7e:	f383 8811 	msr	BASEPRI, r3
 8008d82:	f3bf 8f6f 	isb	sy
 8008d86:	f3bf 8f4f 	dsb	sy
 8008d8a:	e7fe      	b.n	8008d8a <xPortStartScheduler+0xa2>
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 8008d8c:	021b      	lsls	r3, r3, #8
 8008d8e:	4a1a      	ldr	r2, [pc, #104]	@ (8008df8 <xPortStartScheduler+0x110>)
 8008d90:	6013      	str	r3, [r2, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8008d92:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
 8008d96:	6013      	str	r3, [r2, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8008d98:	9b01      	ldr	r3, [sp, #4]
 8008d9a:	b2db      	uxtb	r3, r3
 8008d9c:	4a14      	ldr	r2, [pc, #80]	@ (8008df0 <xPortStartScheduler+0x108>)
 8008d9e:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8008da0:	f04f 24e0 	mov.w	r4, #3758153728	@ 0xe000e000
 8008da4:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	@ 0xd20
 8008da8:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 8008dac:	f8c4 3d20 	str.w	r3, [r4, #3360]	@ 0xd20
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8008db0:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	@ 0xd20
 8008db4:	f043 4370 	orr.w	r3, r3, #4026531840	@ 0xf0000000
 8008db8:	f8c4 3d20 	str.w	r3, [r4, #3360]	@ 0xd20
	vPortSetupTimerInterrupt();
 8008dbc:	f7ff ff80 	bl	8008cc0 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 8008dc0:	2500      	movs	r5, #0
 8008dc2:	4b0e      	ldr	r3, [pc, #56]	@ (8008dfc <xPortStartScheduler+0x114>)
 8008dc4:	601d      	str	r5, [r3, #0]
	vPortEnableVFP();
 8008dc6:	f7ff fec3 	bl	8008b50 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 8008dca:	f8d4 3f34 	ldr.w	r3, [r4, #3892]	@ 0xf34
 8008dce:	f043 4340 	orr.w	r3, r3, #3221225472	@ 0xc0000000
 8008dd2:	f8c4 3f34 	str.w	r3, [r4, #3892]	@ 0xf34
	prvPortStartFirstTask();
 8008dd6:	f7ff fea7 	bl	8008b28 <prvPortStartFirstTask>
	vTaskSwitchContext();
 8008dda:	f7ff fb35 	bl	8008448 <vTaskSwitchContext>
	prvTaskExitError();
 8008dde:	f7ff fe83 	bl	8008ae8 <prvTaskExitError>
}
 8008de2:	4628      	mov	r0, r5
 8008de4:	b003      	add	sp, #12
 8008de6:	bd30      	pop	{r4, r5, pc}
 8008de8:	410fc271 	.word	0x410fc271
 8008dec:	410fc270 	.word	0x410fc270
 8008df0:	e000e400 	.word	0xe000e400
 8008df4:	2400387c 	.word	0x2400387c
 8008df8:	24003878 	.word	0x24003878
 8008dfc:	24000010 	.word	0x24000010

08008e00 <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 8008e00:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8008e04:	2b0f      	cmp	r3, #15
 8008e06:	d90f      	bls.n	8008e28 <vPortValidateInterruptPriority+0x28>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8008e08:	4a11      	ldr	r2, [pc, #68]	@ (8008e50 <vPortValidateInterruptPriority+0x50>)
 8008e0a:	5c9b      	ldrb	r3, [r3, r2]
 8008e0c:	b2db      	uxtb	r3, r3
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8008e0e:	4a11      	ldr	r2, [pc, #68]	@ (8008e54 <vPortValidateInterruptPriority+0x54>)
 8008e10:	7812      	ldrb	r2, [r2, #0]
 8008e12:	429a      	cmp	r2, r3
 8008e14:	d908      	bls.n	8008e28 <vPortValidateInterruptPriority+0x28>
 8008e16:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008e1a:	f383 8811 	msr	BASEPRI, r3
 8008e1e:	f3bf 8f6f 	isb	sy
 8008e22:	f3bf 8f4f 	dsb	sy
 8008e26:	e7fe      	b.n	8008e26 <vPortValidateInterruptPriority+0x26>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8008e28:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8008e2c:	f8d3 3d0c 	ldr.w	r3, [r3, #3340]	@ 0xd0c
 8008e30:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
 8008e34:	4a08      	ldr	r2, [pc, #32]	@ (8008e58 <vPortValidateInterruptPriority+0x58>)
 8008e36:	6812      	ldr	r2, [r2, #0]
 8008e38:	4293      	cmp	r3, r2
 8008e3a:	d908      	bls.n	8008e4e <vPortValidateInterruptPriority+0x4e>
 8008e3c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008e40:	f383 8811 	msr	BASEPRI, r3
 8008e44:	f3bf 8f6f 	isb	sy
 8008e48:	f3bf 8f4f 	dsb	sy
 8008e4c:	e7fe      	b.n	8008e4c <vPortValidateInterruptPriority+0x4c>
	}
 8008e4e:	4770      	bx	lr
 8008e50:	e000e3f0 	.word	0xe000e3f0
 8008e54:	2400387c 	.word	0x2400387c
 8008e58:	24003878 	.word	0x24003878

08008e5c <prvHeapInit>:
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
 8008e5c:	4a12      	ldr	r2, [pc, #72]	@ (8008ea8 <prvHeapInit+0x4c>)

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8008e5e:	f012 0f07 	tst.w	r2, #7
 8008e62:	d01e      	beq.n	8008ea2 <prvHeapInit+0x46>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 8008e64:	1dd1      	adds	r1, r2, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8008e66:	f021 0107 	bic.w	r1, r1, #7
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 8008e6a:	f5c1 430c 	rsb	r3, r1, #35840	@ 0x8c00
 8008e6e:	4413      	add	r3, r2
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8008e70:	460a      	mov	r2, r1

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8008e72:	480e      	ldr	r0, [pc, #56]	@ (8008eac <prvHeapInit+0x50>)
 8008e74:	6002      	str	r2, [r0, #0]
	xStart.xBlockSize = ( size_t ) 0;
 8008e76:	2100      	movs	r1, #0
 8008e78:	6041      	str	r1, [r0, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 8008e7a:	4413      	add	r3, r2
	uxAddress -= xHeapStructSize;
 8008e7c:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8008e7e:	f023 0307 	bic.w	r3, r3, #7
	pxEnd = ( void * ) uxAddress;
 8008e82:	480b      	ldr	r0, [pc, #44]	@ (8008eb0 <prvHeapInit+0x54>)
 8008e84:	6003      	str	r3, [r0, #0]
	pxEnd->xBlockSize = 0;
 8008e86:	6059      	str	r1, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 8008e88:	6019      	str	r1, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8008e8a:	1a99      	subs	r1, r3, r2
 8008e8c:	6051      	str	r1, [r2, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 8008e8e:	6013      	str	r3, [r2, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8008e90:	4b08      	ldr	r3, [pc, #32]	@ (8008eb4 <prvHeapInit+0x58>)
 8008e92:	6019      	str	r1, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8008e94:	4b08      	ldr	r3, [pc, #32]	@ (8008eb8 <prvHeapInit+0x5c>)
 8008e96:	6019      	str	r1, [r3, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8008e98:	4b08      	ldr	r3, [pc, #32]	@ (8008ebc <prvHeapInit+0x60>)
 8008e9a:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
 8008e9e:	601a      	str	r2, [r3, #0]
}
 8008ea0:	4770      	bx	lr
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 8008ea2:	f44f 430c 	mov.w	r3, #35840	@ 0x8c00
 8008ea6:	e7e4      	b.n	8008e72 <prvHeapInit+0x16>
 8008ea8:	240038a0 	.word	0x240038a0
 8008eac:	24003898 	.word	0x24003898
 8008eb0:	24003894 	.word	0x24003894
 8008eb4:	2400388c 	.word	0x2400388c
 8008eb8:	24003890 	.word	0x24003890
 8008ebc:	24003880 	.word	0x24003880

08008ec0 <prvInsertBlockIntoFreeList>:
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8008ec0:	4b16      	ldr	r3, [pc, #88]	@ (8008f1c <prvInsertBlockIntoFreeList+0x5c>)
 8008ec2:	461a      	mov	r2, r3
 8008ec4:	681b      	ldr	r3, [r3, #0]
 8008ec6:	4283      	cmp	r3, r0
 8008ec8:	d3fb      	bcc.n	8008ec2 <prvInsertBlockIntoFreeList+0x2>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8008eca:	6851      	ldr	r1, [r2, #4]
 8008ecc:	eb02 0c01 	add.w	ip, r2, r1
 8008ed0:	4584      	cmp	ip, r0
 8008ed2:	d009      	beq.n	8008ee8 <prvInsertBlockIntoFreeList+0x28>
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8008ed4:	6841      	ldr	r1, [r0, #4]
 8008ed6:	eb00 0c01 	add.w	ip, r0, r1
 8008eda:	4563      	cmp	r3, ip
 8008edc:	d009      	beq.n	8008ef2 <prvInsertBlockIntoFreeList+0x32>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8008ede:	6003      	str	r3, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 8008ee0:	4290      	cmp	r0, r2
 8008ee2:	d019      	beq.n	8008f18 <prvInsertBlockIntoFreeList+0x58>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8008ee4:	6010      	str	r0, [r2, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
 8008ee6:	4770      	bx	lr
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8008ee8:	6840      	ldr	r0, [r0, #4]
 8008eea:	4401      	add	r1, r0
 8008eec:	6051      	str	r1, [r2, #4]
		pxBlockToInsert = pxIterator;
 8008eee:	4610      	mov	r0, r2
 8008ef0:	e7f0      	b.n	8008ed4 <prvInsertBlockIntoFreeList+0x14>
{
 8008ef2:	b410      	push	{r4}
		if( pxIterator->pxNextFreeBlock != pxEnd )
 8008ef4:	4c0a      	ldr	r4, [pc, #40]	@ (8008f20 <prvInsertBlockIntoFreeList+0x60>)
 8008ef6:	6824      	ldr	r4, [r4, #0]
 8008ef8:	42a3      	cmp	r3, r4
 8008efa:	d00b      	beq.n	8008f14 <prvInsertBlockIntoFreeList+0x54>
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8008efc:	685b      	ldr	r3, [r3, #4]
 8008efe:	4419      	add	r1, r3
 8008f00:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8008f02:	6813      	ldr	r3, [r2, #0]
 8008f04:	681b      	ldr	r3, [r3, #0]
 8008f06:	6003      	str	r3, [r0, #0]
	if( pxIterator != pxBlockToInsert )
 8008f08:	4290      	cmp	r0, r2
 8008f0a:	d000      	beq.n	8008f0e <prvInsertBlockIntoFreeList+0x4e>
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8008f0c:	6010      	str	r0, [r2, #0]
	}
}
 8008f0e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008f12:	4770      	bx	lr
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 8008f14:	6004      	str	r4, [r0, #0]
 8008f16:	e7f7      	b.n	8008f08 <prvInsertBlockIntoFreeList+0x48>
 8008f18:	4770      	bx	lr
 8008f1a:	bf00      	nop
 8008f1c:	24003898 	.word	0x24003898
 8008f20:	24003894 	.word	0x24003894

08008f24 <pvPortMalloc>:
{
 8008f24:	b538      	push	{r3, r4, r5, lr}
 8008f26:	4604      	mov	r4, r0
	vTaskSuspendAll();
 8008f28:	f7ff f970 	bl	800820c <vTaskSuspendAll>
		if( pxEnd == NULL )
 8008f2c:	4b38      	ldr	r3, [pc, #224]	@ (8009010 <pvPortMalloc+0xec>)
 8008f2e:	681b      	ldr	r3, [r3, #0]
 8008f30:	b1b3      	cbz	r3, 8008f60 <pvPortMalloc+0x3c>
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8008f32:	4b38      	ldr	r3, [pc, #224]	@ (8009014 <pvPortMalloc+0xf0>)
 8008f34:	681b      	ldr	r3, [r3, #0]
 8008f36:	421c      	tst	r4, r3
 8008f38:	d150      	bne.n	8008fdc <pvPortMalloc+0xb8>
			if( xWantedSize > 0 )
 8008f3a:	2c00      	cmp	r4, #0
 8008f3c:	d050      	beq.n	8008fe0 <pvPortMalloc+0xbc>
				xWantedSize += xHeapStructSize;
 8008f3e:	f104 0208 	add.w	r2, r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8008f42:	f014 0f07 	tst.w	r4, #7
 8008f46:	d002      	beq.n	8008f4e <pvPortMalloc+0x2a>
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8008f48:	f022 0207 	bic.w	r2, r2, #7
 8008f4c:	3208      	adds	r2, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8008f4e:	2a00      	cmp	r2, #0
 8008f50:	d055      	beq.n	8008ffe <pvPortMalloc+0xda>
 8008f52:	4b31      	ldr	r3, [pc, #196]	@ (8009018 <pvPortMalloc+0xf4>)
 8008f54:	681b      	ldr	r3, [r3, #0]
 8008f56:	4293      	cmp	r3, r2
 8008f58:	d353      	bcc.n	8009002 <pvPortMalloc+0xde>
				pxBlock = xStart.pxNextFreeBlock;
 8008f5a:	4930      	ldr	r1, [pc, #192]	@ (800901c <pvPortMalloc+0xf8>)
 8008f5c:	680c      	ldr	r4, [r1, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8008f5e:	e004      	b.n	8008f6a <pvPortMalloc+0x46>
			prvHeapInit();
 8008f60:	f7ff ff7c 	bl	8008e5c <prvHeapInit>
 8008f64:	e7e5      	b.n	8008f32 <pvPortMalloc+0xe>
					pxPreviousBlock = pxBlock;
 8008f66:	4621      	mov	r1, r4
					pxBlock = pxBlock->pxNextFreeBlock;
 8008f68:	461c      	mov	r4, r3
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8008f6a:	6863      	ldr	r3, [r4, #4]
 8008f6c:	4293      	cmp	r3, r2
 8008f6e:	d202      	bcs.n	8008f76 <pvPortMalloc+0x52>
 8008f70:	6823      	ldr	r3, [r4, #0]
 8008f72:	2b00      	cmp	r3, #0
 8008f74:	d1f7      	bne.n	8008f66 <pvPortMalloc+0x42>
				if( pxBlock != pxEnd )
 8008f76:	4b26      	ldr	r3, [pc, #152]	@ (8009010 <pvPortMalloc+0xec>)
 8008f78:	681b      	ldr	r3, [r3, #0]
 8008f7a:	42a3      	cmp	r3, r4
 8008f7c:	d043      	beq.n	8009006 <pvPortMalloc+0xe2>
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8008f7e:	680d      	ldr	r5, [r1, #0]
 8008f80:	3508      	adds	r5, #8
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8008f82:	6823      	ldr	r3, [r4, #0]
 8008f84:	600b      	str	r3, [r1, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8008f86:	6863      	ldr	r3, [r4, #4]
 8008f88:	1a9b      	subs	r3, r3, r2
 8008f8a:	2b10      	cmp	r3, #16
 8008f8c:	d910      	bls.n	8008fb0 <pvPortMalloc+0x8c>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 8008f8e:	18a0      	adds	r0, r4, r2
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 8008f90:	f010 0f07 	tst.w	r0, #7
 8008f94:	d008      	beq.n	8008fa8 <pvPortMalloc+0x84>
 8008f96:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008f9a:	f383 8811 	msr	BASEPRI, r3
 8008f9e:	f3bf 8f6f 	isb	sy
 8008fa2:	f3bf 8f4f 	dsb	sy
 8008fa6:	e7fe      	b.n	8008fa6 <pvPortMalloc+0x82>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8008fa8:	6043      	str	r3, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 8008faa:	6062      	str	r2, [r4, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 8008fac:	f7ff ff88 	bl	8008ec0 <prvInsertBlockIntoFreeList>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8008fb0:	6862      	ldr	r2, [r4, #4]
 8008fb2:	4919      	ldr	r1, [pc, #100]	@ (8009018 <pvPortMalloc+0xf4>)
 8008fb4:	680b      	ldr	r3, [r1, #0]
 8008fb6:	1a9b      	subs	r3, r3, r2
 8008fb8:	600b      	str	r3, [r1, #0]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8008fba:	4919      	ldr	r1, [pc, #100]	@ (8009020 <pvPortMalloc+0xfc>)
 8008fbc:	6809      	ldr	r1, [r1, #0]
 8008fbe:	428b      	cmp	r3, r1
 8008fc0:	d201      	bcs.n	8008fc6 <pvPortMalloc+0xa2>
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8008fc2:	4917      	ldr	r1, [pc, #92]	@ (8009020 <pvPortMalloc+0xfc>)
 8008fc4:	600b      	str	r3, [r1, #0]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8008fc6:	4b13      	ldr	r3, [pc, #76]	@ (8009014 <pvPortMalloc+0xf0>)
 8008fc8:	681b      	ldr	r3, [r3, #0]
 8008fca:	4313      	orrs	r3, r2
 8008fcc:	6063      	str	r3, [r4, #4]
					pxBlock->pxNextFreeBlock = NULL;
 8008fce:	2300      	movs	r3, #0
 8008fd0:	6023      	str	r3, [r4, #0]
					xNumberOfSuccessfulAllocations++;
 8008fd2:	4a14      	ldr	r2, [pc, #80]	@ (8009024 <pvPortMalloc+0x100>)
 8008fd4:	6813      	ldr	r3, [r2, #0]
 8008fd6:	3301      	adds	r3, #1
 8008fd8:	6013      	str	r3, [r2, #0]
 8008fda:	e002      	b.n	8008fe2 <pvPortMalloc+0xbe>
void *pvReturn = NULL;
 8008fdc:	2500      	movs	r5, #0
 8008fde:	e000      	b.n	8008fe2 <pvPortMalloc+0xbe>
 8008fe0:	2500      	movs	r5, #0
	( void ) xTaskResumeAll();
 8008fe2:	f7ff f9b5 	bl	8008350 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 8008fe6:	f015 0f07 	tst.w	r5, #7
 8008fea:	d00e      	beq.n	800900a <pvPortMalloc+0xe6>
 8008fec:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008ff0:	f383 8811 	msr	BASEPRI, r3
 8008ff4:	f3bf 8f6f 	isb	sy
 8008ff8:	f3bf 8f4f 	dsb	sy
 8008ffc:	e7fe      	b.n	8008ffc <pvPortMalloc+0xd8>
void *pvReturn = NULL;
 8008ffe:	2500      	movs	r5, #0
 8009000:	e7ef      	b.n	8008fe2 <pvPortMalloc+0xbe>
 8009002:	2500      	movs	r5, #0
 8009004:	e7ed      	b.n	8008fe2 <pvPortMalloc+0xbe>
 8009006:	2500      	movs	r5, #0
 8009008:	e7eb      	b.n	8008fe2 <pvPortMalloc+0xbe>
}
 800900a:	4628      	mov	r0, r5
 800900c:	bd38      	pop	{r3, r4, r5, pc}
 800900e:	bf00      	nop
 8009010:	24003894 	.word	0x24003894
 8009014:	24003880 	.word	0x24003880
 8009018:	24003890 	.word	0x24003890
 800901c:	24003898 	.word	0x24003898
 8009020:	2400388c 	.word	0x2400388c
 8009024:	24003888 	.word	0x24003888

08009028 <vPortFree>:
	if( pv != NULL )
 8009028:	2800      	cmp	r0, #0
 800902a:	d034      	beq.n	8009096 <vPortFree+0x6e>
{
 800902c:	b538      	push	{r3, r4, r5, lr}
 800902e:	4604      	mov	r4, r0
		puc -= xHeapStructSize;
 8009030:	f1a0 0508 	sub.w	r5, r0, #8
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8009034:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8009038:	4a17      	ldr	r2, [pc, #92]	@ (8009098 <vPortFree+0x70>)
 800903a:	6812      	ldr	r2, [r2, #0]
 800903c:	4213      	tst	r3, r2
 800903e:	d108      	bne.n	8009052 <vPortFree+0x2a>
 8009040:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8009044:	f383 8811 	msr	BASEPRI, r3
 8009048:	f3bf 8f6f 	isb	sy
 800904c:	f3bf 8f4f 	dsb	sy
 8009050:	e7fe      	b.n	8009050 <vPortFree+0x28>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8009052:	f850 1c08 	ldr.w	r1, [r0, #-8]
 8009056:	b141      	cbz	r1, 800906a <vPortFree+0x42>
 8009058:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800905c:	f383 8811 	msr	BASEPRI, r3
 8009060:	f3bf 8f6f 	isb	sy
 8009064:	f3bf 8f4f 	dsb	sy
 8009068:	e7fe      	b.n	8009068 <vPortFree+0x40>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 800906a:	ea23 0302 	bic.w	r3, r3, r2
 800906e:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
 8009072:	f7ff f8cb 	bl	800820c <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 8009076:	f854 1c04 	ldr.w	r1, [r4, #-4]
 800907a:	4a08      	ldr	r2, [pc, #32]	@ (800909c <vPortFree+0x74>)
 800907c:	6813      	ldr	r3, [r2, #0]
 800907e:	440b      	add	r3, r1
 8009080:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8009082:	4628      	mov	r0, r5
 8009084:	f7ff ff1c 	bl	8008ec0 <prvInsertBlockIntoFreeList>
					xNumberOfSuccessfulFrees++;
 8009088:	4a05      	ldr	r2, [pc, #20]	@ (80090a0 <vPortFree+0x78>)
 800908a:	6813      	ldr	r3, [r2, #0]
 800908c:	3301      	adds	r3, #1
 800908e:	6013      	str	r3, [r2, #0]
				( void ) xTaskResumeAll();
 8009090:	f7ff f95e 	bl	8008350 <xTaskResumeAll>
}
 8009094:	bd38      	pop	{r3, r4, r5, pc}
 8009096:	4770      	bx	lr
 8009098:	24003880 	.word	0x24003880
 800909c:	24003890 	.word	0x24003890
 80090a0:	24003884 	.word	0x24003884

080090a4 <netconn_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
static err_t
netconn_apimsg(tcpip_callback_fn fn, struct api_msg *apimsg)
{
 80090a4:	b510      	push	{r4, lr}
 80090a6:	460c      	mov	r4, r1
  err_t err;

#ifdef LWIP_DEBUG
  /* catch functions that don't set err */
  apimsg->err = ERR_VAL;
 80090a8:	23fa      	movs	r3, #250	@ 0xfa
 80090aa:	710b      	strb	r3, [r1, #4]

#if LWIP_NETCONN_SEM_PER_THREAD
  apimsg->op_completed_sem = LWIP_NETCONN_THREAD_SEM_GET();
#endif /* LWIP_NETCONN_SEM_PER_THREAD */

  err = tcpip_send_msg_wait_sem(fn, apimsg, LWIP_API_MSG_SEM(apimsg));
 80090ac:	680a      	ldr	r2, [r1, #0]
 80090ae:	320c      	adds	r2, #12
 80090b0:	f001 fd04 	bl	800aabc <tcpip_send_msg_wait_sem>
  if (err == ERR_OK) {
 80090b4:	b100      	cbz	r0, 80090b8 <netconn_apimsg+0x14>
    return apimsg->err;
  }
  return err;
}
 80090b6:	bd10      	pop	{r4, pc}
    return apimsg->err;
 80090b8:	f994 0004 	ldrsb.w	r0, [r4, #4]
 80090bc:	e7fb      	b.n	80090b6 <netconn_apimsg+0x12>
	...

080090c0 <netconn_tcp_recvd_msg>:
}

#if LWIP_TCP
static err_t
netconn_tcp_recvd_msg(struct netconn *conn, size_t len, struct api_msg *msg)
{
 80090c0:	b510      	push	{r4, lr}
  LWIP_ERROR("netconn_recv_tcp_pbuf: invalid conn", (conn != NULL) &&
 80090c2:	b160      	cbz	r0, 80090de <netconn_tcp_recvd_msg+0x1e>
 80090c4:	460c      	mov	r4, r1
 80090c6:	4611      	mov	r1, r2
 80090c8:	7803      	ldrb	r3, [r0, #0]
 80090ca:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 80090ce:	2b10      	cmp	r3, #16
 80090d0:	d105      	bne.n	80090de <netconn_tcp_recvd_msg+0x1e>
             NETCONNTYPE_GROUP(netconn_type(conn)) == NETCONN_TCP, return ERR_ARG;);

  msg->conn = conn;
 80090d2:	6010      	str	r0, [r2, #0]
  msg->msg.r.len = len;
 80090d4:	6094      	str	r4, [r2, #8]

  return netconn_apimsg(lwip_netconn_do_recv, msg);
 80090d6:	4807      	ldr	r0, [pc, #28]	@ (80090f4 <netconn_tcp_recvd_msg+0x34>)
 80090d8:	f7ff ffe4 	bl	80090a4 <netconn_apimsg>
}
 80090dc:	bd10      	pop	{r4, pc}
  LWIP_ERROR("netconn_recv_tcp_pbuf: invalid conn", (conn != NULL) &&
 80090de:	4b06      	ldr	r3, [pc, #24]	@ (80090f8 <netconn_tcp_recvd_msg+0x38>)
 80090e0:	f240 22a7 	movw	r2, #679	@ 0x2a7
 80090e4:	4905      	ldr	r1, [pc, #20]	@ (80090fc <netconn_tcp_recvd_msg+0x3c>)
 80090e6:	4806      	ldr	r0, [pc, #24]	@ (8009100 <netconn_tcp_recvd_msg+0x40>)
 80090e8:	f00a ff4a 	bl	8013f80 <iprintf>
 80090ec:	f06f 000f 	mvn.w	r0, #15
 80090f0:	e7f4      	b.n	80090dc <netconn_tcp_recvd_msg+0x1c>
 80090f2:	bf00      	nop
 80090f4:	0800a635 	.word	0x0800a635
 80090f8:	080156ec 	.word	0x080156ec
 80090fc:	08015720 	.word	0x08015720
 8009100:	08015744 	.word	0x08015744

08009104 <netconn_close_shutdown>:
 * @param how fully close or only shutdown one side?
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
static err_t
netconn_close_shutdown(struct netconn *conn, u8_t how)
{
 8009104:	b500      	push	{lr}
 8009106:	b089      	sub	sp, #36	@ 0x24
  API_MSG_VAR_DECLARE(msg);
  err_t err;
  LWIP_UNUSED_ARG(how);

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
 8009108:	b160      	cbz	r0, 8009124 <netconn_close_shutdown+0x20>

  API_MSG_VAR_ALLOC(msg);
  API_MSG_VAR_REF(msg).conn = conn;
 800910a:	9000      	str	r0, [sp, #0]
#if LWIP_TCP
  /* shutting down both ends is the same as closing */
  API_MSG_VAR_REF(msg).msg.sd.shut = how;
 800910c:	f88d 1008 	strb.w	r1, [sp, #8]
#if LWIP_SO_SNDTIMEO || LWIP_SO_LINGER
  /* get the time we started, which is later compared to
     sys_now() + conn->send_timeout */
  API_MSG_VAR_REF(msg).msg.sd.time_started = sys_now();
#else /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
  API_MSG_VAR_REF(msg).msg.sd.polls_left =
 8009110:	2329      	movs	r3, #41	@ 0x29
 8009112:	f88d 3009 	strb.w	r3, [sp, #9]
    ((LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT + TCP_SLOW_INTERVAL - 1) / TCP_SLOW_INTERVAL) + 1;
#endif /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
#endif /* LWIP_TCP */
  err = netconn_apimsg(lwip_netconn_do_close, &API_MSG_VAR_REF(msg));
 8009116:	4669      	mov	r1, sp
 8009118:	4807      	ldr	r0, [pc, #28]	@ (8009138 <netconn_close_shutdown+0x34>)
 800911a:	f7ff ffc3 	bl	80090a4 <netconn_apimsg>
  API_MSG_VAR_FREE(msg);

  return err;
}
 800911e:	b009      	add	sp, #36	@ 0x24
 8009120:	f85d fb04 	ldr.w	pc, [sp], #4
  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
 8009124:	4b05      	ldr	r3, [pc, #20]	@ (800913c <netconn_close_shutdown+0x38>)
 8009126:	f240 4247 	movw	r2, #1095	@ 0x447
 800912a:	4905      	ldr	r1, [pc, #20]	@ (8009140 <netconn_close_shutdown+0x3c>)
 800912c:	4805      	ldr	r0, [pc, #20]	@ (8009144 <netconn_close_shutdown+0x40>)
 800912e:	f00a ff27 	bl	8013f80 <iprintf>
 8009132:	f06f 000f 	mvn.w	r0, #15
 8009136:	e7f2      	b.n	800911e <netconn_close_shutdown+0x1a>
 8009138:	0800a749 	.word	0x0800a749
 800913c:	080156ec 	.word	0x080156ec
 8009140:	0801576c 	.word	0x0801576c
 8009144:	08015744 	.word	0x08015744

08009148 <netconn_new_with_proto_and_callback>:
{
 8009148:	b570      	push	{r4, r5, r6, lr}
 800914a:	b088      	sub	sp, #32
 800914c:	460c      	mov	r4, r1
  conn = netconn_alloc(t, callback);
 800914e:	4611      	mov	r1, r2
 8009150:	f000 ffec 	bl	800a12c <netconn_alloc>
  if (conn != NULL) {
 8009154:	4605      	mov	r5, r0
 8009156:	b138      	cbz	r0, 8009168 <netconn_new_with_proto_and_callback+0x20>
    API_MSG_VAR_REF(msg).msg.n.proto = proto;
 8009158:	f88d 4008 	strb.w	r4, [sp, #8]
    API_MSG_VAR_REF(msg).conn = conn;
 800915c:	9000      	str	r0, [sp, #0]
    err = netconn_apimsg(lwip_netconn_do_newconn, &API_MSG_VAR_REF(msg));
 800915e:	4669      	mov	r1, sp
 8009160:	4820      	ldr	r0, [pc, #128]	@ (80091e4 <netconn_new_with_proto_and_callback+0x9c>)
 8009162:	f7ff ff9f 	bl	80090a4 <netconn_apimsg>
    if (err != ERR_OK) {
 8009166:	b910      	cbnz	r0, 800916e <netconn_new_with_proto_and_callback+0x26>
}
 8009168:	4628      	mov	r0, r5
 800916a:	b008      	add	sp, #32
 800916c:	bd70      	pop	{r4, r5, r6, pc}
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
 800916e:	686b      	ldr	r3, [r5, #4]
 8009170:	b12b      	cbz	r3, 800917e <netconn_new_with_proto_and_callback+0x36>
 8009172:	4b1d      	ldr	r3, [pc, #116]	@ (80091e8 <netconn_new_with_proto_and_callback+0xa0>)
 8009174:	22a3      	movs	r2, #163	@ 0xa3
 8009176:	491d      	ldr	r1, [pc, #116]	@ (80091ec <netconn_new_with_proto_and_callback+0xa4>)
 8009178:	481d      	ldr	r0, [pc, #116]	@ (80091f0 <netconn_new_with_proto_and_callback+0xa8>)
 800917a:	f00a ff01 	bl	8013f80 <iprintf>
      LWIP_ASSERT("conn has no recvmbox", sys_mbox_valid(&conn->recvmbox));
 800917e:	f105 0410 	add.w	r4, r5, #16
 8009182:	4620      	mov	r0, r4
 8009184:	f00a f913 	bl	80133ae <sys_mbox_valid>
 8009188:	b1b0      	cbz	r0, 80091b8 <netconn_new_with_proto_and_callback+0x70>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", !sys_mbox_valid(&conn->acceptmbox));
 800918a:	f105 0014 	add.w	r0, r5, #20
 800918e:	f00a f90e 	bl	80133ae <sys_mbox_valid>
 8009192:	b9c0      	cbnz	r0, 80091c6 <netconn_new_with_proto_and_callback+0x7e>
      LWIP_ASSERT("conn has no op_completed", sys_sem_valid(&conn->op_completed));
 8009194:	f105 060c 	add.w	r6, r5, #12
 8009198:	4630      	mov	r0, r6
 800919a:	f00a f973 	bl	8013484 <sys_sem_valid>
 800919e:	b1c8      	cbz	r0, 80091d4 <netconn_new_with_proto_and_callback+0x8c>
      sys_sem_free(&conn->op_completed);
 80091a0:	4630      	mov	r0, r6
 80091a2:	f00a f961 	bl	8013468 <sys_sem_free>
      sys_mbox_free(&conn->recvmbox);
 80091a6:	4620      	mov	r0, r4
 80091a8:	f00a f896 	bl	80132d8 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
 80091ac:	4629      	mov	r1, r5
 80091ae:	2007      	movs	r0, #7
 80091b0:	f002 f9a2 	bl	800b4f8 <memp_free>
      return NULL;
 80091b4:	2500      	movs	r5, #0
 80091b6:	e7d7      	b.n	8009168 <netconn_new_with_proto_and_callback+0x20>
      LWIP_ASSERT("conn has no recvmbox", sys_mbox_valid(&conn->recvmbox));
 80091b8:	4b0b      	ldr	r3, [pc, #44]	@ (80091e8 <netconn_new_with_proto_and_callback+0xa0>)
 80091ba:	22a4      	movs	r2, #164	@ 0xa4
 80091bc:	490d      	ldr	r1, [pc, #52]	@ (80091f4 <netconn_new_with_proto_and_callback+0xac>)
 80091be:	480c      	ldr	r0, [pc, #48]	@ (80091f0 <netconn_new_with_proto_and_callback+0xa8>)
 80091c0:	f00a fede 	bl	8013f80 <iprintf>
 80091c4:	e7e1      	b.n	800918a <netconn_new_with_proto_and_callback+0x42>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", !sys_mbox_valid(&conn->acceptmbox));
 80091c6:	4b08      	ldr	r3, [pc, #32]	@ (80091e8 <netconn_new_with_proto_and_callback+0xa0>)
 80091c8:	22a6      	movs	r2, #166	@ 0xa6
 80091ca:	490b      	ldr	r1, [pc, #44]	@ (80091f8 <netconn_new_with_proto_and_callback+0xb0>)
 80091cc:	4808      	ldr	r0, [pc, #32]	@ (80091f0 <netconn_new_with_proto_and_callback+0xa8>)
 80091ce:	f00a fed7 	bl	8013f80 <iprintf>
 80091d2:	e7df      	b.n	8009194 <netconn_new_with_proto_and_callback+0x4c>
      LWIP_ASSERT("conn has no op_completed", sys_sem_valid(&conn->op_completed));
 80091d4:	4b04      	ldr	r3, [pc, #16]	@ (80091e8 <netconn_new_with_proto_and_callback+0xa0>)
 80091d6:	22a9      	movs	r2, #169	@ 0xa9
 80091d8:	4908      	ldr	r1, [pc, #32]	@ (80091fc <netconn_new_with_proto_and_callback+0xb4>)
 80091da:	4805      	ldr	r0, [pc, #20]	@ (80091f0 <netconn_new_with_proto_and_callback+0xa8>)
 80091dc:	f00a fed0 	bl	8013f80 <iprintf>
 80091e0:	e7de      	b.n	80091a0 <netconn_new_with_proto_and_callback+0x58>
 80091e2:	bf00      	nop
 80091e4:	0800a119 	.word	0x0800a119
 80091e8:	080156ec 	.word	0x080156ec
 80091ec:	08015788 	.word	0x08015788
 80091f0:	08015744 	.word	0x08015744
 80091f4:	080157ac 	.word	0x080157ac
 80091f8:	080157c4 	.word	0x080157c4
 80091fc:	080157e8 	.word	0x080157e8

08009200 <netconn_prepare_delete>:
  if (conn == NULL) {
 8009200:	b160      	cbz	r0, 800921c <netconn_prepare_delete+0x1c>
{
 8009202:	b500      	push	{lr}
 8009204:	b089      	sub	sp, #36	@ 0x24
  API_MSG_VAR_REF(msg).conn = conn;
 8009206:	9000      	str	r0, [sp, #0]
  API_MSG_VAR_REF(msg).msg.sd.polls_left =
 8009208:	2329      	movs	r3, #41	@ 0x29
 800920a:	f88d 3009 	strb.w	r3, [sp, #9]
  err = netconn_apimsg(lwip_netconn_do_delconn, &API_MSG_VAR_REF(msg));
 800920e:	4669      	mov	r1, sp
 8009210:	4803      	ldr	r0, [pc, #12]	@ (8009220 <netconn_prepare_delete+0x20>)
 8009212:	f7ff ff47 	bl	80090a4 <netconn_apimsg>
}
 8009216:	b009      	add	sp, #36	@ 0x24
 8009218:	f85d fb04 	ldr.w	pc, [sp], #4
    return ERR_OK;
 800921c:	2000      	movs	r0, #0
}
 800921e:	4770      	bx	lr
 8009220:	0800a3dd 	.word	0x0800a3dd

08009224 <netconn_delete>:
{
 8009224:	b538      	push	{r3, r4, r5, lr}
  if (conn == NULL) {
 8009226:	b150      	cbz	r0, 800923e <netconn_delete+0x1a>
 8009228:	4605      	mov	r5, r0
    err = netconn_prepare_delete(conn);
 800922a:	f7ff ffe9 	bl	8009200 <netconn_prepare_delete>
  if (err == ERR_OK) {
 800922e:	4604      	mov	r4, r0
 8009230:	b108      	cbz	r0, 8009236 <netconn_delete+0x12>
}
 8009232:	4620      	mov	r0, r4
 8009234:	bd38      	pop	{r3, r4, r5, pc}
    netconn_free(conn);
 8009236:	4628      	mov	r0, r5
 8009238:	f000 ffba 	bl	800a1b0 <netconn_free>
 800923c:	e7f9      	b.n	8009232 <netconn_delete+0xe>
    return ERR_OK;
 800923e:	2400      	movs	r4, #0
 8009240:	e7f7      	b.n	8009232 <netconn_delete+0xe>
	...

08009244 <netconn_bind>:
{
 8009244:	b500      	push	{lr}
 8009246:	b089      	sub	sp, #36	@ 0x24
  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
 8009248:	b160      	cbz	r0, 8009264 <netconn_bind+0x20>
 800924a:	4603      	mov	r3, r0
  if (addr == NULL) {
 800924c:	b1a1      	cbz	r1, 8009278 <netconn_bind+0x34>
  API_MSG_VAR_REF(msg).conn = conn;
 800924e:	9300      	str	r3, [sp, #0]
  API_MSG_VAR_REF(msg).msg.bc.ipaddr = API_MSG_VAR_REF(addr);
 8009250:	9102      	str	r1, [sp, #8]
  API_MSG_VAR_REF(msg).msg.bc.port = port;
 8009252:	f8ad 200c 	strh.w	r2, [sp, #12]
  err = netconn_apimsg(lwip_netconn_do_bind, &API_MSG_VAR_REF(msg));
 8009256:	4669      	mov	r1, sp
 8009258:	4808      	ldr	r0, [pc, #32]	@ (800927c <netconn_bind+0x38>)
 800925a:	f7ff ff23 	bl	80090a4 <netconn_apimsg>
}
 800925e:	b009      	add	sp, #36	@ 0x24
 8009260:	f85d fb04 	ldr.w	pc, [sp], #4
  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
 8009264:	4b06      	ldr	r3, [pc, #24]	@ (8009280 <netconn_bind+0x3c>)
 8009266:	f44f 729c 	mov.w	r2, #312	@ 0x138
 800926a:	4906      	ldr	r1, [pc, #24]	@ (8009284 <netconn_bind+0x40>)
 800926c:	4806      	ldr	r0, [pc, #24]	@ (8009288 <netconn_bind+0x44>)
 800926e:	f00a fe87 	bl	8013f80 <iprintf>
 8009272:	f06f 000f 	mvn.w	r0, #15
 8009276:	e7f2      	b.n	800925e <netconn_bind+0x1a>
    addr = IP4_ADDR_ANY;
 8009278:	4904      	ldr	r1, [pc, #16]	@ (800928c <netconn_bind+0x48>)
 800927a:	e7e8      	b.n	800924e <netconn_bind+0xa>
 800927c:	0800a521 	.word	0x0800a521
 8009280:	080156ec 	.word	0x080156ec
 8009284:	08015804 	.word	0x08015804
 8009288:	08015744 	.word	0x08015744
 800928c:	08018fc0 	.word	0x08018fc0

08009290 <netconn_listen_with_backlog>:
{
 8009290:	b500      	push	{lr}
 8009292:	b089      	sub	sp, #36	@ 0x24
  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
 8009294:	b138      	cbz	r0, 80092a6 <netconn_listen_with_backlog+0x16>
  API_MSG_VAR_REF(msg).conn = conn;
 8009296:	9000      	str	r0, [sp, #0]
  err = netconn_apimsg(lwip_netconn_do_listen, &API_MSG_VAR_REF(msg));
 8009298:	4669      	mov	r1, sp
 800929a:	4808      	ldr	r0, [pc, #32]	@ (80092bc <netconn_listen_with_backlog+0x2c>)
 800929c:	f7ff ff02 	bl	80090a4 <netconn_apimsg>
}
 80092a0:	b009      	add	sp, #36	@ 0x24
 80092a2:	f85d fb04 	ldr.w	pc, [sp], #4
  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
 80092a6:	4b06      	ldr	r3, [pc, #24]	@ (80092c0 <netconn_listen_with_backlog+0x30>)
 80092a8:	f240 12bb 	movw	r2, #443	@ 0x1bb
 80092ac:	4905      	ldr	r1, [pc, #20]	@ (80092c4 <netconn_listen_with_backlog+0x34>)
 80092ae:	4806      	ldr	r0, [pc, #24]	@ (80092c8 <netconn_listen_with_backlog+0x38>)
 80092b0:	f00a fe66 	bl	8013f80 <iprintf>
 80092b4:	f06f 000f 	mvn.w	r0, #15
 80092b8:	e7f2      	b.n	80092a0 <netconn_listen_with_backlog+0x10>
 80092ba:	bf00      	nop
 80092bc:	0800a55d 	.word	0x0800a55d
 80092c0:	080156ec 	.word	0x080156ec
 80092c4:	08015820 	.word	0x08015820
 80092c8:	08015744 	.word	0x08015744

080092cc <netconn_write_vectors_partly>:
{
 80092cc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80092ce:	b089      	sub	sp, #36	@ 0x24
 80092d0:	9e0e      	ldr	r6, [sp, #56]	@ 0x38
  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
 80092d2:	b178      	cbz	r0, 80092f4 <netconn_write_vectors_partly+0x28>
 80092d4:	4684      	mov	ip, r0
  LWIP_ERROR("netconn_write: invalid conn->type",  (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP), return ERR_VAL;);
 80092d6:	7800      	ldrb	r0, [r0, #0]
 80092d8:	f000 00f0 	and.w	r0, r0, #240	@ 0xf0
 80092dc:	2810      	cmp	r0, #16
 80092de:	d113      	bne.n	8009308 <netconn_write_vectors_partly+0x3c>
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
 80092e0:	f89c 0018 	ldrb.w	r0, [ip, #24]
 80092e4:	f010 0f02 	tst.w	r0, #2
 80092e8:	d118      	bne.n	800931c <netconn_write_vectors_partly+0x50>
 80092ea:	f013 0f04 	tst.w	r3, #4
 80092ee:	d028      	beq.n	8009342 <netconn_write_vectors_partly+0x76>
 80092f0:	2001      	movs	r0, #1
 80092f2:	e014      	b.n	800931e <netconn_write_vectors_partly+0x52>
  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
 80092f4:	4b2d      	ldr	r3, [pc, #180]	@ (80093ac <netconn_write_vectors_partly+0xe0>)
 80092f6:	f240 32ee 	movw	r2, #1006	@ 0x3ee
 80092fa:	492d      	ldr	r1, [pc, #180]	@ (80093b0 <netconn_write_vectors_partly+0xe4>)
 80092fc:	482d      	ldr	r0, [pc, #180]	@ (80093b4 <netconn_write_vectors_partly+0xe8>)
 80092fe:	f00a fe3f 	bl	8013f80 <iprintf>
 8009302:	f06f 050f 	mvn.w	r5, #15
 8009306:	e049      	b.n	800939c <netconn_write_vectors_partly+0xd0>
  LWIP_ERROR("netconn_write: invalid conn->type",  (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP), return ERR_VAL;);
 8009308:	4b28      	ldr	r3, [pc, #160]	@ (80093ac <netconn_write_vectors_partly+0xe0>)
 800930a:	f240 32ef 	movw	r2, #1007	@ 0x3ef
 800930e:	492a      	ldr	r1, [pc, #168]	@ (80093b8 <netconn_write_vectors_partly+0xec>)
 8009310:	4828      	ldr	r0, [pc, #160]	@ (80093b4 <netconn_write_vectors_partly+0xe8>)
 8009312:	f00a fe35 	bl	8013f80 <iprintf>
 8009316:	f06f 0505 	mvn.w	r5, #5
 800931a:	e03f      	b.n	800939c <netconn_write_vectors_partly+0xd0>
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
 800931c:	2001      	movs	r0, #1
  if (dontblock && !bytes_written) {
 800931e:	f000 07ff 	and.w	r7, r0, #255	@ 0xff
 8009322:	2e00      	cmp	r6, #0
 8009324:	bf14      	ite	ne
 8009326:	2000      	movne	r0, #0
 8009328:	f000 0001 	andeq.w	r0, r0, #1
 800932c:	bb88      	cbnz	r0, 8009392 <netconn_write_vectors_partly+0xc6>
  size = 0;
 800932e:	4604      	mov	r4, r0
  for (i = 0; i < vectorcnt; i++) {
 8009330:	4282      	cmp	r2, r0
 8009332:	dd08      	ble.n	8009346 <netconn_write_vectors_partly+0x7a>
    size += vectors[i].len;
 8009334:	eb01 05c0 	add.w	r5, r1, r0, lsl #3
 8009338:	686d      	ldr	r5, [r5, #4]
    if (size < vectors[i].len) {
 800933a:	1964      	adds	r4, r4, r5
 800933c:	d22c      	bcs.n	8009398 <netconn_write_vectors_partly+0xcc>
  for (i = 0; i < vectorcnt; i++) {
 800933e:	3001      	adds	r0, #1
 8009340:	e7f6      	b.n	8009330 <netconn_write_vectors_partly+0x64>
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
 8009342:	2000      	movs	r0, #0
 8009344:	e7eb      	b.n	800931e <netconn_write_vectors_partly+0x52>
  if (size == 0) {
 8009346:	b364      	cbz	r4, 80093a2 <netconn_write_vectors_partly+0xd6>
  } else if (size > SSIZE_MAX) {
 8009348:	2c00      	cmp	r4, #0
 800934a:	da02      	bge.n	8009352 <netconn_write_vectors_partly+0x86>
    if (!bytes_written) {
 800934c:	b35e      	cbz	r6, 80093a6 <netconn_write_vectors_partly+0xda>
    size = (size_t)limited;
 800934e:	f06f 4400 	mvn.w	r4, #2147483648	@ 0x80000000
  API_MSG_VAR_REF(msg).conn = conn;
 8009352:	f8cd c000 	str.w	ip, [sp]
  API_MSG_VAR_REF(msg).msg.w.vector = vectors;
 8009356:	9102      	str	r1, [sp, #8]
  API_MSG_VAR_REF(msg).msg.w.vector_cnt = vectorcnt;
 8009358:	f8ad 200c 	strh.w	r2, [sp, #12]
  API_MSG_VAR_REF(msg).msg.w.vector_off = 0;
 800935c:	2200      	movs	r2, #0
 800935e:	9204      	str	r2, [sp, #16]
  API_MSG_VAR_REF(msg).msg.w.apiflags = apiflags;
 8009360:	f88d 301c 	strb.w	r3, [sp, #28]
  API_MSG_VAR_REF(msg).msg.w.len = size;
 8009364:	9405      	str	r4, [sp, #20]
  API_MSG_VAR_REF(msg).msg.w.offset = 0;
 8009366:	9206      	str	r2, [sp, #24]
  err = netconn_apimsg(lwip_netconn_do_write, &API_MSG_VAR_REF(msg));
 8009368:	4669      	mov	r1, sp
 800936a:	4814      	ldr	r0, [pc, #80]	@ (80093bc <netconn_write_vectors_partly+0xf0>)
 800936c:	f7ff fe9a 	bl	80090a4 <netconn_apimsg>
  if (err == ERR_OK) {
 8009370:	4605      	mov	r5, r0
 8009372:	b998      	cbnz	r0, 800939c <netconn_write_vectors_partly+0xd0>
    if (bytes_written != NULL) {
 8009374:	b10e      	cbz	r6, 800937a <netconn_write_vectors_partly+0xae>
      *bytes_written = API_MSG_VAR_REF(msg).msg.w.offset;
 8009376:	9b06      	ldr	r3, [sp, #24]
 8009378:	6033      	str	r3, [r6, #0]
    if (!dontblock) {
 800937a:	b97f      	cbnz	r7, 800939c <netconn_write_vectors_partly+0xd0>
      LWIP_ASSERT("do_write failed to write all bytes", API_MSG_VAR_REF(msg).msg.w.offset == size);
 800937c:	9b06      	ldr	r3, [sp, #24]
 800937e:	42a3      	cmp	r3, r4
 8009380:	d00c      	beq.n	800939c <netconn_write_vectors_partly+0xd0>
 8009382:	4b0a      	ldr	r3, [pc, #40]	@ (80093ac <netconn_write_vectors_partly+0xe0>)
 8009384:	f44f 6286 	mov.w	r2, #1072	@ 0x430
 8009388:	490d      	ldr	r1, [pc, #52]	@ (80093c0 <netconn_write_vectors_partly+0xf4>)
 800938a:	480a      	ldr	r0, [pc, #40]	@ (80093b4 <netconn_write_vectors_partly+0xe8>)
 800938c:	f00a fdf8 	bl	8013f80 <iprintf>
 8009390:	e004      	b.n	800939c <netconn_write_vectors_partly+0xd0>
    return ERR_VAL;
 8009392:	f06f 0505 	mvn.w	r5, #5
 8009396:	e001      	b.n	800939c <netconn_write_vectors_partly+0xd0>
      return ERR_VAL;
 8009398:	f06f 0505 	mvn.w	r5, #5
}
 800939c:	4628      	mov	r0, r5
 800939e:	b009      	add	sp, #36	@ 0x24
 80093a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return ERR_OK;
 80093a2:	2500      	movs	r5, #0
 80093a4:	e7fa      	b.n	800939c <netconn_write_vectors_partly+0xd0>
      return ERR_VAL;
 80093a6:	f06f 0505 	mvn.w	r5, #5
 80093aa:	e7f7      	b.n	800939c <netconn_write_vectors_partly+0xd0>
 80093ac:	080156ec 	.word	0x080156ec
 80093b0:	08015840 	.word	0x08015840
 80093b4:	08015744 	.word	0x08015744
 80093b8:	0801585c 	.word	0x0801585c
 80093bc:	0800a671 	.word	0x0800a671
 80093c0:	08015880 	.word	0x08015880

080093c4 <netconn_write_partly>:
{
 80093c4:	b500      	push	{lr}
 80093c6:	b085      	sub	sp, #20
  vector.ptr = dataptr;
 80093c8:	9102      	str	r1, [sp, #8]
  vector.len = size;
 80093ca:	9203      	str	r2, [sp, #12]
  return netconn_write_vectors_partly(conn, &vector, 1, apiflags, bytes_written);
 80093cc:	9a06      	ldr	r2, [sp, #24]
 80093ce:	9200      	str	r2, [sp, #0]
 80093d0:	2201      	movs	r2, #1
 80093d2:	a902      	add	r1, sp, #8
 80093d4:	f7ff ff7a 	bl	80092cc <netconn_write_vectors_partly>
}
 80093d8:	b005      	add	sp, #20
 80093da:	f85d fb04 	ldr.w	pc, [sp], #4

080093de <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
 80093de:	b508      	push	{r3, lr}
  /* shutting down both ends is the same as closing */
  return netconn_close_shutdown(conn, NETCONN_SHUT_RDWR);
 80093e0:	2103      	movs	r1, #3
 80093e2:	f7ff fe8f 	bl	8009104 <netconn_close_shutdown>
}
 80093e6:	bd08      	pop	{r3, pc}

080093e8 <netconn_err>:
 * @param conn the netconn to get the error from
 * @return and pending error or ERR_OK if no error was pending
 */
err_t
netconn_err(struct netconn *conn)
{
 80093e8:	b538      	push	{r3, r4, r5, lr}
  err_t err;
  SYS_ARCH_DECL_PROTECT(lev);
  if (conn == NULL) {
 80093ea:	b150      	cbz	r0, 8009402 <netconn_err+0x1a>
 80093ec:	4604      	mov	r4, r0
    return ERR_OK;
  }
  SYS_ARCH_PROTECT(lev);
 80093ee:	f00a f8ad 	bl	801354c <sys_arch_protect>
  err = conn->pending_err;
 80093f2:	f994 5008 	ldrsb.w	r5, [r4, #8]
  conn->pending_err = ERR_OK;
 80093f6:	2300      	movs	r3, #0
 80093f8:	7223      	strb	r3, [r4, #8]
  SYS_ARCH_UNPROTECT(lev);
 80093fa:	f00a f8b3 	bl	8013564 <sys_arch_unprotect>
  return err;
}
 80093fe:	4628      	mov	r0, r5
 8009400:	bd38      	pop	{r3, r4, r5, pc}
    return ERR_OK;
 8009402:	2500      	movs	r5, #0
 8009404:	e7fb      	b.n	80093fe <netconn_err+0x16>
	...

08009408 <netconn_accept>:
{
 8009408:	b5f0      	push	{r4, r5, r6, r7, lr}
 800940a:	b083      	sub	sp, #12
  LWIP_ERROR("netconn_accept: invalid pointer",    (new_conn != NULL),                  return ERR_ARG;);
 800940c:	b169      	cbz	r1, 800942a <netconn_accept+0x22>
 800940e:	4604      	mov	r4, r0
 8009410:	460e      	mov	r6, r1
  *new_conn = NULL;
 8009412:	2300      	movs	r3, #0
 8009414:	600b      	str	r3, [r1, #0]
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return ERR_ARG;);
 8009416:	b190      	cbz	r0, 800943e <netconn_accept+0x36>
  err = netconn_err(conn);
 8009418:	f7ff ffe6 	bl	80093e8 <netconn_err>
 800941c:	4605      	mov	r5, r0
 800941e:	f88d 0007 	strb.w	r0, [sp, #7]
  if (err != ERR_OK) {
 8009422:	b1b0      	cbz	r0, 8009452 <netconn_accept+0x4a>
}
 8009424:	4628      	mov	r0, r5
 8009426:	b003      	add	sp, #12
 8009428:	bdf0      	pop	{r4, r5, r6, r7, pc}
  LWIP_ERROR("netconn_accept: invalid pointer",    (new_conn != NULL),                  return ERR_ARG;);
 800942a:	4b26      	ldr	r3, [pc, #152]	@ (80094c4 <netconn_accept+0xbc>)
 800942c:	f240 12e1 	movw	r2, #481	@ 0x1e1
 8009430:	4925      	ldr	r1, [pc, #148]	@ (80094c8 <netconn_accept+0xc0>)
 8009432:	4826      	ldr	r0, [pc, #152]	@ (80094cc <netconn_accept+0xc4>)
 8009434:	f00a fda4 	bl	8013f80 <iprintf>
 8009438:	f06f 050f 	mvn.w	r5, #15
 800943c:	e7f2      	b.n	8009424 <netconn_accept+0x1c>
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return ERR_ARG;);
 800943e:	4b21      	ldr	r3, [pc, #132]	@ (80094c4 <netconn_accept+0xbc>)
 8009440:	f240 12e3 	movw	r2, #483	@ 0x1e3
 8009444:	4922      	ldr	r1, [pc, #136]	@ (80094d0 <netconn_accept+0xc8>)
 8009446:	4821      	ldr	r0, [pc, #132]	@ (80094cc <netconn_accept+0xc4>)
 8009448:	f00a fd9a 	bl	8013f80 <iprintf>
 800944c:	f06f 050f 	mvn.w	r5, #15
 8009450:	e7e8      	b.n	8009424 <netconn_accept+0x1c>
  if (!NETCONN_ACCEPTMBOX_WAITABLE(conn)) {
 8009452:	f104 0714 	add.w	r7, r4, #20
 8009456:	4638      	mov	r0, r7
 8009458:	f009 ffa9 	bl	80133ae <sys_mbox_valid>
 800945c:	b340      	cbz	r0, 80094b0 <netconn_accept+0xa8>
 800945e:	7e23      	ldrb	r3, [r4, #24]
 8009460:	f013 0f01 	tst.w	r3, #1
 8009464:	d127      	bne.n	80094b6 <netconn_accept+0xae>
  if (netconn_is_nonblocking(conn)) {
 8009466:	f013 0f02 	tst.w	r3, #2
 800946a:	d009      	beq.n	8009480 <netconn_accept+0x78>
    if (sys_arch_mbox_tryfetch(&conn->acceptmbox, &accept_ptr) == SYS_ARCH_TIMEOUT) {
 800946c:	4669      	mov	r1, sp
 800946e:	4638      	mov	r0, r7
 8009470:	f009 ff8a 	bl	8013388 <sys_arch_mbox_tryfetch>
 8009474:	f1b0 3fff 	cmp.w	r0, #4294967295
 8009478:	d107      	bne.n	800948a <netconn_accept+0x82>
      return ERR_WOULDBLOCK;
 800947a:	f06f 0506 	mvn.w	r5, #6
 800947e:	e7d1      	b.n	8009424 <netconn_accept+0x1c>
    sys_arch_mbox_fetch(&conn->acceptmbox, &accept_ptr, 0);
 8009480:	2200      	movs	r2, #0
 8009482:	4669      	mov	r1, sp
 8009484:	4638      	mov	r0, r7
 8009486:	f009 ff53 	bl	8013330 <sys_arch_mbox_fetch>
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
 800948a:	6a23      	ldr	r3, [r4, #32]
 800948c:	b11b      	cbz	r3, 8009496 <netconn_accept+0x8e>
 800948e:	2200      	movs	r2, #0
 8009490:	2101      	movs	r1, #1
 8009492:	4620      	mov	r0, r4
 8009494:	4798      	blx	r3
  if (lwip_netconn_is_err_msg(accept_ptr, &err)) {
 8009496:	f10d 0107 	add.w	r1, sp, #7
 800949a:	9800      	ldr	r0, [sp, #0]
 800949c:	f000 fe0e 	bl	800a0bc <lwip_netconn_is_err_msg>
 80094a0:	b918      	cbnz	r0, 80094aa <netconn_accept+0xa2>
  if (accept_ptr == NULL) {
 80094a2:	9b00      	ldr	r3, [sp, #0]
 80094a4:	b153      	cbz	r3, 80094bc <netconn_accept+0xb4>
  *new_conn = newconn;
 80094a6:	6033      	str	r3, [r6, #0]
  return ERR_OK;
 80094a8:	e7bc      	b.n	8009424 <netconn_accept+0x1c>
    return err;
 80094aa:	f99d 5007 	ldrsb.w	r5, [sp, #7]
 80094ae:	e7b9      	b.n	8009424 <netconn_accept+0x1c>
    return ERR_CLSD;
 80094b0:	f06f 050e 	mvn.w	r5, #14
 80094b4:	e7b6      	b.n	8009424 <netconn_accept+0x1c>
 80094b6:	f06f 050e 	mvn.w	r5, #14
 80094ba:	e7b3      	b.n	8009424 <netconn_accept+0x1c>
    return ERR_CLSD;
 80094bc:	f06f 050e 	mvn.w	r5, #14
 80094c0:	e7b0      	b.n	8009424 <netconn_accept+0x1c>
 80094c2:	bf00      	nop
 80094c4:	080156ec 	.word	0x080156ec
 80094c8:	080158a4 	.word	0x080158a4
 80094cc:	08015744 	.word	0x08015744
 80094d0:	080158c4 	.word	0x080158c4

080094d4 <netconn_recv_data>:
{
 80094d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80094d6:	b083      	sub	sp, #12
  void *buf = NULL;
 80094d8:	2300      	movs	r3, #0
 80094da:	9301      	str	r3, [sp, #4]
  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 80094dc:	2900      	cmp	r1, #0
 80094de:	d037      	beq.n	8009550 <netconn_recv_data+0x7c>
 80094e0:	4604      	mov	r4, r0
 80094e2:	4616      	mov	r6, r2
 80094e4:	460f      	mov	r7, r1
  *new_buf = NULL;
 80094e6:	2300      	movs	r3, #0
 80094e8:	600b      	str	r3, [r1, #0]
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 80094ea:	2800      	cmp	r0, #0
 80094ec:	d03a      	beq.n	8009564 <netconn_recv_data+0x90>
  if (!NETCONN_RECVMBOX_WAITABLE(conn)) {
 80094ee:	f100 0510 	add.w	r5, r0, #16
 80094f2:	4628      	mov	r0, r5
 80094f4:	f009 ff5b 	bl	80133ae <sys_mbox_valid>
 80094f8:	2800      	cmp	r0, #0
 80094fa:	d03d      	beq.n	8009578 <netconn_recv_data+0xa4>
  if (netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK) ||
 80094fc:	7e23      	ldrb	r3, [r4, #24]
 80094fe:	f013 0f02 	tst.w	r3, #2
 8009502:	d109      	bne.n	8009518 <netconn_recv_data+0x44>
 8009504:	f016 0f04 	tst.w	r6, #4
 8009508:	d106      	bne.n	8009518 <netconn_recv_data+0x44>
 800950a:	f013 0f01 	tst.w	r3, #1
 800950e:	d103      	bne.n	8009518 <netconn_recv_data+0x44>
      (conn->flags & NETCONN_FLAG_MBOXCLOSED) || (conn->pending_err != ERR_OK)) {
 8009510:	f994 3008 	ldrsb.w	r3, [r4, #8]
 8009514:	2b00      	cmp	r3, #0
 8009516:	d043      	beq.n	80095a0 <netconn_recv_data+0xcc>
    if (sys_arch_mbox_tryfetch(&conn->recvmbox, &buf) == SYS_ARCH_TIMEOUT) {
 8009518:	a901      	add	r1, sp, #4
 800951a:	4628      	mov	r0, r5
 800951c:	f009 ff34 	bl	8013388 <sys_arch_mbox_tryfetch>
 8009520:	f1b0 3fff 	cmp.w	r0, #4294967295
 8009524:	d030      	beq.n	8009588 <netconn_recv_data+0xb4>
  if (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP)
 8009526:	7823      	ldrb	r3, [r4, #0]
 8009528:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 800952c:	2b10      	cmp	r3, #16
 800952e:	d03d      	beq.n	80095ac <netconn_recv_data+0xd8>
    LWIP_ASSERT("buf != NULL", buf != NULL);
 8009530:	9b01      	ldr	r3, [sp, #4]
 8009532:	2b00      	cmp	r3, #0
 8009534:	d04a      	beq.n	80095cc <netconn_recv_data+0xf8>
    len = netbuf_len((struct netbuf *)buf);
 8009536:	9b01      	ldr	r3, [sp, #4]
 8009538:	681b      	ldr	r3, [r3, #0]
 800953a:	891a      	ldrh	r2, [r3, #8]
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
 800953c:	6a23      	ldr	r3, [r4, #32]
 800953e:	b113      	cbz	r3, 8009546 <netconn_recv_data+0x72>
 8009540:	2101      	movs	r1, #1
 8009542:	4620      	mov	r0, r4
 8009544:	4798      	blx	r3
  *new_buf = buf;
 8009546:	9b01      	ldr	r3, [sp, #4]
 8009548:	603b      	str	r3, [r7, #0]
  return ERR_OK;
 800954a:	2000      	movs	r0, #0
}
 800954c:	b003      	add	sp, #12
 800954e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 8009550:	4b24      	ldr	r3, [pc, #144]	@ (80095e4 <netconn_recv_data+0x110>)
 8009552:	f44f 7212 	mov.w	r2, #584	@ 0x248
 8009556:	4924      	ldr	r1, [pc, #144]	@ (80095e8 <netconn_recv_data+0x114>)
 8009558:	4824      	ldr	r0, [pc, #144]	@ (80095ec <netconn_recv_data+0x118>)
 800955a:	f00a fd11 	bl	8013f80 <iprintf>
 800955e:	f06f 000f 	mvn.w	r0, #15
 8009562:	e7f3      	b.n	800954c <netconn_recv_data+0x78>
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 8009564:	4b1f      	ldr	r3, [pc, #124]	@ (80095e4 <netconn_recv_data+0x110>)
 8009566:	f240 224a 	movw	r2, #586	@ 0x24a
 800956a:	4921      	ldr	r1, [pc, #132]	@ (80095f0 <netconn_recv_data+0x11c>)
 800956c:	481f      	ldr	r0, [pc, #124]	@ (80095ec <netconn_recv_data+0x118>)
 800956e:	f00a fd07 	bl	8013f80 <iprintf>
 8009572:	f06f 000f 	mvn.w	r0, #15
 8009576:	e7e9      	b.n	800954c <netconn_recv_data+0x78>
    err_t err = netconn_err(conn);
 8009578:	4620      	mov	r0, r4
 800957a:	f7ff ff35 	bl	80093e8 <netconn_err>
    if (err != ERR_OK) {
 800957e:	2800      	cmp	r0, #0
 8009580:	d1e4      	bne.n	800954c <netconn_recv_data+0x78>
    return ERR_CONN;
 8009582:	f06f 000a 	mvn.w	r0, #10
 8009586:	e7e1      	b.n	800954c <netconn_recv_data+0x78>
      err = netconn_err(conn);
 8009588:	4620      	mov	r0, r4
 800958a:	f7ff ff2d 	bl	80093e8 <netconn_err>
      if (err != ERR_OK) {
 800958e:	2800      	cmp	r0, #0
 8009590:	d1dc      	bne.n	800954c <netconn_recv_data+0x78>
      if (conn->flags & NETCONN_FLAG_MBOXCLOSED) {
 8009592:	7e23      	ldrb	r3, [r4, #24]
 8009594:	f013 0f01 	tst.w	r3, #1
 8009598:	d020      	beq.n	80095dc <netconn_recv_data+0x108>
        return ERR_CONN;
 800959a:	f06f 000a 	mvn.w	r0, #10
 800959e:	e7d5      	b.n	800954c <netconn_recv_data+0x78>
    sys_arch_mbox_fetch(&conn->recvmbox, &buf, 0);
 80095a0:	2200      	movs	r2, #0
 80095a2:	a901      	add	r1, sp, #4
 80095a4:	4628      	mov	r0, r5
 80095a6:	f009 fec3 	bl	8013330 <sys_arch_mbox_fetch>
 80095aa:	e7bc      	b.n	8009526 <netconn_recv_data+0x52>
    if (lwip_netconn_is_err_msg(buf, &err)) {
 80095ac:	f10d 0103 	add.w	r1, sp, #3
 80095b0:	9801      	ldr	r0, [sp, #4]
 80095b2:	f000 fd83 	bl	800a0bc <lwip_netconn_is_err_msg>
 80095b6:	b130      	cbz	r0, 80095c6 <netconn_recv_data+0xf2>
      if (err == ERR_CLSD) {
 80095b8:	f99d 0003 	ldrsb.w	r0, [sp, #3]
 80095bc:	f110 0f0f 	cmn.w	r0, #15
 80095c0:	d1c4      	bne.n	800954c <netconn_recv_data+0x78>
        return ERR_OK;
 80095c2:	2000      	movs	r0, #0
 80095c4:	e7c2      	b.n	800954c <netconn_recv_data+0x78>
    len = ((struct pbuf *)buf)->tot_len;
 80095c6:	9b01      	ldr	r3, [sp, #4]
 80095c8:	891a      	ldrh	r2, [r3, #8]
 80095ca:	e7b7      	b.n	800953c <netconn_recv_data+0x68>
    LWIP_ASSERT("buf != NULL", buf != NULL);
 80095cc:	4b05      	ldr	r3, [pc, #20]	@ (80095e4 <netconn_recv_data+0x110>)
 80095ce:	f240 2291 	movw	r2, #657	@ 0x291
 80095d2:	4908      	ldr	r1, [pc, #32]	@ (80095f4 <netconn_recv_data+0x120>)
 80095d4:	4805      	ldr	r0, [pc, #20]	@ (80095ec <netconn_recv_data+0x118>)
 80095d6:	f00a fcd3 	bl	8013f80 <iprintf>
 80095da:	e7ac      	b.n	8009536 <netconn_recv_data+0x62>
      return ERR_WOULDBLOCK;
 80095dc:	f06f 0006 	mvn.w	r0, #6
 80095e0:	e7b4      	b.n	800954c <netconn_recv_data+0x78>
 80095e2:	bf00      	nop
 80095e4:	080156ec 	.word	0x080156ec
 80095e8:	080158e4 	.word	0x080158e4
 80095ec:	08015744 	.word	0x08015744
 80095f0:	08015904 	.word	0x08015904
 80095f4:	08015920 	.word	0x08015920

080095f8 <netconn_recv_data_tcp>:
{
 80095f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80095fc:	b088      	sub	sp, #32
 80095fe:	4604      	mov	r4, r0
 8009600:	460f      	mov	r7, r1
 8009602:	4615      	mov	r5, r2
  if (!NETCONN_RECVMBOX_WAITABLE(conn)) {
 8009604:	3010      	adds	r0, #16
 8009606:	f009 fed2 	bl	80133ae <sys_mbox_valid>
 800960a:	2800      	cmp	r0, #0
 800960c:	d03f      	beq.n	800968e <netconn_recv_data_tcp+0x96>
  if (netconn_is_flag_set(conn, NETCONN_FIN_RX_PENDING)) {
 800960e:	7e23      	ldrb	r3, [r4, #24]
 8009610:	f994 2018 	ldrsb.w	r2, [r4, #24]
 8009614:	2a00      	cmp	r2, #0
 8009616:	db1d      	blt.n	8009654 <netconn_recv_data_tcp+0x5c>
  if (!(apiflags & NETCONN_NOAUTORCVD)) {
 8009618:	f005 0808 	and.w	r8, r5, #8
  err = netconn_recv_data(conn, (void **)new_buf, apiflags);
 800961c:	462a      	mov	r2, r5
 800961e:	4639      	mov	r1, r7
 8009620:	4620      	mov	r0, r4
 8009622:	f7ff ff57 	bl	80094d4 <netconn_recv_data>
  if (err != ERR_OK) {
 8009626:	4606      	mov	r6, r0
 8009628:	bb20      	cbnz	r0, 8009674 <netconn_recv_data_tcp+0x7c>
  buf = *new_buf;
 800962a:	683f      	ldr	r7, [r7, #0]
  if (!(apiflags & NETCONN_NOAUTORCVD)) {
 800962c:	f1b8 0f00 	cmp.w	r8, #0
 8009630:	d105      	bne.n	800963e <netconn_recv_data_tcp+0x46>
    u16_t len = buf ? buf->tot_len : 1;
 8009632:	b31f      	cbz	r7, 800967c <netconn_recv_data_tcp+0x84>
 8009634:	8939      	ldrh	r1, [r7, #8]
    netconn_tcp_recvd_msg(conn, len,  &API_VAR_REF(msg));
 8009636:	466a      	mov	r2, sp
 8009638:	4620      	mov	r0, r4
 800963a:	f7ff fd41 	bl	80090c0 <netconn_tcp_recvd_msg>
  if (buf == NULL) {
 800963e:	b9cf      	cbnz	r7, 8009674 <netconn_recv_data_tcp+0x7c>
    if (apiflags & NETCONN_NOFIN) {
 8009640:	f015 0f10 	tst.w	r5, #16
 8009644:	d009      	beq.n	800965a <netconn_recv_data_tcp+0x62>
      netconn_set_flags(conn, NETCONN_FIN_RX_PENDING);
 8009646:	7e23      	ldrb	r3, [r4, #24]
 8009648:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800964c:	7623      	strb	r3, [r4, #24]
      return ERR_WOULDBLOCK;
 800964e:	f06f 0606 	mvn.w	r6, #6
 8009652:	e00f      	b.n	8009674 <netconn_recv_data_tcp+0x7c>
    netconn_clear_flags(conn, NETCONN_FIN_RX_PENDING);
 8009654:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8009658:	7623      	strb	r3, [r4, #24]
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
 800965a:	6a23      	ldr	r3, [r4, #32]
 800965c:	b11b      	cbz	r3, 8009666 <netconn_recv_data_tcp+0x6e>
 800965e:	2200      	movs	r2, #0
 8009660:	2101      	movs	r1, #1
 8009662:	4620      	mov	r0, r4
 8009664:	4798      	blx	r3
      if (conn->pcb.ip == NULL) {
 8009666:	6863      	ldr	r3, [r4, #4]
 8009668:	b953      	cbnz	r3, 8009680 <netconn_recv_data_tcp+0x88>
        err = netconn_err(conn);
 800966a:	4620      	mov	r0, r4
 800966c:	f7ff febc 	bl	80093e8 <netconn_err>
        if (err != ERR_OK) {
 8009670:	4606      	mov	r6, r0
 8009672:	b178      	cbz	r0, 8009694 <netconn_recv_data_tcp+0x9c>
}
 8009674:	4630      	mov	r0, r6
 8009676:	b008      	add	sp, #32
 8009678:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    u16_t len = buf ? buf->tot_len : 1;
 800967c:	2101      	movs	r1, #1
 800967e:	e7da      	b.n	8009636 <netconn_recv_data_tcp+0x3e>
      netconn_close_shutdown(conn, NETCONN_SHUT_RD);
 8009680:	2101      	movs	r1, #1
 8009682:	4620      	mov	r0, r4
 8009684:	f7ff fd3e 	bl	8009104 <netconn_close_shutdown>
      return ERR_CLSD;
 8009688:	f06f 060e 	mvn.w	r6, #14
 800968c:	e7f2      	b.n	8009674 <netconn_recv_data_tcp+0x7c>
    return ERR_CONN;
 800968e:	f06f 060a 	mvn.w	r6, #10
 8009692:	e7ef      	b.n	8009674 <netconn_recv_data_tcp+0x7c>
        return ERR_RST;
 8009694:	f06f 060d 	mvn.w	r6, #13
 8009698:	e7ec      	b.n	8009674 <netconn_recv_data_tcp+0x7c>
	...

0800969c <netconn_recv>:
{
 800969c:	b570      	push	{r4, r5, r6, lr}
 800969e:	b082      	sub	sp, #8
  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 80096a0:	b311      	cbz	r1, 80096e8 <netconn_recv+0x4c>
 80096a2:	4604      	mov	r4, r0
 80096a4:	460d      	mov	r5, r1
  *new_buf = NULL;
 80096a6:	2300      	movs	r3, #0
 80096a8:	600b      	str	r3, [r1, #0]
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 80096aa:	b338      	cbz	r0, 80096fc <netconn_recv+0x60>
  if (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP)
 80096ac:	7803      	ldrb	r3, [r0, #0]
 80096ae:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 80096b2:	2b10      	cmp	r3, #16
 80096b4:	d13c      	bne.n	8009730 <netconn_recv+0x94>
    struct pbuf *p = NULL;
 80096b6:	2300      	movs	r3, #0
 80096b8:	9301      	str	r3, [sp, #4]
    buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 80096ba:	2006      	movs	r0, #6
 80096bc:	f001 fee6 	bl	800b48c <memp_malloc>
    if (buf == NULL) {
 80096c0:	4606      	mov	r6, r0
 80096c2:	2800      	cmp	r0, #0
 80096c4:	d031      	beq.n	800972a <netconn_recv+0x8e>
    err = netconn_recv_data_tcp(conn, &p, 0);
 80096c6:	2200      	movs	r2, #0
 80096c8:	a901      	add	r1, sp, #4
 80096ca:	4620      	mov	r0, r4
 80096cc:	f7ff ff94 	bl	80095f8 <netconn_recv_data_tcp>
    if (err != ERR_OK) {
 80096d0:	4604      	mov	r4, r0
 80096d2:	b9e8      	cbnz	r0, 8009710 <netconn_recv+0x74>
    LWIP_ASSERT("p != NULL", p != NULL);
 80096d4:	9b01      	ldr	r3, [sp, #4]
 80096d6:	b303      	cbz	r3, 800971a <netconn_recv+0x7e>
    buf->p = p;
 80096d8:	9b01      	ldr	r3, [sp, #4]
 80096da:	6033      	str	r3, [r6, #0]
    buf->ptr = p;
 80096dc:	6073      	str	r3, [r6, #4]
    buf->port = 0;
 80096de:	2300      	movs	r3, #0
 80096e0:	81b3      	strh	r3, [r6, #12]
    ip_addr_set_zero(&buf->addr);
 80096e2:	60b3      	str	r3, [r6, #8]
    *new_buf = buf;
 80096e4:	602e      	str	r6, [r5, #0]
    return ERR_OK;
 80096e6:	e027      	b.n	8009738 <netconn_recv+0x9c>
  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 80096e8:	4b15      	ldr	r3, [pc, #84]	@ (8009740 <netconn_recv+0xa4>)
 80096ea:	f240 3263 	movw	r2, #867	@ 0x363
 80096ee:	4915      	ldr	r1, [pc, #84]	@ (8009744 <netconn_recv+0xa8>)
 80096f0:	4815      	ldr	r0, [pc, #84]	@ (8009748 <netconn_recv+0xac>)
 80096f2:	f00a fc45 	bl	8013f80 <iprintf>
 80096f6:	f06f 040f 	mvn.w	r4, #15
 80096fa:	e01d      	b.n	8009738 <netconn_recv+0x9c>
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 80096fc:	4b10      	ldr	r3, [pc, #64]	@ (8009740 <netconn_recv+0xa4>)
 80096fe:	f240 3265 	movw	r2, #869	@ 0x365
 8009702:	4912      	ldr	r1, [pc, #72]	@ (800974c <netconn_recv+0xb0>)
 8009704:	4810      	ldr	r0, [pc, #64]	@ (8009748 <netconn_recv+0xac>)
 8009706:	f00a fc3b 	bl	8013f80 <iprintf>
 800970a:	f06f 040f 	mvn.w	r4, #15
 800970e:	e013      	b.n	8009738 <netconn_recv+0x9c>
      memp_free(MEMP_NETBUF, buf);
 8009710:	4631      	mov	r1, r6
 8009712:	2006      	movs	r0, #6
 8009714:	f001 fef0 	bl	800b4f8 <memp_free>
      return err;
 8009718:	e00e      	b.n	8009738 <netconn_recv+0x9c>
    LWIP_ASSERT("p != NULL", p != NULL);
 800971a:	4b09      	ldr	r3, [pc, #36]	@ (8009740 <netconn_recv+0xa4>)
 800971c:	f240 3279 	movw	r2, #889	@ 0x379
 8009720:	490b      	ldr	r1, [pc, #44]	@ (8009750 <netconn_recv+0xb4>)
 8009722:	4809      	ldr	r0, [pc, #36]	@ (8009748 <netconn_recv+0xac>)
 8009724:	f00a fc2c 	bl	8013f80 <iprintf>
 8009728:	e7d6      	b.n	80096d8 <netconn_recv+0x3c>
      return ERR_MEM;
 800972a:	f04f 34ff 	mov.w	r4, #4294967295
 800972e:	e003      	b.n	8009738 <netconn_recv+0x9c>
    return netconn_recv_data(conn, (void **)new_buf, 0);
 8009730:	2200      	movs	r2, #0
 8009732:	f7ff fecf 	bl	80094d4 <netconn_recv_data>
 8009736:	4604      	mov	r4, r0
}
 8009738:	4620      	mov	r0, r4
 800973a:	b002      	add	sp, #8
 800973c:	bd70      	pop	{r4, r5, r6, pc}
 800973e:	bf00      	nop
 8009740:	080156ec 	.word	0x080156ec
 8009744:	080158e4 	.word	0x080158e4
 8009748:	08015744 	.word	0x08015744
 800974c:	08015904 	.word	0x08015904
 8009750:	0801592c 	.word	0x0801592c

08009754 <lwip_netconn_err_to_msg>:

/** Translate an error to a unique void* passed via an mbox */
static void *
lwip_netconn_err_to_msg(err_t err)
{
  switch (err) {
 8009754:	f110 0f0e 	cmn.w	r0, #14
 8009758:	d011      	beq.n	800977e <lwip_netconn_err_to_msg+0x2a>
 800975a:	f110 0f0d 	cmn.w	r0, #13
 800975e:	d010      	beq.n	8009782 <lwip_netconn_err_to_msg+0x2e>
 8009760:	f110 0f0f 	cmn.w	r0, #15
 8009764:	d00f      	beq.n	8009786 <lwip_netconn_err_to_msg+0x32>
    case ERR_RST:
      return LWIP_CONST_CAST(void *, &netconn_reset);
    case ERR_CLSD:
      return LWIP_CONST_CAST(void *, &netconn_closed);
    default:
      LWIP_ASSERT("unhandled error", err == ERR_OK);
 8009766:	b908      	cbnz	r0, 800976c <lwip_netconn_err_to_msg+0x18>
      return NULL;
 8009768:	2000      	movs	r0, #0
  }
}
 800976a:	4770      	bx	lr
{
 800976c:	b508      	push	{r3, lr}
      LWIP_ASSERT("unhandled error", err == ERR_OK);
 800976e:	4b07      	ldr	r3, [pc, #28]	@ (800978c <lwip_netconn_err_to_msg+0x38>)
 8009770:	227d      	movs	r2, #125	@ 0x7d
 8009772:	4907      	ldr	r1, [pc, #28]	@ (8009790 <lwip_netconn_err_to_msg+0x3c>)
 8009774:	4807      	ldr	r0, [pc, #28]	@ (8009794 <lwip_netconn_err_to_msg+0x40>)
 8009776:	f00a fc03 	bl	8013f80 <iprintf>
      return NULL;
 800977a:	2000      	movs	r0, #0
}
 800977c:	bd08      	pop	{r3, pc}
      return LWIP_CONST_CAST(void *, &netconn_reset);
 800977e:	4806      	ldr	r0, [pc, #24]	@ (8009798 <lwip_netconn_err_to_msg+0x44>)
 8009780:	4770      	bx	lr
  switch (err) {
 8009782:	4806      	ldr	r0, [pc, #24]	@ (800979c <lwip_netconn_err_to_msg+0x48>)
 8009784:	4770      	bx	lr
      return LWIP_CONST_CAST(void *, &netconn_closed);
 8009786:	4806      	ldr	r0, [pc, #24]	@ (80097a0 <lwip_netconn_err_to_msg+0x4c>)
 8009788:	4770      	bx	lr
 800978a:	bf00      	nop
 800978c:	08015938 	.word	0x08015938
 8009790:	0801596c 	.word	0x0801596c
 8009794:	08015744 	.word	0x08015744
 8009798:	08018ddd 	.word	0x08018ddd
 800979c:	08018dde 	.word	0x08018dde
 80097a0:	08018ddc 	.word	0x08018ddc

080097a4 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
         const ip_addr_t *addr, u16_t port)
{
 80097a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80097a8:	4604      	mov	r4, r0
 80097aa:	4615      	mov	r5, r2
 80097ac:	4698      	mov	r8, r3
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
 80097ae:	460e      	mov	r6, r1
 80097b0:	b369      	cbz	r1, 800980e <recv_udp+0x6a>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
 80097b2:	2c00      	cmp	r4, #0
 80097b4:	d032      	beq.n	800981c <recv_udp+0x78>
  if (conn == NULL) {
    pbuf_free(p);
    return;
  }

  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
 80097b6:	6863      	ldr	r3, [r4, #4]
 80097b8:	42b3      	cmp	r3, r6
 80097ba:	d005      	beq.n	80097c8 <recv_udp+0x24>
 80097bc:	4b24      	ldr	r3, [pc, #144]	@ (8009850 <recv_udp+0xac>)
 80097be:	22ee      	movs	r2, #238	@ 0xee
 80097c0:	4924      	ldr	r1, [pc, #144]	@ (8009854 <recv_udp+0xb0>)
 80097c2:	4825      	ldr	r0, [pc, #148]	@ (8009858 <recv_udp+0xb4>)
 80097c4:	f00a fbdc 	bl	8013f80 <iprintf>
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if (!NETCONN_MBOX_VALID(conn, &conn->recvmbox) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if (!NETCONN_MBOX_VALID(conn, &conn->recvmbox)) {
 80097c8:	f104 0710 	add.w	r7, r4, #16
 80097cc:	4638      	mov	r0, r7
 80097ce:	f009 fdee 	bl	80133ae <sys_mbox_valid>
 80097d2:	b368      	cbz	r0, 8009830 <recv_udp+0x8c>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
    return;
  }

  buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 80097d4:	2006      	movs	r0, #6
 80097d6:	f001 fe59 	bl	800b48c <memp_malloc>
  if (buf == NULL) {
 80097da:	4606      	mov	r6, r0
 80097dc:	b368      	cbz	r0, 800983a <recv_udp+0x96>
    pbuf_free(p);
    return;
  } else {
    buf->p = p;
 80097de:	6005      	str	r5, [r0, #0]
    buf->ptr = p;
 80097e0:	6045      	str	r5, [r0, #4]
    ip_addr_set(&buf->addr, addr);
 80097e2:	f1b8 0f00 	cmp.w	r8, #0
 80097e6:	d02c      	beq.n	8009842 <recv_udp+0x9e>
 80097e8:	f8d8 3000 	ldr.w	r3, [r8]
 80097ec:	60b3      	str	r3, [r6, #8]
    buf->port = port;
 80097ee:	f8bd 3018 	ldrh.w	r3, [sp, #24]
 80097f2:	81b3      	strh	r3, [r6, #12]
      buf->toport_chksum = udphdr->dest;
    }
#endif /* LWIP_NETBUF_RECVINFO */
  }

  len = p->tot_len;
 80097f4:	892d      	ldrh	r5, [r5, #8]
  if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
 80097f6:	4631      	mov	r1, r6
 80097f8:	4638      	mov	r0, r7
 80097fa:	f009 fd85 	bl	8013308 <sys_mbox_trypost>
 80097fe:	bb10      	cbnz	r0, 8009846 <recv_udp+0xa2>
  } else {
#if LWIP_SO_RCVBUF
    SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 8009800:	6a23      	ldr	r3, [r4, #32]
 8009802:	b1c3      	cbz	r3, 8009836 <recv_udp+0x92>
 8009804:	462a      	mov	r2, r5
 8009806:	2100      	movs	r1, #0
 8009808:	4620      	mov	r0, r4
 800980a:	4798      	blx	r3
 800980c:	e013      	b.n	8009836 <recv_udp+0x92>
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
 800980e:	4b10      	ldr	r3, [pc, #64]	@ (8009850 <recv_udp+0xac>)
 8009810:	22e5      	movs	r2, #229	@ 0xe5
 8009812:	4912      	ldr	r1, [pc, #72]	@ (800985c <recv_udp+0xb8>)
 8009814:	4810      	ldr	r0, [pc, #64]	@ (8009858 <recv_udp+0xb4>)
 8009816:	f00a fbb3 	bl	8013f80 <iprintf>
 800981a:	e7ca      	b.n	80097b2 <recv_udp+0xe>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
 800981c:	4b0c      	ldr	r3, [pc, #48]	@ (8009850 <recv_udp+0xac>)
 800981e:	22e6      	movs	r2, #230	@ 0xe6
 8009820:	490f      	ldr	r1, [pc, #60]	@ (8009860 <recv_udp+0xbc>)
 8009822:	480d      	ldr	r0, [pc, #52]	@ (8009858 <recv_udp+0xb4>)
 8009824:	f00a fbac 	bl	8013f80 <iprintf>
    pbuf_free(p);
 8009828:	4628      	mov	r0, r5
 800982a:	f002 f981 	bl	800bb30 <pbuf_free>
    return;
 800982e:	e002      	b.n	8009836 <recv_udp+0x92>
    pbuf_free(p);
 8009830:	4628      	mov	r0, r5
 8009832:	f002 f97d 	bl	800bb30 <pbuf_free>
  }
}
 8009836:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    pbuf_free(p);
 800983a:	4628      	mov	r0, r5
 800983c:	f002 f978 	bl	800bb30 <pbuf_free>
    return;
 8009840:	e7f9      	b.n	8009836 <recv_udp+0x92>
    ip_addr_set(&buf->addr, addr);
 8009842:	2300      	movs	r3, #0
 8009844:	e7d2      	b.n	80097ec <recv_udp+0x48>
    netbuf_delete(buf);
 8009846:	4630      	mov	r0, r6
 8009848:	f000 fff4 	bl	800a834 <netbuf_delete>
    return;
 800984c:	e7f3      	b.n	8009836 <recv_udp+0x92>
 800984e:	bf00      	nop
 8009850:	08015938 	.word	0x08015938
 8009854:	080159c0 	.word	0x080159c0
 8009858:	08015744 	.word	0x08015744
 800985c:	0801597c 	.word	0x0801597c
 8009860:	080159a0 	.word	0x080159a0

08009864 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
 8009864:	b510      	push	{r4, lr}
 8009866:	4601      	mov	r1, r0
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
 8009868:	6844      	ldr	r4, [r0, #4]
  tcp_arg(pcb, conn);
 800986a:	4620      	mov	r0, r4
 800986c:	f002 fed2 	bl	800c614 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
 8009870:	4908      	ldr	r1, [pc, #32]	@ (8009894 <setup_tcp+0x30>)
 8009872:	4620      	mov	r0, r4
 8009874:	f002 fed2 	bl	800c61c <tcp_recv>
  tcp_sent(pcb, sent_tcp);
 8009878:	4907      	ldr	r1, [pc, #28]	@ (8009898 <setup_tcp+0x34>)
 800987a:	4620      	mov	r0, r4
 800987c:	f002 fee8 	bl	800c650 <tcp_sent>
  tcp_poll(pcb, poll_tcp, NETCONN_TCP_POLL_INTERVAL);
 8009880:	2202      	movs	r2, #2
 8009882:	4906      	ldr	r1, [pc, #24]	@ (800989c <setup_tcp+0x38>)
 8009884:	4620      	mov	r0, r4
 8009886:	f002 ff1f 	bl	800c6c8 <tcp_poll>
  tcp_err(pcb, err_tcp);
 800988a:	4905      	ldr	r1, [pc, #20]	@ (80098a0 <setup_tcp+0x3c>)
 800988c:	4620      	mov	r0, r4
 800988e:	f002 fef9 	bl	800c684 <tcp_err>
}
 8009892:	bd10      	pop	{r4, pc}
 8009894:	08009ff5 	.word	0x08009ff5
 8009898:	08009f85 	.word	0x08009f85
 800989c:	08009f01 	.word	0x08009f01
 80098a0:	0800992d 	.word	0x0800992d

080098a4 <pcb_new>:
 *
 * @param msg the api_msg describing the connection type
 */
static void
pcb_new(struct api_msg *msg)
{
 80098a4:	b538      	push	{r3, r4, r5, lr}
 80098a6:	4604      	mov	r4, r0
  enum lwip_ip_addr_type iptype = IPADDR_TYPE_V4;

  LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
 80098a8:	6803      	ldr	r3, [r0, #0]
 80098aa:	685b      	ldr	r3, [r3, #4]
 80098ac:	b133      	cbz	r3, 80098bc <pcb_new+0x18>
 80098ae:	4b1b      	ldr	r3, [pc, #108]	@ (800991c <pcb_new+0x78>)
 80098b0:	f240 2265 	movw	r2, #613	@ 0x265
 80098b4:	491a      	ldr	r1, [pc, #104]	@ (8009920 <pcb_new+0x7c>)
 80098b6:	481b      	ldr	r0, [pc, #108]	@ (8009924 <pcb_new+0x80>)
 80098b8:	f00a fb62 	bl	8013f80 <iprintf>
    iptype = IPADDR_TYPE_ANY;
  }
#endif

  /* Allocate a PCB for this connection */
  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 80098bc:	6825      	ldr	r5, [r4, #0]
 80098be:	782b      	ldrb	r3, [r5, #0]
 80098c0:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 80098c4:	2b10      	cmp	r3, #16
 80098c6:	d017      	beq.n	80098f8 <pcb_new+0x54>
 80098c8:	2b20      	cmp	r3, #32
 80098ca:	d120      	bne.n	800990e <pcb_new+0x6a>
      }
      break;
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp = udp_new_ip_type(iptype);
 80098cc:	2000      	movs	r0, #0
 80098ce:	f007 fa4c 	bl	8010d6a <udp_new_ip_type>
 80098d2:	6068      	str	r0, [r5, #4]
      if (msg->conn->pcb.udp != NULL) {
 80098d4:	6823      	ldr	r3, [r4, #0]
 80098d6:	685a      	ldr	r2, [r3, #4]
 80098d8:	b13a      	cbz	r2, 80098ea <pcb_new+0x46>
#if LWIP_UDPLITE
        if (NETCONNTYPE_ISUDPLITE(msg->conn->type)) {
          udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
        }
#endif /* LWIP_UDPLITE */
        if (NETCONNTYPE_ISUDPNOCHKSUM(msg->conn->type)) {
 80098da:	781b      	ldrb	r3, [r3, #0]
 80098dc:	2b22      	cmp	r3, #34	@ 0x22
 80098de:	d008      	beq.n	80098f2 <pcb_new+0x4e>
          udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
        }
        udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
 80098e0:	6822      	ldr	r2, [r4, #0]
 80098e2:	4911      	ldr	r1, [pc, #68]	@ (8009928 <pcb_new+0x84>)
 80098e4:	6850      	ldr	r0, [r2, #4]
 80098e6:	f007 f9f3 	bl	8010cd0 <udp_recv>
    default:
      /* Unsupported netconn type, e.g. protocol disabled */
      msg->err = ERR_VAL;
      return;
  }
  if (msg->conn->pcb.ip == NULL) {
 80098ea:	6823      	ldr	r3, [r4, #0]
 80098ec:	685b      	ldr	r3, [r3, #4]
 80098ee:	b18b      	cbz	r3, 8009914 <pcb_new+0x70>
    msg->err = ERR_MEM;
  }
}
 80098f0:	bd38      	pop	{r3, r4, r5, pc}
          udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
 80098f2:	2301      	movs	r3, #1
 80098f4:	7413      	strb	r3, [r2, #16]
 80098f6:	e7f3      	b.n	80098e0 <pcb_new+0x3c>
      msg->conn->pcb.tcp = tcp_new_ip_type(iptype);
 80098f8:	2000      	movs	r0, #0
 80098fa:	f003 f9cf 	bl	800cc9c <tcp_new_ip_type>
 80098fe:	6068      	str	r0, [r5, #4]
      if (msg->conn->pcb.tcp != NULL) {
 8009900:	6820      	ldr	r0, [r4, #0]
 8009902:	6843      	ldr	r3, [r0, #4]
 8009904:	2b00      	cmp	r3, #0
 8009906:	d0f0      	beq.n	80098ea <pcb_new+0x46>
        setup_tcp(msg->conn);
 8009908:	f7ff ffac 	bl	8009864 <setup_tcp>
 800990c:	e7ed      	b.n	80098ea <pcb_new+0x46>
      msg->err = ERR_VAL;
 800990e:	23fa      	movs	r3, #250	@ 0xfa
 8009910:	7123      	strb	r3, [r4, #4]
      return;
 8009912:	e7ed      	b.n	80098f0 <pcb_new+0x4c>
    msg->err = ERR_MEM;
 8009914:	23ff      	movs	r3, #255	@ 0xff
 8009916:	7123      	strb	r3, [r4, #4]
 8009918:	e7ea      	b.n	80098f0 <pcb_new+0x4c>
 800991a:	bf00      	nop
 800991c:	08015938 	.word	0x08015938
 8009920:	080159e0 	.word	0x080159e0
 8009924:	08015744 	.word	0x08015744
 8009928:	080097a5 	.word	0x080097a5

0800992c <err_tcp>:
{
 800992c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009930:	460d      	mov	r5, r1
  LWIP_ASSERT("conn != NULL", (conn != NULL));
 8009932:	4604      	mov	r4, r0
 8009934:	2800      	cmp	r0, #0
 8009936:	d03e      	beq.n	80099b6 <err_tcp+0x8a>
  SYS_ARCH_PROTECT(lev);
 8009938:	f009 fe08 	bl	801354c <sys_arch_protect>
  conn->pcb.tcp = NULL;
 800993c:	2200      	movs	r2, #0
 800993e:	6062      	str	r2, [r4, #4]
  conn->pending_err = err;
 8009940:	7225      	strb	r5, [r4, #8]
  conn->flags |= NETCONN_FLAG_MBOXCLOSED;
 8009942:	7e23      	ldrb	r3, [r4, #24]
 8009944:	f043 0301 	orr.w	r3, r3, #1
 8009948:	7623      	strb	r3, [r4, #24]
  old_state = conn->state;
 800994a:	7866      	ldrb	r6, [r4, #1]
  conn->state = NETCONN_NONE;
 800994c:	7062      	strb	r2, [r4, #1]
  SYS_ARCH_UNPROTECT(lev);
 800994e:	f009 fe09 	bl	8013564 <sys_arch_unprotect>
  API_EVENT(conn, NETCONN_EVT_ERROR, 0);
 8009952:	6a23      	ldr	r3, [r4, #32]
 8009954:	b11b      	cbz	r3, 800995e <err_tcp+0x32>
 8009956:	2200      	movs	r2, #0
 8009958:	2104      	movs	r1, #4
 800995a:	4620      	mov	r0, r4
 800995c:	4798      	blx	r3
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 800995e:	6a23      	ldr	r3, [r4, #32]
 8009960:	b11b      	cbz	r3, 800996a <err_tcp+0x3e>
 8009962:	2200      	movs	r2, #0
 8009964:	4611      	mov	r1, r2
 8009966:	4620      	mov	r0, r4
 8009968:	4798      	blx	r3
  API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 800996a:	6a23      	ldr	r3, [r4, #32]
 800996c:	b11b      	cbz	r3, 8009976 <err_tcp+0x4a>
 800996e:	2200      	movs	r2, #0
 8009970:	2102      	movs	r1, #2
 8009972:	4620      	mov	r0, r4
 8009974:	4798      	blx	r3
  mbox_msg = lwip_netconn_err_to_msg(err);
 8009976:	4628      	mov	r0, r5
 8009978:	f7ff feec 	bl	8009754 <lwip_netconn_err_to_msg>
 800997c:	4607      	mov	r7, r0
  if (NETCONN_MBOX_VALID(conn, &conn->recvmbox)) {
 800997e:	f104 0810 	add.w	r8, r4, #16
 8009982:	4640      	mov	r0, r8
 8009984:	f009 fd13 	bl	80133ae <sys_mbox_valid>
 8009988:	b9e8      	cbnz	r0, 80099c6 <err_tcp+0x9a>
  if (NETCONN_MBOX_VALID(conn, &conn->acceptmbox)) {
 800998a:	f104 0814 	add.w	r8, r4, #20
 800998e:	4640      	mov	r0, r8
 8009990:	f009 fd0d 	bl	80133ae <sys_mbox_valid>
 8009994:	b9e0      	cbnz	r0, 80099d0 <err_tcp+0xa4>
  if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) ||
 8009996:	2e04      	cmp	r6, #4
 8009998:	bf18      	it	ne
 800999a:	2e01      	cmpne	r6, #1
 800999c:	d01d      	beq.n	80099da <err_tcp+0xae>
 800999e:	2e03      	cmp	r6, #3
 80099a0:	d01b      	beq.n	80099da <err_tcp+0xae>
    LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
 80099a2:	69e3      	ldr	r3, [r4, #28]
 80099a4:	b393      	cbz	r3, 8009a0c <err_tcp+0xe0>
 80099a6:	4b24      	ldr	r3, [pc, #144]	@ (8009a38 <err_tcp+0x10c>)
 80099a8:	f240 12f7 	movw	r2, #503	@ 0x1f7
 80099ac:	4923      	ldr	r1, [pc, #140]	@ (8009a3c <err_tcp+0x110>)
 80099ae:	4824      	ldr	r0, [pc, #144]	@ (8009a40 <err_tcp+0x114>)
 80099b0:	f00a fae6 	bl	8013f80 <iprintf>
}
 80099b4:	e02a      	b.n	8009a0c <err_tcp+0xe0>
  LWIP_ASSERT("conn != NULL", (conn != NULL));
 80099b6:	4b20      	ldr	r3, [pc, #128]	@ (8009a38 <err_tcp+0x10c>)
 80099b8:	f44f 72dc 	mov.w	r2, #440	@ 0x1b8
 80099bc:	4921      	ldr	r1, [pc, #132]	@ (8009a44 <err_tcp+0x118>)
 80099be:	4820      	ldr	r0, [pc, #128]	@ (8009a40 <err_tcp+0x114>)
 80099c0:	f00a fade 	bl	8013f80 <iprintf>
 80099c4:	e7b8      	b.n	8009938 <err_tcp+0xc>
    sys_mbox_trypost(&conn->recvmbox, mbox_msg);
 80099c6:	4639      	mov	r1, r7
 80099c8:	4640      	mov	r0, r8
 80099ca:	f009 fc9d 	bl	8013308 <sys_mbox_trypost>
 80099ce:	e7dc      	b.n	800998a <err_tcp+0x5e>
    sys_mbox_trypost(&conn->acceptmbox, mbox_msg);
 80099d0:	4639      	mov	r1, r7
 80099d2:	4640      	mov	r0, r8
 80099d4:	f009 fc98 	bl	8013308 <sys_mbox_trypost>
 80099d8:	e7dd      	b.n	8009996 <err_tcp+0x6a>
    int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
 80099da:	7e23      	ldrb	r3, [r4, #24]
    SET_NONBLOCKING_CONNECT(conn, 0);
 80099dc:	f003 02fb 	and.w	r2, r3, #251	@ 0xfb
 80099e0:	7622      	strb	r2, [r4, #24]
    if (!was_nonblocking_connect) {
 80099e2:	f013 0f04 	tst.w	r3, #4
 80099e6:	d111      	bne.n	8009a0c <err_tcp+0xe0>
      LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
 80099e8:	69e3      	ldr	r3, [r4, #28]
 80099ea:	b18b      	cbz	r3, 8009a10 <err_tcp+0xe4>
      if (old_state == NETCONN_CLOSE) {
 80099ec:	2e04      	cmp	r6, #4
 80099ee:	d017      	beq.n	8009a20 <err_tcp+0xf4>
        conn->current_msg->err = err;
 80099f0:	69e3      	ldr	r3, [r4, #28]
 80099f2:	711d      	strb	r5, [r3, #4]
      op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 80099f4:	69e3      	ldr	r3, [r4, #28]
 80099f6:	681d      	ldr	r5, [r3, #0]
 80099f8:	350c      	adds	r5, #12
      LWIP_ASSERT("inavlid op_completed_sem", sys_sem_valid(op_completed_sem));
 80099fa:	4628      	mov	r0, r5
 80099fc:	f009 fd42 	bl	8013484 <sys_sem_valid>
 8009a00:	b190      	cbz	r0, 8009a28 <err_tcp+0xfc>
      conn->current_msg = NULL;
 8009a02:	2300      	movs	r3, #0
 8009a04:	61e3      	str	r3, [r4, #28]
      sys_sem_signal(op_completed_sem);
 8009a06:	4628      	mov	r0, r5
 8009a08:	f009 fd28 	bl	801345c <sys_sem_signal>
}
 8009a0c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
 8009a10:	4b09      	ldr	r3, [pc, #36]	@ (8009a38 <err_tcp+0x10c>)
 8009a12:	f44f 72f3 	mov.w	r2, #486	@ 0x1e6
 8009a16:	490c      	ldr	r1, [pc, #48]	@ (8009a48 <err_tcp+0x11c>)
 8009a18:	4809      	ldr	r0, [pc, #36]	@ (8009a40 <err_tcp+0x114>)
 8009a1a:	f00a fab1 	bl	8013f80 <iprintf>
 8009a1e:	e7e5      	b.n	80099ec <err_tcp+0xc0>
        conn->current_msg->err = ERR_OK;
 8009a20:	69e3      	ldr	r3, [r4, #28]
 8009a22:	2200      	movs	r2, #0
 8009a24:	711a      	strb	r2, [r3, #4]
 8009a26:	e7e5      	b.n	80099f4 <err_tcp+0xc8>
      LWIP_ASSERT("inavlid op_completed_sem", sys_sem_valid(op_completed_sem));
 8009a28:	4b03      	ldr	r3, [pc, #12]	@ (8009a38 <err_tcp+0x10c>)
 8009a2a:	f240 12ef 	movw	r2, #495	@ 0x1ef
 8009a2e:	4907      	ldr	r1, [pc, #28]	@ (8009a4c <err_tcp+0x120>)
 8009a30:	4803      	ldr	r0, [pc, #12]	@ (8009a40 <err_tcp+0x114>)
 8009a32:	f00a faa5 	bl	8013f80 <iprintf>
 8009a36:	e7e4      	b.n	8009a02 <err_tcp+0xd6>
 8009a38:	08015938 	.word	0x08015938
 8009a3c:	08015a48 	.word	0x08015a48
 8009a40:	08015744 	.word	0x08015744
 8009a44:	08015a00 	.word	0x08015a00
 8009a48:	08015a10 	.word	0x08015a10
 8009a4c:	08015a2c 	.word	0x08015a2c

08009a50 <lwip_netconn_do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
lwip_netconn_do_writemore(struct netconn *conn  WRITE_DELAYED_PARAM)
{
 8009a50:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009a54:	468b      	mov	fp, r1
  size_t diff;
  u8_t dontblock;
  u8_t apiflags;
  u8_t write_more;

  LWIP_ASSERT("conn != NULL", conn != NULL);
 8009a56:	4605      	mov	r5, r0
 8009a58:	b1e0      	cbz	r0, 8009a94 <lwip_netconn_do_writemore+0x44>
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
 8009a5a:	786b      	ldrb	r3, [r5, #1]
 8009a5c:	2b01      	cmp	r3, #1
 8009a5e:	d121      	bne.n	8009aa4 <lwip_netconn_do_writemore+0x54>
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
 8009a60:	69eb      	ldr	r3, [r5, #28]
 8009a62:	b33b      	cbz	r3, 8009ab4 <lwip_netconn_do_writemore+0x64>
  LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
 8009a64:	686b      	ldr	r3, [r5, #4]
 8009a66:	b36b      	cbz	r3, 8009ac4 <lwip_netconn_do_writemore+0x74>
  LWIP_ASSERT("conn->current_msg->msg.w.offset < conn->current_msg->msg.w.len",
 8009a68:	69eb      	ldr	r3, [r5, #28]
 8009a6a:	699a      	ldr	r2, [r3, #24]
 8009a6c:	695b      	ldr	r3, [r3, #20]
 8009a6e:	429a      	cmp	r2, r3
 8009a70:	d230      	bcs.n	8009ad4 <lwip_netconn_do_writemore+0x84>
              conn->current_msg->msg.w.offset < conn->current_msg->msg.w.len);
  LWIP_ASSERT("conn->current_msg->msg.w.vector_cnt > 0", conn->current_msg->msg.w.vector_cnt > 0);
 8009a72:	69eb      	ldr	r3, [r5, #28]
 8009a74:	899b      	ldrh	r3, [r3, #12]
 8009a76:	2b00      	cmp	r3, #0
 8009a78:	d034      	beq.n	8009ae4 <lwip_netconn_do_writemore+0x94>

  apiflags = conn->current_msg->msg.w.apiflags;
 8009a7a:	69eb      	ldr	r3, [r5, #28]
 8009a7c:	f893 801c 	ldrb.w	r8, [r3, #28]
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
 8009a80:	7e2b      	ldrb	r3, [r5, #24]
 8009a82:	f013 0f02 	tst.w	r3, #2
 8009a86:	d135      	bne.n	8009af4 <lwip_netconn_do_writemore+0xa4>
 8009a88:	f018 0f04 	tst.w	r8, #4
 8009a8c:	d037      	beq.n	8009afe <lwip_netconn_do_writemore+0xae>
 8009a8e:	f04f 0a01 	mov.w	sl, #1
 8009a92:	e031      	b.n	8009af8 <lwip_netconn_do_writemore+0xa8>
  LWIP_ASSERT("conn != NULL", conn != NULL);
 8009a94:	4b8b      	ldr	r3, [pc, #556]	@ (8009cc4 <lwip_netconn_do_writemore+0x274>)
 8009a96:	f240 6273 	movw	r2, #1651	@ 0x673
 8009a9a:	498b      	ldr	r1, [pc, #556]	@ (8009cc8 <lwip_netconn_do_writemore+0x278>)
 8009a9c:	488b      	ldr	r0, [pc, #556]	@ (8009ccc <lwip_netconn_do_writemore+0x27c>)
 8009a9e:	f00a fa6f 	bl	8013f80 <iprintf>
 8009aa2:	e7da      	b.n	8009a5a <lwip_netconn_do_writemore+0xa>
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
 8009aa4:	4b87      	ldr	r3, [pc, #540]	@ (8009cc4 <lwip_netconn_do_writemore+0x274>)
 8009aa6:	f240 6274 	movw	r2, #1652	@ 0x674
 8009aaa:	4989      	ldr	r1, [pc, #548]	@ (8009cd0 <lwip_netconn_do_writemore+0x280>)
 8009aac:	4887      	ldr	r0, [pc, #540]	@ (8009ccc <lwip_netconn_do_writemore+0x27c>)
 8009aae:	f00a fa67 	bl	8013f80 <iprintf>
 8009ab2:	e7d5      	b.n	8009a60 <lwip_netconn_do_writemore+0x10>
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
 8009ab4:	4b83      	ldr	r3, [pc, #524]	@ (8009cc4 <lwip_netconn_do_writemore+0x274>)
 8009ab6:	f240 6275 	movw	r2, #1653	@ 0x675
 8009aba:	4986      	ldr	r1, [pc, #536]	@ (8009cd4 <lwip_netconn_do_writemore+0x284>)
 8009abc:	4883      	ldr	r0, [pc, #524]	@ (8009ccc <lwip_netconn_do_writemore+0x27c>)
 8009abe:	f00a fa5f 	bl	8013f80 <iprintf>
 8009ac2:	e7cf      	b.n	8009a64 <lwip_netconn_do_writemore+0x14>
  LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
 8009ac4:	4b7f      	ldr	r3, [pc, #508]	@ (8009cc4 <lwip_netconn_do_writemore+0x274>)
 8009ac6:	f240 6276 	movw	r2, #1654	@ 0x676
 8009aca:	4983      	ldr	r1, [pc, #524]	@ (8009cd8 <lwip_netconn_do_writemore+0x288>)
 8009acc:	487f      	ldr	r0, [pc, #508]	@ (8009ccc <lwip_netconn_do_writemore+0x27c>)
 8009ace:	f00a fa57 	bl	8013f80 <iprintf>
 8009ad2:	e7c9      	b.n	8009a68 <lwip_netconn_do_writemore+0x18>
  LWIP_ASSERT("conn->current_msg->msg.w.offset < conn->current_msg->msg.w.len",
 8009ad4:	4b7b      	ldr	r3, [pc, #492]	@ (8009cc4 <lwip_netconn_do_writemore+0x274>)
 8009ad6:	f240 6277 	movw	r2, #1655	@ 0x677
 8009ada:	4980      	ldr	r1, [pc, #512]	@ (8009cdc <lwip_netconn_do_writemore+0x28c>)
 8009adc:	487b      	ldr	r0, [pc, #492]	@ (8009ccc <lwip_netconn_do_writemore+0x27c>)
 8009ade:	f00a fa4f 	bl	8013f80 <iprintf>
 8009ae2:	e7c6      	b.n	8009a72 <lwip_netconn_do_writemore+0x22>
  LWIP_ASSERT("conn->current_msg->msg.w.vector_cnt > 0", conn->current_msg->msg.w.vector_cnt > 0);
 8009ae4:	4b77      	ldr	r3, [pc, #476]	@ (8009cc4 <lwip_netconn_do_writemore+0x274>)
 8009ae6:	f240 6279 	movw	r2, #1657	@ 0x679
 8009aea:	497d      	ldr	r1, [pc, #500]	@ (8009ce0 <lwip_netconn_do_writemore+0x290>)
 8009aec:	4877      	ldr	r0, [pc, #476]	@ (8009ccc <lwip_netconn_do_writemore+0x27c>)
 8009aee:	f00a fa47 	bl	8013f80 <iprintf>
 8009af2:	e7c2      	b.n	8009a7a <lwip_netconn_do_writemore+0x2a>
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
 8009af4:	f04f 0a01 	mov.w	sl, #1
 8009af8:	fa5f fa8a 	uxtb.w	sl, sl
 8009afc:	e05f      	b.n	8009bbe <lwip_netconn_do_writemore+0x16e>
 8009afe:	f04f 0a00 	mov.w	sl, #0
 8009b02:	e7f9      	b.n	8009af8 <lwip_netconn_do_writemore+0xa8>
      diff = conn->current_msg->msg.w.vector->len - conn->current_msg->msg.w.vector_off;
      if (diff > 0xffffUL) { /* max_u16_t */
        len = 0xffff;
        apiflags |= TCP_WRITE_FLAG_MORE;
      } else {
        len = (u16_t)diff;
 8009b04:	b2b4      	uxth	r4, r6
 8009b06:	e068      	b.n	8009bda <lwip_netconn_do_writemore+0x18a>
        /* don't try to write more than sendbuf */
        len = available;
        if (dontblock) {
          if (!len) {
            /* set error according to partial write or not */
            err = (conn->current_msg->msg.w.offset == 0) ? ERR_WOULDBLOCK : ERR_OK;
 8009b08:	6993      	ldr	r3, [r2, #24]
 8009b0a:	b9b3      	cbnz	r3, 8009b3a <lwip_netconn_do_writemore+0xea>
 8009b0c:	f06f 0406 	mvn.w	r4, #6
      }
    } while (write_more && err == ERR_OK);
    /* if OK or memory error, check available space */
    if ((err == ERR_OK) || (err == ERR_MEM)) {
err_mem:
      if (dontblock && (conn->current_msg->msg.w.offset < conn->current_msg->msg.w.len)) {
 8009b10:	f1ba 0f00 	cmp.w	sl, #0
 8009b14:	f000 8092 	beq.w	8009c3c <lwip_netconn_do_writemore+0x1ec>
 8009b18:	69eb      	ldr	r3, [r5, #28]
 8009b1a:	699a      	ldr	r2, [r3, #24]
 8009b1c:	695b      	ldr	r3, [r3, #20]
 8009b1e:	429a      	cmp	r2, r3
 8009b20:	f080 808c 	bcs.w	8009c3c <lwip_netconn_do_writemore+0x1ec>
        /* non-blocking write did not write everything: mark the pcb non-writable
           and let poll_tcp check writable space to mark the pcb writable again */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, 0);
 8009b24:	6a2b      	ldr	r3, [r5, #32]
 8009b26:	b11b      	cbz	r3, 8009b30 <lwip_netconn_do_writemore+0xe0>
 8009b28:	2200      	movs	r2, #0
 8009b2a:	2103      	movs	r1, #3
 8009b2c:	4628      	mov	r0, r5
 8009b2e:	4798      	blx	r3
        conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
 8009b30:	7e2b      	ldrb	r3, [r5, #24]
 8009b32:	f043 0310 	orr.w	r3, r3, #16
 8009b36:	762b      	strb	r3, [r5, #24]
 8009b38:	e091      	b.n	8009c5e <lwip_netconn_do_writemore+0x20e>
            err = (conn->current_msg->msg.w.offset == 0) ? ERR_WOULDBLOCK : ERR_OK;
 8009b3a:	2400      	movs	r4, #0
            goto err_mem;
 8009b3c:	e7e8      	b.n	8009b10 <lwip_netconn_do_writemore+0xc0>
          apiflags |= TCP_WRITE_FLAG_MORE;
 8009b3e:	f048 0802 	orr.w	r8, r8, #2
        len = available;
 8009b42:	4604      	mov	r4, r0
      LWIP_ASSERT("lwip_netconn_do_writemore: invalid length!",
 8009b44:	46a1      	mov	r9, r4
 8009b46:	4423      	add	r3, r4
 8009b48:	4299      	cmp	r1, r3
 8009b4a:	d30e      	bcc.n	8009b6a <lwip_netconn_do_writemore+0x11a>
      if ((len == 0xffff && diff > 0xffffUL) ||
 8009b4c:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8009b50:	429c      	cmp	r4, r3
 8009b52:	bf14      	ite	ne
 8009b54:	2200      	movne	r2, #0
 8009b56:	2201      	moveq	r2, #1
 8009b58:	429e      	cmp	r6, r3
 8009b5a:	bf98      	it	ls
 8009b5c:	2200      	movls	r2, #0
 8009b5e:	b982      	cbnz	r2, 8009b82 <lwip_netconn_do_writemore+0x132>
          (len == (u16_t)diff && conn->current_msg->msg.w.vector_cnt > 1)) {
 8009b60:	b2b6      	uxth	r6, r6
      if ((len == 0xffff && diff > 0xffffUL) ||
 8009b62:	42a6      	cmp	r6, r4
 8009b64:	d009      	beq.n	8009b7a <lwip_netconn_do_writemore+0x12a>
        write_more = 0;
 8009b66:	2600      	movs	r6, #0
 8009b68:	e00e      	b.n	8009b88 <lwip_netconn_do_writemore+0x138>
      LWIP_ASSERT("lwip_netconn_do_writemore: invalid length!",
 8009b6a:	4b56      	ldr	r3, [pc, #344]	@ (8009cc4 <lwip_netconn_do_writemore+0x274>)
 8009b6c:	f240 62a3 	movw	r2, #1699	@ 0x6a3
 8009b70:	495c      	ldr	r1, [pc, #368]	@ (8009ce4 <lwip_netconn_do_writemore+0x294>)
 8009b72:	4856      	ldr	r0, [pc, #344]	@ (8009ccc <lwip_netconn_do_writemore+0x27c>)
 8009b74:	f00a fa04 	bl	8013f80 <iprintf>
 8009b78:	e7e8      	b.n	8009b4c <lwip_netconn_do_writemore+0xfc>
          (len == (u16_t)diff && conn->current_msg->msg.w.vector_cnt > 1)) {
 8009b7a:	69eb      	ldr	r3, [r5, #28]
 8009b7c:	899b      	ldrh	r3, [r3, #12]
 8009b7e:	2b01      	cmp	r3, #1
 8009b80:	d937      	bls.n	8009bf2 <lwip_netconn_do_writemore+0x1a2>
        apiflags |= TCP_WRITE_FLAG_MORE;
 8009b82:	f048 0802 	orr.w	r8, r8, #2
        write_more = 1;
 8009b86:	2601      	movs	r6, #1
      err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
 8009b88:	4643      	mov	r3, r8
 8009b8a:	4622      	mov	r2, r4
 8009b8c:	4639      	mov	r1, r7
 8009b8e:	6868      	ldr	r0, [r5, #4]
 8009b90:	f005 fc72 	bl	800f478 <tcp_write>
      if (err == ERR_OK) {
 8009b94:	4604      	mov	r4, r0
 8009b96:	b968      	cbnz	r0, 8009bb4 <lwip_netconn_do_writemore+0x164>
        conn->current_msg->msg.w.offset += len;
 8009b98:	69ea      	ldr	r2, [r5, #28]
 8009b9a:	6993      	ldr	r3, [r2, #24]
 8009b9c:	444b      	add	r3, r9
 8009b9e:	6193      	str	r3, [r2, #24]
        conn->current_msg->msg.w.vector_off += len;
 8009ba0:	69ea      	ldr	r2, [r5, #28]
 8009ba2:	6913      	ldr	r3, [r2, #16]
 8009ba4:	444b      	add	r3, r9
 8009ba6:	6113      	str	r3, [r2, #16]
        if (conn->current_msg->msg.w.vector_off == conn->current_msg->msg.w.vector->len) {
 8009ba8:	69eb      	ldr	r3, [r5, #28]
 8009baa:	6919      	ldr	r1, [r3, #16]
 8009bac:	689a      	ldr	r2, [r3, #8]
 8009bae:	6852      	ldr	r2, [r2, #4]
 8009bb0:	4291      	cmp	r1, r2
 8009bb2:	d020      	beq.n	8009bf6 <lwip_netconn_do_writemore+0x1a6>
    } while (write_more && err == ERR_OK);
 8009bb4:	fab4 f384 	clz	r3, r4
 8009bb8:	095b      	lsrs	r3, r3, #5
 8009bba:	b356      	cbz	r6, 8009c12 <lwip_netconn_do_writemore+0x1c2>
 8009bbc:	b34b      	cbz	r3, 8009c12 <lwip_netconn_do_writemore+0x1c2>
      dataptr = (const u8_t *)conn->current_msg->msg.w.vector->ptr + conn->current_msg->msg.w.vector_off;
 8009bbe:	69ea      	ldr	r2, [r5, #28]
 8009bc0:	6891      	ldr	r1, [r2, #8]
 8009bc2:	680f      	ldr	r7, [r1, #0]
 8009bc4:	6913      	ldr	r3, [r2, #16]
 8009bc6:	441f      	add	r7, r3
      diff = conn->current_msg->msg.w.vector->len - conn->current_msg->msg.w.vector_off;
 8009bc8:	6849      	ldr	r1, [r1, #4]
 8009bca:	1ace      	subs	r6, r1, r3
      if (diff > 0xffffUL) { /* max_u16_t */
 8009bcc:	f5b6 3f80 	cmp.w	r6, #65536	@ 0x10000
 8009bd0:	d398      	bcc.n	8009b04 <lwip_netconn_do_writemore+0xb4>
        apiflags |= TCP_WRITE_FLAG_MORE;
 8009bd2:	f048 0802 	orr.w	r8, r8, #2
        len = 0xffff;
 8009bd6:	f64f 74ff 	movw	r4, #65535	@ 0xffff
      available = tcp_sndbuf(conn->pcb.tcp);
 8009bda:	6868      	ldr	r0, [r5, #4]
 8009bdc:	f8b0 0064 	ldrh.w	r0, [r0, #100]	@ 0x64
      if (available < len) {
 8009be0:	4284      	cmp	r4, r0
 8009be2:	d9af      	bls.n	8009b44 <lwip_netconn_do_writemore+0xf4>
        if (dontblock) {
 8009be4:	f1ba 0f00 	cmp.w	sl, #0
 8009be8:	d0a9      	beq.n	8009b3e <lwip_netconn_do_writemore+0xee>
          if (!len) {
 8009bea:	2800      	cmp	r0, #0
 8009bec:	d08c      	beq.n	8009b08 <lwip_netconn_do_writemore+0xb8>
        len = available;
 8009bee:	4604      	mov	r4, r0
 8009bf0:	e7a8      	b.n	8009b44 <lwip_netconn_do_writemore+0xf4>
        write_more = 0;
 8009bf2:	2600      	movs	r6, #0
 8009bf4:	e7c8      	b.n	8009b88 <lwip_netconn_do_writemore+0x138>
          conn->current_msg->msg.w.vector_cnt--;
 8009bf6:	899a      	ldrh	r2, [r3, #12]
 8009bf8:	3a01      	subs	r2, #1
 8009bfa:	819a      	strh	r2, [r3, #12]
          if (conn->current_msg->msg.w.vector_cnt > 0) {
 8009bfc:	69eb      	ldr	r3, [r5, #28]
 8009bfe:	899a      	ldrh	r2, [r3, #12]
 8009c00:	2a00      	cmp	r2, #0
 8009c02:	d0d7      	beq.n	8009bb4 <lwip_netconn_do_writemore+0x164>
            conn->current_msg->msg.w.vector++;
 8009c04:	689a      	ldr	r2, [r3, #8]
 8009c06:	3208      	adds	r2, #8
 8009c08:	609a      	str	r2, [r3, #8]
            conn->current_msg->msg.w.vector_off = 0;
 8009c0a:	69eb      	ldr	r3, [r5, #28]
 8009c0c:	2200      	movs	r2, #0
 8009c0e:	611a      	str	r2, [r3, #16]
 8009c10:	e7d0      	b.n	8009bb4 <lwip_netconn_do_writemore+0x164>
    if ((err == ERR_OK) || (err == ERR_MEM)) {
 8009c12:	1c63      	adds	r3, r4, #1
 8009c14:	b2db      	uxtb	r3, r3
 8009c16:	2b01      	cmp	r3, #1
 8009c18:	f67f af7a 	bls.w	8009b10 <lwip_netconn_do_writemore+0xc0>
           don't try writing any more but return the error
           to the application thread. */
        err = out_err;
        write_finished = 1;
      }
    } else if (err == ERR_MEM) {
 8009c1c:	f1b4 3fff 	cmp.w	r4, #4294967295
 8009c20:	d038      	beq.n	8009c94 <lwip_netconn_do_writemore+0x244>
    }
  }
  if (write_finished) {
    /* everything was written: set back connection state
       and back to application task */
    sys_sem_t *op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 8009c22:	69eb      	ldr	r3, [r5, #28]
 8009c24:	6818      	ldr	r0, [r3, #0]
 8009c26:	300c      	adds	r0, #12
    conn->current_msg->err = err;
 8009c28:	711c      	strb	r4, [r3, #4]
    conn->current_msg = NULL;
 8009c2a:	2300      	movs	r3, #0
 8009c2c:	61eb      	str	r3, [r5, #28]
    conn->state = NETCONN_NONE;
 8009c2e:	706b      	strb	r3, [r5, #1]
#if LWIP_TCPIP_CORE_LOCKING
    if (delayed)
 8009c30:	f1bb 0f00 	cmp.w	fp, #0
 8009c34:	d142      	bne.n	8009cbc <lwip_netconn_do_writemore+0x26c>
#if LWIP_TCPIP_CORE_LOCKING
  else {
    return ERR_MEM;
  }
#endif
  return ERR_OK;
 8009c36:	2000      	movs	r0, #0
}
 8009c38:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
 8009c3c:	686b      	ldr	r3, [r5, #4]
 8009c3e:	f8b3 1064 	ldrh.w	r1, [r3, #100]	@ 0x64
 8009c42:	f640 3269 	movw	r2, #2921	@ 0xb69
 8009c46:	4291      	cmp	r1, r2
 8009c48:	d903      	bls.n	8009c52 <lwip_netconn_do_writemore+0x202>
                 (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
 8009c4a:	f8b3 3066 	ldrh.w	r3, [r3, #102]	@ 0x66
      } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
 8009c4e:	2b07      	cmp	r3, #7
 8009c50:	d905      	bls.n	8009c5e <lwip_netconn_do_writemore+0x20e>
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, 0);
 8009c52:	6a2b      	ldr	r3, [r5, #32]
 8009c54:	b11b      	cbz	r3, 8009c5e <lwip_netconn_do_writemore+0x20e>
 8009c56:	2200      	movs	r2, #0
 8009c58:	2103      	movs	r1, #3
 8009c5a:	4628      	mov	r0, r5
 8009c5c:	4798      	blx	r3
    if (err == ERR_OK) {
 8009c5e:	2c00      	cmp	r4, #0
 8009c60:	d1dc      	bne.n	8009c1c <lwip_netconn_do_writemore+0x1cc>
      if ((conn->current_msg->msg.w.offset == conn->current_msg->msg.w.len) || dontblock) {
 8009c62:	69eb      	ldr	r3, [r5, #28]
 8009c64:	699a      	ldr	r2, [r3, #24]
 8009c66:	695b      	ldr	r3, [r3, #20]
 8009c68:	429a      	cmp	r2, r3
 8009c6a:	d005      	beq.n	8009c78 <lwip_netconn_do_writemore+0x228>
 8009c6c:	f1ba 0f00 	cmp.w	sl, #0
 8009c70:	d004      	beq.n	8009c7c <lwip_netconn_do_writemore+0x22c>
        write_finished = 1;
 8009c72:	f04f 0a01 	mov.w	sl, #1
 8009c76:	e001      	b.n	8009c7c <lwip_netconn_do_writemore+0x22c>
 8009c78:	f04f 0a01 	mov.w	sl, #1
      out_err = tcp_output(conn->pcb.tcp);
 8009c7c:	6868      	ldr	r0, [r5, #4]
 8009c7e:	f006 f9ff 	bl	8010080 <tcp_output>
      if (out_err == ERR_RTE) {
 8009c82:	f110 0f04 	cmn.w	r0, #4
 8009c86:	d015      	beq.n	8009cb4 <lwip_netconn_do_writemore+0x264>
  if (write_finished) {
 8009c88:	f1ba 0f00 	cmp.w	sl, #0
 8009c8c:	d1c9      	bne.n	8009c22 <lwip_netconn_do_writemore+0x1d2>
    return ERR_MEM;
 8009c8e:	f04f 30ff 	mov.w	r0, #4294967295
 8009c92:	e7d1      	b.n	8009c38 <lwip_netconn_do_writemore+0x1e8>
      err_t out_err = tcp_output(conn->pcb.tcp);
 8009c94:	6868      	ldr	r0, [r5, #4]
 8009c96:	f006 f9f3 	bl	8010080 <tcp_output>
 8009c9a:	4604      	mov	r4, r0
      if (out_err == ERR_RTE) {
 8009c9c:	f110 0f04 	cmn.w	r0, #4
 8009ca0:	d0bf      	beq.n	8009c22 <lwip_netconn_do_writemore+0x1d2>
      } else if (dontblock) {
 8009ca2:	f1ba 0f00 	cmp.w	sl, #0
 8009ca6:	d0f2      	beq.n	8009c8e <lwip_netconn_do_writemore+0x23e>
        err = (conn->current_msg->msg.w.offset == 0) ? ERR_WOULDBLOCK : ERR_OK;
 8009ca8:	69eb      	ldr	r3, [r5, #28]
 8009caa:	699b      	ldr	r3, [r3, #24]
 8009cac:	b923      	cbnz	r3, 8009cb8 <lwip_netconn_do_writemore+0x268>
 8009cae:	f06f 0406 	mvn.w	r4, #6
 8009cb2:	e7b6      	b.n	8009c22 <lwip_netconn_do_writemore+0x1d2>
        err = out_err;
 8009cb4:	4604      	mov	r4, r0
 8009cb6:	e7b4      	b.n	8009c22 <lwip_netconn_do_writemore+0x1d2>
        err = (conn->current_msg->msg.w.offset == 0) ? ERR_WOULDBLOCK : ERR_OK;
 8009cb8:	2400      	movs	r4, #0
 8009cba:	e7b2      	b.n	8009c22 <lwip_netconn_do_writemore+0x1d2>
      sys_sem_signal(op_completed_sem);
 8009cbc:	f009 fbce 	bl	801345c <sys_sem_signal>
  return ERR_OK;
 8009cc0:	2000      	movs	r0, #0
 8009cc2:	e7b9      	b.n	8009c38 <lwip_netconn_do_writemore+0x1e8>
 8009cc4:	08015938 	.word	0x08015938
 8009cc8:	08015a00 	.word	0x08015a00
 8009ccc:	08015744 	.word	0x08015744
 8009cd0:	08015a64 	.word	0x08015a64
 8009cd4:	08015a10 	.word	0x08015a10
 8009cd8:	08015a84 	.word	0x08015a84
 8009cdc:	08015a9c 	.word	0x08015a9c
 8009ce0:	08015adc 	.word	0x08015adc
 8009ce4:	08015b04 	.word	0x08015b04

08009ce8 <lwip_netconn_do_close_internal>:
{
 8009ce8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8009cec:	4688      	mov	r8, r1
  LWIP_ASSERT("invalid conn", (conn != NULL));
 8009cee:	4604      	mov	r4, r0
 8009cf0:	2800      	cmp	r0, #0
 8009cf2:	d05b      	beq.n	8009dac <lwip_netconn_do_close_internal+0xc4>
  LWIP_ASSERT("this is for tcp netconns only", (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP));
 8009cf4:	7823      	ldrb	r3, [r4, #0]
 8009cf6:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 8009cfa:	2b10      	cmp	r3, #16
 8009cfc:	d15e      	bne.n	8009dbc <lwip_netconn_do_close_internal+0xd4>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
 8009cfe:	7863      	ldrb	r3, [r4, #1]
 8009d00:	2b04      	cmp	r3, #4
 8009d02:	d163      	bne.n	8009dcc <lwip_netconn_do_close_internal+0xe4>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
 8009d04:	6863      	ldr	r3, [r4, #4]
 8009d06:	2b00      	cmp	r3, #0
 8009d08:	d068      	beq.n	8009ddc <lwip_netconn_do_close_internal+0xf4>
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
 8009d0a:	69e3      	ldr	r3, [r4, #28]
 8009d0c:	2b00      	cmp	r3, #0
 8009d0e:	d06d      	beq.n	8009dec <lwip_netconn_do_close_internal+0x104>
  tpcb = conn->pcb.tcp;
 8009d10:	6866      	ldr	r6, [r4, #4]
  shut = conn->current_msg->msg.sd.shut;
 8009d12:	69e3      	ldr	r3, [r4, #28]
 8009d14:	7a1b      	ldrb	r3, [r3, #8]
  shut_rx = shut & NETCONN_SHUT_RD;
 8009d16:	f003 0901 	and.w	r9, r3, #1
  shut_tx = shut & NETCONN_SHUT_WR;
 8009d1a:	f003 0702 	and.w	r7, r3, #2
  if (shut == NETCONN_SHUT_RDWR) {
 8009d1e:	2b03      	cmp	r3, #3
 8009d20:	d00f      	beq.n	8009d42 <lwip_netconn_do_close_internal+0x5a>
  } else if (shut_rx &&
 8009d22:	f1b9 0f00 	cmp.w	r9, #0
 8009d26:	d006      	beq.n	8009d36 <lwip_netconn_do_close_internal+0x4e>
             ((tpcb->state == FIN_WAIT_1) ||
 8009d28:	7d32      	ldrb	r2, [r6, #20]
              (tpcb->state == FIN_WAIT_2) ||
 8009d2a:	1f53      	subs	r3, r2, #5
 8009d2c:	b2db      	uxtb	r3, r3
  } else if (shut_rx &&
 8009d2e:	2a08      	cmp	r2, #8
 8009d30:	bf18      	it	ne
 8009d32:	2b01      	cmpne	r3, #1
 8009d34:	d905      	bls.n	8009d42 <lwip_netconn_do_close_internal+0x5a>
  } else if (shut_tx && ((tpcb->flags & TF_RXCLOSED) != 0)) {
 8009d36:	2f00      	cmp	r7, #0
 8009d38:	d060      	beq.n	8009dfc <lwip_netconn_do_close_internal+0x114>
 8009d3a:	8b73      	ldrh	r3, [r6, #26]
 8009d3c:	f013 0f10 	tst.w	r3, #16
 8009d40:	d05e      	beq.n	8009e00 <lwip_netconn_do_close_internal+0x118>
    tcp_arg(tpcb, NULL);
 8009d42:	2100      	movs	r1, #0
 8009d44:	4630      	mov	r0, r6
 8009d46:	f002 fc65 	bl	800c614 <tcp_arg>
 8009d4a:	f04f 0a01 	mov.w	sl, #1
  if (tpcb->state == LISTEN) {
 8009d4e:	7d33      	ldrb	r3, [r6, #20]
 8009d50:	2b01      	cmp	r3, #1
 8009d52:	d058      	beq.n	8009e06 <lwip_netconn_do_close_internal+0x11e>
    if (shut_rx) {
 8009d54:	f1b9 0f00 	cmp.w	r9, #0
 8009d58:	d15a      	bne.n	8009e10 <lwip_netconn_do_close_internal+0x128>
    if (shut_tx) {
 8009d5a:	2f00      	cmp	r7, #0
 8009d5c:	d161      	bne.n	8009e22 <lwip_netconn_do_close_internal+0x13a>
    if (shut_close) {
 8009d5e:	f1ba 0f00 	cmp.w	sl, #0
 8009d62:	d163      	bne.n	8009e2c <lwip_netconn_do_close_internal+0x144>
    err = tcp_shutdown(tpcb, shut_rx, shut_tx);
 8009d64:	463a      	mov	r2, r7
 8009d66:	4649      	mov	r1, r9
 8009d68:	4630      	mov	r0, r6
 8009d6a:	f003 f911 	bl	800cf90 <tcp_shutdown>
 8009d6e:	4605      	mov	r5, r0
  if (err == ERR_OK) {
 8009d70:	2d00      	cmp	r5, #0
 8009d72:	d06f      	beq.n	8009e54 <lwip_netconn_do_close_internal+0x16c>
    if (err == ERR_MEM) {
 8009d74:	f1b5 3fff 	cmp.w	r5, #4294967295
 8009d78:	d16c      	bne.n	8009e54 <lwip_netconn_do_close_internal+0x16c>
      if (conn->current_msg->msg.sd.polls_left == 0) {
 8009d7a:	69e3      	ldr	r3, [r4, #28]
 8009d7c:	7a5b      	ldrb	r3, [r3, #9]
 8009d7e:	2b00      	cmp	r3, #0
 8009d80:	d065      	beq.n	8009e4e <lwip_netconn_do_close_internal+0x166>
    LWIP_ASSERT("Closing a listen pcb may not fail!", (tpcb->state != LISTEN));
 8009d82:	7d33      	ldrb	r3, [r6, #20]
 8009d84:	2b01      	cmp	r3, #1
 8009d86:	f000 8097 	beq.w	8009eb8 <lwip_netconn_do_close_internal+0x1d0>
    if (shut_tx) {
 8009d8a:	2f00      	cmp	r7, #0
 8009d8c:	f040 809c 	bne.w	8009ec8 <lwip_netconn_do_close_internal+0x1e0>
    tcp_poll(tpcb, poll_tcp, 1);
 8009d90:	2201      	movs	r2, #1
 8009d92:	4950      	ldr	r1, [pc, #320]	@ (8009ed4 <lwip_netconn_do_close_internal+0x1ec>)
 8009d94:	4630      	mov	r0, r6
 8009d96:	f002 fc97 	bl	800c6c8 <tcp_poll>
    tcp_err(tpcb, err_tcp);
 8009d9a:	494f      	ldr	r1, [pc, #316]	@ (8009ed8 <lwip_netconn_do_close_internal+0x1f0>)
 8009d9c:	4630      	mov	r0, r6
 8009d9e:	f002 fc71 	bl	800c684 <tcp_err>
    tcp_arg(tpcb, conn);
 8009da2:	4621      	mov	r1, r4
 8009da4:	4630      	mov	r0, r6
 8009da6:	f002 fc35 	bl	800c614 <tcp_arg>
  return err;
 8009daa:	e079      	b.n	8009ea0 <lwip_netconn_do_close_internal+0x1b8>
  LWIP_ASSERT("invalid conn", (conn != NULL));
 8009dac:	4b4b      	ldr	r3, [pc, #300]	@ (8009edc <lwip_netconn_do_close_internal+0x1f4>)
 8009dae:	f240 32a2 	movw	r2, #930	@ 0x3a2
 8009db2:	494b      	ldr	r1, [pc, #300]	@ (8009ee0 <lwip_netconn_do_close_internal+0x1f8>)
 8009db4:	484b      	ldr	r0, [pc, #300]	@ (8009ee4 <lwip_netconn_do_close_internal+0x1fc>)
 8009db6:	f00a f8e3 	bl	8013f80 <iprintf>
 8009dba:	e79b      	b.n	8009cf4 <lwip_netconn_do_close_internal+0xc>
  LWIP_ASSERT("this is for tcp netconns only", (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP));
 8009dbc:	4b47      	ldr	r3, [pc, #284]	@ (8009edc <lwip_netconn_do_close_internal+0x1f4>)
 8009dbe:	f240 32a3 	movw	r2, #931	@ 0x3a3
 8009dc2:	4949      	ldr	r1, [pc, #292]	@ (8009ee8 <lwip_netconn_do_close_internal+0x200>)
 8009dc4:	4847      	ldr	r0, [pc, #284]	@ (8009ee4 <lwip_netconn_do_close_internal+0x1fc>)
 8009dc6:	f00a f8db 	bl	8013f80 <iprintf>
 8009dca:	e798      	b.n	8009cfe <lwip_netconn_do_close_internal+0x16>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
 8009dcc:	4b43      	ldr	r3, [pc, #268]	@ (8009edc <lwip_netconn_do_close_internal+0x1f4>)
 8009dce:	f44f 7269 	mov.w	r2, #932	@ 0x3a4
 8009dd2:	4946      	ldr	r1, [pc, #280]	@ (8009eec <lwip_netconn_do_close_internal+0x204>)
 8009dd4:	4843      	ldr	r0, [pc, #268]	@ (8009ee4 <lwip_netconn_do_close_internal+0x1fc>)
 8009dd6:	f00a f8d3 	bl	8013f80 <iprintf>
 8009dda:	e793      	b.n	8009d04 <lwip_netconn_do_close_internal+0x1c>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
 8009ddc:	4b3f      	ldr	r3, [pc, #252]	@ (8009edc <lwip_netconn_do_close_internal+0x1f4>)
 8009dde:	f240 32a5 	movw	r2, #933	@ 0x3a5
 8009de2:	4943      	ldr	r1, [pc, #268]	@ (8009ef0 <lwip_netconn_do_close_internal+0x208>)
 8009de4:	483f      	ldr	r0, [pc, #252]	@ (8009ee4 <lwip_netconn_do_close_internal+0x1fc>)
 8009de6:	f00a f8cb 	bl	8013f80 <iprintf>
 8009dea:	e78e      	b.n	8009d0a <lwip_netconn_do_close_internal+0x22>
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
 8009dec:	4b3b      	ldr	r3, [pc, #236]	@ (8009edc <lwip_netconn_do_close_internal+0x1f4>)
 8009dee:	f240 32a6 	movw	r2, #934	@ 0x3a6
 8009df2:	4940      	ldr	r1, [pc, #256]	@ (8009ef4 <lwip_netconn_do_close_internal+0x20c>)
 8009df4:	483b      	ldr	r0, [pc, #236]	@ (8009ee4 <lwip_netconn_do_close_internal+0x1fc>)
 8009df6:	f00a f8c3 	bl	8013f80 <iprintf>
 8009dfa:	e789      	b.n	8009d10 <lwip_netconn_do_close_internal+0x28>
    shut_close = 0;
 8009dfc:	46ba      	mov	sl, r7
 8009dfe:	e7a6      	b.n	8009d4e <lwip_netconn_do_close_internal+0x66>
 8009e00:	f04f 0a00 	mov.w	sl, #0
 8009e04:	e7a3      	b.n	8009d4e <lwip_netconn_do_close_internal+0x66>
    tcp_accept(tpcb, NULL);
 8009e06:	2100      	movs	r1, #0
 8009e08:	4630      	mov	r0, r6
 8009e0a:	f002 fc55 	bl	800c6b8 <tcp_accept>
 8009e0e:	e016      	b.n	8009e3e <lwip_netconn_do_close_internal+0x156>
      tcp_recv(tpcb, NULL);
 8009e10:	2100      	movs	r1, #0
 8009e12:	4630      	mov	r0, r6
 8009e14:	f002 fc02 	bl	800c61c <tcp_recv>
      tcp_accept(tpcb, NULL);
 8009e18:	2100      	movs	r1, #0
 8009e1a:	4630      	mov	r0, r6
 8009e1c:	f002 fc4c 	bl	800c6b8 <tcp_accept>
 8009e20:	e79b      	b.n	8009d5a <lwip_netconn_do_close_internal+0x72>
      tcp_sent(tpcb, NULL);
 8009e22:	2100      	movs	r1, #0
 8009e24:	4630      	mov	r0, r6
 8009e26:	f002 fc13 	bl	800c650 <tcp_sent>
 8009e2a:	e798      	b.n	8009d5e <lwip_netconn_do_close_internal+0x76>
      tcp_poll(tpcb, NULL, 0);
 8009e2c:	2200      	movs	r2, #0
 8009e2e:	4611      	mov	r1, r2
 8009e30:	4630      	mov	r0, r6
 8009e32:	f002 fc49 	bl	800c6c8 <tcp_poll>
      tcp_err(tpcb, NULL);
 8009e36:	2100      	movs	r1, #0
 8009e38:	4630      	mov	r0, r6
 8009e3a:	f002 fc23 	bl	800c684 <tcp_err>
  if (shut_close) {
 8009e3e:	f1ba 0f00 	cmp.w	sl, #0
 8009e42:	d08f      	beq.n	8009d64 <lwip_netconn_do_close_internal+0x7c>
      err = tcp_close(tpcb);
 8009e44:	4630      	mov	r0, r6
 8009e46:	f002 ffd7 	bl	800cdf8 <tcp_close>
 8009e4a:	4605      	mov	r5, r0
 8009e4c:	e790      	b.n	8009d70 <lwip_netconn_do_close_internal+0x88>
        if (shut_close) {
 8009e4e:	f1ba 0f00 	cmp.w	sl, #0
 8009e52:	d128      	bne.n	8009ea6 <lwip_netconn_do_close_internal+0x1be>
    sys_sem_t *op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
 8009e54:	69e3      	ldr	r3, [r4, #28]
 8009e56:	681e      	ldr	r6, [r3, #0]
 8009e58:	360c      	adds	r6, #12
    conn->current_msg->err = err;
 8009e5a:	711d      	strb	r5, [r3, #4]
    conn->current_msg = NULL;
 8009e5c:	2300      	movs	r3, #0
 8009e5e:	61e3      	str	r3, [r4, #28]
    conn->state = NETCONN_NONE;
 8009e60:	7063      	strb	r3, [r4, #1]
    if (err == ERR_OK) {
 8009e62:	b9cd      	cbnz	r5, 8009e98 <lwip_netconn_do_close_internal+0x1b0>
      if (shut_close) {
 8009e64:	f1ba 0f00 	cmp.w	sl, #0
 8009e68:	d006      	beq.n	8009e78 <lwip_netconn_do_close_internal+0x190>
        conn->pcb.tcp = NULL;
 8009e6a:	6063      	str	r3, [r4, #4]
        API_EVENT(conn, NETCONN_EVT_ERROR, 0);
 8009e6c:	6a23      	ldr	r3, [r4, #32]
 8009e6e:	b11b      	cbz	r3, 8009e78 <lwip_netconn_do_close_internal+0x190>
 8009e70:	2200      	movs	r2, #0
 8009e72:	2104      	movs	r1, #4
 8009e74:	4620      	mov	r0, r4
 8009e76:	4798      	blx	r3
      if (shut_rx) {
 8009e78:	f1b9 0f00 	cmp.w	r9, #0
 8009e7c:	d005      	beq.n	8009e8a <lwip_netconn_do_close_internal+0x1a2>
        API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 8009e7e:	6a23      	ldr	r3, [r4, #32]
 8009e80:	b11b      	cbz	r3, 8009e8a <lwip_netconn_do_close_internal+0x1a2>
 8009e82:	2200      	movs	r2, #0
 8009e84:	4611      	mov	r1, r2
 8009e86:	4620      	mov	r0, r4
 8009e88:	4798      	blx	r3
      if (shut_tx) {
 8009e8a:	b12f      	cbz	r7, 8009e98 <lwip_netconn_do_close_internal+0x1b0>
        API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 8009e8c:	6a23      	ldr	r3, [r4, #32]
 8009e8e:	b11b      	cbz	r3, 8009e98 <lwip_netconn_do_close_internal+0x1b0>
 8009e90:	2200      	movs	r2, #0
 8009e92:	2102      	movs	r1, #2
 8009e94:	4620      	mov	r0, r4
 8009e96:	4798      	blx	r3
    if (delayed)
 8009e98:	f1b8 0f00 	cmp.w	r8, #0
 8009e9c:	d108      	bne.n	8009eb0 <lwip_netconn_do_close_internal+0x1c8>
    return ERR_OK;
 8009e9e:	2500      	movs	r5, #0
}
 8009ea0:	4628      	mov	r0, r5
 8009ea2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          tcp_abort(tpcb);
 8009ea6:	4630      	mov	r0, r6
 8009ea8:	f002 fd98 	bl	800c9dc <tcp_abort>
          err = ERR_OK;
 8009eac:	2500      	movs	r5, #0
 8009eae:	e7d1      	b.n	8009e54 <lwip_netconn_do_close_internal+0x16c>
      sys_sem_signal(op_completed_sem);
 8009eb0:	4630      	mov	r0, r6
 8009eb2:	f009 fad3 	bl	801345c <sys_sem_signal>
 8009eb6:	e7f2      	b.n	8009e9e <lwip_netconn_do_close_internal+0x1b6>
    LWIP_ASSERT("Closing a listen pcb may not fail!", (tpcb->state != LISTEN));
 8009eb8:	4b08      	ldr	r3, [pc, #32]	@ (8009edc <lwip_netconn_do_close_internal+0x1f4>)
 8009eba:	f240 4241 	movw	r2, #1089	@ 0x441
 8009ebe:	490e      	ldr	r1, [pc, #56]	@ (8009ef8 <lwip_netconn_do_close_internal+0x210>)
 8009ec0:	4808      	ldr	r0, [pc, #32]	@ (8009ee4 <lwip_netconn_do_close_internal+0x1fc>)
 8009ec2:	f00a f85d 	bl	8013f80 <iprintf>
 8009ec6:	e760      	b.n	8009d8a <lwip_netconn_do_close_internal+0xa2>
      tcp_sent(tpcb, sent_tcp);
 8009ec8:	490c      	ldr	r1, [pc, #48]	@ (8009efc <lwip_netconn_do_close_internal+0x214>)
 8009eca:	4630      	mov	r0, r6
 8009ecc:	f002 fbc0 	bl	800c650 <tcp_sent>
 8009ed0:	e75e      	b.n	8009d90 <lwip_netconn_do_close_internal+0xa8>
 8009ed2:	bf00      	nop
 8009ed4:	08009f01 	.word	0x08009f01
 8009ed8:	0800992d 	.word	0x0800992d
 8009edc:	08015938 	.word	0x08015938
 8009ee0:	08015b30 	.word	0x08015b30
 8009ee4:	08015744 	.word	0x08015744
 8009ee8:	08015b40 	.word	0x08015b40
 8009eec:	08015b60 	.word	0x08015b60
 8009ef0:	08015b84 	.word	0x08015b84
 8009ef4:	08015a10 	.word	0x08015a10
 8009ef8:	08015b98 	.word	0x08015b98
 8009efc:	08009f85 	.word	0x08009f85

08009f00 <poll_tcp>:
{
 8009f00:	b510      	push	{r4, lr}
  LWIP_ASSERT("conn != NULL", (conn != NULL));
 8009f02:	4604      	mov	r4, r0
 8009f04:	b1f8      	cbz	r0, 8009f46 <poll_tcp+0x46>
  if (conn->state == NETCONN_WRITE) {
 8009f06:	7863      	ldrb	r3, [r4, #1]
 8009f08:	2b01      	cmp	r3, #1
 8009f0a:	d024      	beq.n	8009f56 <poll_tcp+0x56>
  } else if (conn->state == NETCONN_CLOSE) {
 8009f0c:	2b04      	cmp	r3, #4
 8009f0e:	d027      	beq.n	8009f60 <poll_tcp+0x60>
  if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
 8009f10:	7e23      	ldrb	r3, [r4, #24]
 8009f12:	f013 0f10 	tst.w	r3, #16
 8009f16:	d014      	beq.n	8009f42 <poll_tcp+0x42>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 8009f18:	6862      	ldr	r2, [r4, #4]
 8009f1a:	b192      	cbz	r2, 8009f42 <poll_tcp+0x42>
 8009f1c:	f8b2 0064 	ldrh.w	r0, [r2, #100]	@ 0x64
 8009f20:	f640 3169 	movw	r1, #2921	@ 0xb69
 8009f24:	4288      	cmp	r0, r1
 8009f26:	d90c      	bls.n	8009f42 <poll_tcp+0x42>
        (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
 8009f28:	f8b2 2066 	ldrh.w	r2, [r2, #102]	@ 0x66
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 8009f2c:	2a07      	cmp	r2, #7
 8009f2e:	d808      	bhi.n	8009f42 <poll_tcp+0x42>
      netconn_clear_flags(conn, NETCONN_FLAG_CHECK_WRITESPACE);
 8009f30:	f003 03ef 	and.w	r3, r3, #239	@ 0xef
 8009f34:	7623      	strb	r3, [r4, #24]
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 8009f36:	6a23      	ldr	r3, [r4, #32]
 8009f38:	b11b      	cbz	r3, 8009f42 <poll_tcp+0x42>
 8009f3a:	2200      	movs	r2, #0
 8009f3c:	2102      	movs	r1, #2
 8009f3e:	4620      	mov	r0, r4
 8009f40:	4798      	blx	r3
}
 8009f42:	2000      	movs	r0, #0
 8009f44:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("conn != NULL", (conn != NULL));
 8009f46:	4b0c      	ldr	r3, [pc, #48]	@ (8009f78 <poll_tcp+0x78>)
 8009f48:	f44f 72b5 	mov.w	r2, #362	@ 0x16a
 8009f4c:	490b      	ldr	r1, [pc, #44]	@ (8009f7c <poll_tcp+0x7c>)
 8009f4e:	480c      	ldr	r0, [pc, #48]	@ (8009f80 <poll_tcp+0x80>)
 8009f50:	f00a f816 	bl	8013f80 <iprintf>
 8009f54:	e7d7      	b.n	8009f06 <poll_tcp+0x6>
    lwip_netconn_do_writemore(conn  WRITE_DELAYED);
 8009f56:	2101      	movs	r1, #1
 8009f58:	4620      	mov	r0, r4
 8009f5a:	f7ff fd79 	bl	8009a50 <lwip_netconn_do_writemore>
 8009f5e:	e7d7      	b.n	8009f10 <poll_tcp+0x10>
    if (conn->current_msg && conn->current_msg->msg.sd.polls_left) {
 8009f60:	69e3      	ldr	r3, [r4, #28]
 8009f62:	b11b      	cbz	r3, 8009f6c <poll_tcp+0x6c>
 8009f64:	7a5a      	ldrb	r2, [r3, #9]
 8009f66:	b10a      	cbz	r2, 8009f6c <poll_tcp+0x6c>
      conn->current_msg->msg.sd.polls_left--;
 8009f68:	3a01      	subs	r2, #1
 8009f6a:	725a      	strb	r2, [r3, #9]
    lwip_netconn_do_close_internal(conn  WRITE_DELAYED);
 8009f6c:	2101      	movs	r1, #1
 8009f6e:	4620      	mov	r0, r4
 8009f70:	f7ff feba 	bl	8009ce8 <lwip_netconn_do_close_internal>
 8009f74:	e7cc      	b.n	8009f10 <poll_tcp+0x10>
 8009f76:	bf00      	nop
 8009f78:	08015938 	.word	0x08015938
 8009f7c:	08015a00 	.word	0x08015a00
 8009f80:	08015744 	.word	0x08015744

08009f84 <sent_tcp>:
{
 8009f84:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("conn != NULL", (conn != NULL));
 8009f86:	b1e8      	cbz	r0, 8009fc4 <sent_tcp+0x40>
 8009f88:	4615      	mov	r5, r2
 8009f8a:	4604      	mov	r4, r0
    if (conn->state == NETCONN_WRITE) {
 8009f8c:	7843      	ldrb	r3, [r0, #1]
 8009f8e:	2b01      	cmp	r3, #1
 8009f90:	d021      	beq.n	8009fd6 <sent_tcp+0x52>
    } else if (conn->state == NETCONN_CLOSE) {
 8009f92:	2b04      	cmp	r3, #4
 8009f94:	d023      	beq.n	8009fde <sent_tcp+0x5a>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 8009f96:	6863      	ldr	r3, [r4, #4]
 8009f98:	b1db      	cbz	r3, 8009fd2 <sent_tcp+0x4e>
 8009f9a:	f8b3 1064 	ldrh.w	r1, [r3, #100]	@ 0x64
 8009f9e:	f640 3269 	movw	r2, #2921	@ 0xb69
 8009fa2:	4291      	cmp	r1, r2
 8009fa4:	d915      	bls.n	8009fd2 <sent_tcp+0x4e>
        (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
 8009fa6:	f8b3 3066 	ldrh.w	r3, [r3, #102]	@ 0x66
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 8009faa:	2b07      	cmp	r3, #7
 8009fac:	d811      	bhi.n	8009fd2 <sent_tcp+0x4e>
      netconn_clear_flags(conn, NETCONN_FLAG_CHECK_WRITESPACE);
 8009fae:	7e23      	ldrb	r3, [r4, #24]
 8009fb0:	f003 03ef 	and.w	r3, r3, #239	@ 0xef
 8009fb4:	7623      	strb	r3, [r4, #24]
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
 8009fb6:	6a23      	ldr	r3, [r4, #32]
 8009fb8:	b15b      	cbz	r3, 8009fd2 <sent_tcp+0x4e>
 8009fba:	462a      	mov	r2, r5
 8009fbc:	2102      	movs	r1, #2
 8009fbe:	4620      	mov	r0, r4
 8009fc0:	4798      	blx	r3
 8009fc2:	e006      	b.n	8009fd2 <sent_tcp+0x4e>
  LWIP_ASSERT("conn != NULL", (conn != NULL));
 8009fc4:	4b08      	ldr	r3, [pc, #32]	@ (8009fe8 <sent_tcp+0x64>)
 8009fc6:	f240 1293 	movw	r2, #403	@ 0x193
 8009fca:	4908      	ldr	r1, [pc, #32]	@ (8009fec <sent_tcp+0x68>)
 8009fcc:	4808      	ldr	r0, [pc, #32]	@ (8009ff0 <sent_tcp+0x6c>)
 8009fce:	f009 ffd7 	bl	8013f80 <iprintf>
}
 8009fd2:	2000      	movs	r0, #0
 8009fd4:	bd38      	pop	{r3, r4, r5, pc}
      lwip_netconn_do_writemore(conn  WRITE_DELAYED);
 8009fd6:	2101      	movs	r1, #1
 8009fd8:	f7ff fd3a 	bl	8009a50 <lwip_netconn_do_writemore>
 8009fdc:	e7db      	b.n	8009f96 <sent_tcp+0x12>
      lwip_netconn_do_close_internal(conn  WRITE_DELAYED);
 8009fde:	2101      	movs	r1, #1
 8009fe0:	f7ff fe82 	bl	8009ce8 <lwip_netconn_do_close_internal>
 8009fe4:	e7d7      	b.n	8009f96 <sent_tcp+0x12>
 8009fe6:	bf00      	nop
 8009fe8:	08015938 	.word	0x08015938
 8009fec:	08015a00 	.word	0x08015a00
 8009ff0:	08015744 	.word	0x08015744

08009ff4 <recv_tcp>:
{
 8009ff4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009ff6:	4604      	mov	r4, r0
 8009ff8:	4615      	mov	r5, r2
 8009ffa:	461e      	mov	r6, r3
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
 8009ffc:	460f      	mov	r7, r1
 8009ffe:	b321      	cbz	r1, 800a04a <recv_tcp+0x56>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
 800a000:	b35c      	cbz	r4, 800a05a <recv_tcp+0x66>
  LWIP_ASSERT("err != ERR_OK unhandled", err == ERR_OK);
 800a002:	2e00      	cmp	r6, #0
 800a004:	d131      	bne.n	800a06a <recv_tcp+0x76>
  if (conn == NULL) {
 800a006:	2c00      	cmp	r4, #0
 800a008:	d044      	beq.n	800a094 <recv_tcp+0xa0>
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
 800a00a:	6863      	ldr	r3, [r4, #4]
 800a00c:	42bb      	cmp	r3, r7
 800a00e:	d006      	beq.n	800a01e <recv_tcp+0x2a>
 800a010:	4b23      	ldr	r3, [pc, #140]	@ (800a0a0 <recv_tcp+0xac>)
 800a012:	f240 1235 	movw	r2, #309	@ 0x135
 800a016:	4923      	ldr	r1, [pc, #140]	@ (800a0a4 <recv_tcp+0xb0>)
 800a018:	4823      	ldr	r0, [pc, #140]	@ (800a0a8 <recv_tcp+0xb4>)
 800a01a:	f009 ffb1 	bl	8013f80 <iprintf>
  if (!NETCONN_MBOX_VALID(conn, &conn->recvmbox)) {
 800a01e:	f104 0610 	add.w	r6, r4, #16
 800a022:	4630      	mov	r0, r6
 800a024:	f009 f9c3 	bl	80133ae <sys_mbox_valid>
 800a028:	b338      	cbz	r0, 800a07a <recv_tcp+0x86>
  if (p != NULL) {
 800a02a:	b385      	cbz	r5, 800a08e <recv_tcp+0x9a>
    len = p->tot_len;
 800a02c:	892f      	ldrh	r7, [r5, #8]
  if (sys_mbox_trypost(&conn->recvmbox, msg) != ERR_OK) {
 800a02e:	4629      	mov	r1, r5
 800a030:	4630      	mov	r0, r6
 800a032:	f009 f969 	bl	8013308 <sys_mbox_trypost>
 800a036:	4605      	mov	r5, r0
 800a038:	bb78      	cbnz	r0, 800a09a <recv_tcp+0xa6>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 800a03a:	6a23      	ldr	r3, [r4, #32]
 800a03c:	b11b      	cbz	r3, 800a046 <recv_tcp+0x52>
 800a03e:	463a      	mov	r2, r7
 800a040:	2100      	movs	r1, #0
 800a042:	4620      	mov	r0, r4
 800a044:	4798      	blx	r3
}
 800a046:	4628      	mov	r0, r5
 800a048:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
 800a04a:	4b15      	ldr	r3, [pc, #84]	@ (800a0a0 <recv_tcp+0xac>)
 800a04c:	f44f 7296 	mov.w	r2, #300	@ 0x12c
 800a050:	4916      	ldr	r1, [pc, #88]	@ (800a0ac <recv_tcp+0xb8>)
 800a052:	4815      	ldr	r0, [pc, #84]	@ (800a0a8 <recv_tcp+0xb4>)
 800a054:	f009 ff94 	bl	8013f80 <iprintf>
 800a058:	e7d2      	b.n	800a000 <recv_tcp+0xc>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
 800a05a:	4b11      	ldr	r3, [pc, #68]	@ (800a0a0 <recv_tcp+0xac>)
 800a05c:	f240 122d 	movw	r2, #301	@ 0x12d
 800a060:	4913      	ldr	r1, [pc, #76]	@ (800a0b0 <recv_tcp+0xbc>)
 800a062:	4811      	ldr	r0, [pc, #68]	@ (800a0a8 <recv_tcp+0xb4>)
 800a064:	f009 ff8c 	bl	8013f80 <iprintf>
 800a068:	e7cb      	b.n	800a002 <recv_tcp+0xe>
  LWIP_ASSERT("err != ERR_OK unhandled", err == ERR_OK);
 800a06a:	4b0d      	ldr	r3, [pc, #52]	@ (800a0a0 <recv_tcp+0xac>)
 800a06c:	f44f 7297 	mov.w	r2, #302	@ 0x12e
 800a070:	4910      	ldr	r1, [pc, #64]	@ (800a0b4 <recv_tcp+0xc0>)
 800a072:	480d      	ldr	r0, [pc, #52]	@ (800a0a8 <recv_tcp+0xb4>)
 800a074:	f009 ff84 	bl	8013f80 <iprintf>
 800a078:	e7c5      	b.n	800a006 <recv_tcp+0x12>
    if (p != NULL) {
 800a07a:	b135      	cbz	r5, 800a08a <recv_tcp+0x96>
      tcp_recved(pcb, p->tot_len);
 800a07c:	8929      	ldrh	r1, [r5, #8]
 800a07e:	4638      	mov	r0, r7
 800a080:	f002 fa4c 	bl	800c51c <tcp_recved>
      pbuf_free(p);
 800a084:	4628      	mov	r0, r5
 800a086:	f001 fd53 	bl	800bb30 <pbuf_free>
    return ERR_OK;
 800a08a:	2500      	movs	r5, #0
 800a08c:	e7db      	b.n	800a046 <recv_tcp+0x52>
    msg = LWIP_CONST_CAST(void *, &netconn_closed);
 800a08e:	4d0a      	ldr	r5, [pc, #40]	@ (800a0b8 <recv_tcp+0xc4>)
    len = 0;
 800a090:	2700      	movs	r7, #0
 800a092:	e7cc      	b.n	800a02e <recv_tcp+0x3a>
    return ERR_VAL;
 800a094:	f06f 0505 	mvn.w	r5, #5
 800a098:	e7d5      	b.n	800a046 <recv_tcp+0x52>
    return ERR_MEM;
 800a09a:	f04f 35ff 	mov.w	r5, #4294967295
 800a09e:	e7d2      	b.n	800a046 <recv_tcp+0x52>
 800a0a0:	08015938 	.word	0x08015938
 800a0a4:	08015c18 	.word	0x08015c18
 800a0a8:	08015744 	.word	0x08015744
 800a0ac:	08015bbc 	.word	0x08015bbc
 800a0b0:	08015be0 	.word	0x08015be0
 800a0b4:	08015c00 	.word	0x08015c00
 800a0b8:	08018ddc 	.word	0x08018ddc

0800a0bc <lwip_netconn_is_err_msg>:
{
 800a0bc:	b538      	push	{r3, r4, r5, lr}
 800a0be:	4604      	mov	r4, r0
  LWIP_ASSERT("err != NULL", err != NULL);
 800a0c0:	460d      	mov	r5, r1
 800a0c2:	b151      	cbz	r1, 800a0da <lwip_netconn_is_err_msg+0x1e>
  if (msg == &netconn_aborted) {
 800a0c4:	4b0e      	ldr	r3, [pc, #56]	@ (800a100 <lwip_netconn_is_err_msg+0x44>)
 800a0c6:	429c      	cmp	r4, r3
 800a0c8:	d00e      	beq.n	800a0e8 <lwip_netconn_is_err_msg+0x2c>
  } else if (msg == &netconn_reset) {
 800a0ca:	4b0e      	ldr	r3, [pc, #56]	@ (800a104 <lwip_netconn_is_err_msg+0x48>)
 800a0cc:	429c      	cmp	r4, r3
 800a0ce:	d00f      	beq.n	800a0f0 <lwip_netconn_is_err_msg+0x34>
  } else if (msg == &netconn_closed) {
 800a0d0:	4b0d      	ldr	r3, [pc, #52]	@ (800a108 <lwip_netconn_is_err_msg+0x4c>)
 800a0d2:	429c      	cmp	r4, r3
 800a0d4:	d010      	beq.n	800a0f8 <lwip_netconn_is_err_msg+0x3c>
  return 0;
 800a0d6:	2000      	movs	r0, #0
}
 800a0d8:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("err != NULL", err != NULL);
 800a0da:	4b0c      	ldr	r3, [pc, #48]	@ (800a10c <lwip_netconn_is_err_msg+0x50>)
 800a0dc:	2285      	movs	r2, #133	@ 0x85
 800a0de:	490c      	ldr	r1, [pc, #48]	@ (800a110 <lwip_netconn_is_err_msg+0x54>)
 800a0e0:	480c      	ldr	r0, [pc, #48]	@ (800a114 <lwip_netconn_is_err_msg+0x58>)
 800a0e2:	f009 ff4d 	bl	8013f80 <iprintf>
 800a0e6:	e7ed      	b.n	800a0c4 <lwip_netconn_is_err_msg+0x8>
    *err = ERR_ABRT;
 800a0e8:	23f3      	movs	r3, #243	@ 0xf3
 800a0ea:	702b      	strb	r3, [r5, #0]
    return 1;
 800a0ec:	2001      	movs	r0, #1
 800a0ee:	e7f3      	b.n	800a0d8 <lwip_netconn_is_err_msg+0x1c>
    *err = ERR_RST;
 800a0f0:	23f2      	movs	r3, #242	@ 0xf2
 800a0f2:	702b      	strb	r3, [r5, #0]
    return 1;
 800a0f4:	2001      	movs	r0, #1
 800a0f6:	e7ef      	b.n	800a0d8 <lwip_netconn_is_err_msg+0x1c>
    *err = ERR_CLSD;
 800a0f8:	23f1      	movs	r3, #241	@ 0xf1
 800a0fa:	702b      	strb	r3, [r5, #0]
    return 1;
 800a0fc:	2001      	movs	r0, #1
 800a0fe:	e7eb      	b.n	800a0d8 <lwip_netconn_is_err_msg+0x1c>
 800a100:	08018dde 	.word	0x08018dde
 800a104:	08018ddd 	.word	0x08018ddd
 800a108:	08018ddc 	.word	0x08018ddc
 800a10c:	08015938 	.word	0x08015938
 800a110:	08015c38 	.word	0x08015c38
 800a114:	08015744 	.word	0x08015744

0800a118 <lwip_netconn_do_newconn>:
{
 800a118:	b508      	push	{r3, lr}
  msg->err = ERR_OK;
 800a11a:	2300      	movs	r3, #0
 800a11c:	7103      	strb	r3, [r0, #4]
  if (msg->conn->pcb.tcp == NULL) {
 800a11e:	6803      	ldr	r3, [r0, #0]
 800a120:	685b      	ldr	r3, [r3, #4]
 800a122:	b103      	cbz	r3, 800a126 <lwip_netconn_do_newconn+0xe>
}
 800a124:	bd08      	pop	{r3, pc}
    pcb_new(msg);
 800a126:	f7ff fbbd 	bl	80098a4 <pcb_new>
}
 800a12a:	e7fb      	b.n	800a124 <lwip_netconn_do_newconn+0xc>

0800a12c <netconn_alloc>:
{
 800a12c:	b570      	push	{r4, r5, r6, lr}
 800a12e:	4605      	mov	r5, r0
 800a130:	460e      	mov	r6, r1
  conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
 800a132:	2007      	movs	r0, #7
 800a134:	f001 f9aa 	bl	800b48c <memp_malloc>
  if (conn == NULL) {
 800a138:	4604      	mov	r4, r0
 800a13a:	b360      	cbz	r0, 800a196 <netconn_alloc+0x6a>
  conn->pending_err = ERR_OK;
 800a13c:	2300      	movs	r3, #0
 800a13e:	7203      	strb	r3, [r0, #8]
  conn->type = t;
 800a140:	7005      	strb	r5, [r0, #0]
  conn->pcb.tcp = NULL;
 800a142:	6043      	str	r3, [r0, #4]
  switch (NETCONNTYPE_GROUP(t)) {
 800a144:	f005 05f0 	and.w	r5, r5, #240	@ 0xf0
 800a148:	2d10      	cmp	r5, #16
 800a14a:	d001      	beq.n	800a150 <netconn_alloc+0x24>
 800a14c:	2d20      	cmp	r5, #32
 800a14e:	d116      	bne.n	800a17e <netconn_alloc+0x52>
  if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
 800a150:	f104 0510 	add.w	r5, r4, #16
 800a154:	2106      	movs	r1, #6
 800a156:	4628      	mov	r0, r5
 800a158:	f009 f898 	bl	801328c <sys_mbox_new>
 800a15c:	b9b0      	cbnz	r0, 800a18c <netconn_alloc+0x60>
  if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
 800a15e:	2100      	movs	r1, #0
 800a160:	f104 000c 	add.w	r0, r4, #12
 800a164:	f009 f92c 	bl	80133c0 <sys_sem_new>
 800a168:	b9b8      	cbnz	r0, 800a19a <netconn_alloc+0x6e>
  sys_mbox_set_invalid(&conn->acceptmbox);
 800a16a:	f104 0014 	add.w	r0, r4, #20
 800a16e:	f009 f924 	bl	80133ba <sys_mbox_set_invalid>
  conn->state        = NETCONN_NONE;
 800a172:	2300      	movs	r3, #0
 800a174:	7063      	strb	r3, [r4, #1]
  conn->callback     = callback;
 800a176:	6226      	str	r6, [r4, #32]
  conn->current_msg  = NULL;
 800a178:	61e3      	str	r3, [r4, #28]
  conn->flags = init_flags;
 800a17a:	7623      	strb	r3, [r4, #24]
  return conn;
 800a17c:	e00b      	b.n	800a196 <netconn_alloc+0x6a>
      LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
 800a17e:	4b09      	ldr	r3, [pc, #36]	@ (800a1a4 <netconn_alloc+0x78>)
 800a180:	f240 22e5 	movw	r2, #741	@ 0x2e5
 800a184:	4908      	ldr	r1, [pc, #32]	@ (800a1a8 <netconn_alloc+0x7c>)
 800a186:	4809      	ldr	r0, [pc, #36]	@ (800a1ac <netconn_alloc+0x80>)
 800a188:	f009 fefa 	bl	8013f80 <iprintf>
  memp_free(MEMP_NETCONN, conn);
 800a18c:	4621      	mov	r1, r4
 800a18e:	2007      	movs	r0, #7
 800a190:	f001 f9b2 	bl	800b4f8 <memp_free>
  return NULL;
 800a194:	2400      	movs	r4, #0
}
 800a196:	4620      	mov	r0, r4
 800a198:	bd70      	pop	{r4, r5, r6, pc}
    sys_mbox_free(&conn->recvmbox);
 800a19a:	4628      	mov	r0, r5
 800a19c:	f009 f89c 	bl	80132d8 <sys_mbox_free>
    goto free_and_return;
 800a1a0:	e7f4      	b.n	800a18c <netconn_alloc+0x60>
 800a1a2:	bf00      	nop
 800a1a4:	08015938 	.word	0x08015938
 800a1a8:	08015c44 	.word	0x08015c44
 800a1ac:	08015744 	.word	0x08015744

0800a1b0 <netconn_free>:
{
 800a1b0:	b538      	push	{r3, r4, r5, lr}
 800a1b2:	4604      	mov	r4, r0
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
 800a1b4:	6843      	ldr	r3, [r0, #4]
 800a1b6:	b133      	cbz	r3, 800a1c6 <netconn_free+0x16>
 800a1b8:	4b16      	ldr	r3, [pc, #88]	@ (800a214 <netconn_free+0x64>)
 800a1ba:	f44f 7247 	mov.w	r2, #796	@ 0x31c
 800a1be:	4916      	ldr	r1, [pc, #88]	@ (800a218 <netconn_free+0x68>)
 800a1c0:	4816      	ldr	r0, [pc, #88]	@ (800a21c <netconn_free+0x6c>)
 800a1c2:	f009 fedd 	bl	8013f80 <iprintf>
  LWIP_ASSERT("recvmbox must be deallocated before calling this function",
 800a1c6:	f104 0010 	add.w	r0, r4, #16
 800a1ca:	f009 f8f0 	bl	80133ae <sys_mbox_valid>
 800a1ce:	b988      	cbnz	r0, 800a1f4 <netconn_free+0x44>
  LWIP_ASSERT("acceptmbox must be deallocated before calling this function",
 800a1d0:	f104 0014 	add.w	r0, r4, #20
 800a1d4:	f009 f8eb 	bl	80133ae <sys_mbox_valid>
 800a1d8:	b9a0      	cbnz	r0, 800a204 <netconn_free+0x54>
  sys_sem_free(&conn->op_completed);
 800a1da:	f104 050c 	add.w	r5, r4, #12
 800a1de:	4628      	mov	r0, r5
 800a1e0:	f009 f942 	bl	8013468 <sys_sem_free>
  sys_sem_set_invalid(&conn->op_completed);
 800a1e4:	4628      	mov	r0, r5
 800a1e6:	f009 f953 	bl	8013490 <sys_sem_set_invalid>
  memp_free(MEMP_NETCONN, conn);
 800a1ea:	4621      	mov	r1, r4
 800a1ec:	2007      	movs	r0, #7
 800a1ee:	f001 f983 	bl	800b4f8 <memp_free>
}
 800a1f2:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("recvmbox must be deallocated before calling this function",
 800a1f4:	4b07      	ldr	r3, [pc, #28]	@ (800a214 <netconn_free+0x64>)
 800a1f6:	f240 3223 	movw	r2, #803	@ 0x323
 800a1fa:	4909      	ldr	r1, [pc, #36]	@ (800a220 <netconn_free+0x70>)
 800a1fc:	4807      	ldr	r0, [pc, #28]	@ (800a21c <netconn_free+0x6c>)
 800a1fe:	f009 febf 	bl	8013f80 <iprintf>
 800a202:	e7e5      	b.n	800a1d0 <netconn_free+0x20>
  LWIP_ASSERT("acceptmbox must be deallocated before calling this function",
 800a204:	4b03      	ldr	r3, [pc, #12]	@ (800a214 <netconn_free+0x64>)
 800a206:	f240 3226 	movw	r2, #806	@ 0x326
 800a20a:	4906      	ldr	r1, [pc, #24]	@ (800a224 <netconn_free+0x74>)
 800a20c:	4803      	ldr	r0, [pc, #12]	@ (800a21c <netconn_free+0x6c>)
 800a20e:	f009 feb7 	bl	8013f80 <iprintf>
 800a212:	e7e2      	b.n	800a1da <netconn_free+0x2a>
 800a214:	08015938 	.word	0x08015938
 800a218:	08015c6c 	.word	0x08015c6c
 800a21c:	08015744 	.word	0x08015744
 800a220:	08015c9c 	.word	0x08015c9c
 800a224:	08015cd8 	.word	0x08015cd8

0800a228 <netconn_drain>:
{
 800a228:	b530      	push	{r4, r5, lr}
 800a22a:	b083      	sub	sp, #12
 800a22c:	4604      	mov	r4, r0
  if (sys_mbox_valid(&conn->recvmbox)) {
 800a22e:	f100 0510 	add.w	r5, r0, #16
 800a232:	4628      	mov	r0, r5
 800a234:	f009 f8bb 	bl	80133ae <sys_mbox_valid>
 800a238:	b958      	cbnz	r0, 800a252 <netconn_drain+0x2a>
  if (sys_mbox_valid(&conn->acceptmbox)) {
 800a23a:	3414      	adds	r4, #20
 800a23c:	4620      	mov	r0, r4
 800a23e:	f009 f8b6 	bl	80133ae <sys_mbox_valid>
 800a242:	bb20      	cbnz	r0, 800a28e <netconn_drain+0x66>
 800a244:	e043      	b.n	800a2ce <netconn_drain+0xa6>
          if (!lwip_netconn_is_err_msg(mem, &err)) {
 800a246:	f10d 0103 	add.w	r1, sp, #3
 800a24a:	9801      	ldr	r0, [sp, #4]
 800a24c:	f7ff ff36 	bl	800a0bc <lwip_netconn_is_err_msg>
 800a250:	b178      	cbz	r0, 800a272 <netconn_drain+0x4a>
    while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
 800a252:	a901      	add	r1, sp, #4
 800a254:	4628      	mov	r0, r5
 800a256:	f009 f897 	bl	8013388 <sys_arch_mbox_tryfetch>
 800a25a:	f1b0 3fff 	cmp.w	r0, #4294967295
 800a25e:	d00c      	beq.n	800a27a <netconn_drain+0x52>
        if (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP) {
 800a260:	7823      	ldrb	r3, [r4, #0]
 800a262:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 800a266:	2b10      	cmp	r3, #16
 800a268:	d0ed      	beq.n	800a246 <netconn_drain+0x1e>
          netbuf_delete((struct netbuf *)mem);
 800a26a:	9801      	ldr	r0, [sp, #4]
 800a26c:	f000 fae2 	bl	800a834 <netbuf_delete>
 800a270:	e7ef      	b.n	800a252 <netconn_drain+0x2a>
            pbuf_free((struct pbuf *)mem);
 800a272:	9801      	ldr	r0, [sp, #4]
 800a274:	f001 fc5c 	bl	800bb30 <pbuf_free>
 800a278:	e7eb      	b.n	800a252 <netconn_drain+0x2a>
    sys_mbox_free(&conn->recvmbox);
 800a27a:	4628      	mov	r0, r5
 800a27c:	f009 f82c 	bl	80132d8 <sys_mbox_free>
    sys_mbox_set_invalid(&conn->recvmbox);
 800a280:	4628      	mov	r0, r5
 800a282:	f009 f89a 	bl	80133ba <sys_mbox_set_invalid>
 800a286:	e7d8      	b.n	800a23a <netconn_drain+0x12>
          netconn_free(newconn);
 800a288:	4628      	mov	r0, r5
 800a28a:	f7ff ff91 	bl	800a1b0 <netconn_free>
    while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
 800a28e:	a901      	add	r1, sp, #4
 800a290:	4620      	mov	r0, r4
 800a292:	f009 f879 	bl	8013388 <sys_arch_mbox_tryfetch>
 800a296:	f1b0 3fff 	cmp.w	r0, #4294967295
 800a29a:	d012      	beq.n	800a2c2 <netconn_drain+0x9a>
        if (!lwip_netconn_is_err_msg(mem, &err)) {
 800a29c:	f10d 0103 	add.w	r1, sp, #3
 800a2a0:	9801      	ldr	r0, [sp, #4]
 800a2a2:	f7ff ff0b 	bl	800a0bc <lwip_netconn_is_err_msg>
 800a2a6:	2800      	cmp	r0, #0
 800a2a8:	d1f1      	bne.n	800a28e <netconn_drain+0x66>
          struct netconn *newconn = (struct netconn *)mem;
 800a2aa:	9d01      	ldr	r5, [sp, #4]
          netconn_drain(newconn);
 800a2ac:	4628      	mov	r0, r5
 800a2ae:	f7ff ffbb 	bl	800a228 <netconn_drain>
          if (newconn->pcb.tcp != NULL) {
 800a2b2:	6868      	ldr	r0, [r5, #4]
 800a2b4:	2800      	cmp	r0, #0
 800a2b6:	d0e7      	beq.n	800a288 <netconn_drain+0x60>
            tcp_abort(newconn->pcb.tcp);
 800a2b8:	f002 fb90 	bl	800c9dc <tcp_abort>
            newconn->pcb.tcp = NULL;
 800a2bc:	2300      	movs	r3, #0
 800a2be:	606b      	str	r3, [r5, #4]
 800a2c0:	e7e2      	b.n	800a288 <netconn_drain+0x60>
    sys_mbox_free(&conn->acceptmbox);
 800a2c2:	4620      	mov	r0, r4
 800a2c4:	f009 f808 	bl	80132d8 <sys_mbox_free>
    sys_mbox_set_invalid(&conn->acceptmbox);
 800a2c8:	4620      	mov	r0, r4
 800a2ca:	f009 f876 	bl	80133ba <sys_mbox_set_invalid>
}
 800a2ce:	b003      	add	sp, #12
 800a2d0:	bd30      	pop	{r4, r5, pc}
	...

0800a2d4 <accept_function>:
{
 800a2d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (conn == NULL) {
 800a2d6:	2800      	cmp	r0, #0
 800a2d8:	d074      	beq.n	800a3c4 <accept_function+0xf0>
 800a2da:	460d      	mov	r5, r1
 800a2dc:	4616      	mov	r6, r2
 800a2de:	4604      	mov	r4, r0
  if (!NETCONN_MBOX_VALID(conn, &conn->acceptmbox)) {
 800a2e0:	f100 0714 	add.w	r7, r0, #20
 800a2e4:	4638      	mov	r0, r7
 800a2e6:	f009 f862 	bl	80133ae <sys_mbox_valid>
 800a2ea:	2800      	cmp	r0, #0
 800a2ec:	d06d      	beq.n	800a3ca <accept_function+0xf6>
  if (newpcb == NULL) {
 800a2ee:	b1bd      	cbz	r5, 800a320 <accept_function+0x4c>
  LWIP_ASSERT("expect newpcb == NULL or err == ERR_OK", err == ERR_OK);
 800a2f0:	bb46      	cbnz	r6, 800a344 <accept_function+0x70>
  newconn = netconn_alloc(conn->type, conn->callback);
 800a2f2:	6a21      	ldr	r1, [r4, #32]
 800a2f4:	7820      	ldrb	r0, [r4, #0]
 800a2f6:	f7ff ff19 	bl	800a12c <netconn_alloc>
  if (newconn == NULL) {
 800a2fa:	4606      	mov	r6, r0
 800a2fc:	b350      	cbz	r0, 800a354 <accept_function+0x80>
  newconn->pcb.tcp = newpcb;
 800a2fe:	6045      	str	r5, [r0, #4]
  setup_tcp(newconn);
 800a300:	f7ff fab0 	bl	8009864 <setup_tcp>
  if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
 800a304:	4631      	mov	r1, r6
 800a306:	4638      	mov	r0, r7
 800a308:	f008 fffe 	bl	8013308 <sys_mbox_trypost>
 800a30c:	4605      	mov	r5, r0
 800a30e:	bb98      	cbnz	r0, 800a378 <accept_function+0xa4>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 800a310:	6a23      	ldr	r3, [r4, #32]
 800a312:	b11b      	cbz	r3, 800a31c <accept_function+0x48>
 800a314:	2200      	movs	r2, #0
 800a316:	4611      	mov	r1, r2
 800a318:	4620      	mov	r0, r4
 800a31a:	4798      	blx	r3
}
 800a31c:	4628      	mov	r0, r5
 800a31e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (sys_mbox_trypost(&conn->acceptmbox, lwip_netconn_err_to_msg(ERR_ABRT)) == ERR_OK) {
 800a320:	f06f 000c 	mvn.w	r0, #12
 800a324:	f7ff fa16 	bl	8009754 <lwip_netconn_err_to_msg>
 800a328:	4601      	mov	r1, r0
 800a32a:	4638      	mov	r0, r7
 800a32c:	f008 ffec 	bl	8013308 <sys_mbox_trypost>
 800a330:	b928      	cbnz	r0, 800a33e <accept_function+0x6a>
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 800a332:	6a23      	ldr	r3, [r4, #32]
 800a334:	b11b      	cbz	r3, 800a33e <accept_function+0x6a>
 800a336:	2200      	movs	r2, #0
 800a338:	4611      	mov	r1, r2
 800a33a:	4620      	mov	r0, r4
 800a33c:	4798      	blx	r3
    return ERR_VAL;
 800a33e:	f06f 0505 	mvn.w	r5, #5
 800a342:	e7eb      	b.n	800a31c <accept_function+0x48>
  LWIP_ASSERT("expect newpcb == NULL or err == ERR_OK", err == ERR_OK);
 800a344:	4b22      	ldr	r3, [pc, #136]	@ (800a3d0 <accept_function+0xfc>)
 800a346:	f240 222a 	movw	r2, #554	@ 0x22a
 800a34a:	4922      	ldr	r1, [pc, #136]	@ (800a3d4 <accept_function+0x100>)
 800a34c:	4822      	ldr	r0, [pc, #136]	@ (800a3d8 <accept_function+0x104>)
 800a34e:	f009 fe17 	bl	8013f80 <iprintf>
 800a352:	e7ce      	b.n	800a2f2 <accept_function+0x1e>
    if (sys_mbox_trypost(&conn->acceptmbox, lwip_netconn_err_to_msg(ERR_ABRT)) == ERR_OK) {
 800a354:	f06f 000c 	mvn.w	r0, #12
 800a358:	f7ff f9fc 	bl	8009754 <lwip_netconn_err_to_msg>
 800a35c:	4601      	mov	r1, r0
 800a35e:	4638      	mov	r0, r7
 800a360:	f008 ffd2 	bl	8013308 <sys_mbox_trypost>
 800a364:	b928      	cbnz	r0, 800a372 <accept_function+0x9e>
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 800a366:	6a23      	ldr	r3, [r4, #32]
 800a368:	b11b      	cbz	r3, 800a372 <accept_function+0x9e>
 800a36a:	2200      	movs	r2, #0
 800a36c:	4611      	mov	r1, r2
 800a36e:	4620      	mov	r0, r4
 800a370:	4798      	blx	r3
    return ERR_MEM;
 800a372:	f04f 35ff 	mov.w	r5, #4294967295
 800a376:	e7d1      	b.n	800a31c <accept_function+0x48>
    struct tcp_pcb *pcb = newconn->pcb.tcp;
 800a378:	6874      	ldr	r4, [r6, #4]
    tcp_arg(pcb, NULL);
 800a37a:	2100      	movs	r1, #0
 800a37c:	4620      	mov	r0, r4
 800a37e:	f002 f949 	bl	800c614 <tcp_arg>
    tcp_recv(pcb, NULL);
 800a382:	2100      	movs	r1, #0
 800a384:	4620      	mov	r0, r4
 800a386:	f002 f949 	bl	800c61c <tcp_recv>
    tcp_sent(pcb, NULL);
 800a38a:	2100      	movs	r1, #0
 800a38c:	4620      	mov	r0, r4
 800a38e:	f002 f95f 	bl	800c650 <tcp_sent>
    tcp_poll(pcb, NULL, 0);
 800a392:	2200      	movs	r2, #0
 800a394:	4611      	mov	r1, r2
 800a396:	4620      	mov	r0, r4
 800a398:	f002 f996 	bl	800c6c8 <tcp_poll>
    tcp_err(pcb, NULL);
 800a39c:	2100      	movs	r1, #0
 800a39e:	4620      	mov	r0, r4
 800a3a0:	f002 f970 	bl	800c684 <tcp_err>
    newconn->pcb.tcp = NULL;
 800a3a4:	2300      	movs	r3, #0
 800a3a6:	6073      	str	r3, [r6, #4]
    sys_mbox_free(&newconn->recvmbox);
 800a3a8:	f106 0410 	add.w	r4, r6, #16
 800a3ac:	4620      	mov	r0, r4
 800a3ae:	f008 ff93 	bl	80132d8 <sys_mbox_free>
    sys_mbox_set_invalid(&newconn->recvmbox);
 800a3b2:	4620      	mov	r0, r4
 800a3b4:	f009 f801 	bl	80133ba <sys_mbox_set_invalid>
    netconn_free(newconn);
 800a3b8:	4630      	mov	r0, r6
 800a3ba:	f7ff fef9 	bl	800a1b0 <netconn_free>
    return ERR_MEM;
 800a3be:	f04f 35ff 	mov.w	r5, #4294967295
 800a3c2:	e7ab      	b.n	800a31c <accept_function+0x48>
    return ERR_VAL;
 800a3c4:	f06f 0505 	mvn.w	r5, #5
 800a3c8:	e7a8      	b.n	800a31c <accept_function+0x48>
    return ERR_VAL;
 800a3ca:	f06f 0505 	mvn.w	r5, #5
 800a3ce:	e7a5      	b.n	800a31c <accept_function+0x48>
 800a3d0:	08015938 	.word	0x08015938
 800a3d4:	08015d14 	.word	0x08015d14
 800a3d8:	08015744 	.word	0x08015744

0800a3dc <lwip_netconn_do_delconn>:
{
 800a3dc:	b538      	push	{r3, r4, r5, lr}
 800a3de:	4604      	mov	r4, r0
  enum netconn_state state = msg->conn->state;
 800a3e0:	6803      	ldr	r3, [r0, #0]
 800a3e2:	785d      	ldrb	r5, [r3, #1]
  LWIP_ASSERT("netconn state error", /* this only happens for TCP netconns */
 800a3e4:	b125      	cbz	r5, 800a3f0 <lwip_netconn_do_delconn+0x14>
 800a3e6:	781b      	ldrb	r3, [r3, #0]
 800a3e8:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 800a3ec:	2b10      	cmp	r3, #16
 800a3ee:	d10c      	bne.n	800a40a <lwip_netconn_do_delconn+0x2e>
  if (((state != NETCONN_NONE) &&
 800a3f0:	2d00      	cmp	r5, #0
 800a3f2:	bf18      	it	ne
 800a3f4:	2d02      	cmpne	r5, #2
 800a3f6:	d015      	beq.n	800a424 <lwip_netconn_do_delconn+0x48>
       (state != NETCONN_LISTEN) &&
 800a3f8:	2d03      	cmp	r5, #3
 800a3fa:	d00e      	beq.n	800a41a <lwip_netconn_do_delconn+0x3e>
    msg->err = ERR_INPROGRESS;
 800a3fc:	23fb      	movs	r3, #251	@ 0xfb
 800a3fe:	7123      	strb	r3, [r4, #4]
  if (sys_sem_valid(LWIP_API_MSG_SEM(msg))) {
 800a400:	6820      	ldr	r0, [r4, #0]
 800a402:	300c      	adds	r0, #12
 800a404:	f009 f83e 	bl	8013484 <sys_sem_valid>
}
 800a408:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("netconn state error", /* this only happens for TCP netconns */
 800a40a:	4b3e      	ldr	r3, [pc, #248]	@ (800a504 <lwip_netconn_do_delconn+0x128>)
 800a40c:	f240 425e 	movw	r2, #1118	@ 0x45e
 800a410:	493d      	ldr	r1, [pc, #244]	@ (800a508 <lwip_netconn_do_delconn+0x12c>)
 800a412:	483e      	ldr	r0, [pc, #248]	@ (800a50c <lwip_netconn_do_delconn+0x130>)
 800a414:	f009 fdb4 	bl	8013f80 <iprintf>
 800a418:	e7ea      	b.n	800a3f0 <lwip_netconn_do_delconn+0x14>
      ((state == NETCONN_CONNECT) && !IN_NONBLOCKING_CONNECT(msg->conn))) {
 800a41a:	6823      	ldr	r3, [r4, #0]
 800a41c:	7e1b      	ldrb	r3, [r3, #24]
 800a41e:	f013 0f04 	tst.w	r3, #4
 800a422:	d0eb      	beq.n	800a3fc <lwip_netconn_do_delconn+0x20>
    LWIP_ASSERT("blocking connect in progress",
 800a424:	2d03      	cmp	r5, #3
 800a426:	d025      	beq.n	800a474 <lwip_netconn_do_delconn+0x98>
    msg->err = ERR_OK;
 800a428:	2300      	movs	r3, #0
 800a42a:	7123      	strb	r3, [r4, #4]
    netconn_drain(msg->conn);
 800a42c:	6820      	ldr	r0, [r4, #0]
 800a42e:	f7ff fefb 	bl	800a228 <netconn_drain>
    if (msg->conn->pcb.tcp != NULL) {
 800a432:	6822      	ldr	r2, [r4, #0]
 800a434:	6851      	ldr	r1, [r2, #4]
 800a436:	b179      	cbz	r1, 800a458 <lwip_netconn_do_delconn+0x7c>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 800a438:	7813      	ldrb	r3, [r2, #0]
 800a43a:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 800a43e:	2b10      	cmp	r3, #16
 800a440:	d025      	beq.n	800a48e <lwip_netconn_do_delconn+0xb2>
 800a442:	2b20      	cmp	r3, #32
 800a444:	d105      	bne.n	800a452 <lwip_netconn_do_delconn+0x76>
          msg->conn->pcb.udp->recv_arg = NULL;
 800a446:	2300      	movs	r3, #0
 800a448:	624b      	str	r3, [r1, #36]	@ 0x24
          udp_remove(msg->conn->pcb.udp);
 800a44a:	6823      	ldr	r3, [r4, #0]
 800a44c:	6858      	ldr	r0, [r3, #4]
 800a44e:	f006 fc53 	bl	8010cf8 <udp_remove>
      msg->conn->pcb.tcp = NULL;
 800a452:	6823      	ldr	r3, [r4, #0]
 800a454:	2200      	movs	r2, #0
 800a456:	605a      	str	r2, [r3, #4]
    API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
 800a458:	6820      	ldr	r0, [r4, #0]
 800a45a:	6a03      	ldr	r3, [r0, #32]
 800a45c:	b113      	cbz	r3, 800a464 <lwip_netconn_do_delconn+0x88>
 800a45e:	2200      	movs	r2, #0
 800a460:	4611      	mov	r1, r2
 800a462:	4798      	blx	r3
    API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
 800a464:	6820      	ldr	r0, [r4, #0]
 800a466:	6a03      	ldr	r3, [r0, #32]
 800a468:	2b00      	cmp	r3, #0
 800a46a:	d0c9      	beq.n	800a400 <lwip_netconn_do_delconn+0x24>
 800a46c:	2200      	movs	r2, #0
 800a46e:	2102      	movs	r1, #2
 800a470:	4798      	blx	r3
 800a472:	e7c5      	b.n	800a400 <lwip_netconn_do_delconn+0x24>
    LWIP_ASSERT("blocking connect in progress",
 800a474:	6823      	ldr	r3, [r4, #0]
 800a476:	7e1b      	ldrb	r3, [r3, #24]
 800a478:	f013 0f04 	tst.w	r3, #4
 800a47c:	d1d4      	bne.n	800a428 <lwip_netconn_do_delconn+0x4c>
 800a47e:	4b21      	ldr	r3, [pc, #132]	@ (800a504 <lwip_netconn_do_delconn+0x128>)
 800a480:	f240 427a 	movw	r2, #1146	@ 0x47a
 800a484:	4922      	ldr	r1, [pc, #136]	@ (800a510 <lwip_netconn_do_delconn+0x134>)
 800a486:	4821      	ldr	r0, [pc, #132]	@ (800a50c <lwip_netconn_do_delconn+0x130>)
 800a488:	f009 fd7a 	bl	8013f80 <iprintf>
 800a48c:	e7cc      	b.n	800a428 <lwip_netconn_do_delconn+0x4c>
          LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL);
 800a48e:	69d3      	ldr	r3, [r2, #28]
 800a490:	b133      	cbz	r3, 800a4a0 <lwip_netconn_do_delconn+0xc4>
 800a492:	4b1c      	ldr	r3, [pc, #112]	@ (800a504 <lwip_netconn_do_delconn+0x128>)
 800a494:	f240 4294 	movw	r2, #1172	@ 0x494
 800a498:	491e      	ldr	r1, [pc, #120]	@ (800a514 <lwip_netconn_do_delconn+0x138>)
 800a49a:	481c      	ldr	r0, [pc, #112]	@ (800a50c <lwip_netconn_do_delconn+0x130>)
 800a49c:	f009 fd70 	bl	8013f80 <iprintf>
          msg->conn->state = NETCONN_CLOSE;
 800a4a0:	6823      	ldr	r3, [r4, #0]
 800a4a2:	2204      	movs	r2, #4
 800a4a4:	705a      	strb	r2, [r3, #1]
          msg->msg.sd.shut = NETCONN_SHUT_RDWR;
 800a4a6:	2303      	movs	r3, #3
 800a4a8:	7223      	strb	r3, [r4, #8]
          msg->conn->current_msg = msg;
 800a4aa:	6823      	ldr	r3, [r4, #0]
 800a4ac:	61dc      	str	r4, [r3, #28]
          if (lwip_netconn_do_close_internal(msg->conn, 0) != ERR_OK) {
 800a4ae:	2100      	movs	r1, #0
 800a4b0:	6820      	ldr	r0, [r4, #0]
 800a4b2:	f7ff fc19 	bl	8009ce8 <lwip_netconn_do_close_internal>
 800a4b6:	2800      	cmp	r0, #0
 800a4b8:	d0a6      	beq.n	800a408 <lwip_netconn_do_delconn+0x2c>
            LWIP_ASSERT("state!", msg->conn->state == NETCONN_CLOSE);
 800a4ba:	6823      	ldr	r3, [r4, #0]
 800a4bc:	785b      	ldrb	r3, [r3, #1]
 800a4be:	2b04      	cmp	r3, #4
 800a4c0:	d117      	bne.n	800a4f2 <lwip_netconn_do_delconn+0x116>
            UNLOCK_TCPIP_CORE();
 800a4c2:	4d15      	ldr	r5, [pc, #84]	@ (800a518 <lwip_netconn_do_delconn+0x13c>)
 800a4c4:	4628      	mov	r0, r5
 800a4c6:	f009 f824 	bl	8013512 <sys_mutex_unlock>
            sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
 800a4ca:	6820      	ldr	r0, [r4, #0]
 800a4cc:	2100      	movs	r1, #0
 800a4ce:	300c      	adds	r0, #12
 800a4d0:	f008 ffa6 	bl	8013420 <sys_arch_sem_wait>
            LOCK_TCPIP_CORE();
 800a4d4:	4628      	mov	r0, r5
 800a4d6:	f009 f815 	bl	8013504 <sys_mutex_lock>
            LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
 800a4da:	6823      	ldr	r3, [r4, #0]
 800a4dc:	785b      	ldrb	r3, [r3, #1]
 800a4de:	2b00      	cmp	r3, #0
 800a4e0:	d092      	beq.n	800a408 <lwip_netconn_do_delconn+0x2c>
 800a4e2:	4b08      	ldr	r3, [pc, #32]	@ (800a504 <lwip_netconn_do_delconn+0x128>)
 800a4e4:	f240 429e 	movw	r2, #1182	@ 0x49e
 800a4e8:	490c      	ldr	r1, [pc, #48]	@ (800a51c <lwip_netconn_do_delconn+0x140>)
 800a4ea:	4808      	ldr	r0, [pc, #32]	@ (800a50c <lwip_netconn_do_delconn+0x130>)
 800a4ec:	f009 fd48 	bl	8013f80 <iprintf>
          return;
 800a4f0:	e78a      	b.n	800a408 <lwip_netconn_do_delconn+0x2c>
            LWIP_ASSERT("state!", msg->conn->state == NETCONN_CLOSE);
 800a4f2:	4b04      	ldr	r3, [pc, #16]	@ (800a504 <lwip_netconn_do_delconn+0x128>)
 800a4f4:	f240 429a 	movw	r2, #1178	@ 0x49a
 800a4f8:	4908      	ldr	r1, [pc, #32]	@ (800a51c <lwip_netconn_do_delconn+0x140>)
 800a4fa:	4804      	ldr	r0, [pc, #16]	@ (800a50c <lwip_netconn_do_delconn+0x130>)
 800a4fc:	f009 fd40 	bl	8013f80 <iprintf>
 800a500:	e7df      	b.n	800a4c2 <lwip_netconn_do_delconn+0xe6>
 800a502:	bf00      	nop
 800a504:	08015938 	.word	0x08015938
 800a508:	08015d3c 	.word	0x08015d3c
 800a50c:	08015744 	.word	0x08015744
 800a510:	08015d50 	.word	0x08015d50
 800a514:	08015d70 	.word	0x08015d70
 800a518:	2400c4a0 	.word	0x2400c4a0
 800a51c:	08015d8c 	.word	0x08015d8c

0800a520 <lwip_netconn_do_bind>:
{
 800a520:	b510      	push	{r4, lr}
 800a522:	4604      	mov	r4, r0
  if (msg->conn->pcb.tcp != NULL) {
 800a524:	6803      	ldr	r3, [r0, #0]
 800a526:	6858      	ldr	r0, [r3, #4]
 800a528:	b180      	cbz	r0, 800a54c <lwip_netconn_do_bind+0x2c>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 800a52a:	781b      	ldrb	r3, [r3, #0]
 800a52c:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 800a530:	2b10      	cmp	r3, #16
 800a532:	d006      	beq.n	800a542 <lwip_netconn_do_bind+0x22>
 800a534:	2b20      	cmp	r3, #32
 800a536:	d10d      	bne.n	800a554 <lwip_netconn_do_bind+0x34>
        err = udp_bind(msg->conn->pcb.udp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
 800a538:	89a2      	ldrh	r2, [r4, #12]
 800a53a:	68a1      	ldr	r1, [r4, #8]
 800a53c:	f006 f94a 	bl	80107d4 <udp_bind>
        break;
 800a540:	e006      	b.n	800a550 <lwip_netconn_do_bind+0x30>
        err = tcp_bind(msg->conn->pcb.tcp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
 800a542:	89a2      	ldrh	r2, [r4, #12]
 800a544:	68a1      	ldr	r1, [r4, #8]
 800a546:	f001 fedb 	bl	800c300 <tcp_bind>
        break;
 800a54a:	e001      	b.n	800a550 <lwip_netconn_do_bind+0x30>
    err = ERR_VAL;
 800a54c:	f06f 0005 	mvn.w	r0, #5
  msg->err = err;
 800a550:	7120      	strb	r0, [r4, #4]
}
 800a552:	bd10      	pop	{r4, pc}
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 800a554:	f06f 0005 	mvn.w	r0, #5
 800a558:	e7fa      	b.n	800a550 <lwip_netconn_do_bind+0x30>
	...

0800a55c <lwip_netconn_do_listen>:
{
 800a55c:	b530      	push	{r4, r5, lr}
 800a55e:	b083      	sub	sp, #12
 800a560:	4604      	mov	r4, r0
  if (msg->conn->pcb.tcp != NULL) {
 800a562:	6803      	ldr	r3, [r0, #0]
 800a564:	6858      	ldr	r0, [r3, #4]
 800a566:	2800      	cmp	r0, #0
 800a568:	d05e      	beq.n	800a628 <lwip_netconn_do_listen+0xcc>
    if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) {
 800a56a:	781a      	ldrb	r2, [r3, #0]
 800a56c:	f002 02f0 	and.w	r2, r2, #240	@ 0xf0
 800a570:	2a10      	cmp	r2, #16
 800a572:	d007      	beq.n	800a584 <lwip_netconn_do_listen+0x28>
      err = ERR_ARG;
 800a574:	23f0      	movs	r3, #240	@ 0xf0
 800a576:	f88d 3007 	strb.w	r3, [sp, #7]
  msg->err = err;
 800a57a:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800a57e:	7123      	strb	r3, [r4, #4]
}
 800a580:	b003      	add	sp, #12
 800a582:	bd30      	pop	{r4, r5, pc}
      if (msg->conn->state == NETCONN_NONE) {
 800a584:	785b      	ldrb	r3, [r3, #1]
 800a586:	2b00      	cmp	r3, #0
 800a588:	d144      	bne.n	800a614 <lwip_netconn_do_listen+0xb8>
        if (msg->conn->pcb.tcp->state != CLOSED) {
 800a58a:	7d03      	ldrb	r3, [r0, #20]
 800a58c:	b11b      	cbz	r3, 800a596 <lwip_netconn_do_listen+0x3a>
          err = ERR_VAL;
 800a58e:	23fa      	movs	r3, #250	@ 0xfa
 800a590:	f88d 3007 	strb.w	r3, [sp, #7]
 800a594:	e7f1      	b.n	800a57a <lwip_netconn_do_listen+0x1e>
          lpcb = tcp_listen_with_backlog_and_err(msg->conn->pcb.tcp, backlog, &err);
 800a596:	f10d 0207 	add.w	r2, sp, #7
 800a59a:	21ff      	movs	r1, #255	@ 0xff
 800a59c:	f001 ff12 	bl	800c3c4 <tcp_listen_with_backlog_and_err>
          if (lpcb == NULL) {
 800a5a0:	4605      	mov	r5, r0
 800a5a2:	2800      	cmp	r0, #0
 800a5a4:	d0e9      	beq.n	800a57a <lwip_netconn_do_listen+0x1e>
            if (sys_mbox_valid(&msg->conn->recvmbox)) {
 800a5a6:	6820      	ldr	r0, [r4, #0]
 800a5a8:	3010      	adds	r0, #16
 800a5aa:	f008 ff00 	bl	80133ae <sys_mbox_valid>
 800a5ae:	b9c8      	cbnz	r0, 800a5e4 <lwip_netconn_do_listen+0x88>
            err = ERR_OK;
 800a5b0:	2300      	movs	r3, #0
 800a5b2:	f88d 3007 	strb.w	r3, [sp, #7]
            if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
 800a5b6:	6820      	ldr	r0, [r4, #0]
 800a5b8:	3014      	adds	r0, #20
 800a5ba:	f008 fef8 	bl	80133ae <sys_mbox_valid>
 800a5be:	b1d0      	cbz	r0, 800a5f6 <lwip_netconn_do_listen+0x9a>
            if (err == ERR_OK) {
 800a5c0:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 800a5c4:	b9fb      	cbnz	r3, 800a606 <lwip_netconn_do_listen+0xaa>
              msg->conn->state = NETCONN_LISTEN;
 800a5c6:	6823      	ldr	r3, [r4, #0]
 800a5c8:	2202      	movs	r2, #2
 800a5ca:	705a      	strb	r2, [r3, #1]
              msg->conn->pcb.tcp = lpcb;
 800a5cc:	6823      	ldr	r3, [r4, #0]
 800a5ce:	605d      	str	r5, [r3, #4]
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
 800a5d0:	6821      	ldr	r1, [r4, #0]
 800a5d2:	6848      	ldr	r0, [r1, #4]
 800a5d4:	f002 f81e 	bl	800c614 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
 800a5d8:	6823      	ldr	r3, [r4, #0]
 800a5da:	4915      	ldr	r1, [pc, #84]	@ (800a630 <lwip_netconn_do_listen+0xd4>)
 800a5dc:	6858      	ldr	r0, [r3, #4]
 800a5de:	f002 f86b 	bl	800c6b8 <tcp_accept>
 800a5e2:	e7ca      	b.n	800a57a <lwip_netconn_do_listen+0x1e>
              sys_mbox_free(&msg->conn->recvmbox);
 800a5e4:	6820      	ldr	r0, [r4, #0]
 800a5e6:	3010      	adds	r0, #16
 800a5e8:	f008 fe76 	bl	80132d8 <sys_mbox_free>
              sys_mbox_set_invalid(&msg->conn->recvmbox);
 800a5ec:	6820      	ldr	r0, [r4, #0]
 800a5ee:	3010      	adds	r0, #16
 800a5f0:	f008 fee3 	bl	80133ba <sys_mbox_set_invalid>
 800a5f4:	e7dc      	b.n	800a5b0 <lwip_netconn_do_listen+0x54>
              err = sys_mbox_new(&msg->conn->acceptmbox, DEFAULT_ACCEPTMBOX_SIZE);
 800a5f6:	6820      	ldr	r0, [r4, #0]
 800a5f8:	2106      	movs	r1, #6
 800a5fa:	3014      	adds	r0, #20
 800a5fc:	f008 fe46 	bl	801328c <sys_mbox_new>
 800a600:	f88d 0007 	strb.w	r0, [sp, #7]
 800a604:	e7dc      	b.n	800a5c0 <lwip_netconn_do_listen+0x64>
              tcp_close(lpcb);
 800a606:	4628      	mov	r0, r5
 800a608:	f002 fbf6 	bl	800cdf8 <tcp_close>
              msg->conn->pcb.tcp = NULL;
 800a60c:	6823      	ldr	r3, [r4, #0]
 800a60e:	2200      	movs	r2, #0
 800a610:	605a      	str	r2, [r3, #4]
 800a612:	e7b2      	b.n	800a57a <lwip_netconn_do_listen+0x1e>
      } else if (msg->conn->state == NETCONN_LISTEN) {
 800a614:	2b02      	cmp	r3, #2
 800a616:	d003      	beq.n	800a620 <lwip_netconn_do_listen+0xc4>
        err = ERR_CONN;
 800a618:	23f5      	movs	r3, #245	@ 0xf5
 800a61a:	f88d 3007 	strb.w	r3, [sp, #7]
 800a61e:	e7ac      	b.n	800a57a <lwip_netconn_do_listen+0x1e>
        err = ERR_OK;
 800a620:	2300      	movs	r3, #0
 800a622:	f88d 3007 	strb.w	r3, [sp, #7]
        tcp_backlog_set(msg->conn->pcb.tcp, msg->msg.lb.backlog);
 800a626:	e7a8      	b.n	800a57a <lwip_netconn_do_listen+0x1e>
    err = ERR_CONN;
 800a628:	23f5      	movs	r3, #245	@ 0xf5
 800a62a:	f88d 3007 	strb.w	r3, [sp, #7]
 800a62e:	e7a4      	b.n	800a57a <lwip_netconn_do_listen+0x1e>
 800a630:	0800a2d5 	.word	0x0800a2d5

0800a634 <lwip_netconn_do_recv>:
  msg->err = ERR_OK;
 800a634:	2300      	movs	r3, #0
 800a636:	7103      	strb	r3, [r0, #4]
  if (msg->conn->pcb.tcp != NULL) {
 800a638:	6803      	ldr	r3, [r0, #0]
 800a63a:	685a      	ldr	r2, [r3, #4]
 800a63c:	b1ba      	cbz	r2, 800a66e <lwip_netconn_do_recv+0x3a>
{
 800a63e:	b570      	push	{r4, r5, r6, lr}
 800a640:	4606      	mov	r6, r0
    if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) {
 800a642:	781b      	ldrb	r3, [r3, #0]
 800a644:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 800a648:	2b10      	cmp	r3, #16
 800a64a:	d000      	beq.n	800a64e <lwip_netconn_do_recv+0x1a>
}
 800a64c:	bd70      	pop	{r4, r5, r6, pc}
      size_t remaining = msg->msg.r.len;
 800a64e:	6884      	ldr	r4, [r0, #8]
 800a650:	e008      	b.n	800a664 <lwip_netconn_do_recv+0x30>
        u16_t recved = (u16_t)((remaining > 0xffff) ? 0xffff : remaining);
 800a652:	f64f 75ff 	movw	r5, #65535	@ 0xffff
        tcp_recved(msg->conn->pcb.tcp, recved);
 800a656:	6833      	ldr	r3, [r6, #0]
 800a658:	4629      	mov	r1, r5
 800a65a:	6858      	ldr	r0, [r3, #4]
 800a65c:	f001 ff5e 	bl	800c51c <tcp_recved>
      } while (remaining != 0);
 800a660:	1b64      	subs	r4, r4, r5
 800a662:	d0f3      	beq.n	800a64c <lwip_netconn_do_recv+0x18>
        u16_t recved = (u16_t)((remaining > 0xffff) ? 0xffff : remaining);
 800a664:	f5b4 3f80 	cmp.w	r4, #65536	@ 0x10000
 800a668:	d2f3      	bcs.n	800a652 <lwip_netconn_do_recv+0x1e>
 800a66a:	b2a5      	uxth	r5, r4
 800a66c:	e7f3      	b.n	800a656 <lwip_netconn_do_recv+0x22>
 800a66e:	4770      	bx	lr

0800a670 <lwip_netconn_do_write>:
 *
 * @param m the api_msg pointing to the connection
 */
void
lwip_netconn_do_write(void *m)
{
 800a670:	b538      	push	{r3, r4, r5, lr}
 800a672:	4604      	mov	r4, r0
  struct api_msg *msg = (struct api_msg *)m;

  err_t err = netconn_err(msg->conn);
 800a674:	6800      	ldr	r0, [r0, #0]
 800a676:	f7fe feb7 	bl	80093e8 <netconn_err>
  if (err == ERR_OK) {
 800a67a:	4603      	mov	r3, r0
 800a67c:	b938      	cbnz	r0, 800a68e <lwip_netconn_do_write+0x1e>
    if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) {
 800a67e:	6822      	ldr	r2, [r4, #0]
 800a680:	7813      	ldrb	r3, [r2, #0]
 800a682:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 800a686:	2b10      	cmp	r3, #16
 800a688:	d003      	beq.n	800a692 <lwip_netconn_do_write+0x22>
#else /* LWIP_TCP */
      err = ERR_VAL;
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      err = ERR_VAL;
 800a68a:	f06f 0305 	mvn.w	r3, #5
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  msg->err = err;
 800a68e:	7123      	strb	r3, [r4, #4]
  TCPIP_APIMSG_ACK(msg);
}
 800a690:	bd38      	pop	{r3, r4, r5, pc}
      if (msg->conn->state != NETCONN_NONE) {
 800a692:	7853      	ldrb	r3, [r2, #1]
 800a694:	2b00      	cmp	r3, #0
 800a696:	d144      	bne.n	800a722 <lwip_netconn_do_write+0xb2>
      } else if (msg->conn->pcb.tcp != NULL) {
 800a698:	6853      	ldr	r3, [r2, #4]
 800a69a:	2b00      	cmp	r3, #0
 800a69c:	d044      	beq.n	800a728 <lwip_netconn_do_write+0xb8>
        msg->conn->state = NETCONN_WRITE;
 800a69e:	2301      	movs	r3, #1
 800a6a0:	7053      	strb	r3, [r2, #1]
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL);
 800a6a2:	6823      	ldr	r3, [r4, #0]
 800a6a4:	69db      	ldr	r3, [r3, #28]
 800a6a6:	b133      	cbz	r3, 800a6b6 <lwip_netconn_do_write+0x46>
 800a6a8:	4b21      	ldr	r3, [pc, #132]	@ (800a730 <lwip_netconn_do_write+0xc0>)
 800a6aa:	f240 7223 	movw	r2, #1827	@ 0x723
 800a6ae:	4921      	ldr	r1, [pc, #132]	@ (800a734 <lwip_netconn_do_write+0xc4>)
 800a6b0:	4821      	ldr	r0, [pc, #132]	@ (800a738 <lwip_netconn_do_write+0xc8>)
 800a6b2:	f009 fc65 	bl	8013f80 <iprintf>
        LWIP_ASSERT("msg->msg.w.len != 0", msg->msg.w.len != 0);
 800a6b6:	6963      	ldr	r3, [r4, #20]
 800a6b8:	b31b      	cbz	r3, 800a702 <lwip_netconn_do_write+0x92>
        msg->conn->current_msg = msg;
 800a6ba:	6823      	ldr	r3, [r4, #0]
 800a6bc:	61dc      	str	r4, [r3, #28]
        if (lwip_netconn_do_writemore(msg->conn, 0) != ERR_OK) {
 800a6be:	2100      	movs	r1, #0
 800a6c0:	6820      	ldr	r0, [r4, #0]
 800a6c2:	f7ff f9c5 	bl	8009a50 <lwip_netconn_do_writemore>
 800a6c6:	2800      	cmp	r0, #0
 800a6c8:	d0e2      	beq.n	800a690 <lwip_netconn_do_write+0x20>
          LWIP_ASSERT("state!", msg->conn->state == NETCONN_WRITE);
 800a6ca:	6823      	ldr	r3, [r4, #0]
 800a6cc:	785b      	ldrb	r3, [r3, #1]
 800a6ce:	2b01      	cmp	r3, #1
 800a6d0:	d11f      	bne.n	800a712 <lwip_netconn_do_write+0xa2>
          UNLOCK_TCPIP_CORE();
 800a6d2:	4d1a      	ldr	r5, [pc, #104]	@ (800a73c <lwip_netconn_do_write+0xcc>)
 800a6d4:	4628      	mov	r0, r5
 800a6d6:	f008 ff1c 	bl	8013512 <sys_mutex_unlock>
          sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
 800a6da:	6820      	ldr	r0, [r4, #0]
 800a6dc:	2100      	movs	r1, #0
 800a6de:	300c      	adds	r0, #12
 800a6e0:	f008 fe9e 	bl	8013420 <sys_arch_sem_wait>
          LOCK_TCPIP_CORE();
 800a6e4:	4628      	mov	r0, r5
 800a6e6:	f008 ff0d 	bl	8013504 <sys_mutex_lock>
          LWIP_ASSERT("state!", msg->conn->state != NETCONN_WRITE);
 800a6ea:	6823      	ldr	r3, [r4, #0]
 800a6ec:	785b      	ldrb	r3, [r3, #1]
 800a6ee:	2b01      	cmp	r3, #1
 800a6f0:	d1ce      	bne.n	800a690 <lwip_netconn_do_write+0x20>
 800a6f2:	4b0f      	ldr	r3, [pc, #60]	@ (800a730 <lwip_netconn_do_write+0xc0>)
 800a6f4:	f240 722c 	movw	r2, #1836	@ 0x72c
 800a6f8:	4911      	ldr	r1, [pc, #68]	@ (800a740 <lwip_netconn_do_write+0xd0>)
 800a6fa:	480f      	ldr	r0, [pc, #60]	@ (800a738 <lwip_netconn_do_write+0xc8>)
 800a6fc:	f009 fc40 	bl	8013f80 <iprintf>
        return;
 800a700:	e7c6      	b.n	800a690 <lwip_netconn_do_write+0x20>
        LWIP_ASSERT("msg->msg.w.len != 0", msg->msg.w.len != 0);
 800a702:	4b0b      	ldr	r3, [pc, #44]	@ (800a730 <lwip_netconn_do_write+0xc0>)
 800a704:	f240 7224 	movw	r2, #1828	@ 0x724
 800a708:	490e      	ldr	r1, [pc, #56]	@ (800a744 <lwip_netconn_do_write+0xd4>)
 800a70a:	480b      	ldr	r0, [pc, #44]	@ (800a738 <lwip_netconn_do_write+0xc8>)
 800a70c:	f009 fc38 	bl	8013f80 <iprintf>
 800a710:	e7d3      	b.n	800a6ba <lwip_netconn_do_write+0x4a>
          LWIP_ASSERT("state!", msg->conn->state == NETCONN_WRITE);
 800a712:	4b07      	ldr	r3, [pc, #28]	@ (800a730 <lwip_netconn_do_write+0xc0>)
 800a714:	f44f 62e5 	mov.w	r2, #1832	@ 0x728
 800a718:	4909      	ldr	r1, [pc, #36]	@ (800a740 <lwip_netconn_do_write+0xd0>)
 800a71a:	4807      	ldr	r0, [pc, #28]	@ (800a738 <lwip_netconn_do_write+0xc8>)
 800a71c:	f009 fc30 	bl	8013f80 <iprintf>
 800a720:	e7d7      	b.n	800a6d2 <lwip_netconn_do_write+0x62>
        err = ERR_INPROGRESS;
 800a722:	f06f 0304 	mvn.w	r3, #4
 800a726:	e7b2      	b.n	800a68e <lwip_netconn_do_write+0x1e>
        err = ERR_CONN;
 800a728:	f06f 030a 	mvn.w	r3, #10
 800a72c:	e7af      	b.n	800a68e <lwip_netconn_do_write+0x1e>
 800a72e:	bf00      	nop
 800a730:	08015938 	.word	0x08015938
 800a734:	08015d70 	.word	0x08015d70
 800a738:	08015744 	.word	0x08015744
 800a73c:	2400c4a0 	.word	0x2400c4a0
 800a740:	08015d8c 	.word	0x08015d8c
 800a744:	08015d94 	.word	0x08015d94

0800a748 <lwip_netconn_do_close>:
 *
 * @param m the api_msg pointing to the connection
 */
void
lwip_netconn_do_close(void *m)
{
 800a748:	b538      	push	{r3, r4, r5, lr}
 800a74a:	4604      	mov	r4, r0
  struct api_msg *msg = (struct api_msg *)m;

#if LWIP_TCP
  enum netconn_state state = msg->conn->state;
 800a74c:	6800      	ldr	r0, [r0, #0]
 800a74e:	7842      	ldrb	r2, [r0, #1]
  /* First check if this is a TCP netconn and if it is in a correct state
      (LISTEN doesn't support half shutdown) */
  if ((msg->conn->pcb.tcp != NULL) &&
 800a750:	6843      	ldr	r3, [r0, #4]
 800a752:	b123      	cbz	r3, 800a75e <lwip_netconn_do_close+0x16>
      (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) &&
 800a754:	7803      	ldrb	r3, [r0, #0]
  if ((msg->conn->pcb.tcp != NULL) &&
 800a756:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 800a75a:	2b10      	cmp	r3, #16
 800a75c:	d002      	beq.n	800a764 <lwip_netconn_do_close+0x1c>
      return;
    }
  } else
#endif /* LWIP_TCP */
  {
    msg->err = ERR_CONN;
 800a75e:	23f5      	movs	r3, #245	@ 0xf5
 800a760:	7123      	strb	r3, [r4, #4]
  }
  TCPIP_APIMSG_ACK(msg);
}
 800a762:	bd38      	pop	{r3, r4, r5, pc}
      ((msg->msg.sd.shut == NETCONN_SHUT_RDWR) || (state != NETCONN_LISTEN))) {
 800a764:	7a23      	ldrb	r3, [r4, #8]
      (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) &&
 800a766:	2b03      	cmp	r3, #3
 800a768:	d001      	beq.n	800a76e <lwip_netconn_do_close+0x26>
      ((msg->msg.sd.shut == NETCONN_SHUT_RDWR) || (state != NETCONN_LISTEN))) {
 800a76a:	2a02      	cmp	r2, #2
 800a76c:	d0f7      	beq.n	800a75e <lwip_netconn_do_close+0x16>
    if (state == NETCONN_CONNECT) {
 800a76e:	2a03      	cmp	r2, #3
 800a770:	d004      	beq.n	800a77c <lwip_netconn_do_close+0x34>
    } else if (state == NETCONN_WRITE) {
 800a772:	2a01      	cmp	r2, #1
 800a774:	d105      	bne.n	800a782 <lwip_netconn_do_close+0x3a>
      msg->err = ERR_INPROGRESS;
 800a776:	23fb      	movs	r3, #251	@ 0xfb
 800a778:	7123      	strb	r3, [r4, #4]
 800a77a:	e7f2      	b.n	800a762 <lwip_netconn_do_close+0x1a>
      msg->err = ERR_CONN;
 800a77c:	23f5      	movs	r3, #245	@ 0xf5
 800a77e:	7123      	strb	r3, [r4, #4]
 800a780:	e7ef      	b.n	800a762 <lwip_netconn_do_close+0x1a>
      if (msg->msg.sd.shut & NETCONN_SHUT_RD) {
 800a782:	f013 0f01 	tst.w	r3, #1
 800a786:	d130      	bne.n	800a7ea <lwip_netconn_do_close+0xa2>
      LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL);
 800a788:	6823      	ldr	r3, [r4, #0]
 800a78a:	69db      	ldr	r3, [r3, #28]
 800a78c:	b133      	cbz	r3, 800a79c <lwip_netconn_do_close+0x54>
 800a78e:	4b1c      	ldr	r3, [pc, #112]	@ (800a800 <lwip_netconn_do_close+0xb8>)
 800a790:	f240 72bd 	movw	r2, #1981	@ 0x7bd
 800a794:	491b      	ldr	r1, [pc, #108]	@ (800a804 <lwip_netconn_do_close+0xbc>)
 800a796:	481c      	ldr	r0, [pc, #112]	@ (800a808 <lwip_netconn_do_close+0xc0>)
 800a798:	f009 fbf2 	bl	8013f80 <iprintf>
      msg->conn->state = NETCONN_CLOSE;
 800a79c:	6823      	ldr	r3, [r4, #0]
 800a79e:	2204      	movs	r2, #4
 800a7a0:	705a      	strb	r2, [r3, #1]
      msg->conn->current_msg = msg;
 800a7a2:	6823      	ldr	r3, [r4, #0]
 800a7a4:	61dc      	str	r4, [r3, #28]
      if (lwip_netconn_do_close_internal(msg->conn, 0) != ERR_OK) {
 800a7a6:	2100      	movs	r1, #0
 800a7a8:	6820      	ldr	r0, [r4, #0]
 800a7aa:	f7ff fa9d 	bl	8009ce8 <lwip_netconn_do_close_internal>
 800a7ae:	2800      	cmp	r0, #0
 800a7b0:	d0d7      	beq.n	800a762 <lwip_netconn_do_close+0x1a>
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_CLOSE);
 800a7b2:	6823      	ldr	r3, [r4, #0]
 800a7b4:	785b      	ldrb	r3, [r3, #1]
 800a7b6:	2b04      	cmp	r3, #4
 800a7b8:	d11a      	bne.n	800a7f0 <lwip_netconn_do_close+0xa8>
        UNLOCK_TCPIP_CORE();
 800a7ba:	4d14      	ldr	r5, [pc, #80]	@ (800a80c <lwip_netconn_do_close+0xc4>)
 800a7bc:	4628      	mov	r0, r5
 800a7be:	f008 fea8 	bl	8013512 <sys_mutex_unlock>
        sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
 800a7c2:	6820      	ldr	r0, [r4, #0]
 800a7c4:	2100      	movs	r1, #0
 800a7c6:	300c      	adds	r0, #12
 800a7c8:	f008 fe2a 	bl	8013420 <sys_arch_sem_wait>
        LOCK_TCPIP_CORE();
 800a7cc:	4628      	mov	r0, r5
 800a7ce:	f008 fe99 	bl	8013504 <sys_mutex_lock>
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
 800a7d2:	6823      	ldr	r3, [r4, #0]
 800a7d4:	785b      	ldrb	r3, [r3, #1]
 800a7d6:	2b00      	cmp	r3, #0
 800a7d8:	d0c3      	beq.n	800a762 <lwip_netconn_do_close+0x1a>
 800a7da:	4b09      	ldr	r3, [pc, #36]	@ (800a800 <lwip_netconn_do_close+0xb8>)
 800a7dc:	f240 72c6 	movw	r2, #1990	@ 0x7c6
 800a7e0:	490b      	ldr	r1, [pc, #44]	@ (800a810 <lwip_netconn_do_close+0xc8>)
 800a7e2:	4809      	ldr	r0, [pc, #36]	@ (800a808 <lwip_netconn_do_close+0xc0>)
 800a7e4:	f009 fbcc 	bl	8013f80 <iprintf>
      return;
 800a7e8:	e7bb      	b.n	800a762 <lwip_netconn_do_close+0x1a>
        netconn_drain(msg->conn);
 800a7ea:	f7ff fd1d 	bl	800a228 <netconn_drain>
 800a7ee:	e7cb      	b.n	800a788 <lwip_netconn_do_close+0x40>
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_CLOSE);
 800a7f0:	4b03      	ldr	r3, [pc, #12]	@ (800a800 <lwip_netconn_do_close+0xb8>)
 800a7f2:	f240 72c2 	movw	r2, #1986	@ 0x7c2
 800a7f6:	4906      	ldr	r1, [pc, #24]	@ (800a810 <lwip_netconn_do_close+0xc8>)
 800a7f8:	4803      	ldr	r0, [pc, #12]	@ (800a808 <lwip_netconn_do_close+0xc0>)
 800a7fa:	f009 fbc1 	bl	8013f80 <iprintf>
 800a7fe:	e7dc      	b.n	800a7ba <lwip_netconn_do_close+0x72>
 800a800:	08015938 	.word	0x08015938
 800a804:	08015d70 	.word	0x08015d70
 800a808:	08015744 	.word	0x08015744
 800a80c:	2400c4a0 	.word	0x2400c4a0
 800a810:	08015d8c 	.word	0x08015d8c

0800a814 <lwip_strerr>:
 * @return a string representation for err
 */
const char *
lwip_strerr(err_t err)
{
  if ((err > 0) || (-err >= (err_t)LWIP_ARRAYSIZE(err_strerr))) {
 800a814:	f100 0310 	add.w	r3, r0, #16
 800a818:	b2db      	uxtb	r3, r3
 800a81a:	2b10      	cmp	r3, #16
 800a81c:	d804      	bhi.n	800a828 <lwip_strerr+0x14>
    return "Unknown error.";
  }
  return err_strerr[-err];
 800a81e:	4240      	negs	r0, r0
 800a820:	4b02      	ldr	r3, [pc, #8]	@ (800a82c <lwip_strerr+0x18>)
 800a822:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 800a826:	4770      	bx	lr
    return "Unknown error.";
 800a828:	4801      	ldr	r0, [pc, #4]	@ (800a830 <lwip_strerr+0x1c>)
}
 800a82a:	4770      	bx	lr
 800a82c:	08018de0 	.word	0x08018de0
 800a830:	08015da8 	.word	0x08015da8

0800a834 <netbuf_delete>:
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  if (buf != NULL) {
 800a834:	b168      	cbz	r0, 800a852 <netbuf_delete+0x1e>
{
 800a836:	b510      	push	{r4, lr}
 800a838:	4604      	mov	r4, r0
    if (buf->p != NULL) {
 800a83a:	6800      	ldr	r0, [r0, #0]
 800a83c:	b120      	cbz	r0, 800a848 <netbuf_delete+0x14>
      pbuf_free(buf->p);
 800a83e:	f001 f977 	bl	800bb30 <pbuf_free>
      buf->p = buf->ptr = NULL;
 800a842:	2300      	movs	r3, #0
 800a844:	6063      	str	r3, [r4, #4]
 800a846:	6023      	str	r3, [r4, #0]
    }
    memp_free(MEMP_NETBUF, buf);
 800a848:	4621      	mov	r1, r4
 800a84a:	2006      	movs	r0, #6
 800a84c:	f000 fe54 	bl	800b4f8 <memp_free>
  }
}
 800a850:	bd10      	pop	{r4, pc}
 800a852:	4770      	bx	lr

0800a854 <netbuf_data>:
 * @return ERR_OK if the information was retrieved,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
 800a854:	b508      	push	{r3, lr}
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
 800a856:	b158      	cbz	r0, 800a870 <netbuf_data+0x1c>
 800a858:	4603      	mov	r3, r0
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 800a85a:	b191      	cbz	r1, 800a882 <netbuf_data+0x2e>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
 800a85c:	b1d2      	cbz	r2, 800a894 <netbuf_data+0x40>

  if (buf->ptr == NULL) {
 800a85e:	6840      	ldr	r0, [r0, #4]
 800a860:	b308      	cbz	r0, 800a8a6 <netbuf_data+0x52>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
 800a862:	6840      	ldr	r0, [r0, #4]
 800a864:	6008      	str	r0, [r1, #0]
  *len = buf->ptr->len;
 800a866:	685b      	ldr	r3, [r3, #4]
 800a868:	895b      	ldrh	r3, [r3, #10]
 800a86a:	8013      	strh	r3, [r2, #0]
  return ERR_OK;
 800a86c:	2000      	movs	r0, #0
}
 800a86e:	bd08      	pop	{r3, pc}
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
 800a870:	4b0e      	ldr	r3, [pc, #56]	@ (800a8ac <netbuf_data+0x58>)
 800a872:	22c6      	movs	r2, #198	@ 0xc6
 800a874:	490e      	ldr	r1, [pc, #56]	@ (800a8b0 <netbuf_data+0x5c>)
 800a876:	480f      	ldr	r0, [pc, #60]	@ (800a8b4 <netbuf_data+0x60>)
 800a878:	f009 fb82 	bl	8013f80 <iprintf>
 800a87c:	f06f 000f 	mvn.w	r0, #15
 800a880:	e7f5      	b.n	800a86e <netbuf_data+0x1a>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 800a882:	4b0a      	ldr	r3, [pc, #40]	@ (800a8ac <netbuf_data+0x58>)
 800a884:	22c7      	movs	r2, #199	@ 0xc7
 800a886:	490c      	ldr	r1, [pc, #48]	@ (800a8b8 <netbuf_data+0x64>)
 800a888:	480a      	ldr	r0, [pc, #40]	@ (800a8b4 <netbuf_data+0x60>)
 800a88a:	f009 fb79 	bl	8013f80 <iprintf>
 800a88e:	f06f 000f 	mvn.w	r0, #15
 800a892:	e7ec      	b.n	800a86e <netbuf_data+0x1a>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
 800a894:	4b05      	ldr	r3, [pc, #20]	@ (800a8ac <netbuf_data+0x58>)
 800a896:	22c8      	movs	r2, #200	@ 0xc8
 800a898:	4908      	ldr	r1, [pc, #32]	@ (800a8bc <netbuf_data+0x68>)
 800a89a:	4806      	ldr	r0, [pc, #24]	@ (800a8b4 <netbuf_data+0x60>)
 800a89c:	f009 fb70 	bl	8013f80 <iprintf>
 800a8a0:	f06f 000f 	mvn.w	r0, #15
 800a8a4:	e7e3      	b.n	800a86e <netbuf_data+0x1a>
    return ERR_BUF;
 800a8a6:	f06f 0001 	mvn.w	r0, #1
 800a8aa:	e7e0      	b.n	800a86e <netbuf_data+0x1a>
 800a8ac:	08015ef4 	.word	0x08015ef4
 800a8b0:	08015f68 	.word	0x08015f68
 800a8b4:	08015744 	.word	0x08015744
 800a8b8:	08015f84 	.word	0x08015f84
 800a8bc:	08015fa4 	.word	0x08015fa4

0800a8c0 <tcpip_timeouts_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
static void
tcpip_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg)
{
 800a8c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a8c2:	4606      	mov	r6, r0
 800a8c4:	460f      	mov	r7, r1
 800a8c6:	e00e      	b.n	800a8e6 <tcpip_timeouts_mbox_fetch+0x26>
again:
  LWIP_ASSERT_CORE_LOCKED();

  sleeptime = sys_timeouts_sleeptime();
  if (sleeptime == SYS_TIMEOUTS_SLEEPTIME_INFINITE) {
    UNLOCK_TCPIP_CORE();
 800a8c8:	4c14      	ldr	r4, [pc, #80]	@ (800a91c <tcpip_timeouts_mbox_fetch+0x5c>)
 800a8ca:	4620      	mov	r0, r4
 800a8cc:	f008 fe21 	bl	8013512 <sys_mutex_unlock>
    sys_arch_mbox_fetch(mbox, msg, 0);
 800a8d0:	2200      	movs	r2, #0
 800a8d2:	4639      	mov	r1, r7
 800a8d4:	4630      	mov	r0, r6
 800a8d6:	f008 fd2b 	bl	8013330 <sys_arch_mbox_fetch>
    LOCK_TCPIP_CORE();
 800a8da:	4620      	mov	r0, r4
 800a8dc:	f008 fe12 	bl	8013504 <sys_mutex_lock>
       before a message could be fetched. */
    sys_check_timeouts();
    /* We try again to fetch a message from the mbox. */
    goto again;
  }
}
 800a8e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    sys_check_timeouts();
 800a8e2:	f005 feb1 	bl	8010648 <sys_check_timeouts>
  sleeptime = sys_timeouts_sleeptime();
 800a8e6:	f005 fecf 	bl	8010688 <sys_timeouts_sleeptime>
 800a8ea:	4604      	mov	r4, r0
  if (sleeptime == SYS_TIMEOUTS_SLEEPTIME_INFINITE) {
 800a8ec:	f1b0 3fff 	cmp.w	r0, #4294967295
 800a8f0:	d0ea      	beq.n	800a8c8 <tcpip_timeouts_mbox_fetch+0x8>
  } else if (sleeptime == 0) {
 800a8f2:	2800      	cmp	r0, #0
 800a8f4:	d0f5      	beq.n	800a8e2 <tcpip_timeouts_mbox_fetch+0x22>
  UNLOCK_TCPIP_CORE();
 800a8f6:	4d09      	ldr	r5, [pc, #36]	@ (800a91c <tcpip_timeouts_mbox_fetch+0x5c>)
 800a8f8:	4628      	mov	r0, r5
 800a8fa:	f008 fe0a 	bl	8013512 <sys_mutex_unlock>
  res = sys_arch_mbox_fetch(mbox, msg, sleeptime);
 800a8fe:	4622      	mov	r2, r4
 800a900:	4639      	mov	r1, r7
 800a902:	4630      	mov	r0, r6
 800a904:	f008 fd14 	bl	8013330 <sys_arch_mbox_fetch>
 800a908:	4604      	mov	r4, r0
  LOCK_TCPIP_CORE();
 800a90a:	4628      	mov	r0, r5
 800a90c:	f008 fdfa 	bl	8013504 <sys_mutex_lock>
  if (res == SYS_ARCH_TIMEOUT) {
 800a910:	f1b4 3fff 	cmp.w	r4, #4294967295
 800a914:	d1e4      	bne.n	800a8e0 <tcpip_timeouts_mbox_fetch+0x20>
    sys_check_timeouts();
 800a916:	f005 fe97 	bl	8010648 <sys_check_timeouts>
    goto again;
 800a91a:	e7e4      	b.n	800a8e6 <tcpip_timeouts_mbox_fetch+0x26>
 800a91c:	2400c4a0 	.word	0x2400c4a0

0800a920 <tcpip_thread_handle_msg>:
/* Handle a single tcpip_msg
 * This is in its own function for access by tests only.
 */
static void
tcpip_thread_handle_msg(struct tcpip_msg *msg)
{
 800a920:	b510      	push	{r4, lr}
 800a922:	4604      	mov	r4, r0
  switch (msg->type) {
 800a924:	7803      	ldrb	r3, [r0, #0]
 800a926:	2b01      	cmp	r3, #1
 800a928:	d010      	beq.n	800a94c <tcpip_thread_handle_msg+0x2c>
 800a92a:	2b02      	cmp	r3, #2
 800a92c:	d016      	beq.n	800a95c <tcpip_thread_handle_msg+0x3c>
 800a92e:	b9cb      	cbnz	r3, 800a964 <tcpip_thread_handle_msg+0x44>
#endif /* !LWIP_TCPIP_CORE_LOCKING */

#if !LWIP_TCPIP_CORE_LOCKING_INPUT
    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
      if (msg->msg.inp.input_fn(msg->msg.inp.p, msg->msg.inp.netif) != ERR_OK) {
 800a930:	68c3      	ldr	r3, [r0, #12]
 800a932:	6881      	ldr	r1, [r0, #8]
 800a934:	6840      	ldr	r0, [r0, #4]
 800a936:	4798      	blx	r3
 800a938:	b920      	cbnz	r0, 800a944 <tcpip_thread_handle_msg+0x24>
        pbuf_free(msg->msg.inp.p);
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
 800a93a:	4621      	mov	r1, r4
 800a93c:	2009      	movs	r0, #9
 800a93e:	f000 fddb 	bl	800b4f8 <memp_free>
    default:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: invalid message: %d\n", msg->type));
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
      break;
  }
}
 800a942:	bd10      	pop	{r4, pc}
        pbuf_free(msg->msg.inp.p);
 800a944:	6860      	ldr	r0, [r4, #4]
 800a946:	f001 f8f3 	bl	800bb30 <pbuf_free>
 800a94a:	e7f6      	b.n	800a93a <tcpip_thread_handle_msg+0x1a>
      msg->msg.cb.function(msg->msg.cb.ctx);
 800a94c:	6843      	ldr	r3, [r0, #4]
 800a94e:	6880      	ldr	r0, [r0, #8]
 800a950:	4798      	blx	r3
      memp_free(MEMP_TCPIP_MSG_API, msg);
 800a952:	4621      	mov	r1, r4
 800a954:	2008      	movs	r0, #8
 800a956:	f000 fdcf 	bl	800b4f8 <memp_free>
      break;
 800a95a:	e7f2      	b.n	800a942 <tcpip_thread_handle_msg+0x22>
      msg->msg.cb.function(msg->msg.cb.ctx);
 800a95c:	6843      	ldr	r3, [r0, #4]
 800a95e:	6880      	ldr	r0, [r0, #8]
 800a960:	4798      	blx	r3
      break;
 800a962:	e7ee      	b.n	800a942 <tcpip_thread_handle_msg+0x22>
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
 800a964:	4b03      	ldr	r3, [pc, #12]	@ (800a974 <tcpip_thread_handle_msg+0x54>)
 800a966:	22cf      	movs	r2, #207	@ 0xcf
 800a968:	4903      	ldr	r1, [pc, #12]	@ (800a978 <tcpip_thread_handle_msg+0x58>)
 800a96a:	4804      	ldr	r0, [pc, #16]	@ (800a97c <tcpip_thread_handle_msg+0x5c>)
 800a96c:	f009 fb08 	bl	8013f80 <iprintf>
}
 800a970:	e7e7      	b.n	800a942 <tcpip_thread_handle_msg+0x22>
 800a972:	bf00      	nop
 800a974:	08015fc0 	.word	0x08015fc0
 800a978:	08015ff0 	.word	0x08015ff0
 800a97c:	08015744 	.word	0x08015744

0800a980 <tcpip_thread>:
{
 800a980:	b500      	push	{lr}
 800a982:	b083      	sub	sp, #12
  LOCK_TCPIP_CORE();
 800a984:	480c      	ldr	r0, [pc, #48]	@ (800a9b8 <tcpip_thread+0x38>)
 800a986:	f008 fdbd 	bl	8013504 <sys_mutex_lock>
  if (tcpip_init_done != NULL) {
 800a98a:	4b0c      	ldr	r3, [pc, #48]	@ (800a9bc <tcpip_thread+0x3c>)
 800a98c:	681b      	ldr	r3, [r3, #0]
 800a98e:	b12b      	cbz	r3, 800a99c <tcpip_thread+0x1c>
    tcpip_init_done(tcpip_init_done_arg);
 800a990:	4a0b      	ldr	r2, [pc, #44]	@ (800a9c0 <tcpip_thread+0x40>)
 800a992:	6810      	ldr	r0, [r2, #0]
 800a994:	4798      	blx	r3
 800a996:	e001      	b.n	800a99c <tcpip_thread+0x1c>
    tcpip_thread_handle_msg(msg);
 800a998:	f7ff ffc2 	bl	800a920 <tcpip_thread_handle_msg>
    TCPIP_MBOX_FETCH(&tcpip_mbox, (void **)&msg);
 800a99c:	a901      	add	r1, sp, #4
 800a99e:	4809      	ldr	r0, [pc, #36]	@ (800a9c4 <tcpip_thread+0x44>)
 800a9a0:	f7ff ff8e 	bl	800a8c0 <tcpip_timeouts_mbox_fetch>
    if (msg == NULL) {
 800a9a4:	9801      	ldr	r0, [sp, #4]
 800a9a6:	2800      	cmp	r0, #0
 800a9a8:	d1f6      	bne.n	800a998 <tcpip_thread+0x18>
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
 800a9aa:	4b07      	ldr	r3, [pc, #28]	@ (800a9c8 <tcpip_thread+0x48>)
 800a9ac:	2291      	movs	r2, #145	@ 0x91
 800a9ae:	4907      	ldr	r1, [pc, #28]	@ (800a9cc <tcpip_thread+0x4c>)
 800a9b0:	4807      	ldr	r0, [pc, #28]	@ (800a9d0 <tcpip_thread+0x50>)
 800a9b2:	f009 fae5 	bl	8013f80 <iprintf>
      continue;
 800a9b6:	e7f1      	b.n	800a99c <tcpip_thread+0x1c>
 800a9b8:	2400c4a0 	.word	0x2400c4a0
 800a9bc:	2400c4ac 	.word	0x2400c4ac
 800a9c0:	2400c4a8 	.word	0x2400c4a8
 800a9c4:	2400c4a4 	.word	0x2400c4a4
 800a9c8:	08015fc0 	.word	0x08015fc0
 800a9cc:	08015ff0 	.word	0x08015ff0
 800a9d0:	08015744 	.word	0x08015744

0800a9d4 <tcpip_inpkt>:
 * @param inp the network interface on which the packet was received
 * @param input_fn input function to call
 */
err_t
tcpip_inpkt(struct pbuf *p, struct netif *inp, netif_input_fn input_fn)
{
 800a9d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a9d6:	4607      	mov	r7, r0
 800a9d8:	460e      	mov	r6, r1
 800a9da:	4615      	mov	r5, r2
  UNLOCK_TCPIP_CORE();
  return ret;
#else /* LWIP_TCPIP_CORE_LOCKING_INPUT */
  struct tcpip_msg *msg;

  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(tcpip_mbox));
 800a9dc:	4812      	ldr	r0, [pc, #72]	@ (800aa28 <tcpip_inpkt+0x54>)
 800a9de:	f008 fce6 	bl	80133ae <sys_mbox_valid>
 800a9e2:	b178      	cbz	r0, 800aa04 <tcpip_inpkt+0x30>

  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
 800a9e4:	2009      	movs	r0, #9
 800a9e6:	f000 fd51 	bl	800b48c <memp_malloc>
  if (msg == NULL) {
 800a9ea:	4604      	mov	r4, r0
 800a9ec:	b1c0      	cbz	r0, 800aa20 <tcpip_inpkt+0x4c>
    return ERR_MEM;
  }

  msg->type = TCPIP_MSG_INPKT;
 800a9ee:	2300      	movs	r3, #0
 800a9f0:	7003      	strb	r3, [r0, #0]
  msg->msg.inp.p = p;
 800a9f2:	6047      	str	r7, [r0, #4]
  msg->msg.inp.netif = inp;
 800a9f4:	6086      	str	r6, [r0, #8]
  msg->msg.inp.input_fn = input_fn;
 800a9f6:	60c5      	str	r5, [r0, #12]
  if (sys_mbox_trypost(&tcpip_mbox, msg) != ERR_OK) {
 800a9f8:	4601      	mov	r1, r0
 800a9fa:	480b      	ldr	r0, [pc, #44]	@ (800aa28 <tcpip_inpkt+0x54>)
 800a9fc:	f008 fc84 	bl	8013308 <sys_mbox_trypost>
 800aa00:	b938      	cbnz	r0, 800aa12 <tcpip_inpkt+0x3e>
    memp_free(MEMP_TCPIP_MSG_INPKT, msg);
    return ERR_MEM;
  }
  return ERR_OK;
#endif /* LWIP_TCPIP_CORE_LOCKING_INPUT */
}
 800aa02:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(tcpip_mbox));
 800aa04:	4b09      	ldr	r3, [pc, #36]	@ (800aa2c <tcpip_inpkt+0x58>)
 800aa06:	22fc      	movs	r2, #252	@ 0xfc
 800aa08:	4909      	ldr	r1, [pc, #36]	@ (800aa30 <tcpip_inpkt+0x5c>)
 800aa0a:	480a      	ldr	r0, [pc, #40]	@ (800aa34 <tcpip_inpkt+0x60>)
 800aa0c:	f009 fab8 	bl	8013f80 <iprintf>
 800aa10:	e7e8      	b.n	800a9e4 <tcpip_inpkt+0x10>
    memp_free(MEMP_TCPIP_MSG_INPKT, msg);
 800aa12:	4621      	mov	r1, r4
 800aa14:	2009      	movs	r0, #9
 800aa16:	f000 fd6f 	bl	800b4f8 <memp_free>
    return ERR_MEM;
 800aa1a:	f04f 30ff 	mov.w	r0, #4294967295
 800aa1e:	e7f0      	b.n	800aa02 <tcpip_inpkt+0x2e>
    return ERR_MEM;
 800aa20:	f04f 30ff 	mov.w	r0, #4294967295
 800aa24:	e7ed      	b.n	800aa02 <tcpip_inpkt+0x2e>
 800aa26:	bf00      	nop
 800aa28:	2400c4a4 	.word	0x2400c4a4
 800aa2c:	08015fc0 	.word	0x08015fc0
 800aa30:	08016010 	.word	0x08016010
 800aa34:	08015744 	.word	0x08015744

0800aa38 <tcpip_input>:
 *          NETIF_FLAG_ETHERNET flags)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
 800aa38:	b508      	push	{r3, lr}
#if LWIP_ETHERNET
  if (inp->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
 800aa3a:	f891 302d 	ldrb.w	r3, [r1, #45]	@ 0x2d
 800aa3e:	f013 0f18 	tst.w	r3, #24
 800aa42:	d003      	beq.n	800aa4c <tcpip_input+0x14>
    return tcpip_inpkt(p, inp, ethernet_input);
 800aa44:	4a03      	ldr	r2, [pc, #12]	@ (800aa54 <tcpip_input+0x1c>)
 800aa46:	f7ff ffc5 	bl	800a9d4 <tcpip_inpkt>
  } else
#endif /* LWIP_ETHERNET */
    return tcpip_inpkt(p, inp, ip_input);
}
 800aa4a:	bd08      	pop	{r3, pc}
    return tcpip_inpkt(p, inp, ip_input);
 800aa4c:	4a02      	ldr	r2, [pc, #8]	@ (800aa58 <tcpip_input+0x20>)
 800aa4e:	f7ff ffc1 	bl	800a9d4 <tcpip_inpkt>
 800aa52:	e7fa      	b.n	800aa4a <tcpip_input+0x12>
 800aa54:	08013139 	.word	0x08013139
 800aa58:	0801228d 	.word	0x0801228d

0800aa5c <tcpip_try_callback>:
 *
 * @see tcpip_callback
 */
err_t
tcpip_try_callback(tcpip_callback_fn function, void *ctx)
{
 800aa5c:	b570      	push	{r4, r5, r6, lr}
 800aa5e:	4606      	mov	r6, r0
 800aa60:	460d      	mov	r5, r1
  struct tcpip_msg *msg;

  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(tcpip_mbox));
 800aa62:	4812      	ldr	r0, [pc, #72]	@ (800aaac <tcpip_try_callback+0x50>)
 800aa64:	f008 fca3 	bl	80133ae <sys_mbox_valid>
 800aa68:	b170      	cbz	r0, 800aa88 <tcpip_try_callback+0x2c>

  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 800aa6a:	2008      	movs	r0, #8
 800aa6c:	f000 fd0e 	bl	800b48c <memp_malloc>
  if (msg == NULL) {
 800aa70:	4604      	mov	r4, r0
 800aa72:	b1c0      	cbz	r0, 800aaa6 <tcpip_try_callback+0x4a>
    return ERR_MEM;
  }

  msg->type = TCPIP_MSG_CALLBACK;
 800aa74:	2301      	movs	r3, #1
 800aa76:	7003      	strb	r3, [r0, #0]
  msg->msg.cb.function = function;
 800aa78:	6046      	str	r6, [r0, #4]
  msg->msg.cb.ctx = ctx;
 800aa7a:	6085      	str	r5, [r0, #8]

  if (sys_mbox_trypost(&tcpip_mbox, msg) != ERR_OK) {
 800aa7c:	4601      	mov	r1, r0
 800aa7e:	480b      	ldr	r0, [pc, #44]	@ (800aaac <tcpip_try_callback+0x50>)
 800aa80:	f008 fc42 	bl	8013308 <sys_mbox_trypost>
 800aa84:	b940      	cbnz	r0, 800aa98 <tcpip_try_callback+0x3c>
    memp_free(MEMP_TCPIP_MSG_API, msg);
    return ERR_MEM;
  }
  return ERR_OK;
}
 800aa86:	bd70      	pop	{r4, r5, r6, pc}
  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(tcpip_mbox));
 800aa88:	4b09      	ldr	r3, [pc, #36]	@ (800aab0 <tcpip_try_callback+0x54>)
 800aa8a:	f240 125d 	movw	r2, #349	@ 0x15d
 800aa8e:	4909      	ldr	r1, [pc, #36]	@ (800aab4 <tcpip_try_callback+0x58>)
 800aa90:	4809      	ldr	r0, [pc, #36]	@ (800aab8 <tcpip_try_callback+0x5c>)
 800aa92:	f009 fa75 	bl	8013f80 <iprintf>
 800aa96:	e7e8      	b.n	800aa6a <tcpip_try_callback+0xe>
    memp_free(MEMP_TCPIP_MSG_API, msg);
 800aa98:	4621      	mov	r1, r4
 800aa9a:	2008      	movs	r0, #8
 800aa9c:	f000 fd2c 	bl	800b4f8 <memp_free>
    return ERR_MEM;
 800aaa0:	f04f 30ff 	mov.w	r0, #4294967295
 800aaa4:	e7ef      	b.n	800aa86 <tcpip_try_callback+0x2a>
    return ERR_MEM;
 800aaa6:	f04f 30ff 	mov.w	r0, #4294967295
 800aaaa:	e7ec      	b.n	800aa86 <tcpip_try_callback+0x2a>
 800aaac:	2400c4a4 	.word	0x2400c4a4
 800aab0:	08015fc0 	.word	0x08015fc0
 800aab4:	08016010 	.word	0x08016010
 800aab8:	08015744 	.word	0x08015744

0800aabc <tcpip_send_msg_wait_sem>:
 * @param sem semaphore to wait on
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_send_msg_wait_sem(tcpip_callback_fn fn, void *apimsg, sys_sem_t *sem)
{
 800aabc:	b570      	push	{r4, r5, r6, lr}
 800aabe:	4604      	mov	r4, r0
 800aac0:	460d      	mov	r5, r1
#if LWIP_TCPIP_CORE_LOCKING
  LWIP_UNUSED_ARG(sem);
  LOCK_TCPIP_CORE();
 800aac2:	4e05      	ldr	r6, [pc, #20]	@ (800aad8 <tcpip_send_msg_wait_sem+0x1c>)
 800aac4:	4630      	mov	r0, r6
 800aac6:	f008 fd1d 	bl	8013504 <sys_mutex_lock>
  fn(apimsg);
 800aaca:	4628      	mov	r0, r5
 800aacc:	47a0      	blx	r4
  UNLOCK_TCPIP_CORE();
 800aace:	4630      	mov	r0, r6
 800aad0:	f008 fd1f 	bl	8013512 <sys_mutex_unlock>
  sys_mbox_post(&tcpip_mbox, &TCPIP_MSG_VAR_REF(msg));
  sys_arch_sem_wait(sem, 0);
  TCPIP_MSG_VAR_FREE(msg);
  return ERR_OK;
#endif /* LWIP_TCPIP_CORE_LOCKING */
}
 800aad4:	2000      	movs	r0, #0
 800aad6:	bd70      	pop	{r4, r5, r6, pc}
 800aad8:	2400c4a0 	.word	0x2400c4a0

0800aadc <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(tcpip_init_done_fn initfunc, void *arg)
{
 800aadc:	b530      	push	{r4, r5, lr}
 800aade:	b083      	sub	sp, #12
 800aae0:	4605      	mov	r5, r0
 800aae2:	460c      	mov	r4, r1
  lwip_init();
 800aae4:	f000 f885 	bl	800abf2 <lwip_init>

  tcpip_init_done = initfunc;
 800aae8:	4b13      	ldr	r3, [pc, #76]	@ (800ab38 <tcpip_init+0x5c>)
 800aaea:	601d      	str	r5, [r3, #0]
  tcpip_init_done_arg = arg;
 800aaec:	4b13      	ldr	r3, [pc, #76]	@ (800ab3c <tcpip_init+0x60>)
 800aaee:	601c      	str	r4, [r3, #0]
  if (sys_mbox_new(&tcpip_mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
 800aaf0:	2106      	movs	r1, #6
 800aaf2:	4813      	ldr	r0, [pc, #76]	@ (800ab40 <tcpip_init+0x64>)
 800aaf4:	f008 fbca 	bl	801328c <sys_mbox_new>
 800aaf8:	b970      	cbnz	r0, 800ab18 <tcpip_init+0x3c>
    LWIP_ASSERT("failed to create tcpip_thread mbox", 0);
  }
#if LWIP_TCPIP_CORE_LOCKING
  if (sys_mutex_new(&lock_tcpip_core) != ERR_OK) {
 800aafa:	4812      	ldr	r0, [pc, #72]	@ (800ab44 <tcpip_init+0x68>)
 800aafc:	f008 fcd8 	bl	80134b0 <sys_mutex_new>
 800ab00:	b990      	cbnz	r0, 800ab28 <tcpip_init+0x4c>
    LWIP_ASSERT("failed to create lock_tcpip_core", 0);
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
 800ab02:	2302      	movs	r3, #2
 800ab04:	9300      	str	r3, [sp, #0]
 800ab06:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 800ab0a:	2200      	movs	r2, #0
 800ab0c:	490e      	ldr	r1, [pc, #56]	@ (800ab48 <tcpip_init+0x6c>)
 800ab0e:	480f      	ldr	r0, [pc, #60]	@ (800ab4c <tcpip_init+0x70>)
 800ab10:	f008 fd04 	bl	801351c <sys_thread_new>
}
 800ab14:	b003      	add	sp, #12
 800ab16:	bd30      	pop	{r4, r5, pc}
    LWIP_ASSERT("failed to create tcpip_thread mbox", 0);
 800ab18:	4b0d      	ldr	r3, [pc, #52]	@ (800ab50 <tcpip_init+0x74>)
 800ab1a:	f240 2261 	movw	r2, #609	@ 0x261
 800ab1e:	490d      	ldr	r1, [pc, #52]	@ (800ab54 <tcpip_init+0x78>)
 800ab20:	480d      	ldr	r0, [pc, #52]	@ (800ab58 <tcpip_init+0x7c>)
 800ab22:	f009 fa2d 	bl	8013f80 <iprintf>
 800ab26:	e7e8      	b.n	800aafa <tcpip_init+0x1e>
    LWIP_ASSERT("failed to create lock_tcpip_core", 0);
 800ab28:	4b09      	ldr	r3, [pc, #36]	@ (800ab50 <tcpip_init+0x74>)
 800ab2a:	f240 2265 	movw	r2, #613	@ 0x265
 800ab2e:	490b      	ldr	r1, [pc, #44]	@ (800ab5c <tcpip_init+0x80>)
 800ab30:	4809      	ldr	r0, [pc, #36]	@ (800ab58 <tcpip_init+0x7c>)
 800ab32:	f009 fa25 	bl	8013f80 <iprintf>
 800ab36:	e7e4      	b.n	800ab02 <tcpip_init+0x26>
 800ab38:	2400c4ac 	.word	0x2400c4ac
 800ab3c:	2400c4a8 	.word	0x2400c4a8
 800ab40:	2400c4a4 	.word	0x2400c4a4
 800ab44:	2400c4a0 	.word	0x2400c4a0
 800ab48:	0800a981 	.word	0x0800a981
 800ab4c:	08016068 	.word	0x08016068
 800ab50:	08015fc0 	.word	0x08015fc0
 800ab54:	08016020 	.word	0x08016020
 800ab58:	08015744 	.word	0x08015744
 800ab5c:	08016044 	.word	0x08016044

0800ab60 <lwip_htons>:
 * @return n in network byte order
 */
u16_t
lwip_htons(u16_t n)
{
  return PP_HTONS(n);
 800ab60:	0203      	lsls	r3, r0, #8
 800ab62:	ea43 2010 	orr.w	r0, r3, r0, lsr #8
}
 800ab66:	b280      	uxth	r0, r0
 800ab68:	4770      	bx	lr

0800ab6a <lwip_htonl>:
 * @return n in network byte order
 */
u32_t
lwip_htonl(u32_t n)
{
  return PP_HTONL(n);
 800ab6a:	0203      	lsls	r3, r0, #8
 800ab6c:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800ab70:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 800ab74:	0a02      	lsrs	r2, r0, #8
 800ab76:	f402 427f 	and.w	r2, r2, #65280	@ 0xff00
 800ab7a:	4313      	orrs	r3, r2
}
 800ab7c:	ea43 6010 	orr.w	r0, r3, r0, lsr #24
 800ab80:	4770      	bx	lr

0800ab82 <lwip_standard_chksum>:
 * @param len length of data to be summed
 * @return host order (!) lwip checksum (non-inverted Internet sum)
 */
u16_t
lwip_standard_chksum(const void *dataptr, int len)
{
 800ab82:	b410      	push	{r4}
  const u8_t *pb = (const u8_t *)dataptr;
  const u16_t *ps;
  u16_t t = 0;
 800ab84:	f04f 0c00 	mov.w	ip, #0
  u32_t sum = 0;
  int odd = ((mem_ptr_t)pb & 1);
 800ab88:	f000 0401 	and.w	r4, r0, #1

  /* Get aligned to u16_t */
  if (odd && len > 0) {
 800ab8c:	460b      	mov	r3, r1
 800ab8e:	4561      	cmp	r1, ip
 800ab90:	bfd4      	ite	le
 800ab92:	2200      	movle	r2, #0
 800ab94:	f000 0201 	andgt.w	r2, r0, #1
 800ab98:	b122      	cbz	r2, 800aba4 <lwip_standard_chksum+0x22>
    ((u8_t *)&t)[1] = *pb++;
 800ab9a:	f810 2b01 	ldrb.w	r2, [r0], #1
 800ab9e:	f362 2c1f 	bfi	ip, r2, #8, #24
    len--;
 800aba2:	1e4b      	subs	r3, r1, #1
  u32_t sum = 0;
 800aba4:	2200      	movs	r2, #0
  }

  /* Add the bulk of the data */
  ps = (const u16_t *)(const void *)pb;
  while (len > 1) {
 800aba6:	e003      	b.n	800abb0 <lwip_standard_chksum+0x2e>
    sum += *ps++;
 800aba8:	f830 1b02 	ldrh.w	r1, [r0], #2
 800abac:	440a      	add	r2, r1
    len -= 2;
 800abae:	3b02      	subs	r3, #2
  while (len > 1) {
 800abb0:	2b01      	cmp	r3, #1
 800abb2:	dcf9      	bgt.n	800aba8 <lwip_standard_chksum+0x26>
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
 800abb4:	2b00      	cmp	r3, #0
 800abb6:	dd04      	ble.n	800abc2 <lwip_standard_chksum+0x40>
    ((u8_t *)&t)[0] = *(const u8_t *)ps;
 800abb8:	7803      	ldrb	r3, [r0, #0]
 800abba:	f363 0c07 	bfi	ip, r3, #0, #8
 800abbe:	fa1f fc8c 	uxth.w	ip, ip
  }

  /* Add end bytes */
  sum += t;
 800abc2:	4494      	add	ip, r2

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  sum = FOLD_U32T(sum);
 800abc4:	fa1f f38c 	uxth.w	r3, ip
 800abc8:	eb03 431c 	add.w	r3, r3, ip, lsr #16
  sum = FOLD_U32T(sum);
 800abcc:	b298      	uxth	r0, r3
 800abce:	eb00 4013 	add.w	r0, r0, r3, lsr #16

  /* Swap if alignment was odd */
  if (odd) {
 800abd2:	b124      	cbz	r4, 800abde <lwip_standard_chksum+0x5c>
    sum = SWAP_BYTES_IN_WORD(sum);
 800abd4:	0203      	lsls	r3, r0, #8
 800abd6:	b29b      	uxth	r3, r3
 800abd8:	f3c0 2007 	ubfx	r0, r0, #8, #8
 800abdc:	4318      	orrs	r0, r3
  }

  return (u16_t)sum;
}
 800abde:	b280      	uxth	r0, r0
 800abe0:	f85d 4b04 	ldr.w	r4, [sp], #4
 800abe4:	4770      	bx	lr

0800abe6 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(const void *dataptr, u16_t len)
{
 800abe6:	b508      	push	{r3, lr}
  return (u16_t)~(unsigned int)LWIP_CHKSUM(dataptr, len);
 800abe8:	f7ff ffcb 	bl	800ab82 <lwip_standard_chksum>
 800abec:	43c0      	mvns	r0, r0
}
 800abee:	b280      	uxth	r0, r0
 800abf0:	bd08      	pop	{r3, pc}

0800abf2 <lwip_init>:
 * Initialize all modules.
 * Use this in NO_SYS mode. Use tcpip_init() otherwise.
 */
void
lwip_init(void)
{
 800abf2:	b508      	push	{r3, lr}
#ifndef LWIP_SKIP_PACKING_CHECK
  LWIP_ASSERT("Struct packing not implemented correctly. Check your lwIP port.", sizeof(struct packed_struct_test) == PACKED_STRUCT_TEST_EXPECTED_SIZE);
#endif

  /* Modules initialization */
  stats_init();
 800abf4:	f001 fa6c 	bl	800c0d0 <stats_init>
#if !NO_SYS
  sys_init();
 800abf8:	f008 fc4e 	bl	8013498 <sys_init>
#endif /* !NO_SYS */
  mem_init();
 800abfc:	f000 f8c8 	bl	800ad90 <mem_init>
  memp_init();
 800ac00:	f000 fc14 	bl	800b42c <memp_init>
  pbuf_init();
  netif_init();
 800ac04:	f000 fd18 	bl	800b638 <netif_init>
#endif /* LWIP_IPV4 */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
 800ac08:	f005 fdd8 	bl	80107bc <udp_init>
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
 800ac0c:	f001 fb54 	bl	800c2b8 <tcp_init>
#endif /* LWIP_TCP */
#if LWIP_IGMP
  igmp_init();
 800ac10:	f007 f932 	bl	8011e78 <igmp_init>
#if PPP_SUPPORT
  ppp_init();
#endif

#if LWIP_TIMERS
  sys_timeouts_init();
 800ac14:	f005 fd04 	bl	8010620 <sys_timeouts_init>
#endif /* LWIP_TIMERS */
}
 800ac18:	bd08      	pop	{r3, pc}
	...

0800ac1c <ptr_to_mem>:
#endif /* MEM_OVERFLOW_CHECK */

static struct mem *
ptr_to_mem(mem_size_t ptr)
{
  return (struct mem *)(void *)&ram[ptr];
 800ac1c:	4b01      	ldr	r3, [pc, #4]	@ (800ac24 <ptr_to_mem+0x8>)
 800ac1e:	681b      	ldr	r3, [r3, #0]
}
 800ac20:	4418      	add	r0, r3
 800ac22:	4770      	bx	lr
 800ac24:	2400c4d4 	.word	0x2400c4d4

0800ac28 <mem_to_ptr>:

static mem_size_t
mem_to_ptr(void *mem)
{
  return (mem_size_t)((u8_t *)mem - ram);
 800ac28:	4b02      	ldr	r3, [pc, #8]	@ (800ac34 <mem_to_ptr+0xc>)
 800ac2a:	681b      	ldr	r3, [r3, #0]
 800ac2c:	1ac0      	subs	r0, r0, r3
}
 800ac2e:	b280      	uxth	r0, r0
 800ac30:	4770      	bx	lr
 800ac32:	bf00      	nop
 800ac34:	2400c4d4 	.word	0x2400c4d4

0800ac38 <mem_link_valid>:
/* Check if a struct mem is correctly linked.
 * If not, double-free is a possible reason.
 */
static int
mem_link_valid(struct mem *mem)
{
 800ac38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ac3a:	4604      	mov	r4, r0
  struct mem *nmem, *pmem;
  mem_size_t rmem_idx;
  rmem_idx = mem_to_ptr(mem);
 800ac3c:	f7ff fff4 	bl	800ac28 <mem_to_ptr>
 800ac40:	4607      	mov	r7, r0
  nmem = ptr_to_mem(mem->next);
 800ac42:	8825      	ldrh	r5, [r4, #0]
 800ac44:	4628      	mov	r0, r5
 800ac46:	f7ff ffe9 	bl	800ac1c <ptr_to_mem>
 800ac4a:	4606      	mov	r6, r0
  pmem = ptr_to_mem(mem->prev);
 800ac4c:	8864      	ldrh	r4, [r4, #2]
 800ac4e:	4620      	mov	r0, r4
 800ac50:	f7ff ffe4 	bl	800ac1c <ptr_to_mem>
  if ((mem->next > MEM_SIZE_ALIGNED) || (mem->prev > MEM_SIZE_ALIGNED) ||
 800ac54:	f5b5 4fc0 	cmp.w	r5, #24576	@ 0x6000
 800ac58:	d810      	bhi.n	800ac7c <mem_link_valid+0x44>
 800ac5a:	f5b4 4fc0 	cmp.w	r4, #24576	@ 0x6000
 800ac5e:	d80f      	bhi.n	800ac80 <mem_link_valid+0x48>
 800ac60:	42bc      	cmp	r4, r7
 800ac62:	d002      	beq.n	800ac6a <mem_link_valid+0x32>
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
 800ac64:	8803      	ldrh	r3, [r0, #0]
 800ac66:	42bb      	cmp	r3, r7
 800ac68:	d10c      	bne.n	800ac84 <mem_link_valid+0x4c>
      ((nmem != ram_end) && (nmem->prev != rmem_idx))) {
 800ac6a:	4b09      	ldr	r3, [pc, #36]	@ (800ac90 <mem_link_valid+0x58>)
 800ac6c:	681b      	ldr	r3, [r3, #0]
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
 800ac6e:	42b3      	cmp	r3, r6
 800ac70:	d00a      	beq.n	800ac88 <mem_link_valid+0x50>
      ((nmem != ram_end) && (nmem->prev != rmem_idx))) {
 800ac72:	8873      	ldrh	r3, [r6, #2]
 800ac74:	42bb      	cmp	r3, r7
 800ac76:	d109      	bne.n	800ac8c <mem_link_valid+0x54>
    return 0;
  }
  return 1;
 800ac78:	2001      	movs	r0, #1
 800ac7a:	e000      	b.n	800ac7e <mem_link_valid+0x46>
    return 0;
 800ac7c:	2000      	movs	r0, #0
}
 800ac7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return 0;
 800ac80:	2000      	movs	r0, #0
 800ac82:	e7fc      	b.n	800ac7e <mem_link_valid+0x46>
 800ac84:	2000      	movs	r0, #0
 800ac86:	e7fa      	b.n	800ac7e <mem_link_valid+0x46>
  return 1;
 800ac88:	2001      	movs	r0, #1
 800ac8a:	e7f8      	b.n	800ac7e <mem_link_valid+0x46>
    return 0;
 800ac8c:	2000      	movs	r0, #0
 800ac8e:	e7f6      	b.n	800ac7e <mem_link_valid+0x46>
 800ac90:	2400c4d0 	.word	0x2400c4d0

0800ac94 <plug_holes>:
{
 800ac94:	b538      	push	{r3, r4, r5, lr}
 800ac96:	4604      	mov	r4, r0
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 800ac98:	4b34      	ldr	r3, [pc, #208]	@ (800ad6c <plug_holes+0xd8>)
 800ac9a:	681b      	ldr	r3, [r3, #0]
 800ac9c:	4283      	cmp	r3, r0
 800ac9e:	d83e      	bhi.n	800ad1e <plug_holes+0x8a>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
 800aca0:	4b33      	ldr	r3, [pc, #204]	@ (800ad70 <plug_holes+0xdc>)
 800aca2:	681b      	ldr	r3, [r3, #0]
 800aca4:	42a3      	cmp	r3, r4
 800aca6:	d942      	bls.n	800ad2e <plug_holes+0x9a>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
 800aca8:	7923      	ldrb	r3, [r4, #4]
 800acaa:	2b00      	cmp	r3, #0
 800acac:	d147      	bne.n	800ad3e <plug_holes+0xaa>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
 800acae:	8823      	ldrh	r3, [r4, #0]
 800acb0:	f5b3 4fc0 	cmp.w	r3, #24576	@ 0x6000
 800acb4:	d84b      	bhi.n	800ad4e <plug_holes+0xba>
  nmem = ptr_to_mem(mem->next);
 800acb6:	8820      	ldrh	r0, [r4, #0]
 800acb8:	f7ff ffb0 	bl	800ac1c <ptr_to_mem>
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
 800acbc:	4284      	cmp	r4, r0
 800acbe:	d015      	beq.n	800acec <plug_holes+0x58>
 800acc0:	7903      	ldrb	r3, [r0, #4]
 800acc2:	b99b      	cbnz	r3, 800acec <plug_holes+0x58>
 800acc4:	4b2a      	ldr	r3, [pc, #168]	@ (800ad70 <plug_holes+0xdc>)
 800acc6:	681b      	ldr	r3, [r3, #0]
 800acc8:	4283      	cmp	r3, r0
 800acca:	d00f      	beq.n	800acec <plug_holes+0x58>
    if (lfree == nmem) {
 800accc:	4b29      	ldr	r3, [pc, #164]	@ (800ad74 <plug_holes+0xe0>)
 800acce:	681b      	ldr	r3, [r3, #0]
 800acd0:	4283      	cmp	r3, r0
 800acd2:	d044      	beq.n	800ad5e <plug_holes+0xca>
    mem->next = nmem->next;
 800acd4:	8800      	ldrh	r0, [r0, #0]
 800acd6:	8020      	strh	r0, [r4, #0]
    if (nmem->next != MEM_SIZE_ALIGNED) {
 800acd8:	f5b0 4fc0 	cmp.w	r0, #24576	@ 0x6000
 800acdc:	d006      	beq.n	800acec <plug_holes+0x58>
      ptr_to_mem(nmem->next)->prev = mem_to_ptr(mem);
 800acde:	f7ff ff9d 	bl	800ac1c <ptr_to_mem>
 800ace2:	4605      	mov	r5, r0
 800ace4:	4620      	mov	r0, r4
 800ace6:	f7ff ff9f 	bl	800ac28 <mem_to_ptr>
 800acea:	8068      	strh	r0, [r5, #2]
  pmem = ptr_to_mem(mem->prev);
 800acec:	8860      	ldrh	r0, [r4, #2]
 800acee:	f7ff ff95 	bl	800ac1c <ptr_to_mem>
 800acf2:	4605      	mov	r5, r0
  if (pmem != mem && pmem->used == 0) {
 800acf4:	4284      	cmp	r4, r0
 800acf6:	d011      	beq.n	800ad1c <plug_holes+0x88>
 800acf8:	7903      	ldrb	r3, [r0, #4]
 800acfa:	b97b      	cbnz	r3, 800ad1c <plug_holes+0x88>
    if (lfree == mem) {
 800acfc:	4b1d      	ldr	r3, [pc, #116]	@ (800ad74 <plug_holes+0xe0>)
 800acfe:	681b      	ldr	r3, [r3, #0]
 800ad00:	42a3      	cmp	r3, r4
 800ad02:	d02f      	beq.n	800ad64 <plug_holes+0xd0>
    pmem->next = mem->next;
 800ad04:	8820      	ldrh	r0, [r4, #0]
 800ad06:	8028      	strh	r0, [r5, #0]
    if (mem->next != MEM_SIZE_ALIGNED) {
 800ad08:	f5b0 4fc0 	cmp.w	r0, #24576	@ 0x6000
 800ad0c:	d006      	beq.n	800ad1c <plug_holes+0x88>
      ptr_to_mem(mem->next)->prev = mem_to_ptr(pmem);
 800ad0e:	f7ff ff85 	bl	800ac1c <ptr_to_mem>
 800ad12:	4604      	mov	r4, r0
 800ad14:	4628      	mov	r0, r5
 800ad16:	f7ff ff87 	bl	800ac28 <mem_to_ptr>
 800ad1a:	8060      	strh	r0, [r4, #2]
}
 800ad1c:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 800ad1e:	4b16      	ldr	r3, [pc, #88]	@ (800ad78 <plug_holes+0xe4>)
 800ad20:	f240 12df 	movw	r2, #479	@ 0x1df
 800ad24:	4915      	ldr	r1, [pc, #84]	@ (800ad7c <plug_holes+0xe8>)
 800ad26:	4816      	ldr	r0, [pc, #88]	@ (800ad80 <plug_holes+0xec>)
 800ad28:	f009 f92a 	bl	8013f80 <iprintf>
 800ad2c:	e7b8      	b.n	800aca0 <plug_holes+0xc>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
 800ad2e:	4b12      	ldr	r3, [pc, #72]	@ (800ad78 <plug_holes+0xe4>)
 800ad30:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 800ad34:	4913      	ldr	r1, [pc, #76]	@ (800ad84 <plug_holes+0xf0>)
 800ad36:	4812      	ldr	r0, [pc, #72]	@ (800ad80 <plug_holes+0xec>)
 800ad38:	f009 f922 	bl	8013f80 <iprintf>
 800ad3c:	e7b4      	b.n	800aca8 <plug_holes+0x14>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
 800ad3e:	4b0e      	ldr	r3, [pc, #56]	@ (800ad78 <plug_holes+0xe4>)
 800ad40:	f240 12e1 	movw	r2, #481	@ 0x1e1
 800ad44:	4910      	ldr	r1, [pc, #64]	@ (800ad88 <plug_holes+0xf4>)
 800ad46:	480e      	ldr	r0, [pc, #56]	@ (800ad80 <plug_holes+0xec>)
 800ad48:	f009 f91a 	bl	8013f80 <iprintf>
 800ad4c:	e7af      	b.n	800acae <plug_holes+0x1a>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
 800ad4e:	4b0a      	ldr	r3, [pc, #40]	@ (800ad78 <plug_holes+0xe4>)
 800ad50:	f44f 72f2 	mov.w	r2, #484	@ 0x1e4
 800ad54:	490d      	ldr	r1, [pc, #52]	@ (800ad8c <plug_holes+0xf8>)
 800ad56:	480a      	ldr	r0, [pc, #40]	@ (800ad80 <plug_holes+0xec>)
 800ad58:	f009 f912 	bl	8013f80 <iprintf>
 800ad5c:	e7ab      	b.n	800acb6 <plug_holes+0x22>
      lfree = mem;
 800ad5e:	4b05      	ldr	r3, [pc, #20]	@ (800ad74 <plug_holes+0xe0>)
 800ad60:	601c      	str	r4, [r3, #0]
 800ad62:	e7b7      	b.n	800acd4 <plug_holes+0x40>
      lfree = pmem;
 800ad64:	4b03      	ldr	r3, [pc, #12]	@ (800ad74 <plug_holes+0xe0>)
 800ad66:	6018      	str	r0, [r3, #0]
 800ad68:	e7cc      	b.n	800ad04 <plug_holes+0x70>
 800ad6a:	bf00      	nop
 800ad6c:	2400c4d4 	.word	0x2400c4d4
 800ad70:	2400c4d0 	.word	0x2400c4d0
 800ad74:	2400c4c8 	.word	0x2400c4c8
 800ad78:	08016070 	.word	0x08016070
 800ad7c:	080160a0 	.word	0x080160a0
 800ad80:	08015744 	.word	0x08015744
 800ad84:	080160b8 	.word	0x080160b8
 800ad88:	080160d4 	.word	0x080160d4
 800ad8c:	080160f0 	.word	0x080160f0

0800ad90 <mem_init>:
{
 800ad90:	b538      	push	{r3, r4, r5, lr}
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 800ad92:	4d12      	ldr	r5, [pc, #72]	@ (800addc <mem_init+0x4c>)
 800ad94:	4b12      	ldr	r3, [pc, #72]	@ (800ade0 <mem_init+0x50>)
 800ad96:	602b      	str	r3, [r5, #0]
  mem->next = MEM_SIZE_ALIGNED;
 800ad98:	f44f 44c0 	mov.w	r4, #24576	@ 0x6000
 800ad9c:	801c      	strh	r4, [r3, #0]
  mem->prev = 0;
 800ad9e:	2200      	movs	r2, #0
 800ada0:	805a      	strh	r2, [r3, #2]
  mem->used = 0;
 800ada2:	711a      	strb	r2, [r3, #4]
  ram_end = ptr_to_mem(MEM_SIZE_ALIGNED);
 800ada4:	4620      	mov	r0, r4
 800ada6:	f7ff ff39 	bl	800ac1c <ptr_to_mem>
 800adaa:	4b0e      	ldr	r3, [pc, #56]	@ (800ade4 <mem_init+0x54>)
 800adac:	6018      	str	r0, [r3, #0]
  ram_end->used = 1;
 800adae:	2301      	movs	r3, #1
 800adb0:	7103      	strb	r3, [r0, #4]
  ram_end->next = MEM_SIZE_ALIGNED;
 800adb2:	8004      	strh	r4, [r0, #0]
  ram_end->prev = MEM_SIZE_ALIGNED;
 800adb4:	8044      	strh	r4, [r0, #2]
  lfree = (struct mem *)(void *)ram;
 800adb6:	682a      	ldr	r2, [r5, #0]
 800adb8:	4b0b      	ldr	r3, [pc, #44]	@ (800ade8 <mem_init+0x58>)
 800adba:	601a      	str	r2, [r3, #0]
  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
 800adbc:	4b0b      	ldr	r3, [pc, #44]	@ (800adec <mem_init+0x5c>)
 800adbe:	f8a3 40ca 	strh.w	r4, [r3, #202]	@ 0xca
  if (sys_mutex_new(&mem_mutex) != ERR_OK) {
 800adc2:	480b      	ldr	r0, [pc, #44]	@ (800adf0 <mem_init+0x60>)
 800adc4:	f008 fb74 	bl	80134b0 <sys_mutex_new>
 800adc8:	b900      	cbnz	r0, 800adcc <mem_init+0x3c>
}
 800adca:	bd38      	pop	{r3, r4, r5, pc}
    LWIP_ASSERT("failed to create mem_mutex", 0);
 800adcc:	4b09      	ldr	r3, [pc, #36]	@ (800adf4 <mem_init+0x64>)
 800adce:	f240 221f 	movw	r2, #543	@ 0x21f
 800add2:	4909      	ldr	r1, [pc, #36]	@ (800adf8 <mem_init+0x68>)
 800add4:	4809      	ldr	r0, [pc, #36]	@ (800adfc <mem_init+0x6c>)
 800add6:	f009 f8d3 	bl	8013f80 <iprintf>
}
 800adda:	e7f6      	b.n	800adca <mem_init+0x3a>
 800addc:	2400c4d4 	.word	0x2400c4d4
 800ade0:	30004000 	.word	0x30004000
 800ade4:	2400c4d0 	.word	0x2400c4d0
 800ade8:	2400c4c8 	.word	0x2400c4c8
 800adec:	240141b4 	.word	0x240141b4
 800adf0:	2400c4cc 	.word	0x2400c4cc
 800adf4:	08016070 	.word	0x08016070
 800adf8:	0801611c 	.word	0x0801611c
 800adfc:	08015744 	.word	0x08015744

0800ae00 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
 800ae00:	b538      	push	{r3, r4, r5, lr}
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
 800ae02:	b328      	cbz	r0, 800ae50 <mem_free+0x50>
 800ae04:	4604      	mov	r4, r0
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  if ((((mem_ptr_t)rmem) & (MEM_ALIGNMENT - 1)) != 0) {
 800ae06:	f010 0f03 	tst.w	r0, #3
 800ae0a:	d125      	bne.n	800ae58 <mem_free+0x58>
    return;
  }

  /* Get the corresponding struct mem: */
  /* cast through void* to get rid of alignment warnings */
  mem = (struct mem *)(void *)((u8_t *)rmem - (SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET));
 800ae0c:	f1a0 0508 	sub.w	r5, r0, #8

  if ((u8_t *)mem < ram || (u8_t *)rmem + MIN_SIZE_ALIGNED > (u8_t *)ram_end) {
 800ae10:	4b49      	ldr	r3, [pc, #292]	@ (800af38 <mem_free+0x138>)
 800ae12:	681b      	ldr	r3, [r3, #0]
 800ae14:	42ab      	cmp	r3, r5
 800ae16:	d805      	bhi.n	800ae24 <mem_free+0x24>
 800ae18:	f100 030c 	add.w	r3, r0, #12
 800ae1c:	4a47      	ldr	r2, [pc, #284]	@ (800af3c <mem_free+0x13c>)
 800ae1e:	6812      	ldr	r2, [r2, #0]
 800ae20:	4293      	cmp	r3, r2
 800ae22:	d92f      	bls.n	800ae84 <mem_free+0x84>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory");
 800ae24:	4c46      	ldr	r4, [pc, #280]	@ (800af40 <mem_free+0x140>)
 800ae26:	4b47      	ldr	r3, [pc, #284]	@ (800af44 <mem_free+0x144>)
 800ae28:	f240 227f 	movw	r2, #639	@ 0x27f
 800ae2c:	4621      	mov	r1, r4
 800ae2e:	4846      	ldr	r0, [pc, #280]	@ (800af48 <mem_free+0x148>)
 800ae30:	f009 f8a6 	bl	8013f80 <iprintf>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
 800ae34:	4620      	mov	r0, r4
 800ae36:	f009 f913 	bl	8014060 <puts>
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
 800ae3a:	f008 fb87 	bl	801354c <sys_arch_protect>
 800ae3e:	4a43      	ldr	r2, [pc, #268]	@ (800af4c <mem_free+0x14c>)
 800ae40:	f8b2 30d0 	ldrh.w	r3, [r2, #208]	@ 0xd0
 800ae44:	3301      	adds	r3, #1
 800ae46:	f8a2 30d0 	strh.w	r3, [r2, #208]	@ 0xd0
 800ae4a:	f008 fb8b 	bl	8013564 <sys_arch_unprotect>
  MEM_SANITY();
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
 800ae4e:	bd38      	pop	{r3, r4, r5, pc}
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
 800ae50:	483f      	ldr	r0, [pc, #252]	@ (800af50 <mem_free+0x150>)
 800ae52:	f009 f905 	bl	8014060 <puts>
    return;
 800ae56:	e7fa      	b.n	800ae4e <mem_free+0x4e>
    LWIP_MEM_ILLEGAL_FREE("mem_free: sanity check alignment");
 800ae58:	4c3e      	ldr	r4, [pc, #248]	@ (800af54 <mem_free+0x154>)
 800ae5a:	4b3a      	ldr	r3, [pc, #232]	@ (800af44 <mem_free+0x144>)
 800ae5c:	f240 2273 	movw	r2, #627	@ 0x273
 800ae60:	4621      	mov	r1, r4
 800ae62:	4839      	ldr	r0, [pc, #228]	@ (800af48 <mem_free+0x148>)
 800ae64:	f009 f88c 	bl	8013f80 <iprintf>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: sanity check alignment\n"));
 800ae68:	4620      	mov	r0, r4
 800ae6a:	f009 f8f9 	bl	8014060 <puts>
    MEM_STATS_INC_LOCKED(illegal);
 800ae6e:	f008 fb6d 	bl	801354c <sys_arch_protect>
 800ae72:	4a36      	ldr	r2, [pc, #216]	@ (800af4c <mem_free+0x14c>)
 800ae74:	f8b2 30d0 	ldrh.w	r3, [r2, #208]	@ 0xd0
 800ae78:	3301      	adds	r3, #1
 800ae7a:	f8a2 30d0 	strh.w	r3, [r2, #208]	@ 0xd0
 800ae7e:	f008 fb71 	bl	8013564 <sys_arch_unprotect>
    return;
 800ae82:	e7e4      	b.n	800ae4e <mem_free+0x4e>
  LWIP_MEM_FREE_PROTECT();
 800ae84:	4834      	ldr	r0, [pc, #208]	@ (800af58 <mem_free+0x158>)
 800ae86:	f008 fb3d 	bl	8013504 <sys_mutex_lock>
  if (!mem->used) {
 800ae8a:	f814 3c04 	ldrb.w	r3, [r4, #-4]
 800ae8e:	b313      	cbz	r3, 800aed6 <mem_free+0xd6>
  if (!mem_link_valid(mem)) {
 800ae90:	4628      	mov	r0, r5
 800ae92:	f7ff fed1 	bl	800ac38 <mem_link_valid>
 800ae96:	2800      	cmp	r0, #0
 800ae98:	d035      	beq.n	800af06 <mem_free+0x106>
  mem->used = 0;
 800ae9a:	2300      	movs	r3, #0
 800ae9c:	f804 3c04 	strb.w	r3, [r4, #-4]
  if (mem < lfree) {
 800aea0:	4b2e      	ldr	r3, [pc, #184]	@ (800af5c <mem_free+0x15c>)
 800aea2:	681b      	ldr	r3, [r3, #0]
 800aea4:	42ab      	cmp	r3, r5
 800aea6:	d901      	bls.n	800aeac <mem_free+0xac>
    lfree = mem;
 800aea8:	4b2c      	ldr	r3, [pc, #176]	@ (800af5c <mem_free+0x15c>)
 800aeaa:	601d      	str	r5, [r3, #0]
  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
 800aeac:	4a27      	ldr	r2, [pc, #156]	@ (800af4c <mem_free+0x14c>)
 800aeae:	f8b2 10cc 	ldrh.w	r1, [r2, #204]	@ 0xcc
 800aeb2:	4b21      	ldr	r3, [pc, #132]	@ (800af38 <mem_free+0x138>)
 800aeb4:	681b      	ldr	r3, [r3, #0]
 800aeb6:	1aeb      	subs	r3, r5, r3
 800aeb8:	b29b      	uxth	r3, r3
 800aeba:	f834 0c08 	ldrh.w	r0, [r4, #-8]
 800aebe:	1a1b      	subs	r3, r3, r0
 800aec0:	fa11 f383 	uxtah	r3, r1, r3
 800aec4:	f8a2 30cc 	strh.w	r3, [r2, #204]	@ 0xcc
  plug_holes(mem);
 800aec8:	4628      	mov	r0, r5
 800aeca:	f7ff fee3 	bl	800ac94 <plug_holes>
  LWIP_MEM_FREE_UNPROTECT();
 800aece:	4822      	ldr	r0, [pc, #136]	@ (800af58 <mem_free+0x158>)
 800aed0:	f008 fb1f 	bl	8013512 <sys_mutex_unlock>
 800aed4:	e7bb      	b.n	800ae4e <mem_free+0x4e>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory: double free");
 800aed6:	4b1b      	ldr	r3, [pc, #108]	@ (800af44 <mem_free+0x144>)
 800aed8:	f44f 7223 	mov.w	r2, #652	@ 0x28c
 800aedc:	4920      	ldr	r1, [pc, #128]	@ (800af60 <mem_free+0x160>)
 800aede:	481a      	ldr	r0, [pc, #104]	@ (800af48 <mem_free+0x148>)
 800aee0:	f009 f84e 	bl	8013f80 <iprintf>
    LWIP_MEM_FREE_UNPROTECT();
 800aee4:	481c      	ldr	r0, [pc, #112]	@ (800af58 <mem_free+0x158>)
 800aee6:	f008 fb14 	bl	8013512 <sys_mutex_unlock>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory: double free?\n"));
 800aeea:	481e      	ldr	r0, [pc, #120]	@ (800af64 <mem_free+0x164>)
 800aeec:	f009 f8b8 	bl	8014060 <puts>
    MEM_STATS_INC_LOCKED(illegal);
 800aef0:	f008 fb2c 	bl	801354c <sys_arch_protect>
 800aef4:	4a15      	ldr	r2, [pc, #84]	@ (800af4c <mem_free+0x14c>)
 800aef6:	f8b2 30d0 	ldrh.w	r3, [r2, #208]	@ 0xd0
 800aefa:	3301      	adds	r3, #1
 800aefc:	f8a2 30d0 	strh.w	r3, [r2, #208]	@ 0xd0
 800af00:	f008 fb30 	bl	8013564 <sys_arch_unprotect>
    return;
 800af04:	e7a3      	b.n	800ae4e <mem_free+0x4e>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory: non-linked: double free");
 800af06:	4b0f      	ldr	r3, [pc, #60]	@ (800af44 <mem_free+0x144>)
 800af08:	f240 2295 	movw	r2, #661	@ 0x295
 800af0c:	4916      	ldr	r1, [pc, #88]	@ (800af68 <mem_free+0x168>)
 800af0e:	480e      	ldr	r0, [pc, #56]	@ (800af48 <mem_free+0x148>)
 800af10:	f009 f836 	bl	8013f80 <iprintf>
    LWIP_MEM_FREE_UNPROTECT();
 800af14:	4810      	ldr	r0, [pc, #64]	@ (800af58 <mem_free+0x158>)
 800af16:	f008 fafc 	bl	8013512 <sys_mutex_unlock>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory: non-linked: double free?\n"));
 800af1a:	4814      	ldr	r0, [pc, #80]	@ (800af6c <mem_free+0x16c>)
 800af1c:	f009 f8a0 	bl	8014060 <puts>
    MEM_STATS_INC_LOCKED(illegal);
 800af20:	f008 fb14 	bl	801354c <sys_arch_protect>
 800af24:	4a09      	ldr	r2, [pc, #36]	@ (800af4c <mem_free+0x14c>)
 800af26:	f8b2 30d0 	ldrh.w	r3, [r2, #208]	@ 0xd0
 800af2a:	3301      	adds	r3, #1
 800af2c:	f8a2 30d0 	strh.w	r3, [r2, #208]	@ 0xd0
 800af30:	f008 fb18 	bl	8013564 <sys_arch_unprotect>
    return;
 800af34:	e78b      	b.n	800ae4e <mem_free+0x4e>
 800af36:	bf00      	nop
 800af38:	2400c4d4 	.word	0x2400c4d4
 800af3c:	2400c4d0 	.word	0x2400c4d0
 800af40:	0801617c 	.word	0x0801617c
 800af44:	08016070 	.word	0x08016070
 800af48:	08015744 	.word	0x08015744
 800af4c:	240141b4 	.word	0x240141b4
 800af50:	08016138 	.word	0x08016138
 800af54:	08016158 	.word	0x08016158
 800af58:	2400c4cc 	.word	0x2400c4cc
 800af5c:	2400c4c8 	.word	0x2400c4c8
 800af60:	08016198 	.word	0x08016198
 800af64:	080161c0 	.word	0x080161c0
 800af68:	080161e8 	.word	0x080161e8
 800af6c:	0801621c 	.word	0x0801621c

0800af70 <mem_trim>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t new_size)
{
 800af70:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800af74:	4605      	mov	r5, r0
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = (mem_size_t)LWIP_MEM_ALIGN_SIZE(new_size);
 800af76:	1ccc      	adds	r4, r1, #3
 800af78:	b2a4      	uxth	r4, r4
 800af7a:	f024 0403 	bic.w	r4, r4, #3
 800af7e:	b2a4      	uxth	r4, r4
  if (newsize < MIN_SIZE_ALIGNED) {
 800af80:	2c0b      	cmp	r4, #11
 800af82:	d800      	bhi.n	800af86 <mem_trim+0x16>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
 800af84:	240c      	movs	r4, #12
  }
#if MEM_OVERFLOW_CHECK
  newsize += MEM_SANITY_REGION_BEFORE_ALIGNED + MEM_SANITY_REGION_AFTER_ALIGNED;
#endif
  if ((newsize > MEM_SIZE_ALIGNED) || (newsize < new_size)) {
 800af86:	428c      	cmp	r4, r1
 800af88:	bf2c      	ite	cs
 800af8a:	2100      	movcs	r1, #0
 800af8c:	2101      	movcc	r1, #1
 800af8e:	f5b4 4fc0 	cmp.w	r4, #24576	@ 0x6000
 800af92:	bf88      	it	hi
 800af94:	f041 0101 	orrhi.w	r1, r1, #1
 800af98:	2900      	cmp	r1, #0
 800af9a:	f040 80c4 	bne.w	800b126 <mem_trim+0x1b6>
    return NULL;
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 800af9e:	4b65      	ldr	r3, [pc, #404]	@ (800b134 <mem_trim+0x1c4>)
 800afa0:	681b      	ldr	r3, [r3, #0]
 800afa2:	42ab      	cmp	r3, r5
 800afa4:	d803      	bhi.n	800afae <mem_trim+0x3e>
 800afa6:	4b64      	ldr	r3, [pc, #400]	@ (800b138 <mem_trim+0x1c8>)
 800afa8:	681b      	ldr	r3, [r3, #0]
 800afaa:	42ab      	cmp	r3, r5
 800afac:	d806      	bhi.n	800afbc <mem_trim+0x4c>
 800afae:	4b63      	ldr	r3, [pc, #396]	@ (800b13c <mem_trim+0x1cc>)
 800afb0:	f240 22d1 	movw	r2, #721	@ 0x2d1
 800afb4:	4962      	ldr	r1, [pc, #392]	@ (800b140 <mem_trim+0x1d0>)
 800afb6:	4863      	ldr	r0, [pc, #396]	@ (800b144 <mem_trim+0x1d4>)
 800afb8:	f008 ffe2 	bl	8013f80 <iprintf>
              (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 800afbc:	4b5d      	ldr	r3, [pc, #372]	@ (800b134 <mem_trim+0x1c4>)
 800afbe:	681b      	ldr	r3, [r3, #0]
 800afc0:	42ab      	cmp	r3, r5
 800afc2:	d851      	bhi.n	800b068 <mem_trim+0xf8>
 800afc4:	4b5c      	ldr	r3, [pc, #368]	@ (800b138 <mem_trim+0x1c8>)
 800afc6:	681b      	ldr	r3, [r3, #0]
 800afc8:	42ab      	cmp	r3, r5
 800afca:	d94d      	bls.n	800b068 <mem_trim+0xf8>
  mem = (struct mem *)(void *)((u8_t *)rmem - (SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET));
#if MEM_OVERFLOW_CHECK
  mem_overflow_check_element(mem);
#endif
  /* ... and its offset pointer */
  ptr = mem_to_ptr(mem);
 800afcc:	f1a5 0008 	sub.w	r0, r5, #8
 800afd0:	f7ff fe2a 	bl	800ac28 <mem_to_ptr>
 800afd4:	4607      	mov	r7, r0

  size = (mem_size_t)((mem_size_t)(mem->next - ptr) - (SIZEOF_STRUCT_MEM + MEM_SANITY_OVERHEAD));
 800afd6:	f835 6c08 	ldrh.w	r6, [r5, #-8]
 800afda:	1a36      	subs	r6, r6, r0
 800afdc:	b2b6      	uxth	r6, r6
 800afde:	3e08      	subs	r6, #8
 800afe0:	b2b6      	uxth	r6, r6
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
 800afe2:	42b4      	cmp	r4, r6
 800afe4:	d850      	bhi.n	800b088 <mem_trim+0x118>
  if (newsize > size) {
 800afe6:	42b4      	cmp	r4, r6
 800afe8:	f200 809f 	bhi.w	800b12a <mem_trim+0x1ba>
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
 800afec:	f000 809f 	beq.w	800b12e <mem_trim+0x1be>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
 800aff0:	4855      	ldr	r0, [pc, #340]	@ (800b148 <mem_trim+0x1d8>)
 800aff2:	f008 fa87 	bl	8013504 <sys_mutex_lock>

  mem2 = ptr_to_mem(mem->next);
 800aff6:	f835 9c08 	ldrh.w	r9, [r5, #-8]
 800affa:	4648      	mov	r0, r9
 800affc:	f7ff fe0e 	bl	800ac1c <ptr_to_mem>
 800b000:	4680      	mov	r8, r0
  if (mem2->used == 0) {
 800b002:	7903      	ldrb	r3, [r0, #4]
 800b004:	2b00      	cmp	r3, #0
 800b006:	d155      	bne.n	800b0b4 <mem_trim+0x144>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    LWIP_ASSERT("invalid next ptr", mem->next != MEM_SIZE_ALIGNED);
 800b008:	f5b9 4fc0 	cmp.w	r9, #24576	@ 0x6000
 800b00c:	d044      	beq.n	800b098 <mem_trim+0x128>
    /* remember the old next pointer */
    next = mem2->next;
 800b00e:	f8b8 a000 	ldrh.w	sl, [r8]
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + newsize);
 800b012:	eb04 0907 	add.w	r9, r4, r7
 800b016:	fa1f f989 	uxth.w	r9, r9
 800b01a:	f109 0908 	add.w	r9, r9, #8
 800b01e:	fa1f f989 	uxth.w	r9, r9
    if (lfree == mem2) {
 800b022:	4b4a      	ldr	r3, [pc, #296]	@ (800b14c <mem_trim+0x1dc>)
 800b024:	681b      	ldr	r3, [r3, #0]
 800b026:	4543      	cmp	r3, r8
 800b028:	d03e      	beq.n	800b0a8 <mem_trim+0x138>
      lfree = ptr_to_mem(ptr2);
    }
    mem2 = ptr_to_mem(ptr2);
 800b02a:	4648      	mov	r0, r9
 800b02c:	f7ff fdf6 	bl	800ac1c <ptr_to_mem>
    mem2->used = 0;
 800b030:	2300      	movs	r3, #0
 800b032:	7103      	strb	r3, [r0, #4]
    /* restore the next pointer */
    mem2->next = next;
 800b034:	f8a0 a000 	strh.w	sl, [r0]
    /* link it back to mem */
    mem2->prev = ptr;
 800b038:	8047      	strh	r7, [r0, #2]
    /* link mem to it */
    mem->next = ptr2;
 800b03a:	f825 9c08 	strh.w	r9, [r5, #-8]
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
 800b03e:	8800      	ldrh	r0, [r0, #0]
 800b040:	f5b0 4fc0 	cmp.w	r0, #24576	@ 0x6000
 800b044:	d003      	beq.n	800b04e <mem_trim+0xde>
      ptr_to_mem(mem2->next)->prev = ptr2;
 800b046:	f7ff fde9 	bl	800ac1c <ptr_to_mem>
 800b04a:	f8a0 9002 	strh.w	r9, [r0, #2]
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
 800b04e:	4b40      	ldr	r3, [pc, #256]	@ (800b150 <mem_trim+0x1e0>)
 800b050:	f8b3 20cc 	ldrh.w	r2, [r3, #204]	@ 0xcc
 800b054:	1ba6      	subs	r6, r4, r6
 800b056:	fa12 f686 	uxtah	r6, r2, r6
 800b05a:	f8a3 60cc 	strh.w	r6, [r3, #204]	@ 0xcc
#endif
  MEM_SANITY();
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
 800b05e:	483a      	ldr	r0, [pc, #232]	@ (800b148 <mem_trim+0x1d8>)
 800b060:	f008 fa57 	bl	8013512 <sys_mutex_unlock>
  return rmem;
 800b064:	4628      	mov	r0, r5
 800b066:	e00d      	b.n	800b084 <mem_trim+0x114>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
 800b068:	483a      	ldr	r0, [pc, #232]	@ (800b154 <mem_trim+0x1e4>)
 800b06a:	f008 fff9 	bl	8014060 <puts>
    MEM_STATS_INC_LOCKED(illegal);
 800b06e:	f008 fa6d 	bl	801354c <sys_arch_protect>
 800b072:	4a37      	ldr	r2, [pc, #220]	@ (800b150 <mem_trim+0x1e0>)
 800b074:	f8b2 30d0 	ldrh.w	r3, [r2, #208]	@ 0xd0
 800b078:	3301      	adds	r3, #1
 800b07a:	f8a2 30d0 	strh.w	r3, [r2, #208]	@ 0xd0
 800b07e:	f008 fa71 	bl	8013564 <sys_arch_unprotect>
    return rmem;
 800b082:	4628      	mov	r0, r5
}
 800b084:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
 800b088:	4b2c      	ldr	r3, [pc, #176]	@ (800b13c <mem_trim+0x1cc>)
 800b08a:	f44f 7239 	mov.w	r2, #740	@ 0x2e4
 800b08e:	4932      	ldr	r1, [pc, #200]	@ (800b158 <mem_trim+0x1e8>)
 800b090:	482c      	ldr	r0, [pc, #176]	@ (800b144 <mem_trim+0x1d4>)
 800b092:	f008 ff75 	bl	8013f80 <iprintf>
 800b096:	e7a6      	b.n	800afe6 <mem_trim+0x76>
    LWIP_ASSERT("invalid next ptr", mem->next != MEM_SIZE_ALIGNED);
 800b098:	4b28      	ldr	r3, [pc, #160]	@ (800b13c <mem_trim+0x1cc>)
 800b09a:	f240 22f5 	movw	r2, #757	@ 0x2f5
 800b09e:	492f      	ldr	r1, [pc, #188]	@ (800b15c <mem_trim+0x1ec>)
 800b0a0:	4828      	ldr	r0, [pc, #160]	@ (800b144 <mem_trim+0x1d4>)
 800b0a2:	f008 ff6d 	bl	8013f80 <iprintf>
 800b0a6:	e7b2      	b.n	800b00e <mem_trim+0x9e>
      lfree = ptr_to_mem(ptr2);
 800b0a8:	4648      	mov	r0, r9
 800b0aa:	f7ff fdb7 	bl	800ac1c <ptr_to_mem>
 800b0ae:	4b27      	ldr	r3, [pc, #156]	@ (800b14c <mem_trim+0x1dc>)
 800b0b0:	6018      	str	r0, [r3, #0]
 800b0b2:	e7ba      	b.n	800b02a <mem_trim+0xba>
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 800b0b4:	f104 0314 	add.w	r3, r4, #20
 800b0b8:	42b3      	cmp	r3, r6
 800b0ba:	d8d0      	bhi.n	800b05e <mem_trim+0xee>
    ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + newsize);
 800b0bc:	eb04 0807 	add.w	r8, r4, r7
 800b0c0:	fa1f f888 	uxth.w	r8, r8
 800b0c4:	f108 0808 	add.w	r8, r8, #8
 800b0c8:	fa1f f888 	uxth.w	r8, r8
    LWIP_ASSERT("invalid next ptr", mem->next != MEM_SIZE_ALIGNED);
 800b0cc:	f5b9 4fc0 	cmp.w	r9, #24576	@ 0x6000
 800b0d0:	d021      	beq.n	800b116 <mem_trim+0x1a6>
    mem2 = ptr_to_mem(ptr2);
 800b0d2:	4640      	mov	r0, r8
 800b0d4:	f7ff fda2 	bl	800ac1c <ptr_to_mem>
    if (mem2 < lfree) {
 800b0d8:	4b1c      	ldr	r3, [pc, #112]	@ (800b14c <mem_trim+0x1dc>)
 800b0da:	681b      	ldr	r3, [r3, #0]
 800b0dc:	4283      	cmp	r3, r0
 800b0de:	d901      	bls.n	800b0e4 <mem_trim+0x174>
      lfree = mem2;
 800b0e0:	4b1a      	ldr	r3, [pc, #104]	@ (800b14c <mem_trim+0x1dc>)
 800b0e2:	6018      	str	r0, [r3, #0]
    mem2->used = 0;
 800b0e4:	2300      	movs	r3, #0
 800b0e6:	7103      	strb	r3, [r0, #4]
    mem2->next = mem->next;
 800b0e8:	f835 3c08 	ldrh.w	r3, [r5, #-8]
 800b0ec:	8003      	strh	r3, [r0, #0]
    mem2->prev = ptr;
 800b0ee:	8047      	strh	r7, [r0, #2]
    mem->next = ptr2;
 800b0f0:	f825 8c08 	strh.w	r8, [r5, #-8]
    if (mem2->next != MEM_SIZE_ALIGNED) {
 800b0f4:	8800      	ldrh	r0, [r0, #0]
 800b0f6:	f5b0 4fc0 	cmp.w	r0, #24576	@ 0x6000
 800b0fa:	d003      	beq.n	800b104 <mem_trim+0x194>
      ptr_to_mem(mem2->next)->prev = ptr2;
 800b0fc:	f7ff fd8e 	bl	800ac1c <ptr_to_mem>
 800b100:	f8a0 8002 	strh.w	r8, [r0, #2]
    MEM_STATS_DEC_USED(used, (size - newsize));
 800b104:	4b12      	ldr	r3, [pc, #72]	@ (800b150 <mem_trim+0x1e0>)
 800b106:	f8b3 20cc 	ldrh.w	r2, [r3, #204]	@ 0xcc
 800b10a:	1ba4      	subs	r4, r4, r6
 800b10c:	fa12 f484 	uxtah	r4, r2, r4
 800b110:	f8a3 40cc 	strh.w	r4, [r3, #204]	@ 0xcc
 800b114:	e7a3      	b.n	800b05e <mem_trim+0xee>
    LWIP_ASSERT("invalid next ptr", mem->next != MEM_SIZE_ALIGNED);
 800b116:	4b09      	ldr	r3, [pc, #36]	@ (800b13c <mem_trim+0x1cc>)
 800b118:	f240 3216 	movw	r2, #790	@ 0x316
 800b11c:	490f      	ldr	r1, [pc, #60]	@ (800b15c <mem_trim+0x1ec>)
 800b11e:	4809      	ldr	r0, [pc, #36]	@ (800b144 <mem_trim+0x1d4>)
 800b120:	f008 ff2e 	bl	8013f80 <iprintf>
 800b124:	e7d5      	b.n	800b0d2 <mem_trim+0x162>
    return NULL;
 800b126:	2000      	movs	r0, #0
 800b128:	e7ac      	b.n	800b084 <mem_trim+0x114>
    return NULL;
 800b12a:	2000      	movs	r0, #0
 800b12c:	e7aa      	b.n	800b084 <mem_trim+0x114>
    return rmem;
 800b12e:	4628      	mov	r0, r5
 800b130:	e7a8      	b.n	800b084 <mem_trim+0x114>
 800b132:	bf00      	nop
 800b134:	2400c4d4 	.word	0x2400c4d4
 800b138:	2400c4d0 	.word	0x2400c4d0
 800b13c:	08016070 	.word	0x08016070
 800b140:	08016250 	.word	0x08016250
 800b144:	08015744 	.word	0x08015744
 800b148:	2400c4cc 	.word	0x2400c4cc
 800b14c:	2400c4c8 	.word	0x2400c4c8
 800b150:	240141b4 	.word	0x240141b4
 800b154:	08016268 	.word	0x08016268
 800b158:	08016284 	.word	0x08016284
 800b15c:	080162a4 	.word	0x080162a4

0800b160 <mem_malloc>:
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size_in == 0) {
 800b160:	2800      	cmp	r0, #0
 800b162:	f000 80d3 	beq.w	800b30c <mem_malloc+0x1ac>
{
 800b166:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b16a:	4603      	mov	r3, r0
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = (mem_size_t)LWIP_MEM_ALIGN_SIZE(size_in);
 800b16c:	1cc7      	adds	r7, r0, #3
 800b16e:	b2bf      	uxth	r7, r7
 800b170:	f027 0703 	bic.w	r7, r7, #3
 800b174:	b2bf      	uxth	r7, r7
  if (size < MIN_SIZE_ALIGNED) {
 800b176:	2f0b      	cmp	r7, #11
 800b178:	d800      	bhi.n	800b17c <mem_malloc+0x1c>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
 800b17a:	270c      	movs	r7, #12
  }
#if MEM_OVERFLOW_CHECK
  size += MEM_SANITY_REGION_BEFORE_ALIGNED + MEM_SANITY_REGION_AFTER_ALIGNED;
#endif
  if ((size > MEM_SIZE_ALIGNED) || (size < size_in)) {
 800b17c:	429f      	cmp	r7, r3
 800b17e:	bf2c      	ite	cs
 800b180:	2300      	movcs	r3, #0
 800b182:	2301      	movcc	r3, #1
 800b184:	f5b7 4fc0 	cmp.w	r7, #24576	@ 0x6000
 800b188:	bf88      	it	hi
 800b18a:	f043 0301 	orrhi.w	r3, r3, #1
 800b18e:	2b00      	cmp	r3, #0
 800b190:	f040 80be 	bne.w	800b310 <mem_malloc+0x1b0>
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_mutex_lock(&mem_mutex);
 800b194:	485f      	ldr	r0, [pc, #380]	@ (800b314 <mem_malloc+0x1b4>)
 800b196:	f008 f9b5 	bl	8013504 <sys_mutex_lock>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = mem_to_ptr(lfree); ptr < MEM_SIZE_ALIGNED - size;
 800b19a:	4b5f      	ldr	r3, [pc, #380]	@ (800b318 <mem_malloc+0x1b8>)
 800b19c:	6818      	ldr	r0, [r3, #0]
 800b19e:	f7ff fd43 	bl	800ac28 <mem_to_ptr>
 800b1a2:	4605      	mov	r5, r0
 800b1a4:	e04d      	b.n	800b242 <mem_malloc+0xe2>
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + size);
          LWIP_ASSERT("invalid next ptr",ptr2 != MEM_SIZE_ALIGNED);
 800b1a6:	4b5d      	ldr	r3, [pc, #372]	@ (800b31c <mem_malloc+0x1bc>)
 800b1a8:	f240 3287 	movw	r2, #903	@ 0x387
 800b1ac:	495c      	ldr	r1, [pc, #368]	@ (800b320 <mem_malloc+0x1c0>)
 800b1ae:	485d      	ldr	r0, [pc, #372]	@ (800b324 <mem_malloc+0x1c4>)
 800b1b0:	f008 fee6 	bl	8013f80 <iprintf>
 800b1b4:	e062      	b.n	800b27c <mem_malloc+0x11c>
           * take care of this).
           * -> near fit or exact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
 800b1b6:	2201      	movs	r2, #1
 800b1b8:	7102      	strb	r2, [r0, #4]
          MEM_STATS_INC_USED(used, mem->next - mem_to_ptr(mem));
 800b1ba:	4e5b      	ldr	r6, [pc, #364]	@ (800b328 <mem_malloc+0x1c8>)
 800b1bc:	f8b6 20cc 	ldrh.w	r2, [r6, #204]	@ 0xcc
 800b1c0:	4413      	add	r3, r2
 800b1c2:	b29d      	uxth	r5, r3
 800b1c4:	f7ff fd30 	bl	800ac28 <mem_to_ptr>
 800b1c8:	1a2b      	subs	r3, r5, r0
 800b1ca:	b29b      	uxth	r3, r3
 800b1cc:	f8a6 30cc 	strh.w	r3, [r6, #204]	@ 0xcc
 800b1d0:	f8b6 20ce 	ldrh.w	r2, [r6, #206]	@ 0xce
 800b1d4:	4293      	cmp	r3, r2
 800b1d6:	d973      	bls.n	800b2c0 <mem_malloc+0x160>
 800b1d8:	f8a6 30ce 	strh.w	r3, [r6, #206]	@ 0xce
 800b1dc:	e070      	b.n	800b2c0 <mem_malloc+0x160>
              /* If mem_free or mem_trim have run, we have to restart since they
                 could have altered our current struct mem or lfree. */
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = ptr_to_mem(cur->next);
 800b1de:	8800      	ldrh	r0, [r0, #0]
 800b1e0:	f7ff fd1c 	bl	800ac1c <ptr_to_mem>
          while (cur->used && cur != ram_end) {
 800b1e4:	7903      	ldrb	r3, [r0, #4]
 800b1e6:	b11b      	cbz	r3, 800b1f0 <mem_malloc+0x90>
 800b1e8:	4a50      	ldr	r2, [pc, #320]	@ (800b32c <mem_malloc+0x1cc>)
 800b1ea:	6812      	ldr	r2, [r2, #0]
 800b1ec:	4282      	cmp	r2, r0
 800b1ee:	d1f6      	bne.n	800b1de <mem_malloc+0x7e>
          }
          lfree = cur;
 800b1f0:	4a49      	ldr	r2, [pc, #292]	@ (800b318 <mem_malloc+0x1b8>)
 800b1f2:	6010      	str	r0, [r2, #0]
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
 800b1f4:	4a4d      	ldr	r2, [pc, #308]	@ (800b32c <mem_malloc+0x1cc>)
 800b1f6:	6812      	ldr	r2, [r2, #0]
 800b1f8:	4282      	cmp	r2, r0
 800b1fa:	d065      	beq.n	800b2c8 <mem_malloc+0x168>
 800b1fc:	2b00      	cmp	r3, #0
 800b1fe:	d063      	beq.n	800b2c8 <mem_malloc+0x168>
 800b200:	4b46      	ldr	r3, [pc, #280]	@ (800b31c <mem_malloc+0x1bc>)
 800b202:	f240 32b5 	movw	r2, #949	@ 0x3b5
 800b206:	494a      	ldr	r1, [pc, #296]	@ (800b330 <mem_malloc+0x1d0>)
 800b208:	4846      	ldr	r0, [pc, #280]	@ (800b324 <mem_malloc+0x1c4>)
 800b20a:	f008 feb9 	bl	8013f80 <iprintf>
 800b20e:	e05b      	b.n	800b2c8 <mem_malloc+0x168>
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
 800b210:	4b42      	ldr	r3, [pc, #264]	@ (800b31c <mem_malloc+0x1bc>)
 800b212:	f240 32b9 	movw	r2, #953	@ 0x3b9
 800b216:	4947      	ldr	r1, [pc, #284]	@ (800b334 <mem_malloc+0x1d4>)
 800b218:	4842      	ldr	r0, [pc, #264]	@ (800b324 <mem_malloc+0x1c4>)
 800b21a:	f008 feb1 	bl	8013f80 <iprintf>
 800b21e:	e05d      	b.n	800b2dc <mem_malloc+0x17c>
                    (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
 800b220:	4b3e      	ldr	r3, [pc, #248]	@ (800b31c <mem_malloc+0x1bc>)
 800b222:	f240 32bb 	movw	r2, #955	@ 0x3bb
 800b226:	4944      	ldr	r1, [pc, #272]	@ (800b338 <mem_malloc+0x1d8>)
 800b228:	483e      	ldr	r0, [pc, #248]	@ (800b324 <mem_malloc+0x1c4>)
 800b22a:	f008 fea9 	bl	8013f80 <iprintf>
 800b22e:	e058      	b.n	800b2e2 <mem_malloc+0x182>
                    ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
 800b230:	4b3a      	ldr	r3, [pc, #232]	@ (800b31c <mem_malloc+0x1bc>)
 800b232:	f240 32bd 	movw	r2, #957	@ 0x3bd
 800b236:	4941      	ldr	r1, [pc, #260]	@ (800b33c <mem_malloc+0x1dc>)
 800b238:	483a      	ldr	r0, [pc, #232]	@ (800b324 <mem_malloc+0x1c4>)
 800b23a:	f008 fea1 	bl	8013f80 <iprintf>
 800b23e:	e052      	b.n	800b2e6 <mem_malloc+0x186>
         ptr = ptr_to_mem(ptr)->next) {
 800b240:	8825      	ldrh	r5, [r4, #0]
    for (ptr = mem_to_ptr(lfree); ptr < MEM_SIZE_ALIGNED - size;
 800b242:	462e      	mov	r6, r5
 800b244:	46b8      	mov	r8, r7
 800b246:	f5c7 43c0 	rsb	r3, r7, #24576	@ 0x6000
 800b24a:	429d      	cmp	r5, r3
 800b24c:	d24e      	bcs.n	800b2ec <mem_malloc+0x18c>
      mem = ptr_to_mem(ptr);
 800b24e:	4628      	mov	r0, r5
 800b250:	f7ff fce4 	bl	800ac1c <ptr_to_mem>
 800b254:	4604      	mov	r4, r0
      if ((!mem->used) &&
 800b256:	7903      	ldrb	r3, [r0, #4]
 800b258:	2b00      	cmp	r3, #0
 800b25a:	d1f1      	bne.n	800b240 <mem_malloc+0xe0>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 800b25c:	8803      	ldrh	r3, [r0, #0]
 800b25e:	1b9e      	subs	r6, r3, r6
 800b260:	3e08      	subs	r6, #8
      if ((!mem->used) &&
 800b262:	4546      	cmp	r6, r8
 800b264:	d3ec      	bcc.n	800b240 <mem_malloc+0xe0>
        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
 800b266:	f108 0214 	add.w	r2, r8, #20
 800b26a:	4296      	cmp	r6, r2
 800b26c:	d3a3      	bcc.n	800b1b6 <mem_malloc+0x56>
          ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + size);
 800b26e:	19ee      	adds	r6, r5, r7
 800b270:	b2b6      	uxth	r6, r6
 800b272:	3608      	adds	r6, #8
 800b274:	b2b6      	uxth	r6, r6
          LWIP_ASSERT("invalid next ptr",ptr2 != MEM_SIZE_ALIGNED);
 800b276:	f5b6 4fc0 	cmp.w	r6, #24576	@ 0x6000
 800b27a:	d094      	beq.n	800b1a6 <mem_malloc+0x46>
          mem2 = ptr_to_mem(ptr2);
 800b27c:	4630      	mov	r0, r6
 800b27e:	f7ff fccd 	bl	800ac1c <ptr_to_mem>
          mem2->used = 0;
 800b282:	2300      	movs	r3, #0
 800b284:	7103      	strb	r3, [r0, #4]
          mem2->next = mem->next;
 800b286:	8823      	ldrh	r3, [r4, #0]
 800b288:	8003      	strh	r3, [r0, #0]
          mem2->prev = ptr;
 800b28a:	8045      	strh	r5, [r0, #2]
          mem->next = ptr2;
 800b28c:	8026      	strh	r6, [r4, #0]
          mem->used = 1;
 800b28e:	2301      	movs	r3, #1
 800b290:	7123      	strb	r3, [r4, #4]
          if (mem2->next != MEM_SIZE_ALIGNED) {
 800b292:	8800      	ldrh	r0, [r0, #0]
 800b294:	f5b0 4fc0 	cmp.w	r0, #24576	@ 0x6000
 800b298:	d002      	beq.n	800b2a0 <mem_malloc+0x140>
            ptr_to_mem(mem2->next)->prev = ptr2;
 800b29a:	f7ff fcbf 	bl	800ac1c <ptr_to_mem>
 800b29e:	8046      	strh	r6, [r0, #2]
          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
 800b2a0:	4a21      	ldr	r2, [pc, #132]	@ (800b328 <mem_malloc+0x1c8>)
 800b2a2:	f8b2 30cc 	ldrh.w	r3, [r2, #204]	@ 0xcc
 800b2a6:	443b      	add	r3, r7
 800b2a8:	b29b      	uxth	r3, r3
 800b2aa:	3308      	adds	r3, #8
 800b2ac:	b29b      	uxth	r3, r3
 800b2ae:	f8a2 30cc 	strh.w	r3, [r2, #204]	@ 0xcc
 800b2b2:	f8b2 20ce 	ldrh.w	r2, [r2, #206]	@ 0xce
 800b2b6:	4293      	cmp	r3, r2
 800b2b8:	d902      	bls.n	800b2c0 <mem_malloc+0x160>
 800b2ba:	4a1b      	ldr	r2, [pc, #108]	@ (800b328 <mem_malloc+0x1c8>)
 800b2bc:	f8a2 30ce 	strh.w	r3, [r2, #206]	@ 0xce
        if (mem == lfree) {
 800b2c0:	4b15      	ldr	r3, [pc, #84]	@ (800b318 <mem_malloc+0x1b8>)
 800b2c2:	6818      	ldr	r0, [r3, #0]
 800b2c4:	42a0      	cmp	r0, r4
 800b2c6:	d08d      	beq.n	800b1e4 <mem_malloc+0x84>
        sys_mutex_unlock(&mem_mutex);
 800b2c8:	4812      	ldr	r0, [pc, #72]	@ (800b314 <mem_malloc+0x1b4>)
 800b2ca:	f008 f922 	bl	8013512 <sys_mutex_unlock>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
 800b2ce:	44a0      	add	r8, r4
 800b2d0:	f108 0808 	add.w	r8, r8, #8
 800b2d4:	4b15      	ldr	r3, [pc, #84]	@ (800b32c <mem_malloc+0x1cc>)
 800b2d6:	681b      	ldr	r3, [r3, #0]
 800b2d8:	4598      	cmp	r8, r3
 800b2da:	d899      	bhi.n	800b210 <mem_malloc+0xb0>
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
 800b2dc:	f014 0503 	ands.w	r5, r4, #3
 800b2e0:	d19e      	bne.n	800b220 <mem_malloc+0xc0>
        LWIP_ASSERT("mem_malloc: sanity check alignment",
 800b2e2:	2d00      	cmp	r5, #0
 800b2e4:	d1a4      	bne.n	800b230 <mem_malloc+0xd0>

#if MEM_OVERFLOW_CHECK
        mem_overflow_init_element(mem, size_in);
#endif
        MEM_SANITY();
        return (u8_t *)mem + SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET;
 800b2e6:	f104 0008 	add.w	r0, r4, #8
 800b2ea:	e00d      	b.n	800b308 <mem_malloc+0x1a8>
    }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
    /* if we got interrupted by a mem_free, try again */
  } while (local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  MEM_STATS_INC(err);
 800b2ec:	4a0e      	ldr	r2, [pc, #56]	@ (800b328 <mem_malloc+0x1c8>)
 800b2ee:	f8b2 30c8 	ldrh.w	r3, [r2, #200]	@ 0xc8
 800b2f2:	3301      	adds	r3, #1
 800b2f4:	f8a2 30c8 	strh.w	r3, [r2, #200]	@ 0xc8
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
 800b2f8:	4806      	ldr	r0, [pc, #24]	@ (800b314 <mem_malloc+0x1b4>)
 800b2fa:	f008 f90a 	bl	8013512 <sys_mutex_unlock>
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
 800b2fe:	b239      	sxth	r1, r7
 800b300:	480f      	ldr	r0, [pc, #60]	@ (800b340 <mem_malloc+0x1e0>)
 800b302:	f008 fe3d 	bl	8013f80 <iprintf>
  return NULL;
 800b306:	2000      	movs	r0, #0
}
 800b308:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return NULL;
 800b30c:	2000      	movs	r0, #0
}
 800b30e:	4770      	bx	lr
    return NULL;
 800b310:	2000      	movs	r0, #0
 800b312:	e7f9      	b.n	800b308 <mem_malloc+0x1a8>
 800b314:	2400c4cc 	.word	0x2400c4cc
 800b318:	2400c4c8 	.word	0x2400c4c8
 800b31c:	08016070 	.word	0x08016070
 800b320:	080162a4 	.word	0x080162a4
 800b324:	08015744 	.word	0x08015744
 800b328:	240141b4 	.word	0x240141b4
 800b32c:	2400c4d0 	.word	0x2400c4d0
 800b330:	080162b8 	.word	0x080162b8
 800b334:	080162d4 	.word	0x080162d4
 800b338:	08016304 	.word	0x08016304
 800b33c:	08016334 	.word	0x08016334
 800b340:	08016358 	.word	0x08016358

0800b344 <do_memp_malloc_pool>:
#if !MEMP_OVERFLOW_CHECK
do_memp_malloc_pool(const struct memp_desc *desc)
#else
do_memp_malloc_pool_fn(const struct memp_desc *desc, const char *file, const int line)
#endif
{
 800b344:	b570      	push	{r4, r5, r6, lr}
 800b346:	4604      	mov	r4, r0

#if MEMP_MEM_MALLOC
  memp = (struct memp *)mem_malloc(MEMP_SIZE + MEMP_ALIGN_SIZE(desc->size));
  SYS_ARCH_PROTECT(old_level);
#else /* MEMP_MEM_MALLOC */
  SYS_ARCH_PROTECT(old_level);
 800b348:	f008 f900 	bl	801354c <sys_arch_protect>
 800b34c:	4606      	mov	r6, r0

  memp = *desc->tab;
 800b34e:	6923      	ldr	r3, [r4, #16]
 800b350:	681d      	ldr	r5, [r3, #0]
#endif /* MEMP_MEM_MALLOC */

  if (memp != NULL) {
 800b352:	b1dd      	cbz	r5, 800b38c <do_memp_malloc_pool+0x48>
#if !MEMP_MEM_MALLOC
#if MEMP_OVERFLOW_CHECK == 1
    memp_overflow_check_element(memp, desc);
#endif /* MEMP_OVERFLOW_CHECK */

    *desc->tab = memp->next;
 800b354:	682a      	ldr	r2, [r5, #0]
 800b356:	601a      	str	r2, [r3, #0]
    memp->line = line;
#if MEMP_MEM_MALLOC
    memp_overflow_init_element(memp, desc);
#endif /* MEMP_MEM_MALLOC */
#endif /* MEMP_OVERFLOW_CHECK */
    LWIP_ASSERT("memp_malloc: memp properly aligned",
 800b358:	f015 0f03 	tst.w	r5, #3
 800b35c:	d10e      	bne.n	800b37c <do_memp_malloc_pool+0x38>
                ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
#if MEMP_STATS
    desc->stats->used++;
 800b35e:	6862      	ldr	r2, [r4, #4]
 800b360:	8913      	ldrh	r3, [r2, #8]
 800b362:	3301      	adds	r3, #1
 800b364:	8113      	strh	r3, [r2, #8]
    if (desc->stats->used > desc->stats->max) {
 800b366:	6863      	ldr	r3, [r4, #4]
 800b368:	891a      	ldrh	r2, [r3, #8]
 800b36a:	8959      	ldrh	r1, [r3, #10]
 800b36c:	428a      	cmp	r2, r1
 800b36e:	d900      	bls.n	800b372 <do_memp_malloc_pool+0x2e>
      desc->stats->max = desc->stats->used;
 800b370:	815a      	strh	r2, [r3, #10]
    }
#endif
    SYS_ARCH_UNPROTECT(old_level);
 800b372:	4630      	mov	r0, r6
 800b374:	f008 f8f6 	bl	8013564 <sys_arch_unprotect>
    SYS_ARCH_UNPROTECT(old_level);
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", desc->desc));
  }

  return NULL;
}
 800b378:	4628      	mov	r0, r5
 800b37a:	bd70      	pop	{r4, r5, r6, pc}
    LWIP_ASSERT("memp_malloc: memp properly aligned",
 800b37c:	4b09      	ldr	r3, [pc, #36]	@ (800b3a4 <do_memp_malloc_pool+0x60>)
 800b37e:	f44f 728c 	mov.w	r2, #280	@ 0x118
 800b382:	4909      	ldr	r1, [pc, #36]	@ (800b3a8 <do_memp_malloc_pool+0x64>)
 800b384:	4809      	ldr	r0, [pc, #36]	@ (800b3ac <do_memp_malloc_pool+0x68>)
 800b386:	f008 fdfb 	bl	8013f80 <iprintf>
 800b38a:	e7e8      	b.n	800b35e <do_memp_malloc_pool+0x1a>
    desc->stats->err++;
 800b38c:	6862      	ldr	r2, [r4, #4]
 800b38e:	8893      	ldrh	r3, [r2, #4]
 800b390:	3301      	adds	r3, #1
 800b392:	8093      	strh	r3, [r2, #4]
    SYS_ARCH_UNPROTECT(old_level);
 800b394:	f008 f8e6 	bl	8013564 <sys_arch_unprotect>
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", desc->desc));
 800b398:	6821      	ldr	r1, [r4, #0]
 800b39a:	4805      	ldr	r0, [pc, #20]	@ (800b3b0 <do_memp_malloc_pool+0x6c>)
 800b39c:	f008 fdf0 	bl	8013f80 <iprintf>
  return NULL;
 800b3a0:	e7ea      	b.n	800b378 <do_memp_malloc_pool+0x34>
 800b3a2:	bf00      	nop
 800b3a4:	08016384 	.word	0x08016384
 800b3a8:	080163b4 	.word	0x080163b4
 800b3ac:	08015744 	.word	0x08015744
 800b3b0:	080163d8 	.word	0x080163d8

0800b3b4 <do_memp_free_pool>:
  return memp;
}

static void
do_memp_free_pool(const struct memp_desc *desc, void *mem)
{
 800b3b4:	b538      	push	{r3, r4, r5, lr}
 800b3b6:	4605      	mov	r5, r0
 800b3b8:	460c      	mov	r4, r1
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  LWIP_ASSERT("memp_free: mem properly aligned",
 800b3ba:	f011 0f03 	tst.w	r1, #3
 800b3be:	d10d      	bne.n	800b3dc <do_memp_free_pool+0x28>
              ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  /* cast through void* to get rid of alignment warnings */
  memp = (struct memp *)(void *)((u8_t *)mem - MEMP_SIZE);

  SYS_ARCH_PROTECT(old_level);
 800b3c0:	f008 f8c4 	bl	801354c <sys_arch_protect>
#if MEMP_OVERFLOW_CHECK == 1
  memp_overflow_check_element(memp, desc);
#endif /* MEMP_OVERFLOW_CHECK */

#if MEMP_STATS
  desc->stats->used--;
 800b3c4:	686a      	ldr	r2, [r5, #4]
 800b3c6:	8913      	ldrh	r3, [r2, #8]
 800b3c8:	3b01      	subs	r3, #1
 800b3ca:	8113      	strh	r3, [r2, #8]
#if MEMP_MEM_MALLOC
  LWIP_UNUSED_ARG(desc);
  SYS_ARCH_UNPROTECT(old_level);
  mem_free(memp);
#else /* MEMP_MEM_MALLOC */
  memp->next = *desc->tab;
 800b3cc:	692b      	ldr	r3, [r5, #16]
 800b3ce:	681b      	ldr	r3, [r3, #0]
 800b3d0:	6023      	str	r3, [r4, #0]
  *desc->tab = memp;
 800b3d2:	692b      	ldr	r3, [r5, #16]
 800b3d4:	601c      	str	r4, [r3, #0]

#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity(desc));
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
 800b3d6:	f008 f8c5 	bl	8013564 <sys_arch_unprotect>
#endif /* !MEMP_MEM_MALLOC */
}
 800b3da:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("memp_free: mem properly aligned",
 800b3dc:	4b03      	ldr	r3, [pc, #12]	@ (800b3ec <do_memp_free_pool+0x38>)
 800b3de:	f44f 72b6 	mov.w	r2, #364	@ 0x16c
 800b3e2:	4903      	ldr	r1, [pc, #12]	@ (800b3f0 <do_memp_free_pool+0x3c>)
 800b3e4:	4803      	ldr	r0, [pc, #12]	@ (800b3f4 <do_memp_free_pool+0x40>)
 800b3e6:	f008 fdcb 	bl	8013f80 <iprintf>
 800b3ea:	e7e9      	b.n	800b3c0 <do_memp_free_pool+0xc>
 800b3ec:	08016384 	.word	0x08016384
 800b3f0:	08016400 	.word	0x08016400
 800b3f4:	08015744 	.word	0x08015744

0800b3f8 <memp_init_pool>:
  *desc->tab = NULL;
 800b3f8:	6903      	ldr	r3, [r0, #16]
 800b3fa:	2200      	movs	r2, #0
 800b3fc:	601a      	str	r2, [r3, #0]
  memp = (struct memp *)LWIP_MEM_ALIGN(desc->base);
 800b3fe:	68c3      	ldr	r3, [r0, #12]
 800b400:	3303      	adds	r3, #3
 800b402:	f023 0303 	bic.w	r3, r3, #3
  for (i = 0; i < desc->num; ++i) {
 800b406:	e007      	b.n	800b418 <memp_init_pool+0x20>
    memp->next = *desc->tab;
 800b408:	6901      	ldr	r1, [r0, #16]
 800b40a:	6809      	ldr	r1, [r1, #0]
 800b40c:	6019      	str	r1, [r3, #0]
    *desc->tab = memp;
 800b40e:	6901      	ldr	r1, [r0, #16]
 800b410:	600b      	str	r3, [r1, #0]
    memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + desc->size
 800b412:	8901      	ldrh	r1, [r0, #8]
 800b414:	440b      	add	r3, r1
  for (i = 0; i < desc->num; ++i) {
 800b416:	3201      	adds	r2, #1
 800b418:	8941      	ldrh	r1, [r0, #10]
 800b41a:	4291      	cmp	r1, r2
 800b41c:	dcf4      	bgt.n	800b408 <memp_init_pool+0x10>
  desc->stats->avail = desc->num;
 800b41e:	6843      	ldr	r3, [r0, #4]
 800b420:	80d9      	strh	r1, [r3, #6]
  desc->stats->name  = desc->desc;
 800b422:	6843      	ldr	r3, [r0, #4]
 800b424:	6802      	ldr	r2, [r0, #0]
 800b426:	601a      	str	r2, [r3, #0]
}
 800b428:	4770      	bx	lr
	...

0800b42c <memp_init>:
{
 800b42c:	b538      	push	{r3, r4, r5, lr}
  for (i = 0; i < LWIP_ARRAYSIZE(memp_pools); i++) {
 800b42e:	2400      	movs	r4, #0
 800b430:	e00e      	b.n	800b450 <memp_init+0x24>
    memp_init_pool(memp_pools[i]);
 800b432:	4b09      	ldr	r3, [pc, #36]	@ (800b458 <memp_init+0x2c>)
 800b434:	f853 5024 	ldr.w	r5, [r3, r4, lsl #2]
 800b438:	4628      	mov	r0, r5
 800b43a:	f7ff ffdd 	bl	800b3f8 <memp_init_pool>
    lwip_stats.memp[i] = memp_pools[i]->stats;
 800b43e:	686a      	ldr	r2, [r5, #4]
 800b440:	f104 0134 	add.w	r1, r4, #52	@ 0x34
 800b444:	4b05      	ldr	r3, [pc, #20]	@ (800b45c <memp_init+0x30>)
 800b446:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 800b44a:	605a      	str	r2, [r3, #4]
  for (i = 0; i < LWIP_ARRAYSIZE(memp_pools); i++) {
 800b44c:	3401      	adds	r4, #1
 800b44e:	b2a4      	uxth	r4, r4
 800b450:	2c0d      	cmp	r4, #13
 800b452:	d9ee      	bls.n	800b432 <memp_init+0x6>
}
 800b454:	bd38      	pop	{r3, r4, r5, pc}
 800b456:	bf00      	nop
 800b458:	08018e24 	.word	0x08018e24
 800b45c:	240141b4 	.word	0x240141b4

0800b460 <memp_malloc_pool>:
{
 800b460:	b510      	push	{r4, lr}
  LWIP_ASSERT("invalid pool desc", desc != NULL);
 800b462:	4604      	mov	r4, r0
 800b464:	b110      	cbz	r0, 800b46c <memp_malloc_pool+0xc>
  return do_memp_malloc_pool(desc);
 800b466:	f7ff ff6d 	bl	800b344 <do_memp_malloc_pool>
}
 800b46a:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("invalid pool desc", desc != NULL);
 800b46c:	4b04      	ldr	r3, [pc, #16]	@ (800b480 <memp_malloc_pool+0x20>)
 800b46e:	f44f 729e 	mov.w	r2, #316	@ 0x13c
 800b472:	4904      	ldr	r1, [pc, #16]	@ (800b484 <memp_malloc_pool+0x24>)
 800b474:	4804      	ldr	r0, [pc, #16]	@ (800b488 <memp_malloc_pool+0x28>)
 800b476:	f008 fd83 	bl	8013f80 <iprintf>
    return NULL;
 800b47a:	4620      	mov	r0, r4
 800b47c:	e7f5      	b.n	800b46a <memp_malloc_pool+0xa>
 800b47e:	bf00      	nop
 800b480:	08016384 	.word	0x08016384
 800b484:	08016420 	.word	0x08016420
 800b488:	08015744 	.word	0x08015744

0800b48c <memp_malloc>:
{
 800b48c:	b508      	push	{r3, lr}
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 800b48e:	280d      	cmp	r0, #13
 800b490:	d805      	bhi.n	800b49e <memp_malloc+0x12>
  memp = do_memp_malloc_pool(memp_pools[type]);
 800b492:	4b07      	ldr	r3, [pc, #28]	@ (800b4b0 <memp_malloc+0x24>)
 800b494:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 800b498:	f7ff ff54 	bl	800b344 <do_memp_malloc_pool>
}
 800b49c:	bd08      	pop	{r3, pc}
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 800b49e:	4b05      	ldr	r3, [pc, #20]	@ (800b4b4 <memp_malloc+0x28>)
 800b4a0:	f240 1257 	movw	r2, #343	@ 0x157
 800b4a4:	4904      	ldr	r1, [pc, #16]	@ (800b4b8 <memp_malloc+0x2c>)
 800b4a6:	4805      	ldr	r0, [pc, #20]	@ (800b4bc <memp_malloc+0x30>)
 800b4a8:	f008 fd6a 	bl	8013f80 <iprintf>
 800b4ac:	2000      	movs	r0, #0
 800b4ae:	e7f5      	b.n	800b49c <memp_malloc+0x10>
 800b4b0:	08018e24 	.word	0x08018e24
 800b4b4:	08016384 	.word	0x08016384
 800b4b8:	08016434 	.word	0x08016434
 800b4bc:	08015744 	.word	0x08015744

0800b4c0 <memp_free_pool>:
 * @param desc the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free_pool(const struct memp_desc *desc, void *mem)
{
 800b4c0:	b538      	push	{r3, r4, r5, lr}
 800b4c2:	460c      	mov	r4, r1
  LWIP_ASSERT("invalid pool desc", desc != NULL);
 800b4c4:	4605      	mov	r5, r0
 800b4c6:	b120      	cbz	r0, 800b4d2 <memp_free_pool+0x12>
  if ((desc == NULL) || (mem == NULL)) {
 800b4c8:	2c00      	cmp	r4, #0
 800b4ca:	bf18      	it	ne
 800b4cc:	2d00      	cmpne	r5, #0
 800b4ce:	d108      	bne.n	800b4e2 <memp_free_pool+0x22>
    return;
  }

  do_memp_free_pool(desc, mem);
}
 800b4d0:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("invalid pool desc", desc != NULL);
 800b4d2:	4b06      	ldr	r3, [pc, #24]	@ (800b4ec <memp_free_pool+0x2c>)
 800b4d4:	f240 1295 	movw	r2, #405	@ 0x195
 800b4d8:	4905      	ldr	r1, [pc, #20]	@ (800b4f0 <memp_free_pool+0x30>)
 800b4da:	4806      	ldr	r0, [pc, #24]	@ (800b4f4 <memp_free_pool+0x34>)
 800b4dc:	f008 fd50 	bl	8013f80 <iprintf>
 800b4e0:	e7f2      	b.n	800b4c8 <memp_free_pool+0x8>
  do_memp_free_pool(desc, mem);
 800b4e2:	4621      	mov	r1, r4
 800b4e4:	4628      	mov	r0, r5
 800b4e6:	f7ff ff65 	bl	800b3b4 <do_memp_free_pool>
 800b4ea:	e7f1      	b.n	800b4d0 <memp_free_pool+0x10>
 800b4ec:	08016384 	.word	0x08016384
 800b4f0:	08016420 	.word	0x08016420
 800b4f4:	08015744 	.word	0x08015744

0800b4f8 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
 800b4f8:	b508      	push	{r3, lr}
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  struct memp *old_first;
#endif

  LWIP_ERROR("memp_free: type < MEMP_MAX", (type < MEMP_MAX), return;);
 800b4fa:	280d      	cmp	r0, #13
 800b4fc:	d806      	bhi.n	800b50c <memp_free+0x14>

  if (mem == NULL) {
 800b4fe:	b121      	cbz	r1, 800b50a <memp_free+0x12>

#ifdef LWIP_HOOK_MEMP_AVAILABLE
  old_first = *memp_pools[type]->tab;
#endif

  do_memp_free_pool(memp_pools[type], mem);
 800b500:	4b06      	ldr	r3, [pc, #24]	@ (800b51c <memp_free+0x24>)
 800b502:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 800b506:	f7ff ff55 	bl	800b3b4 <do_memp_free_pool>
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  if (old_first == NULL) {
    LWIP_HOOK_MEMP_AVAILABLE(type);
  }
#endif
}
 800b50a:	bd08      	pop	{r3, pc}
  LWIP_ERROR("memp_free: type < MEMP_MAX", (type < MEMP_MAX), return;);
 800b50c:	4b04      	ldr	r3, [pc, #16]	@ (800b520 <memp_free+0x28>)
 800b50e:	f44f 72d5 	mov.w	r2, #426	@ 0x1aa
 800b512:	4904      	ldr	r1, [pc, #16]	@ (800b524 <memp_free+0x2c>)
 800b514:	4804      	ldr	r0, [pc, #16]	@ (800b528 <memp_free+0x30>)
 800b516:	f008 fd33 	bl	8013f80 <iprintf>
 800b51a:	e7f6      	b.n	800b50a <memp_free+0x12>
 800b51c:	08018e24 	.word	0x08018e24
 800b520:	08016384 	.word	0x08016384
 800b524:	08016454 	.word	0x08016454
 800b528:	08015744 	.word	0x08015744

0800b52c <netif_do_set_netmask>:

static int
netif_do_set_netmask(struct netif *netif, const ip4_addr_t *netmask, ip_addr_t *old_nm)
{
  /* address is actually being changed? */
  if (ip4_addr_cmp(netmask, netif_ip4_netmask(netif)) == 0) {
 800b52c:	680b      	ldr	r3, [r1, #0]
 800b52e:	6882      	ldr	r2, [r0, #8]
 800b530:	4293      	cmp	r3, r2
 800b532:	d002      	beq.n	800b53a <netif_do_set_netmask+0xe>
#else
    LWIP_UNUSED_ARG(old_nm);
#endif
    mib2_remove_route_ip4(0, netif);
    /* set new netmask to netif */
    ip4_addr_set(ip_2_ip4(&netif->netmask), netmask);
 800b534:	6083      	str	r3, [r0, #8]
                netif->name[0], netif->name[1],
                ip4_addr1_16(netif_ip4_netmask(netif)),
                ip4_addr2_16(netif_ip4_netmask(netif)),
                ip4_addr3_16(netif_ip4_netmask(netif)),
                ip4_addr4_16(netif_ip4_netmask(netif))));
    return 1; /* netmask changed */
 800b536:	2001      	movs	r0, #1
 800b538:	4770      	bx	lr
  }
  return 0; /* netmask unchanged */
 800b53a:	2000      	movs	r0, #0
}
 800b53c:	4770      	bx	lr

0800b53e <netif_do_set_gw>:

static int
netif_do_set_gw(struct netif *netif, const ip4_addr_t *gw, ip_addr_t *old_gw)
{
  /* address is actually being changed? */
  if (ip4_addr_cmp(gw, netif_ip4_gw(netif)) == 0) {
 800b53e:	680b      	ldr	r3, [r1, #0]
 800b540:	68c2      	ldr	r2, [r0, #12]
 800b542:	4293      	cmp	r3, r2
 800b544:	d002      	beq.n	800b54c <netif_do_set_gw+0xe>
    ip_addr_copy(*old_gw, *netif_ip_gw4(netif));
#else
    LWIP_UNUSED_ARG(old_gw);
#endif

    ip4_addr_set(ip_2_ip4(&netif->gw), gw);
 800b546:	60c3      	str	r3, [r0, #12]
                netif->name[0], netif->name[1],
                ip4_addr1_16(netif_ip4_gw(netif)),
                ip4_addr2_16(netif_ip4_gw(netif)),
                ip4_addr3_16(netif_ip4_gw(netif)),
                ip4_addr4_16(netif_ip4_gw(netif))));
    return 1; /* gateway changed */
 800b548:	2001      	movs	r0, #1
 800b54a:	4770      	bx	lr
  }
  return 0; /* gateway unchanged */
 800b54c:	2000      	movs	r0, #0
}
 800b54e:	4770      	bx	lr

0800b550 <netif_null_output_ip4>:
  LWIP_UNUSED_ARG(netif);
  LWIP_UNUSED_ARG(p);
  LWIP_UNUSED_ARG(ipaddr);

  return ERR_IF;
}
 800b550:	f06f 000b 	mvn.w	r0, #11
 800b554:	4770      	bx	lr

0800b556 <netif_do_ip_addr_changed>:
{
 800b556:	b538      	push	{r3, r4, r5, lr}
 800b558:	4604      	mov	r4, r0
 800b55a:	460d      	mov	r5, r1
  tcp_netif_ip_addr_changed(old_addr, new_addr);
 800b55c:	f001 fac2 	bl	800cae4 <tcp_netif_ip_addr_changed>
  udp_netif_ip_addr_changed(old_addr, new_addr);
 800b560:	4629      	mov	r1, r5
 800b562:	4620      	mov	r0, r4
 800b564:	f005 fc06 	bl	8010d74 <udp_netif_ip_addr_changed>
}
 800b568:	bd38      	pop	{r3, r4, r5, pc}
	...

0800b56c <netif_issue_reports>:
{
 800b56c:	b538      	push	{r3, r4, r5, lr}
 800b56e:	460c      	mov	r4, r1
  LWIP_ASSERT("netif_issue_reports: invalid netif", netif != NULL);
 800b570:	4605      	mov	r5, r0
 800b572:	b198      	cbz	r0, 800b59c <netif_issue_reports+0x30>
  if (!(netif->flags & NETIF_FLAG_LINK_UP) ||
 800b574:	f895 302d 	ldrb.w	r3, [r5, #45]	@ 0x2d
 800b578:	f003 0205 	and.w	r2, r3, #5
 800b57c:	2a05      	cmp	r2, #5
 800b57e:	d10c      	bne.n	800b59a <netif_issue_reports+0x2e>
  if ((report_type & NETIF_REPORT_TYPE_IPV4) &&
 800b580:	f014 0f01 	tst.w	r4, #1
 800b584:	d009      	beq.n	800b59a <netif_issue_reports+0x2e>
      !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 800b586:	686a      	ldr	r2, [r5, #4]
  if ((report_type & NETIF_REPORT_TYPE_IPV4) &&
 800b588:	b13a      	cbz	r2, 800b59a <netif_issue_reports+0x2e>
    if (netif->flags & (NETIF_FLAG_ETHARP)) {
 800b58a:	f013 0f08 	tst.w	r3, #8
 800b58e:	d10d      	bne.n	800b5ac <netif_issue_reports+0x40>
    if (netif->flags & NETIF_FLAG_IGMP) {
 800b590:	f895 302d 	ldrb.w	r3, [r5, #45]	@ 0x2d
 800b594:	f013 0f20 	tst.w	r3, #32
 800b598:	d10d      	bne.n	800b5b6 <netif_issue_reports+0x4a>
}
 800b59a:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("netif_issue_reports: invalid netif", netif != NULL);
 800b59c:	4b08      	ldr	r3, [pc, #32]	@ (800b5c0 <netif_issue_reports+0x54>)
 800b59e:	f240 326d 	movw	r2, #877	@ 0x36d
 800b5a2:	4908      	ldr	r1, [pc, #32]	@ (800b5c4 <netif_issue_reports+0x58>)
 800b5a4:	4808      	ldr	r0, [pc, #32]	@ (800b5c8 <netif_issue_reports+0x5c>)
 800b5a6:	f008 fceb 	bl	8013f80 <iprintf>
 800b5aa:	e7e3      	b.n	800b574 <netif_issue_reports+0x8>
      etharp_gratuitous(netif);
 800b5ac:	1d29      	adds	r1, r5, #4
 800b5ae:	4628      	mov	r0, r5
 800b5b0:	f006 f808 	bl	80115c4 <etharp_request>
 800b5b4:	e7ec      	b.n	800b590 <netif_issue_reports+0x24>
      igmp_report_groups(netif);
 800b5b6:	4628      	mov	r0, r5
 800b5b8:	f006 fc6c 	bl	8011e94 <igmp_report_groups>
 800b5bc:	e7ed      	b.n	800b59a <netif_issue_reports+0x2e>
 800b5be:	bf00      	nop
 800b5c0:	08016514 	.word	0x08016514
 800b5c4:	08016548 	.word	0x08016548
 800b5c8:	08015744 	.word	0x08015744

0800b5cc <netif_do_set_ipaddr>:
{
 800b5cc:	b570      	push	{r4, r5, r6, lr}
 800b5ce:	b082      	sub	sp, #8
 800b5d0:	4604      	mov	r4, r0
 800b5d2:	4615      	mov	r5, r2
  LWIP_ASSERT("invalid pointer", ipaddr != NULL);
 800b5d4:	460e      	mov	r6, r1
 800b5d6:	b139      	cbz	r1, 800b5e8 <netif_do_set_ipaddr+0x1c>
  LWIP_ASSERT("invalid pointer", old_addr != NULL);
 800b5d8:	b175      	cbz	r5, 800b5f8 <netif_do_set_ipaddr+0x2c>
  if (ip4_addr_cmp(ipaddr, netif_ip4_addr(netif)) == 0) {
 800b5da:	6832      	ldr	r2, [r6, #0]
 800b5dc:	6863      	ldr	r3, [r4, #4]
 800b5de:	429a      	cmp	r2, r3
 800b5e0:	d112      	bne.n	800b608 <netif_do_set_ipaddr+0x3c>
  return 0; /* address unchanged */
 800b5e2:	2000      	movs	r0, #0
}
 800b5e4:	b002      	add	sp, #8
 800b5e6:	bd70      	pop	{r4, r5, r6, pc}
  LWIP_ASSERT("invalid pointer", ipaddr != NULL);
 800b5e8:	4b10      	ldr	r3, [pc, #64]	@ (800b62c <netif_do_set_ipaddr+0x60>)
 800b5ea:	f240 12cb 	movw	r2, #459	@ 0x1cb
 800b5ee:	4910      	ldr	r1, [pc, #64]	@ (800b630 <netif_do_set_ipaddr+0x64>)
 800b5f0:	4810      	ldr	r0, [pc, #64]	@ (800b634 <netif_do_set_ipaddr+0x68>)
 800b5f2:	f008 fcc5 	bl	8013f80 <iprintf>
 800b5f6:	e7ef      	b.n	800b5d8 <netif_do_set_ipaddr+0xc>
  LWIP_ASSERT("invalid pointer", old_addr != NULL);
 800b5f8:	4b0c      	ldr	r3, [pc, #48]	@ (800b62c <netif_do_set_ipaddr+0x60>)
 800b5fa:	f44f 72e6 	mov.w	r2, #460	@ 0x1cc
 800b5fe:	490c      	ldr	r1, [pc, #48]	@ (800b630 <netif_do_set_ipaddr+0x64>)
 800b600:	480c      	ldr	r0, [pc, #48]	@ (800b634 <netif_do_set_ipaddr+0x68>)
 800b602:	f008 fcbd 	bl	8013f80 <iprintf>
 800b606:	e7e8      	b.n	800b5da <netif_do_set_ipaddr+0xe>
    *ip_2_ip4(&new_addr) = *ipaddr;
 800b608:	9201      	str	r2, [sp, #4]
    ip_addr_copy(*old_addr, *netif_ip_addr4(netif));
 800b60a:	602b      	str	r3, [r5, #0]
    netif_do_ip_addr_changed(old_addr, &new_addr);
 800b60c:	a901      	add	r1, sp, #4
 800b60e:	4628      	mov	r0, r5
 800b610:	f7ff ffa1 	bl	800b556 <netif_do_ip_addr_changed>
    ip4_addr_set(ip_2_ip4(&netif->ip_addr), ipaddr);
 800b614:	b13e      	cbz	r6, 800b626 <netif_do_set_ipaddr+0x5a>
 800b616:	6833      	ldr	r3, [r6, #0]
 800b618:	6063      	str	r3, [r4, #4]
    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4);
 800b61a:	2101      	movs	r1, #1
 800b61c:	4620      	mov	r0, r4
 800b61e:	f7ff ffa5 	bl	800b56c <netif_issue_reports>
    return 1; /* address changed */
 800b622:	2001      	movs	r0, #1
 800b624:	e7de      	b.n	800b5e4 <netif_do_set_ipaddr+0x18>
    ip4_addr_set(ip_2_ip4(&netif->ip_addr), ipaddr);
 800b626:	2300      	movs	r3, #0
 800b628:	e7f6      	b.n	800b618 <netif_do_set_ipaddr+0x4c>
 800b62a:	bf00      	nop
 800b62c:	08016514 	.word	0x08016514
 800b630:	080158b4 	.word	0x080158b4
 800b634:	08015744 	.word	0x08015744

0800b638 <netif_init>:
}
 800b638:	4770      	bx	lr
	...

0800b63c <netif_set_addr>:
{
 800b63c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b640:	b082      	sub	sp, #8
 800b642:	4604      	mov	r4, r0
 800b644:	4616      	mov	r6, r2
 800b646:	461d      	mov	r5, r3
  if (ipaddr == NULL) {
 800b648:	460f      	mov	r7, r1
 800b64a:	b1d9      	cbz	r1, 800b684 <netif_set_addr+0x48>
  if (netmask == NULL) {
 800b64c:	b1e6      	cbz	r6, 800b688 <netif_set_addr+0x4c>
  if (gw == NULL) {
 800b64e:	b1ed      	cbz	r5, 800b68c <netif_set_addr+0x50>
  remove = ip4_addr_isany(ipaddr);
 800b650:	b10f      	cbz	r7, 800b656 <netif_set_addr+0x1a>
 800b652:	683b      	ldr	r3, [r7, #0]
 800b654:	b9e3      	cbnz	r3, 800b690 <netif_set_addr+0x54>
    if (netif_do_set_ipaddr(netif, ipaddr, &old_addr)) {
 800b656:	aa01      	add	r2, sp, #4
 800b658:	4639      	mov	r1, r7
 800b65a:	4620      	mov	r0, r4
 800b65c:	f7ff ffb6 	bl	800b5cc <netif_do_set_ipaddr>
 800b660:	f04f 0801 	mov.w	r8, #1
  if (netif_do_set_netmask(netif, netmask, old_nm)) {
 800b664:	2200      	movs	r2, #0
 800b666:	4631      	mov	r1, r6
 800b668:	4620      	mov	r0, r4
 800b66a:	f7ff ff5f 	bl	800b52c <netif_do_set_netmask>
  if (netif_do_set_gw(netif, gw, old_gw)) {
 800b66e:	2200      	movs	r2, #0
 800b670:	4629      	mov	r1, r5
 800b672:	4620      	mov	r0, r4
 800b674:	f7ff ff63 	bl	800b53e <netif_do_set_gw>
  if (!remove) {
 800b678:	f1b8 0f00 	cmp.w	r8, #0
 800b67c:	d00b      	beq.n	800b696 <netif_set_addr+0x5a>
}
 800b67e:	b002      	add	sp, #8
 800b680:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ipaddr = IP4_ADDR_ANY4;
 800b684:	4f07      	ldr	r7, [pc, #28]	@ (800b6a4 <netif_set_addr+0x68>)
 800b686:	e7e1      	b.n	800b64c <netif_set_addr+0x10>
    netmask = IP4_ADDR_ANY4;
 800b688:	4e06      	ldr	r6, [pc, #24]	@ (800b6a4 <netif_set_addr+0x68>)
 800b68a:	e7e0      	b.n	800b64e <netif_set_addr+0x12>
    gw = IP4_ADDR_ANY4;
 800b68c:	4d05      	ldr	r5, [pc, #20]	@ (800b6a4 <netif_set_addr+0x68>)
 800b68e:	e7df      	b.n	800b650 <netif_set_addr+0x14>
  remove = ip4_addr_isany(ipaddr);
 800b690:	f04f 0800 	mov.w	r8, #0
 800b694:	e7e6      	b.n	800b664 <netif_set_addr+0x28>
    if (netif_do_set_ipaddr(netif, ipaddr, &old_addr)) {
 800b696:	aa01      	add	r2, sp, #4
 800b698:	4639      	mov	r1, r7
 800b69a:	4620      	mov	r0, r4
 800b69c:	f7ff ff96 	bl	800b5cc <netif_do_set_ipaddr>
}
 800b6a0:	e7ed      	b.n	800b67e <netif_set_addr+0x42>
 800b6a2:	bf00      	nop
 800b6a4:	08018fc0 	.word	0x08018fc0

0800b6a8 <netif_add>:
{
 800b6a8:	b570      	push	{r4, r5, r6, lr}
 800b6aa:	9c05      	ldr	r4, [sp, #20]
  LWIP_ERROR("netif_add: invalid netif", netif != NULL, return NULL);
 800b6ac:	4606      	mov	r6, r0
 800b6ae:	b318      	cbz	r0, 800b6f8 <netif_add+0x50>
  LWIP_ERROR("netif_add: No init function given", init != NULL, return NULL);
 800b6b0:	2c00      	cmp	r4, #0
 800b6b2:	d029      	beq.n	800b708 <netif_add+0x60>
  if (ipaddr == NULL) {
 800b6b4:	2900      	cmp	r1, #0
 800b6b6:	d030      	beq.n	800b71a <netif_add+0x72>
  if (netmask == NULL) {
 800b6b8:	2a00      	cmp	r2, #0
 800b6ba:	d030      	beq.n	800b71e <netif_add+0x76>
  if (gw == NULL) {
 800b6bc:	2b00      	cmp	r3, #0
 800b6be:	d030      	beq.n	800b722 <netif_add+0x7a>
  ip_addr_set_zero_ip4(&netif->ip_addr);
 800b6c0:	2000      	movs	r0, #0
 800b6c2:	6070      	str	r0, [r6, #4]
  ip_addr_set_zero_ip4(&netif->netmask);
 800b6c4:	60b0      	str	r0, [r6, #8]
  ip_addr_set_zero_ip4(&netif->gw);
 800b6c6:	60f0      	str	r0, [r6, #12]
  netif->output = netif_null_output_ip4;
 800b6c8:	4d3a      	ldr	r5, [pc, #232]	@ (800b7b4 <netif_add+0x10c>)
 800b6ca:	6175      	str	r5, [r6, #20]
  netif->mtu = 0;
 800b6cc:	84b0      	strh	r0, [r6, #36]	@ 0x24
  netif->flags = 0;
 800b6ce:	f886 002d 	strb.w	r0, [r6, #45]	@ 0x2d
  memset(netif->client_data, 0, sizeof(netif->client_data));
 800b6d2:	6230      	str	r0, [r6, #32]
  netif->igmp_mac_filter = NULL;
 800b6d4:	6370      	str	r0, [r6, #52]	@ 0x34
  netif->state = state;
 800b6d6:	9804      	ldr	r0, [sp, #16]
 800b6d8:	61f0      	str	r0, [r6, #28]
  netif->num = netif_num;
 800b6da:	4837      	ldr	r0, [pc, #220]	@ (800b7b8 <netif_add+0x110>)
 800b6dc:	7800      	ldrb	r0, [r0, #0]
 800b6de:	f886 0030 	strb.w	r0, [r6, #48]	@ 0x30
  netif->input = input;
 800b6e2:	9806      	ldr	r0, [sp, #24]
 800b6e4:	6130      	str	r0, [r6, #16]
  netif_set_addr(netif, ipaddr, netmask, gw);
 800b6e6:	4630      	mov	r0, r6
 800b6e8:	f7ff ffa8 	bl	800b63c <netif_set_addr>
  if (init(netif) != ERR_OK) {
 800b6ec:	4630      	mov	r0, r6
 800b6ee:	47a0      	blx	r4
 800b6f0:	2800      	cmp	r0, #0
 800b6f2:	d03d      	beq.n	800b770 <netif_add+0xc8>
    return NULL;
 800b6f4:	2600      	movs	r6, #0
 800b6f6:	e053      	b.n	800b7a0 <netif_add+0xf8>
  LWIP_ERROR("netif_add: invalid netif", netif != NULL, return NULL);
 800b6f8:	4b30      	ldr	r3, [pc, #192]	@ (800b7bc <netif_add+0x114>)
 800b6fa:	f240 1227 	movw	r2, #295	@ 0x127
 800b6fe:	4930      	ldr	r1, [pc, #192]	@ (800b7c0 <netif_add+0x118>)
 800b700:	4830      	ldr	r0, [pc, #192]	@ (800b7c4 <netif_add+0x11c>)
 800b702:	f008 fc3d 	bl	8013f80 <iprintf>
 800b706:	e04b      	b.n	800b7a0 <netif_add+0xf8>
  LWIP_ERROR("netif_add: No init function given", init != NULL, return NULL);
 800b708:	4b2c      	ldr	r3, [pc, #176]	@ (800b7bc <netif_add+0x114>)
 800b70a:	f44f 7294 	mov.w	r2, #296	@ 0x128
 800b70e:	492e      	ldr	r1, [pc, #184]	@ (800b7c8 <netif_add+0x120>)
 800b710:	482c      	ldr	r0, [pc, #176]	@ (800b7c4 <netif_add+0x11c>)
 800b712:	f008 fc35 	bl	8013f80 <iprintf>
 800b716:	2600      	movs	r6, #0
 800b718:	e042      	b.n	800b7a0 <netif_add+0xf8>
    ipaddr = ip_2_ip4(IP4_ADDR_ANY);
 800b71a:	492c      	ldr	r1, [pc, #176]	@ (800b7cc <netif_add+0x124>)
 800b71c:	e7cc      	b.n	800b6b8 <netif_add+0x10>
    netmask = ip_2_ip4(IP4_ADDR_ANY);
 800b71e:	4a2b      	ldr	r2, [pc, #172]	@ (800b7cc <netif_add+0x124>)
 800b720:	e7cc      	b.n	800b6bc <netif_add+0x14>
    gw = ip_2_ip4(IP4_ADDR_ANY);
 800b722:	4b2a      	ldr	r3, [pc, #168]	@ (800b7cc <netif_add+0x124>)
 800b724:	e7cc      	b.n	800b6c0 <netif_add+0x18>
        netif->num = 0;
 800b726:	2300      	movs	r3, #0
 800b728:	f886 3030 	strb.w	r3, [r6, #48]	@ 0x30
 800b72c:	e024      	b.n	800b778 <netif_add+0xd0>
        LWIP_ASSERT("netif already added", netif2 != netif);
 800b72e:	4b23      	ldr	r3, [pc, #140]	@ (800b7bc <netif_add+0x114>)
 800b730:	f240 128b 	movw	r2, #395	@ 0x18b
 800b734:	4926      	ldr	r1, [pc, #152]	@ (800b7d0 <netif_add+0x128>)
 800b736:	4823      	ldr	r0, [pc, #140]	@ (800b7c4 <netif_add+0x11c>)
 800b738:	f008 fc22 	bl	8013f80 <iprintf>
 800b73c:	e009      	b.n	800b752 <netif_add+0xaa>
        if (netif2->num == netif->num) {
 800b73e:	f894 2030 	ldrb.w	r2, [r4, #48]	@ 0x30
 800b742:	f896 3030 	ldrb.w	r3, [r6, #48]	@ 0x30
 800b746:	429a      	cmp	r2, r3
 800b748:	d00e      	beq.n	800b768 <netif_add+0xc0>
      for (netif2 = netif_list; netif2 != NULL; netif2 = netif2->next) {
 800b74a:	6824      	ldr	r4, [r4, #0]
 800b74c:	b17c      	cbz	r4, 800b76e <netif_add+0xc6>
        LWIP_ASSERT("netif already added", netif2 != netif);
 800b74e:	42a6      	cmp	r6, r4
 800b750:	d0ed      	beq.n	800b72e <netif_add+0x86>
        num_netifs++;
 800b752:	3501      	adds	r5, #1
        LWIP_ASSERT("too many netifs, max. supported number is 255", num_netifs <= 255);
 800b754:	2dff      	cmp	r5, #255	@ 0xff
 800b756:	ddf2      	ble.n	800b73e <netif_add+0x96>
 800b758:	4b18      	ldr	r3, [pc, #96]	@ (800b7bc <netif_add+0x114>)
 800b75a:	f240 128d 	movw	r2, #397	@ 0x18d
 800b75e:	491d      	ldr	r1, [pc, #116]	@ (800b7d4 <netif_add+0x12c>)
 800b760:	4818      	ldr	r0, [pc, #96]	@ (800b7c4 <netif_add+0x11c>)
 800b762:	f008 fc0d 	bl	8013f80 <iprintf>
 800b766:	e7ea      	b.n	800b73e <netif_add+0x96>
          netif->num++;
 800b768:	3301      	adds	r3, #1
 800b76a:	f886 3030 	strb.w	r3, [r6, #48]	@ 0x30
    } while (netif2 != NULL);
 800b76e:	b13c      	cbz	r4, 800b780 <netif_add+0xd8>
      if (netif->num == 255) {
 800b770:	f896 3030 	ldrb.w	r3, [r6, #48]	@ 0x30
 800b774:	2bff      	cmp	r3, #255	@ 0xff
 800b776:	d0d6      	beq.n	800b726 <netif_add+0x7e>
      for (netif2 = netif_list; netif2 != NULL; netif2 = netif2->next) {
 800b778:	4b17      	ldr	r3, [pc, #92]	@ (800b7d8 <netif_add+0x130>)
 800b77a:	681c      	ldr	r4, [r3, #0]
      num_netifs = 0;
 800b77c:	2500      	movs	r5, #0
      for (netif2 = netif_list; netif2 != NULL; netif2 = netif2->next) {
 800b77e:	e7e5      	b.n	800b74c <netif_add+0xa4>
  if (netif->num == 254) {
 800b780:	f896 3030 	ldrb.w	r3, [r6, #48]	@ 0x30
 800b784:	2bfe      	cmp	r3, #254	@ 0xfe
 800b786:	d00d      	beq.n	800b7a4 <netif_add+0xfc>
    netif_num = (u8_t)(netif->num + 1);
 800b788:	3301      	adds	r3, #1
 800b78a:	4a0b      	ldr	r2, [pc, #44]	@ (800b7b8 <netif_add+0x110>)
 800b78c:	7013      	strb	r3, [r2, #0]
  netif->next = netif_list;
 800b78e:	4b12      	ldr	r3, [pc, #72]	@ (800b7d8 <netif_add+0x130>)
 800b790:	681a      	ldr	r2, [r3, #0]
 800b792:	6032      	str	r2, [r6, #0]
  netif_list = netif;
 800b794:	601e      	str	r6, [r3, #0]
  if (netif->flags & NETIF_FLAG_IGMP) {
 800b796:	f896 302d 	ldrb.w	r3, [r6, #45]	@ 0x2d
 800b79a:	f013 0f20 	tst.w	r3, #32
 800b79e:	d105      	bne.n	800b7ac <netif_add+0x104>
}
 800b7a0:	4630      	mov	r0, r6
 800b7a2:	bd70      	pop	{r4, r5, r6, pc}
    netif_num = 0;
 800b7a4:	4b04      	ldr	r3, [pc, #16]	@ (800b7b8 <netif_add+0x110>)
 800b7a6:	2200      	movs	r2, #0
 800b7a8:	701a      	strb	r2, [r3, #0]
 800b7aa:	e7f0      	b.n	800b78e <netif_add+0xe6>
    igmp_start(netif);
 800b7ac:	4630      	mov	r0, r6
 800b7ae:	f006 fbcf 	bl	8011f50 <igmp_start>
 800b7b2:	e7f5      	b.n	800b7a0 <netif_add+0xf8>
 800b7b4:	0800b551 	.word	0x0800b551
 800b7b8:	240141a7 	.word	0x240141a7
 800b7bc:	08016514 	.word	0x08016514
 800b7c0:	0801656c 	.word	0x0801656c
 800b7c4:	08015744 	.word	0x08015744
 800b7c8:	08016588 	.word	0x08016588
 800b7cc:	08018fc0 	.word	0x08018fc0
 800b7d0:	080165ac 	.word	0x080165ac
 800b7d4:	080165c0 	.word	0x080165c0
 800b7d8:	240141ac 	.word	0x240141ac

0800b7dc <netif_set_default>:
  netif_default = netif;
 800b7dc:	4b01      	ldr	r3, [pc, #4]	@ (800b7e4 <netif_set_default+0x8>)
 800b7de:	6018      	str	r0, [r3, #0]
}
 800b7e0:	4770      	bx	lr
 800b7e2:	bf00      	nop
 800b7e4:	240141a8 	.word	0x240141a8

0800b7e8 <netif_set_up>:
{
 800b7e8:	b508      	push	{r3, lr}
  LWIP_ERROR("netif_set_up: invalid netif", netif != NULL, return);
 800b7ea:	b128      	cbz	r0, 800b7f8 <netif_set_up+0x10>
  if (!(netif->flags & NETIF_FLAG_UP)) {
 800b7ec:	f890 302d 	ldrb.w	r3, [r0, #45]	@ 0x2d
 800b7f0:	f013 0f01 	tst.w	r3, #1
 800b7f4:	d008      	beq.n	800b808 <netif_set_up+0x20>
}
 800b7f6:	bd08      	pop	{r3, pc}
  LWIP_ERROR("netif_set_up: invalid netif", netif != NULL, return);
 800b7f8:	4b07      	ldr	r3, [pc, #28]	@ (800b818 <netif_set_up+0x30>)
 800b7fa:	f44f 7254 	mov.w	r2, #848	@ 0x350
 800b7fe:	4907      	ldr	r1, [pc, #28]	@ (800b81c <netif_set_up+0x34>)
 800b800:	4807      	ldr	r0, [pc, #28]	@ (800b820 <netif_set_up+0x38>)
 800b802:	f008 fbbd 	bl	8013f80 <iprintf>
 800b806:	e7f6      	b.n	800b7f6 <netif_set_up+0xe>
    netif_set_flags(netif, NETIF_FLAG_UP);
 800b808:	f043 0301 	orr.w	r3, r3, #1
 800b80c:	f880 302d 	strb.w	r3, [r0, #45]	@ 0x2d
    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4 | NETIF_REPORT_TYPE_IPV6);
 800b810:	2103      	movs	r1, #3
 800b812:	f7ff feab 	bl	800b56c <netif_issue_reports>
 800b816:	e7ee      	b.n	800b7f6 <netif_set_up+0xe>
 800b818:	08016514 	.word	0x08016514
 800b81c:	080165f0 	.word	0x080165f0
 800b820:	08015744 	.word	0x08015744

0800b824 <netif_set_down>:
{
 800b824:	b508      	push	{r3, lr}
  LWIP_ERROR("netif_set_down: invalid netif", netif != NULL, return);
 800b826:	b160      	cbz	r0, 800b842 <netif_set_down+0x1e>
  if (netif->flags & NETIF_FLAG_UP) {
 800b828:	f890 302d 	ldrb.w	r3, [r0, #45]	@ 0x2d
 800b82c:	f013 0f01 	tst.w	r3, #1
 800b830:	d006      	beq.n	800b840 <netif_set_down+0x1c>
    netif_clear_flags(netif, NETIF_FLAG_UP);
 800b832:	f003 01fe 	and.w	r1, r3, #254	@ 0xfe
 800b836:	f880 102d 	strb.w	r1, [r0, #45]	@ 0x2d
    if (netif->flags & NETIF_FLAG_ETHARP) {
 800b83a:	f013 0f08 	tst.w	r3, #8
 800b83e:	d108      	bne.n	800b852 <netif_set_down+0x2e>
}
 800b840:	bd08      	pop	{r3, pc}
  LWIP_ERROR("netif_set_down: invalid netif", netif != NULL, return);
 800b842:	4b05      	ldr	r3, [pc, #20]	@ (800b858 <netif_set_down+0x34>)
 800b844:	f240 329b 	movw	r2, #923	@ 0x39b
 800b848:	4904      	ldr	r1, [pc, #16]	@ (800b85c <netif_set_down+0x38>)
 800b84a:	4805      	ldr	r0, [pc, #20]	@ (800b860 <netif_set_down+0x3c>)
 800b84c:	f008 fb98 	bl	8013f80 <iprintf>
 800b850:	e7f6      	b.n	800b840 <netif_set_down+0x1c>
      etharp_cleanup_netif(netif);
 800b852:	f005 fe2b 	bl	80114ac <etharp_cleanup_netif>
    NETIF_STATUS_CALLBACK(netif);
 800b856:	e7f3      	b.n	800b840 <netif_set_down+0x1c>
 800b858:	08016514 	.word	0x08016514
 800b85c:	0801660c 	.word	0x0801660c
 800b860:	08015744 	.word	0x08015744

0800b864 <netif_set_link_up>:
{
 800b864:	b508      	push	{r3, lr}
  LWIP_ERROR("netif_set_link_up: invalid netif", netif != NULL, return);
 800b866:	b128      	cbz	r0, 800b874 <netif_set_link_up+0x10>
  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
 800b868:	f890 302d 	ldrb.w	r3, [r0, #45]	@ 0x2d
 800b86c:	f013 0f04 	tst.w	r3, #4
 800b870:	d008      	beq.n	800b884 <netif_set_link_up+0x20>
}
 800b872:	bd08      	pop	{r3, pc}
  LWIP_ERROR("netif_set_link_up: invalid netif", netif != NULL, return);
 800b874:	4b07      	ldr	r3, [pc, #28]	@ (800b894 <netif_set_link_up+0x30>)
 800b876:	f44f 7278 	mov.w	r2, #992	@ 0x3e0
 800b87a:	4907      	ldr	r1, [pc, #28]	@ (800b898 <netif_set_link_up+0x34>)
 800b87c:	4807      	ldr	r0, [pc, #28]	@ (800b89c <netif_set_link_up+0x38>)
 800b87e:	f008 fb7f 	bl	8013f80 <iprintf>
 800b882:	e7f6      	b.n	800b872 <netif_set_link_up+0xe>
    netif_set_flags(netif, NETIF_FLAG_LINK_UP);
 800b884:	f043 0304 	orr.w	r3, r3, #4
 800b888:	f880 302d 	strb.w	r3, [r0, #45]	@ 0x2d
    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4 | NETIF_REPORT_TYPE_IPV6);
 800b88c:	2103      	movs	r1, #3
 800b88e:	f7ff fe6d 	bl	800b56c <netif_issue_reports>
    NETIF_LINK_CALLBACK(netif);
 800b892:	e7ee      	b.n	800b872 <netif_set_link_up+0xe>
 800b894:	08016514 	.word	0x08016514
 800b898:	0801662c 	.word	0x0801662c
 800b89c:	08015744 	.word	0x08015744

0800b8a0 <netif_set_link_down>:
{
 800b8a0:	b508      	push	{r3, lr}
  LWIP_ERROR("netif_set_link_down: invalid netif", netif != NULL, return);
 800b8a2:	b148      	cbz	r0, 800b8b8 <netif_set_link_down+0x18>
  if (netif->flags & NETIF_FLAG_LINK_UP) {
 800b8a4:	f890 302d 	ldrb.w	r3, [r0, #45]	@ 0x2d
 800b8a8:	f013 0f04 	tst.w	r3, #4
 800b8ac:	d003      	beq.n	800b8b6 <netif_set_link_down+0x16>
    netif_clear_flags(netif, NETIF_FLAG_LINK_UP);
 800b8ae:	f003 03fb 	and.w	r3, r3, #251	@ 0xfb
 800b8b2:	f880 302d 	strb.w	r3, [r0, #45]	@ 0x2d
}
 800b8b6:	bd08      	pop	{r3, pc}
  LWIP_ERROR("netif_set_link_down: invalid netif", netif != NULL, return);
 800b8b8:	4b03      	ldr	r3, [pc, #12]	@ (800b8c8 <netif_set_link_down+0x28>)
 800b8ba:	f240 4206 	movw	r2, #1030	@ 0x406
 800b8be:	4903      	ldr	r1, [pc, #12]	@ (800b8cc <netif_set_link_down+0x2c>)
 800b8c0:	4803      	ldr	r0, [pc, #12]	@ (800b8d0 <netif_set_link_down+0x30>)
 800b8c2:	f008 fb5d 	bl	8013f80 <iprintf>
 800b8c6:	e7f6      	b.n	800b8b6 <netif_set_link_down+0x16>
 800b8c8:	08016514 	.word	0x08016514
 800b8cc:	08016650 	.word	0x08016650
 800b8d0:	08015744 	.word	0x08015744

0800b8d4 <netif_get_by_index>:
{
  struct netif *netif;

  LWIP_ASSERT_CORE_LOCKED();

  if (idx != NETIF_NO_INDEX) {
 800b8d4:	4602      	mov	r2, r0
 800b8d6:	b158      	cbz	r0, 800b8f0 <netif_get_by_index+0x1c>
    NETIF_FOREACH(netif) {
 800b8d8:	4b06      	ldr	r3, [pc, #24]	@ (800b8f4 <netif_get_by_index+0x20>)
 800b8da:	6818      	ldr	r0, [r3, #0]
 800b8dc:	b138      	cbz	r0, 800b8ee <netif_get_by_index+0x1a>
      if (idx == netif_get_index(netif)) {
 800b8de:	f890 3030 	ldrb.w	r3, [r0, #48]	@ 0x30
 800b8e2:	3301      	adds	r3, #1
 800b8e4:	b2db      	uxtb	r3, r3
 800b8e6:	4293      	cmp	r3, r2
 800b8e8:	d003      	beq.n	800b8f2 <netif_get_by_index+0x1e>
    NETIF_FOREACH(netif) {
 800b8ea:	6800      	ldr	r0, [r0, #0]
 800b8ec:	e7f6      	b.n	800b8dc <netif_get_by_index+0x8>
 800b8ee:	4770      	bx	lr
        return netif; /* found! */
      }
    }
  }

  return NULL;
 800b8f0:	2000      	movs	r0, #0
}
 800b8f2:	4770      	bx	lr
 800b8f4:	240141ac 	.word	0x240141ac

0800b8f8 <pbuf_init_alloced_pbuf>:
#endif /* !LWIP_TCP || !TCP_QUEUE_OOSEQ || !PBUF_POOL_FREE_OOSEQ */

/* Initialize members of struct pbuf after allocation */
static void
pbuf_init_alloced_pbuf(struct pbuf *p, void *payload, u16_t tot_len, u16_t len, pbuf_type type, u8_t flags)
{
 800b8f8:	b410      	push	{r4}
  p->next = NULL;
 800b8fa:	2400      	movs	r4, #0
 800b8fc:	6004      	str	r4, [r0, #0]
  p->payload = payload;
 800b8fe:	6041      	str	r1, [r0, #4]
  p->tot_len = tot_len;
 800b900:	8102      	strh	r2, [r0, #8]
  p->len = len;
 800b902:	8143      	strh	r3, [r0, #10]
  p->type_internal = (u8_t)type;
 800b904:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800b908:	7303      	strb	r3, [r0, #12]
  p->flags = flags;
 800b90a:	f89d 3008 	ldrb.w	r3, [sp, #8]
 800b90e:	7343      	strb	r3, [r0, #13]
  p->ref = 1;
 800b910:	2301      	movs	r3, #1
 800b912:	7383      	strb	r3, [r0, #14]
  p->if_idx = NETIF_NO_INDEX;
 800b914:	73c4      	strb	r4, [r0, #15]
}
 800b916:	f85d 4b04 	ldr.w	r4, [sp], #4
 800b91a:	4770      	bx	lr

0800b91c <pbuf_add_header_impl>:
 * @return non-zero on failure, zero on success.
 *
 */
static u8_t
pbuf_add_header_impl(struct pbuf *p, size_t header_size_increment, u8_t force)
{
 800b91c:	b570      	push	{r4, r5, r6, lr}
 800b91e:	460c      	mov	r4, r1
 800b920:	4616      	mov	r6, r2
  u16_t type_internal;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
 800b922:	4605      	mov	r5, r0
 800b924:	b1c8      	cbz	r0, 800b95a <pbuf_add_header_impl+0x3e>
  if ((p == NULL) || (header_size_increment > 0xFFFF)) {
 800b926:	2d00      	cmp	r5, #0
 800b928:	bf18      	it	ne
 800b92a:	f5b4 3f80 	cmpne.w	r4, #65536	@ 0x10000
 800b92e:	d224      	bcs.n	800b97a <pbuf_add_header_impl+0x5e>
    return 1;
  }
  if (header_size_increment == 0) {
 800b930:	b32c      	cbz	r4, 800b97e <pbuf_add_header_impl+0x62>
    return 0;
  }

  increment_magnitude = (u16_t)header_size_increment;
 800b932:	b2a2      	uxth	r2, r4
  /* Do not allow tot_len to wrap as a result. */
  if ((u16_t)(increment_magnitude + p->tot_len) < increment_magnitude) {
 800b934:	892b      	ldrh	r3, [r5, #8]
 800b936:	4413      	add	r3, r2
 800b938:	b29b      	uxth	r3, r3
 800b93a:	4293      	cmp	r3, r2
 800b93c:	d321      	bcc.n	800b982 <pbuf_add_header_impl+0x66>
  }

  type_internal = p->type_internal;

  /* pbuf types containing payloads? */
  if (type_internal & PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS) {
 800b93e:	f995 100c 	ldrsb.w	r1, [r5, #12]
 800b942:	2900      	cmp	r1, #0
 800b944:	db11      	blt.n	800b96a <pbuf_add_header_impl+0x4e>
      return 1;
    }
    /* pbuf types referring to external payloads? */
  } else {
    /* hide a header in the payload? */
    if (force) {
 800b946:	b1f6      	cbz	r6, 800b986 <pbuf_add_header_impl+0x6a>
      payload = (u8_t *)p->payload - header_size_increment;
 800b948:	6869      	ldr	r1, [r5, #4]
 800b94a:	1b0c      	subs	r4, r1, r4
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_add_header: old %p new %p (%"U16_F")\n",
              (void *)p->payload, (void *)payload, increment_magnitude));

  /* modify pbuf fields */
  p->payload = payload;
 800b94c:	606c      	str	r4, [r5, #4]
  p->len = (u16_t)(p->len + increment_magnitude);
 800b94e:	8969      	ldrh	r1, [r5, #10]
 800b950:	440a      	add	r2, r1
 800b952:	816a      	strh	r2, [r5, #10]
  p->tot_len = (u16_t)(p->tot_len + increment_magnitude);
 800b954:	812b      	strh	r3, [r5, #8]


  return 0;
 800b956:	2000      	movs	r0, #0
 800b958:	e010      	b.n	800b97c <pbuf_add_header_impl+0x60>
  LWIP_ASSERT("p != NULL", p != NULL);
 800b95a:	4b0c      	ldr	r3, [pc, #48]	@ (800b98c <pbuf_add_header_impl+0x70>)
 800b95c:	f240 12df 	movw	r2, #479	@ 0x1df
 800b960:	490b      	ldr	r1, [pc, #44]	@ (800b990 <pbuf_add_header_impl+0x74>)
 800b962:	480c      	ldr	r0, [pc, #48]	@ (800b994 <pbuf_add_header_impl+0x78>)
 800b964:	f008 fb0c 	bl	8013f80 <iprintf>
 800b968:	e7dd      	b.n	800b926 <pbuf_add_header_impl+0xa>
    payload = (u8_t *)p->payload - header_size_increment;
 800b96a:	6869      	ldr	r1, [r5, #4]
 800b96c:	1b0c      	subs	r4, r1, r4
    if ((u8_t *)payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 800b96e:	f105 0110 	add.w	r1, r5, #16
 800b972:	42a1      	cmp	r1, r4
 800b974:	d9ea      	bls.n	800b94c <pbuf_add_header_impl+0x30>
      return 1;
 800b976:	2001      	movs	r0, #1
 800b978:	e000      	b.n	800b97c <pbuf_add_header_impl+0x60>
    return 1;
 800b97a:	2001      	movs	r0, #1
}
 800b97c:	bd70      	pop	{r4, r5, r6, pc}
    return 0;
 800b97e:	2000      	movs	r0, #0
 800b980:	e7fc      	b.n	800b97c <pbuf_add_header_impl+0x60>
    return 1;
 800b982:	2001      	movs	r0, #1
 800b984:	e7fa      	b.n	800b97c <pbuf_add_header_impl+0x60>
      return 1;
 800b986:	2001      	movs	r0, #1
 800b988:	e7f8      	b.n	800b97c <pbuf_add_header_impl+0x60>
 800b98a:	bf00      	nop
 800b98c:	08016674 	.word	0x08016674
 800b990:	0801592c 	.word	0x0801592c
 800b994:	08015744 	.word	0x08015744

0800b998 <pbuf_pool_is_empty>:
{
 800b998:	b510      	push	{r4, lr}
  SYS_ARCH_PROTECT(old_level);
 800b99a:	f007 fdd7 	bl	801354c <sys_arch_protect>
  queued = pbuf_free_ooseq_pending;
 800b99e:	4b0b      	ldr	r3, [pc, #44]	@ (800b9cc <pbuf_pool_is_empty+0x34>)
 800b9a0:	781c      	ldrb	r4, [r3, #0]
 800b9a2:	b2e4      	uxtb	r4, r4
  pbuf_free_ooseq_pending = 1;
 800b9a4:	2201      	movs	r2, #1
 800b9a6:	701a      	strb	r2, [r3, #0]
  SYS_ARCH_UNPROTECT(old_level);
 800b9a8:	f007 fddc 	bl	8013564 <sys_arch_unprotect>
  if (!queued) {
 800b9ac:	b104      	cbz	r4, 800b9b0 <pbuf_pool_is_empty+0x18>
}
 800b9ae:	bd10      	pop	{r4, pc}
    PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
 800b9b0:	2100      	movs	r1, #0
 800b9b2:	4807      	ldr	r0, [pc, #28]	@ (800b9d0 <pbuf_pool_is_empty+0x38>)
 800b9b4:	f7ff f852 	bl	800aa5c <tcpip_try_callback>
 800b9b8:	2800      	cmp	r0, #0
 800b9ba:	d0f8      	beq.n	800b9ae <pbuf_pool_is_empty+0x16>
 800b9bc:	f007 fdc6 	bl	801354c <sys_arch_protect>
 800b9c0:	4b02      	ldr	r3, [pc, #8]	@ (800b9cc <pbuf_pool_is_empty+0x34>)
 800b9c2:	2200      	movs	r2, #0
 800b9c4:	701a      	strb	r2, [r3, #0]
 800b9c6:	f007 fdcd 	bl	8013564 <sys_arch_unprotect>
}
 800b9ca:	e7f0      	b.n	800b9ae <pbuf_pool_is_empty+0x16>
 800b9cc:	240141b0 	.word	0x240141b0
 800b9d0:	0800ba05 	.word	0x0800ba05

0800b9d4 <pbuf_free_ooseq>:
{
 800b9d4:	b508      	push	{r3, lr}
  SYS_ARCH_SET(pbuf_free_ooseq_pending, 0);
 800b9d6:	f007 fdb9 	bl	801354c <sys_arch_protect>
 800b9da:	4b08      	ldr	r3, [pc, #32]	@ (800b9fc <pbuf_free_ooseq+0x28>)
 800b9dc:	2200      	movs	r2, #0
 800b9de:	701a      	strb	r2, [r3, #0]
 800b9e0:	f007 fdc0 	bl	8013564 <sys_arch_unprotect>
  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 800b9e4:	4b06      	ldr	r3, [pc, #24]	@ (800ba00 <pbuf_free_ooseq+0x2c>)
 800b9e6:	6818      	ldr	r0, [r3, #0]
 800b9e8:	e000      	b.n	800b9ec <pbuf_free_ooseq+0x18>
 800b9ea:	68c0      	ldr	r0, [r0, #12]
 800b9ec:	b120      	cbz	r0, 800b9f8 <pbuf_free_ooseq+0x24>
    if (pcb->ooseq != NULL) {
 800b9ee:	6f43      	ldr	r3, [r0, #116]	@ 0x74
 800b9f0:	2b00      	cmp	r3, #0
 800b9f2:	d0fa      	beq.n	800b9ea <pbuf_free_ooseq+0x16>
      tcp_free_ooseq(pcb);
 800b9f4:	f000 fec8 	bl	800c788 <tcp_free_ooseq>
}
 800b9f8:	bd08      	pop	{r3, pc}
 800b9fa:	bf00      	nop
 800b9fc:	240141b0 	.word	0x240141b0
 800ba00:	240142dc 	.word	0x240142dc

0800ba04 <pbuf_free_ooseq_callback>:
{
 800ba04:	b508      	push	{r3, lr}
  pbuf_free_ooseq();
 800ba06:	f7ff ffe5 	bl	800b9d4 <pbuf_free_ooseq>
}
 800ba0a:	bd08      	pop	{r3, pc}

0800ba0c <pbuf_alloc_reference>:
{
 800ba0c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ba0e:	b083      	sub	sp, #12
 800ba10:	4606      	mov	r6, r0
 800ba12:	460d      	mov	r5, r1
 800ba14:	4614      	mov	r4, r2
  LWIP_ASSERT("invalid pbuf_type", (type == PBUF_REF) || (type == PBUF_ROM));
 800ba16:	2a41      	cmp	r2, #65	@ 0x41
 800ba18:	bf18      	it	ne
 800ba1a:	2a01      	cmpne	r2, #1
 800ba1c:	d10f      	bne.n	800ba3e <pbuf_alloc_reference+0x32>
  p = (struct pbuf *)memp_malloc(MEMP_PBUF);
 800ba1e:	200c      	movs	r0, #12
 800ba20:	f7ff fd34 	bl	800b48c <memp_malloc>
  if (p == NULL) {
 800ba24:	4607      	mov	r7, r0
 800ba26:	b138      	cbz	r0, 800ba38 <pbuf_alloc_reference+0x2c>
  pbuf_init_alloced_pbuf(p, payload, length, length, type, 0);
 800ba28:	2300      	movs	r3, #0
 800ba2a:	9301      	str	r3, [sp, #4]
 800ba2c:	9400      	str	r4, [sp, #0]
 800ba2e:	462b      	mov	r3, r5
 800ba30:	462a      	mov	r2, r5
 800ba32:	4631      	mov	r1, r6
 800ba34:	f7ff ff60 	bl	800b8f8 <pbuf_init_alloced_pbuf>
}
 800ba38:	4638      	mov	r0, r7
 800ba3a:	b003      	add	sp, #12
 800ba3c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  LWIP_ASSERT("invalid pbuf_type", (type == PBUF_REF) || (type == PBUF_ROM));
 800ba3e:	4b04      	ldr	r3, [pc, #16]	@ (800ba50 <pbuf_alloc_reference+0x44>)
 800ba40:	f44f 72a5 	mov.w	r2, #330	@ 0x14a
 800ba44:	4903      	ldr	r1, [pc, #12]	@ (800ba54 <pbuf_alloc_reference+0x48>)
 800ba46:	4804      	ldr	r0, [pc, #16]	@ (800ba58 <pbuf_alloc_reference+0x4c>)
 800ba48:	f008 fa9a 	bl	8013f80 <iprintf>
 800ba4c:	e7e7      	b.n	800ba1e <pbuf_alloc_reference+0x12>
 800ba4e:	bf00      	nop
 800ba50:	08016674 	.word	0x08016674
 800ba54:	080166a4 	.word	0x080166a4
 800ba58:	08015744 	.word	0x08015744

0800ba5c <pbuf_alloced_custom>:
{
 800ba5c:	b510      	push	{r4, lr}
 800ba5e:	b082      	sub	sp, #8
 800ba60:	4684      	mov	ip, r0
 800ba62:	468e      	mov	lr, r1
 800ba64:	4618      	mov	r0, r3
 800ba66:	9904      	ldr	r1, [sp, #16]
  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
 800ba68:	f10c 0c03 	add.w	ip, ip, #3
 800ba6c:	f02c 0c03 	bic.w	ip, ip, #3
 800ba70:	eb0e 040c 	add.w	r4, lr, ip
 800ba74:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 800ba78:	429c      	cmp	r4, r3
 800ba7a:	d80c      	bhi.n	800ba96 <pbuf_alloced_custom+0x3a>
  if (payload_mem != NULL) {
 800ba7c:	b101      	cbz	r1, 800ba80 <pbuf_alloced_custom+0x24>
    payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
 800ba7e:	4461      	add	r1, ip
  pbuf_init_alloced_pbuf(&p->pbuf, payload, length, length, type, PBUF_FLAG_IS_CUSTOM);
 800ba80:	4604      	mov	r4, r0
 800ba82:	2302      	movs	r3, #2
 800ba84:	9301      	str	r3, [sp, #4]
 800ba86:	9200      	str	r2, [sp, #0]
 800ba88:	4673      	mov	r3, lr
 800ba8a:	4672      	mov	r2, lr
 800ba8c:	f7ff ff34 	bl	800b8f8 <pbuf_init_alloced_pbuf>
}
 800ba90:	4620      	mov	r0, r4
 800ba92:	b002      	add	sp, #8
 800ba94:	bd10      	pop	{r4, pc}
    return NULL;
 800ba96:	2400      	movs	r4, #0
 800ba98:	e7fa      	b.n	800ba90 <pbuf_alloced_custom+0x34>

0800ba9a <pbuf_add_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_add_header(struct pbuf *p, size_t header_size_increment)
{
 800ba9a:	b508      	push	{r3, lr}
  return pbuf_add_header_impl(p, header_size_increment, 0);
 800ba9c:	2200      	movs	r2, #0
 800ba9e:	f7ff ff3d 	bl	800b91c <pbuf_add_header_impl>
}
 800baa2:	bd08      	pop	{r3, pc}

0800baa4 <pbuf_remove_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_remove_header(struct pbuf *p, size_t header_size_decrement)
{
 800baa4:	b538      	push	{r3, r4, r5, lr}
 800baa6:	460c      	mov	r4, r1
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
 800baa8:	4605      	mov	r5, r0
 800baaa:	b198      	cbz	r0, 800bad4 <pbuf_remove_header+0x30>
  if ((p == NULL) || (header_size_decrement > 0xFFFF)) {
 800baac:	2d00      	cmp	r5, #0
 800baae:	bf18      	it	ne
 800bab0:	f5b4 3f80 	cmpne.w	r4, #65536	@ 0x10000
 800bab4:	d21f      	bcs.n	800baf6 <pbuf_remove_header+0x52>
    return 1;
  }
  if (header_size_decrement == 0) {
 800bab6:	b304      	cbz	r4, 800bafa <pbuf_remove_header+0x56>
    return 0;
  }

  increment_magnitude = (u16_t)header_size_decrement;
 800bab8:	b2a2      	uxth	r2, r4
  /* Check that we aren't going to move off the end of the pbuf */
  LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 800baba:	896b      	ldrh	r3, [r5, #10]
 800babc:	4293      	cmp	r3, r2
 800babe:	d311      	bcc.n	800bae4 <pbuf_remove_header+0x40>
  /* remember current payload pointer */
  payload = p->payload;
  LWIP_UNUSED_ARG(payload); /* only used in LWIP_DEBUGF below */

  /* increase payload pointer (guarded by length check above) */
  p->payload = (u8_t *)p->payload + header_size_decrement;
 800bac0:	6869      	ldr	r1, [r5, #4]
 800bac2:	4421      	add	r1, r4
 800bac4:	6069      	str	r1, [r5, #4]
  /* modify pbuf length fields */
  p->len = (u16_t)(p->len - increment_magnitude);
 800bac6:	1a9b      	subs	r3, r3, r2
 800bac8:	816b      	strh	r3, [r5, #10]
  p->tot_len = (u16_t)(p->tot_len - increment_magnitude);
 800baca:	892b      	ldrh	r3, [r5, #8]
 800bacc:	1a9b      	subs	r3, r3, r2
 800bace:	812b      	strh	r3, [r5, #8]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_remove_header: old %p new %p (%"U16_F")\n",
              (void *)payload, (void *)p->payload, increment_magnitude));

  return 0;
 800bad0:	2000      	movs	r0, #0
}
 800bad2:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("p != NULL", p != NULL);
 800bad4:	4b0a      	ldr	r3, [pc, #40]	@ (800bb00 <pbuf_remove_header+0x5c>)
 800bad6:	f240 224b 	movw	r2, #587	@ 0x24b
 800bada:	490a      	ldr	r1, [pc, #40]	@ (800bb04 <pbuf_remove_header+0x60>)
 800badc:	480a      	ldr	r0, [pc, #40]	@ (800bb08 <pbuf_remove_header+0x64>)
 800bade:	f008 fa4f 	bl	8013f80 <iprintf>
 800bae2:	e7e3      	b.n	800baac <pbuf_remove_header+0x8>
  LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 800bae4:	4b06      	ldr	r3, [pc, #24]	@ (800bb00 <pbuf_remove_header+0x5c>)
 800bae6:	f240 2255 	movw	r2, #597	@ 0x255
 800baea:	4908      	ldr	r1, [pc, #32]	@ (800bb0c <pbuf_remove_header+0x68>)
 800baec:	4806      	ldr	r0, [pc, #24]	@ (800bb08 <pbuf_remove_header+0x64>)
 800baee:	f008 fa47 	bl	8013f80 <iprintf>
 800baf2:	2001      	movs	r0, #1
 800baf4:	e7ed      	b.n	800bad2 <pbuf_remove_header+0x2e>
    return 1;
 800baf6:	2001      	movs	r0, #1
 800baf8:	e7eb      	b.n	800bad2 <pbuf_remove_header+0x2e>
    return 0;
 800bafa:	2000      	movs	r0, #0
 800bafc:	e7e9      	b.n	800bad2 <pbuf_remove_header+0x2e>
 800bafe:	bf00      	nop
 800bb00:	08016674 	.word	0x08016674
 800bb04:	0801592c 	.word	0x0801592c
 800bb08:	08015744 	.word	0x08015744
 800bb0c:	080166b8 	.word	0x080166b8

0800bb10 <pbuf_header_impl>:

static u8_t
pbuf_header_impl(struct pbuf *p, s16_t header_size_increment, u8_t force)
{
 800bb10:	b508      	push	{r3, lr}
  if (header_size_increment < 0) {
 800bb12:	2900      	cmp	r1, #0
 800bb14:	db02      	blt.n	800bb1c <pbuf_header_impl+0xc>
    return pbuf_remove_header(p, (size_t) - header_size_increment);
  } else {
    return pbuf_add_header_impl(p, (size_t)header_size_increment, force);
 800bb16:	f7ff ff01 	bl	800b91c <pbuf_add_header_impl>
  }
}
 800bb1a:	bd08      	pop	{r3, pc}
    return pbuf_remove_header(p, (size_t) - header_size_increment);
 800bb1c:	4249      	negs	r1, r1
 800bb1e:	f7ff ffc1 	bl	800baa4 <pbuf_remove_header>
 800bb22:	e7fa      	b.n	800bb1a <pbuf_header_impl+0xa>

0800bb24 <pbuf_header_force>:
 * Same as pbuf_header but does not check if 'header_size > 0' is allowed.
 * This is used internally only, to allow PBUF_REF for RX.
 */
u8_t
pbuf_header_force(struct pbuf *p, s16_t header_size_increment)
{
 800bb24:	b508      	push	{r3, lr}
  return pbuf_header_impl(p, header_size_increment, 1);
 800bb26:	2201      	movs	r2, #1
 800bb28:	f7ff fff2 	bl	800bb10 <pbuf_header_impl>
}
 800bb2c:	bd08      	pop	{r3, pc}
	...

0800bb30 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
 800bb30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  u8_t alloc_src;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
 800bb32:	b110      	cbz	r0, 800bb3a <pbuf_free+0xa>
 800bb34:	4604      	mov	r4, r0
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  count = 0;
 800bb36:	2600      	movs	r6, #0
 800bb38:	e017      	b.n	800bb6a <pbuf_free+0x3a>
    LWIP_ASSERT("p != NULL", p != NULL);
 800bb3a:	4b2b      	ldr	r3, [pc, #172]	@ (800bbe8 <pbuf_free+0xb8>)
 800bb3c:	f44f 7237 	mov.w	r2, #732	@ 0x2dc
 800bb40:	492a      	ldr	r1, [pc, #168]	@ (800bbec <pbuf_free+0xbc>)
 800bb42:	482b      	ldr	r0, [pc, #172]	@ (800bbf0 <pbuf_free+0xc0>)
 800bb44:	f008 fa1c 	bl	8013f80 <iprintf>
    return 0;
 800bb48:	2600      	movs	r6, #0
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
 800bb4a:	4630      	mov	r0, r6
 800bb4c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
 800bb4e:	4b26      	ldr	r3, [pc, #152]	@ (800bbe8 <pbuf_free+0xb8>)
 800bb50:	f240 22f1 	movw	r2, #753	@ 0x2f1
 800bb54:	4927      	ldr	r1, [pc, #156]	@ (800bbf4 <pbuf_free+0xc4>)
 800bb56:	4826      	ldr	r0, [pc, #152]	@ (800bbf0 <pbuf_free+0xc0>)
 800bb58:	f008 fa12 	bl	8013f80 <iprintf>
 800bb5c:	e00d      	b.n	800bb7a <pbuf_free+0x4a>
        pc->custom_free_function(p);
 800bb5e:	6923      	ldr	r3, [r4, #16]
 800bb60:	4620      	mov	r0, r4
 800bb62:	4798      	blx	r3
      count++;
 800bb64:	3601      	adds	r6, #1
 800bb66:	b2f6      	uxtb	r6, r6
      p = q;
 800bb68:	462c      	mov	r4, r5
  while (p != NULL) {
 800bb6a:	2c00      	cmp	r4, #0
 800bb6c:	d0ed      	beq.n	800bb4a <pbuf_free+0x1a>
    SYS_ARCH_PROTECT(old_level);
 800bb6e:	f007 fced 	bl	801354c <sys_arch_protect>
 800bb72:	4607      	mov	r7, r0
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
 800bb74:	7ba3      	ldrb	r3, [r4, #14]
 800bb76:	2b00      	cmp	r3, #0
 800bb78:	d0e9      	beq.n	800bb4e <pbuf_free+0x1e>
    ref = --(p->ref);
 800bb7a:	7ba5      	ldrb	r5, [r4, #14]
 800bb7c:	3d01      	subs	r5, #1
 800bb7e:	b2ed      	uxtb	r5, r5
 800bb80:	73a5      	strb	r5, [r4, #14]
    SYS_ARCH_UNPROTECT(old_level);
 800bb82:	4638      	mov	r0, r7
 800bb84:	f007 fcee 	bl	8013564 <sys_arch_unprotect>
    if (ref == 0) {
 800bb88:	2d00      	cmp	r5, #0
 800bb8a:	d1de      	bne.n	800bb4a <pbuf_free+0x1a>
      q = p->next;
 800bb8c:	6825      	ldr	r5, [r4, #0]
      alloc_src = pbuf_get_allocsrc(p);
 800bb8e:	7b23      	ldrb	r3, [r4, #12]
 800bb90:	f003 030f 	and.w	r3, r3, #15
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 800bb94:	7b62      	ldrb	r2, [r4, #13]
 800bb96:	f012 0f02 	tst.w	r2, #2
 800bb9a:	d00a      	beq.n	800bbb2 <pbuf_free+0x82>
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
 800bb9c:	6923      	ldr	r3, [r4, #16]
 800bb9e:	2b00      	cmp	r3, #0
 800bba0:	d1dd      	bne.n	800bb5e <pbuf_free+0x2e>
 800bba2:	4b11      	ldr	r3, [pc, #68]	@ (800bbe8 <pbuf_free+0xb8>)
 800bba4:	f240 22ff 	movw	r2, #767	@ 0x2ff
 800bba8:	4913      	ldr	r1, [pc, #76]	@ (800bbf8 <pbuf_free+0xc8>)
 800bbaa:	4811      	ldr	r0, [pc, #68]	@ (800bbf0 <pbuf_free+0xc0>)
 800bbac:	f008 f9e8 	bl	8013f80 <iprintf>
 800bbb0:	e7d5      	b.n	800bb5e <pbuf_free+0x2e>
        if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF_POOL) {
 800bbb2:	2b02      	cmp	r3, #2
 800bbb4:	d006      	beq.n	800bbc4 <pbuf_free+0x94>
        } else if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF) {
 800bbb6:	2b01      	cmp	r3, #1
 800bbb8:	d009      	beq.n	800bbce <pbuf_free+0x9e>
        } else if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP) {
 800bbba:	b96b      	cbnz	r3, 800bbd8 <pbuf_free+0xa8>
          mem_free(p);
 800bbbc:	4620      	mov	r0, r4
 800bbbe:	f7ff f91f 	bl	800ae00 <mem_free>
 800bbc2:	e7cf      	b.n	800bb64 <pbuf_free+0x34>
          memp_free(MEMP_PBUF_POOL, p);
 800bbc4:	4621      	mov	r1, r4
 800bbc6:	200d      	movs	r0, #13
 800bbc8:	f7ff fc96 	bl	800b4f8 <memp_free>
 800bbcc:	e7ca      	b.n	800bb64 <pbuf_free+0x34>
          memp_free(MEMP_PBUF, p);
 800bbce:	4621      	mov	r1, r4
 800bbd0:	200c      	movs	r0, #12
 800bbd2:	f7ff fc91 	bl	800b4f8 <memp_free>
 800bbd6:	e7c5      	b.n	800bb64 <pbuf_free+0x34>
          LWIP_ASSERT("invalid pbuf type", 0);
 800bbd8:	4b03      	ldr	r3, [pc, #12]	@ (800bbe8 <pbuf_free+0xb8>)
 800bbda:	f240 320f 	movw	r2, #783	@ 0x30f
 800bbde:	4907      	ldr	r1, [pc, #28]	@ (800bbfc <pbuf_free+0xcc>)
 800bbe0:	4803      	ldr	r0, [pc, #12]	@ (800bbf0 <pbuf_free+0xc0>)
 800bbe2:	f008 f9cd 	bl	8013f80 <iprintf>
 800bbe6:	e7bd      	b.n	800bb64 <pbuf_free+0x34>
 800bbe8:	08016674 	.word	0x08016674
 800bbec:	0801592c 	.word	0x0801592c
 800bbf0:	08015744 	.word	0x08015744
 800bbf4:	080166d8 	.word	0x080166d8
 800bbf8:	080166f0 	.word	0x080166f0
 800bbfc:	08016714 	.word	0x08016714

0800bc00 <pbuf_alloc>:
{
 800bc00:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800bc04:	b082      	sub	sp, #8
 800bc06:	460e      	mov	r6, r1
 800bc08:	4690      	mov	r8, r2
  switch (type) {
 800bc0a:	f5b2 7fc1 	cmp.w	r2, #386	@ 0x182
 800bc0e:	d04d      	beq.n	800bcac <pbuf_alloc+0xac>
 800bc10:	4604      	mov	r4, r0
 800bc12:	d80d      	bhi.n	800bc30 <pbuf_alloc+0x30>
 800bc14:	2a01      	cmp	r2, #1
 800bc16:	d03f      	beq.n	800bc98 <pbuf_alloc+0x98>
 800bc18:	2a41      	cmp	r2, #65	@ 0x41
 800bc1a:	d03d      	beq.n	800bc98 <pbuf_alloc+0x98>
      LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
 800bc1c:	4b49      	ldr	r3, [pc, #292]	@ (800bd44 <pbuf_alloc+0x144>)
 800bc1e:	f240 1227 	movw	r2, #295	@ 0x127
 800bc22:	4949      	ldr	r1, [pc, #292]	@ (800bd48 <pbuf_alloc+0x148>)
 800bc24:	4849      	ldr	r0, [pc, #292]	@ (800bd4c <pbuf_alloc+0x14c>)
 800bc26:	f008 f9ab 	bl	8013f80 <iprintf>
      return NULL;
 800bc2a:	f04f 0900 	mov.w	r9, #0
 800bc2e:	e039      	b.n	800bca4 <pbuf_alloc+0xa4>
  switch (type) {
 800bc30:	f5b2 7f20 	cmp.w	r2, #640	@ 0x280
 800bc34:	d1f2      	bne.n	800bc1c <pbuf_alloc+0x1c>
      u16_t payload_len = (u16_t)(LWIP_MEM_ALIGN_SIZE(offset) + LWIP_MEM_ALIGN_SIZE(length));
 800bc36:	1cc1      	adds	r1, r0, #3
 800bc38:	f401 71fe 	and.w	r1, r1, #508	@ 0x1fc
 800bc3c:	1cf2      	adds	r2, r6, #3
 800bc3e:	b293      	uxth	r3, r2
 800bc40:	f023 0303 	bic.w	r3, r3, #3
 800bc44:	440b      	add	r3, r1
 800bc46:	b29b      	uxth	r3, r3
      mem_size_t alloc_len = (mem_size_t)(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF) + payload_len);
 800bc48:	f103 0010 	add.w	r0, r3, #16
 800bc4c:	b280      	uxth	r0, r0
      if ((payload_len < LWIP_MEM_ALIGN_SIZE(length)) ||
 800bc4e:	f022 0203 	bic.w	r2, r2, #3
 800bc52:	4293      	cmp	r3, r2
 800bc54:	d36f      	bcc.n	800bd36 <pbuf_alloc+0x136>
 800bc56:	4282      	cmp	r2, r0
 800bc58:	d870      	bhi.n	800bd3c <pbuf_alloc+0x13c>
      p = (struct pbuf *)mem_malloc(alloc_len);
 800bc5a:	f7ff fa81 	bl	800b160 <mem_malloc>
      if (p == NULL) {
 800bc5e:	4681      	mov	r9, r0
 800bc60:	b300      	cbz	r0, 800bca4 <pbuf_alloc+0xa4>
      pbuf_init_alloced_pbuf(p, LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset)),
 800bc62:	f104 0110 	add.w	r1, r4, #16
 800bc66:	4401      	add	r1, r0
 800bc68:	3103      	adds	r1, #3
 800bc6a:	2300      	movs	r3, #0
 800bc6c:	9301      	str	r3, [sp, #4]
 800bc6e:	f8cd 8000 	str.w	r8, [sp]
 800bc72:	4633      	mov	r3, r6
 800bc74:	4632      	mov	r2, r6
 800bc76:	f021 0103 	bic.w	r1, r1, #3
 800bc7a:	f7ff fe3d 	bl	800b8f8 <pbuf_init_alloced_pbuf>
      LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
 800bc7e:	f8d9 3004 	ldr.w	r3, [r9, #4]
 800bc82:	f013 0f03 	tst.w	r3, #3
 800bc86:	d00d      	beq.n	800bca4 <pbuf_alloc+0xa4>
 800bc88:	4b2e      	ldr	r3, [pc, #184]	@ (800bd44 <pbuf_alloc+0x144>)
 800bc8a:	f44f 7291 	mov.w	r2, #290	@ 0x122
 800bc8e:	4930      	ldr	r1, [pc, #192]	@ (800bd50 <pbuf_alloc+0x150>)
 800bc90:	482e      	ldr	r0, [pc, #184]	@ (800bd4c <pbuf_alloc+0x14c>)
 800bc92:	f008 f975 	bl	8013f80 <iprintf>
 800bc96:	e005      	b.n	800bca4 <pbuf_alloc+0xa4>
      p = pbuf_alloc_reference(NULL, length, type);
 800bc98:	4642      	mov	r2, r8
 800bc9a:	4631      	mov	r1, r6
 800bc9c:	2000      	movs	r0, #0
 800bc9e:	f7ff feb5 	bl	800ba0c <pbuf_alloc_reference>
 800bca2:	4681      	mov	r9, r0
}
 800bca4:	4648      	mov	r0, r9
 800bca6:	b002      	add	sp, #8
 800bca8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800bcac:	4605      	mov	r5, r0
  switch (type) {
 800bcae:	2700      	movs	r7, #0
 800bcb0:	46b9      	mov	r9, r7
 800bcb2:	e013      	b.n	800bcdc <pbuf_alloc+0xdc>
          PBUF_POOL_IS_EMPTY();
 800bcb4:	f7ff fe70 	bl	800b998 <pbuf_pool_is_empty>
          if (p) {
 800bcb8:	f1b9 0f00 	cmp.w	r9, #0
 800bcbc:	d002      	beq.n	800bcc4 <pbuf_alloc+0xc4>
            pbuf_free(p);
 800bcbe:	4648      	mov	r0, r9
 800bcc0:	f7ff ff36 	bl	800bb30 <pbuf_free>
          return NULL;
 800bcc4:	46b9      	mov	r9, r7
 800bcc6:	e7ed      	b.n	800bca4 <pbuf_alloc+0xa4>
        if (p == NULL) {
 800bcc8:	f1b9 0f00 	cmp.w	r9, #0
 800bccc:	d031      	beq.n	800bd32 <pbuf_alloc+0x132>
          last->next = q;
 800bcce:	f8ca 7000 	str.w	r7, [sl]
        rem_len = (u16_t)(rem_len - qlen);
 800bcd2:	1b34      	subs	r4, r6, r4
 800bcd4:	b2a6      	uxth	r6, r4
        offset = 0;
 800bcd6:	2500      	movs	r5, #0
      } while (rem_len > 0);
 800bcd8:	2e00      	cmp	r6, #0
 800bcda:	d0e3      	beq.n	800bca4 <pbuf_alloc+0xa4>
        q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 800bcdc:	46ba      	mov	sl, r7
 800bcde:	200d      	movs	r0, #13
 800bce0:	f7ff fbd4 	bl	800b48c <memp_malloc>
        if (q == NULL) {
 800bce4:	4607      	mov	r7, r0
 800bce6:	2800      	cmp	r0, #0
 800bce8:	d0e4      	beq.n	800bcb4 <pbuf_alloc+0xb4>
        qlen = LWIP_MIN(rem_len, (u16_t)(PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)));
 800bcea:	1cec      	adds	r4, r5, #3
 800bcec:	f024 0403 	bic.w	r4, r4, #3
 800bcf0:	b2a4      	uxth	r4, r4
 800bcf2:	f5c4 64c0 	rsb	r4, r4, #1536	@ 0x600
 800bcf6:	b2a4      	uxth	r4, r4
 800bcf8:	42b4      	cmp	r4, r6
 800bcfa:	bf28      	it	cs
 800bcfc:	4634      	movcs	r4, r6
        pbuf_init_alloced_pbuf(q, LWIP_MEM_ALIGN((void *)((u8_t *)q + SIZEOF_STRUCT_PBUF + offset)),
 800bcfe:	f105 0110 	add.w	r1, r5, #16
 800bd02:	4401      	add	r1, r0
 800bd04:	3103      	adds	r1, #3
 800bd06:	2300      	movs	r3, #0
 800bd08:	9301      	str	r3, [sp, #4]
 800bd0a:	f8cd 8000 	str.w	r8, [sp]
 800bd0e:	4623      	mov	r3, r4
 800bd10:	4632      	mov	r2, r6
 800bd12:	f021 0103 	bic.w	r1, r1, #3
 800bd16:	f7ff fdef 	bl	800b8f8 <pbuf_init_alloced_pbuf>
        LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
 800bd1a:	687b      	ldr	r3, [r7, #4]
 800bd1c:	f013 0f03 	tst.w	r3, #3
 800bd20:	d0d2      	beq.n	800bcc8 <pbuf_alloc+0xc8>
 800bd22:	4b08      	ldr	r3, [pc, #32]	@ (800bd44 <pbuf_alloc+0x144>)
 800bd24:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800bd28:	490a      	ldr	r1, [pc, #40]	@ (800bd54 <pbuf_alloc+0x154>)
 800bd2a:	4808      	ldr	r0, [pc, #32]	@ (800bd4c <pbuf_alloc+0x14c>)
 800bd2c:	f008 f928 	bl	8013f80 <iprintf>
        LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
 800bd30:	e7ca      	b.n	800bcc8 <pbuf_alloc+0xc8>
          p = q;
 800bd32:	46b9      	mov	r9, r7
 800bd34:	e7cd      	b.n	800bcd2 <pbuf_alloc+0xd2>
        return NULL;
 800bd36:	f04f 0900 	mov.w	r9, #0
 800bd3a:	e7b3      	b.n	800bca4 <pbuf_alloc+0xa4>
 800bd3c:	f04f 0900 	mov.w	r9, #0
 800bd40:	e7b0      	b.n	800bca4 <pbuf_alloc+0xa4>
 800bd42:	bf00      	nop
 800bd44:	08016674 	.word	0x08016674
 800bd48:	080167b8 	.word	0x080167b8
 800bd4c:	08015744 	.word	0x08015744
 800bd50:	0801678c 	.word	0x0801678c
 800bd54:	08016728 	.word	0x08016728

0800bd58 <pbuf_realloc>:
{
 800bd58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800bd5a:	460e      	mov	r6, r1
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
 800bd5c:	4604      	mov	r4, r0
 800bd5e:	b1b8      	cbz	r0, 800bd90 <pbuf_realloc+0x38>
  if (new_len >= p->tot_len) {
 800bd60:	8927      	ldrh	r7, [r4, #8]
 800bd62:	42b7      	cmp	r7, r6
 800bd64:	d92e      	bls.n	800bdc4 <pbuf_realloc+0x6c>
  rem_len = new_len;
 800bd66:	4635      	mov	r5, r6
  while (rem_len > q->len) {
 800bd68:	8963      	ldrh	r3, [r4, #10]
 800bd6a:	42ab      	cmp	r3, r5
 800bd6c:	d218      	bcs.n	800bda0 <pbuf_realloc+0x48>
    rem_len = (u16_t)(rem_len - q->len);
 800bd6e:	1aeb      	subs	r3, r5, r3
 800bd70:	b29d      	uxth	r5, r3
    q->tot_len = (u16_t)(q->tot_len - shrink);
 800bd72:	8923      	ldrh	r3, [r4, #8]
 800bd74:	1bf2      	subs	r2, r6, r7
 800bd76:	4413      	add	r3, r2
 800bd78:	8123      	strh	r3, [r4, #8]
    q = q->next;
 800bd7a:	6824      	ldr	r4, [r4, #0]
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
 800bd7c:	2c00      	cmp	r4, #0
 800bd7e:	d1f3      	bne.n	800bd68 <pbuf_realloc+0x10>
 800bd80:	4b1a      	ldr	r3, [pc, #104]	@ (800bdec <pbuf_realloc+0x94>)
 800bd82:	f240 12af 	movw	r2, #431	@ 0x1af
 800bd86:	491a      	ldr	r1, [pc, #104]	@ (800bdf0 <pbuf_realloc+0x98>)
 800bd88:	481a      	ldr	r0, [pc, #104]	@ (800bdf4 <pbuf_realloc+0x9c>)
 800bd8a:	f008 f8f9 	bl	8013f80 <iprintf>
 800bd8e:	e7eb      	b.n	800bd68 <pbuf_realloc+0x10>
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
 800bd90:	4b16      	ldr	r3, [pc, #88]	@ (800bdec <pbuf_realloc+0x94>)
 800bd92:	f44f 72cc 	mov.w	r2, #408	@ 0x198
 800bd96:	4918      	ldr	r1, [pc, #96]	@ (800bdf8 <pbuf_realloc+0xa0>)
 800bd98:	4816      	ldr	r0, [pc, #88]	@ (800bdf4 <pbuf_realloc+0x9c>)
 800bd9a:	f008 f8f1 	bl	8013f80 <iprintf>
 800bd9e:	e7df      	b.n	800bd60 <pbuf_realloc+0x8>
  if (pbuf_match_allocsrc(q, PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP) && (rem_len != q->len)
 800bda0:	7b22      	ldrb	r2, [r4, #12]
 800bda2:	f012 0f0f 	tst.w	r2, #15
 800bda6:	d105      	bne.n	800bdb4 <pbuf_realloc+0x5c>
 800bda8:	42ab      	cmp	r3, r5
 800bdaa:	d003      	beq.n	800bdb4 <pbuf_realloc+0x5c>
      && ((q->flags & PBUF_FLAG_IS_CUSTOM) == 0)
 800bdac:	7b63      	ldrb	r3, [r4, #13]
 800bdae:	f013 0f02 	tst.w	r3, #2
 800bdb2:	d008      	beq.n	800bdc6 <pbuf_realloc+0x6e>
  q->len = rem_len;
 800bdb4:	8165      	strh	r5, [r4, #10]
  q->tot_len = q->len;
 800bdb6:	8125      	strh	r5, [r4, #8]
  if (q->next != NULL) {
 800bdb8:	6820      	ldr	r0, [r4, #0]
 800bdba:	b108      	cbz	r0, 800bdc0 <pbuf_realloc+0x68>
    pbuf_free(q->next);
 800bdbc:	f7ff feb8 	bl	800bb30 <pbuf_free>
  q->next = NULL;
 800bdc0:	2300      	movs	r3, #0
 800bdc2:	6023      	str	r3, [r4, #0]
}
 800bdc4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    q = (struct pbuf *)mem_trim(q, (mem_size_t)(((u8_t *)q->payload - (u8_t *)q) + rem_len));
 800bdc6:	6863      	ldr	r3, [r4, #4]
 800bdc8:	1b1b      	subs	r3, r3, r4
 800bdca:	18e9      	adds	r1, r5, r3
 800bdcc:	b289      	uxth	r1, r1
 800bdce:	4620      	mov	r0, r4
 800bdd0:	f7ff f8ce 	bl	800af70 <mem_trim>
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
 800bdd4:	4604      	mov	r4, r0
 800bdd6:	2800      	cmp	r0, #0
 800bdd8:	d1ec      	bne.n	800bdb4 <pbuf_realloc+0x5c>
 800bdda:	4b04      	ldr	r3, [pc, #16]	@ (800bdec <pbuf_realloc+0x94>)
 800bddc:	f240 12bd 	movw	r2, #445	@ 0x1bd
 800bde0:	4906      	ldr	r1, [pc, #24]	@ (800bdfc <pbuf_realloc+0xa4>)
 800bde2:	4804      	ldr	r0, [pc, #16]	@ (800bdf4 <pbuf_realloc+0x9c>)
 800bde4:	f008 f8cc 	bl	8013f80 <iprintf>
 800bde8:	e7e4      	b.n	800bdb4 <pbuf_realloc+0x5c>
 800bdea:	bf00      	nop
 800bdec:	08016674 	.word	0x08016674
 800bdf0:	080167ec 	.word	0x080167ec
 800bdf4:	08015744 	.word	0x08015744
 800bdf8:	080167d4 	.word	0x080167d4
 800bdfc:	08016804 	.word	0x08016804

0800be00 <pbuf_clen>:
 * @param p first pbuf of chain
 * @return the number of pbufs in a chain
 */
u16_t
pbuf_clen(const struct pbuf *p)
{
 800be00:	4603      	mov	r3, r0
  u16_t len;

  len = 0;
 800be02:	2000      	movs	r0, #0
  while (p != NULL) {
 800be04:	e002      	b.n	800be0c <pbuf_clen+0xc>
    ++len;
 800be06:	3001      	adds	r0, #1
 800be08:	b280      	uxth	r0, r0
    p = p->next;
 800be0a:	681b      	ldr	r3, [r3, #0]
  while (p != NULL) {
 800be0c:	2b00      	cmp	r3, #0
 800be0e:	d1fa      	bne.n	800be06 <pbuf_clen+0x6>
  }
  return len;
}
 800be10:	4770      	bx	lr
	...

0800be14 <pbuf_ref>:
 */
void
pbuf_ref(struct pbuf *p)
{
  /* pbuf given? */
  if (p != NULL) {
 800be14:	b198      	cbz	r0, 800be3e <pbuf_ref+0x2a>
{
 800be16:	b510      	push	{r4, lr}
 800be18:	4604      	mov	r4, r0
    SYS_ARCH_SET(p->ref, (LWIP_PBUF_REF_T)(p->ref + 1));
 800be1a:	f007 fb97 	bl	801354c <sys_arch_protect>
 800be1e:	7ba3      	ldrb	r3, [r4, #14]
 800be20:	3301      	adds	r3, #1
 800be22:	73a3      	strb	r3, [r4, #14]
 800be24:	f007 fb9e 	bl	8013564 <sys_arch_unprotect>
    LWIP_ASSERT("pbuf ref overflow", p->ref > 0);
 800be28:	7ba3      	ldrb	r3, [r4, #14]
 800be2a:	b103      	cbz	r3, 800be2e <pbuf_ref+0x1a>
  }
}
 800be2c:	bd10      	pop	{r4, pc}
    LWIP_ASSERT("pbuf ref overflow", p->ref > 0);
 800be2e:	4b04      	ldr	r3, [pc, #16]	@ (800be40 <pbuf_ref+0x2c>)
 800be30:	f240 3242 	movw	r2, #834	@ 0x342
 800be34:	4903      	ldr	r1, [pc, #12]	@ (800be44 <pbuf_ref+0x30>)
 800be36:	4804      	ldr	r0, [pc, #16]	@ (800be48 <pbuf_ref+0x34>)
 800be38:	f008 f8a2 	bl	8013f80 <iprintf>
}
 800be3c:	e7f6      	b.n	800be2c <pbuf_ref+0x18>
 800be3e:	4770      	bx	lr
 800be40:	08016674 	.word	0x08016674
 800be44:	08016820 	.word	0x08016820
 800be48:	08015744 	.word	0x08015744

0800be4c <pbuf_cat>:
 *
 * @see pbuf_chain()
 */
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
 800be4c:	b538      	push	{r3, r4, r5, lr}
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 800be4e:	4604      	mov	r4, r0
 800be50:	460d      	mov	r5, r1
 800be52:	2900      	cmp	r1, #0
 800be54:	bf18      	it	ne
 800be56:	2800      	cmpne	r0, #0
 800be58:	d10c      	bne.n	800be74 <pbuf_cat+0x28>
 800be5a:	4b15      	ldr	r3, [pc, #84]	@ (800beb0 <pbuf_cat+0x64>)
 800be5c:	f240 3259 	movw	r2, #857	@ 0x359
 800be60:	4914      	ldr	r1, [pc, #80]	@ (800beb4 <pbuf_cat+0x68>)
 800be62:	4815      	ldr	r0, [pc, #84]	@ (800beb8 <pbuf_cat+0x6c>)
 800be64:	f008 f88c 	bl	8013f80 <iprintf>
 800be68:	e019      	b.n	800be9e <pbuf_cat+0x52>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len = (u16_t)(p->tot_len + t->tot_len);
 800be6a:	8923      	ldrh	r3, [r4, #8]
 800be6c:	8929      	ldrh	r1, [r5, #8]
 800be6e:	440b      	add	r3, r1
 800be70:	8123      	strh	r3, [r4, #8]
  for (p = h; p->next != NULL; p = p->next) {
 800be72:	4614      	mov	r4, r2
 800be74:	6822      	ldr	r2, [r4, #0]
 800be76:	2a00      	cmp	r2, #0
 800be78:	d1f7      	bne.n	800be6a <pbuf_cat+0x1e>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
 800be7a:	8922      	ldrh	r2, [r4, #8]
 800be7c:	8963      	ldrh	r3, [r4, #10]
 800be7e:	429a      	cmp	r2, r3
 800be80:	d10e      	bne.n	800bea0 <pbuf_cat+0x54>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
 800be82:	6823      	ldr	r3, [r4, #0]
 800be84:	b133      	cbz	r3, 800be94 <pbuf_cat+0x48>
 800be86:	4b0a      	ldr	r3, [pc, #40]	@ (800beb0 <pbuf_cat+0x64>)
 800be88:	f240 3263 	movw	r2, #867	@ 0x363
 800be8c:	490b      	ldr	r1, [pc, #44]	@ (800bebc <pbuf_cat+0x70>)
 800be8e:	480a      	ldr	r0, [pc, #40]	@ (800beb8 <pbuf_cat+0x6c>)
 800be90:	f008 f876 	bl	8013f80 <iprintf>
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len = (u16_t)(p->tot_len + t->tot_len);
 800be94:	8923      	ldrh	r3, [r4, #8]
 800be96:	892a      	ldrh	r2, [r5, #8]
 800be98:	4413      	add	r3, r2
 800be9a:	8123      	strh	r3, [r4, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
 800be9c:	6025      	str	r5, [r4, #0]
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
 800be9e:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
 800bea0:	4b03      	ldr	r3, [pc, #12]	@ (800beb0 <pbuf_cat+0x64>)
 800bea2:	f240 3262 	movw	r2, #866	@ 0x362
 800bea6:	4906      	ldr	r1, [pc, #24]	@ (800bec0 <pbuf_cat+0x74>)
 800bea8:	4803      	ldr	r0, [pc, #12]	@ (800beb8 <pbuf_cat+0x6c>)
 800beaa:	f008 f869 	bl	8013f80 <iprintf>
 800beae:	e7e8      	b.n	800be82 <pbuf_cat+0x36>
 800beb0:	08016674 	.word	0x08016674
 800beb4:	08016834 	.word	0x08016834
 800beb8:	08015744 	.word	0x08015744
 800bebc:	0801689c 	.word	0x0801689c
 800bec0:	0801686c 	.word	0x0801686c

0800bec4 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
 800bec4:	b510      	push	{r4, lr}
 800bec6:	460c      	mov	r4, r1
  pbuf_cat(h, t);
 800bec8:	f7ff ffc0 	bl	800be4c <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
 800becc:	4620      	mov	r0, r4
 800bece:	f7ff ffa1 	bl	800be14 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
 800bed2:	bd10      	pop	{r4, pc}

0800bed4 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, const struct pbuf *p_from)
{
 800bed4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
              (const void *)p_to, (const void *)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 800bed8:	2900      	cmp	r1, #0
 800beda:	bf18      	it	ne
 800bedc:	2800      	cmpne	r0, #0
 800bede:	d008      	beq.n	800bef2 <pbuf_copy+0x1e>
 800bee0:	4605      	mov	r5, r0
 800bee2:	460c      	mov	r4, r1
 800bee4:	8902      	ldrh	r2, [r0, #8]
 800bee6:	890b      	ldrh	r3, [r1, #8]
 800bee8:	429a      	cmp	r2, r3
 800beea:	d302      	bcc.n	800bef2 <pbuf_copy+0x1e>
  size_t offset_to = 0, offset_from = 0, len;
 800beec:	2700      	movs	r7, #0
 800beee:	46b8      	mov	r8, r7
 800bef0:	e03c      	b.n	800bf6c <pbuf_copy+0x98>
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 800bef2:	4b3b      	ldr	r3, [pc, #236]	@ (800bfe0 <pbuf_copy+0x10c>)
 800bef4:	f240 32c9 	movw	r2, #969	@ 0x3c9
 800bef8:	493a      	ldr	r1, [pc, #232]	@ (800bfe4 <pbuf_copy+0x110>)
 800befa:	483b      	ldr	r0, [pc, #236]	@ (800bfe8 <pbuf_copy+0x114>)
 800befc:	f008 f840 	bl	8013f80 <iprintf>
 800bf00:	f06f 000f 	mvn.w	r0, #15
 800bf04:	e06a      	b.n	800bfdc <pbuf_copy+0x108>
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 800bf06:	4b36      	ldr	r3, [pc, #216]	@ (800bfe0 <pbuf_copy+0x10c>)
 800bf08:	f240 32d9 	movw	r2, #985	@ 0x3d9
 800bf0c:	4937      	ldr	r1, [pc, #220]	@ (800bfec <pbuf_copy+0x118>)
 800bf0e:	4836      	ldr	r0, [pc, #216]	@ (800bfe8 <pbuf_copy+0x114>)
 800bf10:	f008 f836 	bl	8013f80 <iprintf>
 800bf14:	e03e      	b.n	800bf94 <pbuf_copy+0xc0>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
 800bf16:	4b32      	ldr	r3, [pc, #200]	@ (800bfe0 <pbuf_copy+0x10c>)
 800bf18:	f240 32da 	movw	r2, #986	@ 0x3da
 800bf1c:	4934      	ldr	r1, [pc, #208]	@ (800bff0 <pbuf_copy+0x11c>)
 800bf1e:	4832      	ldr	r0, [pc, #200]	@ (800bfe8 <pbuf_copy+0x114>)
 800bf20:	f008 f82e 	bl	8013f80 <iprintf>
 800bf24:	e039      	b.n	800bf9a <pbuf_copy+0xc6>
      p_from = p_from->next;
    }
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
 800bf26:	682d      	ldr	r5, [r5, #0]
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL), return ERR_ARG;);
 800bf28:	fab5 f385 	clz	r3, r5
 800bf2c:	095b      	lsrs	r3, r3, #5
 800bf2e:	2c00      	cmp	r4, #0
 800bf30:	bf08      	it	eq
 800bf32:	2300      	moveq	r3, #0
 800bf34:	b913      	cbnz	r3, 800bf3c <pbuf_copy+0x68>
      offset_to = 0;
 800bf36:	f04f 0800 	mov.w	r8, #0
 800bf3a:	e036      	b.n	800bfaa <pbuf_copy+0xd6>
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL), return ERR_ARG;);
 800bf3c:	4b28      	ldr	r3, [pc, #160]	@ (800bfe0 <pbuf_copy+0x10c>)
 800bf3e:	f44f 7279 	mov.w	r2, #996	@ 0x3e4
 800bf42:	492c      	ldr	r1, [pc, #176]	@ (800bff4 <pbuf_copy+0x120>)
 800bf44:	4828      	ldr	r0, [pc, #160]	@ (800bfe8 <pbuf_copy+0x114>)
 800bf46:	f008 f81b 	bl	8013f80 <iprintf>
 800bf4a:	f06f 000f 	mvn.w	r0, #15
 800bf4e:	e045      	b.n	800bfdc <pbuf_copy+0x108>
    }

    if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
 800bf50:	6823      	ldr	r3, [r4, #0]
 800bf52:	b37b      	cbz	r3, 800bfb4 <pbuf_copy+0xe0>
 800bf54:	4b22      	ldr	r3, [pc, #136]	@ (800bfe0 <pbuf_copy+0x10c>)
 800bf56:	f240 32e9 	movw	r2, #1001	@ 0x3e9
 800bf5a:	4927      	ldr	r1, [pc, #156]	@ (800bff8 <pbuf_copy+0x124>)
 800bf5c:	4822      	ldr	r0, [pc, #136]	@ (800bfe8 <pbuf_copy+0x114>)
 800bf5e:	f008 f80f 	bl	8013f80 <iprintf>
 800bf62:	f06f 0005 	mvn.w	r0, #5
 800bf66:	e039      	b.n	800bfdc <pbuf_copy+0x108>
    if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
                 (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
 800bf68:	2c00      	cmp	r4, #0
 800bf6a:	d036      	beq.n	800bfda <pbuf_copy+0x106>
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 800bf6c:	896e      	ldrh	r6, [r5, #10]
 800bf6e:	eba6 0608 	sub.w	r6, r6, r8
 800bf72:	8963      	ldrh	r3, [r4, #10]
 800bf74:	1bdb      	subs	r3, r3, r7
 800bf76:	429e      	cmp	r6, r3
 800bf78:	d300      	bcc.n	800bf7c <pbuf_copy+0xa8>
      len = p_from->len - offset_from;
 800bf7a:	461e      	mov	r6, r3
    MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
 800bf7c:	6868      	ldr	r0, [r5, #4]
 800bf7e:	6861      	ldr	r1, [r4, #4]
 800bf80:	4632      	mov	r2, r6
 800bf82:	4439      	add	r1, r7
 800bf84:	4440      	add	r0, r8
 800bf86:	f008 fa3c 	bl	8014402 <memcpy>
    offset_to += len;
 800bf8a:	44b0      	add	r8, r6
    offset_from += len;
 800bf8c:	4437      	add	r7, r6
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 800bf8e:	896b      	ldrh	r3, [r5, #10]
 800bf90:	4543      	cmp	r3, r8
 800bf92:	d3b8      	bcc.n	800bf06 <pbuf_copy+0x32>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
 800bf94:	8963      	ldrh	r3, [r4, #10]
 800bf96:	42bb      	cmp	r3, r7
 800bf98:	d3bd      	bcc.n	800bf16 <pbuf_copy+0x42>
    if (offset_from >= p_from->len) {
 800bf9a:	8963      	ldrh	r3, [r4, #10]
 800bf9c:	42bb      	cmp	r3, r7
 800bf9e:	d801      	bhi.n	800bfa4 <pbuf_copy+0xd0>
      p_from = p_from->next;
 800bfa0:	6824      	ldr	r4, [r4, #0]
      offset_from = 0;
 800bfa2:	2700      	movs	r7, #0
    if (offset_to == p_to->len) {
 800bfa4:	896b      	ldrh	r3, [r5, #10]
 800bfa6:	4543      	cmp	r3, r8
 800bfa8:	d0bd      	beq.n	800bf26 <pbuf_copy+0x52>
    if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 800bfaa:	b11c      	cbz	r4, 800bfb4 <pbuf_copy+0xe0>
 800bfac:	8962      	ldrh	r2, [r4, #10]
 800bfae:	8923      	ldrh	r3, [r4, #8]
 800bfb0:	429a      	cmp	r2, r3
 800bfb2:	d0cd      	beq.n	800bf50 <pbuf_copy+0x7c>
    if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 800bfb4:	2d00      	cmp	r5, #0
 800bfb6:	d0d7      	beq.n	800bf68 <pbuf_copy+0x94>
 800bfb8:	896a      	ldrh	r2, [r5, #10]
 800bfba:	892b      	ldrh	r3, [r5, #8]
 800bfbc:	429a      	cmp	r2, r3
 800bfbe:	d1d3      	bne.n	800bf68 <pbuf_copy+0x94>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
 800bfc0:	682b      	ldr	r3, [r5, #0]
 800bfc2:	2b00      	cmp	r3, #0
 800bfc4:	d0d0      	beq.n	800bf68 <pbuf_copy+0x94>
 800bfc6:	4b06      	ldr	r3, [pc, #24]	@ (800bfe0 <pbuf_copy+0x10c>)
 800bfc8:	f240 32ee 	movw	r2, #1006	@ 0x3ee
 800bfcc:	490a      	ldr	r1, [pc, #40]	@ (800bff8 <pbuf_copy+0x124>)
 800bfce:	4806      	ldr	r0, [pc, #24]	@ (800bfe8 <pbuf_copy+0x114>)
 800bfd0:	f007 ffd6 	bl	8013f80 <iprintf>
 800bfd4:	f06f 0005 	mvn.w	r0, #5
 800bfd8:	e000      	b.n	800bfdc <pbuf_copy+0x108>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
 800bfda:	2000      	movs	r0, #0
}
 800bfdc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800bfe0:	08016674 	.word	0x08016674
 800bfe4:	080168ac 	.word	0x080168ac
 800bfe8:	08015744 	.word	0x08015744
 800bfec:	080168dc 	.word	0x080168dc
 800bff0:	080168f4 	.word	0x080168f4
 800bff4:	08016910 	.word	0x08016910
 800bff8:	08016920 	.word	0x08016920

0800bffc <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(const struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
 800bffc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  const struct pbuf *p;
  u16_t left = 0;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 800c000:	b130      	cbz	r0, 800c010 <pbuf_copy_partial+0x14>
 800c002:	4688      	mov	r8, r1
 800c004:	4691      	mov	r9, r2
 800c006:	4605      	mov	r5, r0
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 800c008:	b169      	cbz	r1, 800c026 <pbuf_copy_partial+0x2a>
  u16_t copied_total = 0;
 800c00a:	2700      	movs	r7, #0
  u16_t left = 0;
 800c00c:	463e      	mov	r6, r7
 800c00e:	e02a      	b.n	800c066 <pbuf_copy_partial+0x6a>
  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 800c010:	4b1d      	ldr	r3, [pc, #116]	@ (800c088 <pbuf_copy_partial+0x8c>)
 800c012:	f240 420a 	movw	r2, #1034	@ 0x40a
 800c016:	491d      	ldr	r1, [pc, #116]	@ (800c08c <pbuf_copy_partial+0x90>)
 800c018:	481d      	ldr	r0, [pc, #116]	@ (800c090 <pbuf_copy_partial+0x94>)
 800c01a:	f007 ffb1 	bl	8013f80 <iprintf>
 800c01e:	2700      	movs	r7, #0
      len = (u16_t)(len - buf_copy_len);
      offset = 0;
    }
  }
  return copied_total;
}
 800c020:	4638      	mov	r0, r7
 800c022:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 800c026:	4b18      	ldr	r3, [pc, #96]	@ (800c088 <pbuf_copy_partial+0x8c>)
 800c028:	f240 420b 	movw	r2, #1035	@ 0x40b
 800c02c:	4919      	ldr	r1, [pc, #100]	@ (800c094 <pbuf_copy_partial+0x98>)
 800c02e:	4818      	ldr	r0, [pc, #96]	@ (800c090 <pbuf_copy_partial+0x94>)
 800c030:	f007 ffa6 	bl	8013f80 <iprintf>
 800c034:	2700      	movs	r7, #0
 800c036:	e7f3      	b.n	800c020 <pbuf_copy_partial+0x24>
      buf_copy_len = (u16_t)(p->len - offset);
 800c038:	896c      	ldrh	r4, [r5, #10]
 800c03a:	1ae4      	subs	r4, r4, r3
 800c03c:	b2a4      	uxth	r4, r4
      if (buf_copy_len > len) {
 800c03e:	45a1      	cmp	r9, r4
 800c040:	d200      	bcs.n	800c044 <pbuf_copy_partial+0x48>
        buf_copy_len = len;
 800c042:	464c      	mov	r4, r9
      MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
 800c044:	6869      	ldr	r1, [r5, #4]
 800c046:	4622      	mov	r2, r4
 800c048:	4419      	add	r1, r3
 800c04a:	eb08 0006 	add.w	r0, r8, r6
 800c04e:	f008 f9d8 	bl	8014402 <memcpy>
      copied_total = (u16_t)(copied_total + buf_copy_len);
 800c052:	4427      	add	r7, r4
 800c054:	b2bf      	uxth	r7, r7
      left = (u16_t)(left + buf_copy_len);
 800c056:	4426      	add	r6, r4
 800c058:	b2b6      	uxth	r6, r6
      len = (u16_t)(len - buf_copy_len);
 800c05a:	eba9 0404 	sub.w	r4, r9, r4
 800c05e:	fa1f f984 	uxth.w	r9, r4
      offset = 0;
 800c062:	2300      	movs	r3, #0
  for (p = buf; len != 0 && p != NULL; p = p->next) {
 800c064:	682d      	ldr	r5, [r5, #0]
 800c066:	1e2a      	subs	r2, r5, #0
 800c068:	bf18      	it	ne
 800c06a:	2201      	movne	r2, #1
 800c06c:	f1b9 0f00 	cmp.w	r9, #0
 800c070:	d0d6      	beq.n	800c020 <pbuf_copy_partial+0x24>
 800c072:	2a00      	cmp	r2, #0
 800c074:	d0d4      	beq.n	800c020 <pbuf_copy_partial+0x24>
    if ((offset != 0) && (offset >= p->len)) {
 800c076:	2b00      	cmp	r3, #0
 800c078:	d0de      	beq.n	800c038 <pbuf_copy_partial+0x3c>
 800c07a:	896a      	ldrh	r2, [r5, #10]
 800c07c:	429a      	cmp	r2, r3
 800c07e:	d8db      	bhi.n	800c038 <pbuf_copy_partial+0x3c>
      offset = (u16_t)(offset - p->len);
 800c080:	1a9b      	subs	r3, r3, r2
 800c082:	b29b      	uxth	r3, r3
 800c084:	e7ee      	b.n	800c064 <pbuf_copy_partial+0x68>
 800c086:	bf00      	nop
 800c088:	08016674 	.word	0x08016674
 800c08c:	0801694c 	.word	0x0801694c
 800c090:	08015744 	.word	0x08015744
 800c094:	0801696c 	.word	0x0801696c

0800c098 <pbuf_clone>:
 *
 * @return a new pbuf or NULL if allocation fails
 */
struct pbuf *
pbuf_clone(pbuf_layer layer, pbuf_type type, struct pbuf *p)
{
 800c098:	b538      	push	{r3, r4, r5, lr}
 800c09a:	4614      	mov	r4, r2
  struct pbuf *q;
  err_t err;
  q = pbuf_alloc(layer, p->tot_len, type);
 800c09c:	460a      	mov	r2, r1
 800c09e:	8921      	ldrh	r1, [r4, #8]
 800c0a0:	f7ff fdae 	bl	800bc00 <pbuf_alloc>
  if (q == NULL) {
 800c0a4:	4605      	mov	r5, r0
 800c0a6:	b118      	cbz	r0, 800c0b0 <pbuf_clone+0x18>
    return NULL;
  }
  err = pbuf_copy(q, p);
 800c0a8:	4621      	mov	r1, r4
 800c0aa:	f7ff ff13 	bl	800bed4 <pbuf_copy>
  LWIP_UNUSED_ARG(err); /* in case of LWIP_NOASSERT */
  LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
 800c0ae:	b908      	cbnz	r0, 800c0b4 <pbuf_clone+0x1c>
  return q;
}
 800c0b0:	4628      	mov	r0, r5
 800c0b2:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
 800c0b4:	4b03      	ldr	r3, [pc, #12]	@ (800c0c4 <pbuf_clone+0x2c>)
 800c0b6:	f240 5224 	movw	r2, #1316	@ 0x524
 800c0ba:	4903      	ldr	r1, [pc, #12]	@ (800c0c8 <pbuf_clone+0x30>)
 800c0bc:	4803      	ldr	r0, [pc, #12]	@ (800c0cc <pbuf_clone+0x34>)
 800c0be:	f007 ff5f 	bl	8013f80 <iprintf>
 800c0c2:	e7f5      	b.n	800c0b0 <pbuf_clone+0x18>
 800c0c4:	08016674 	.word	0x08016674
 800c0c8:	08016990 	.word	0x08016990
 800c0cc:	08015744 	.word	0x08015744

0800c0d0 <stats_init>:
void
stats_init(void)
{
#ifdef LWIP_DEBUG
#if MEM_STATS
  lwip_stats.mem.name = "MEM";
 800c0d0:	4b02      	ldr	r3, [pc, #8]	@ (800c0dc <stats_init+0xc>)
 800c0d2:	4a03      	ldr	r2, [pc, #12]	@ (800c0e0 <stats_init+0x10>)
 800c0d4:	f8c3 20c4 	str.w	r2, [r3, #196]	@ 0xc4
#endif /* MEM_STATS */
#endif /* LWIP_DEBUG */
}
 800c0d8:	4770      	bx	lr
 800c0da:	bf00      	nop
 800c0dc:	240141b4 	.word	0x240141b4
 800c0e0:	080169a4 	.word	0x080169a4

0800c0e4 <tcp_new_port>:
 */
static u16_t
tcp_new_port(void)
{
  u8_t i;
  u16_t n = 0;
 800c0e4:	f04f 0c00 	mov.w	ip, #0
 800c0e8:	e00b      	b.n	800c102 <tcp_new_port+0x1e>
  struct tcp_pcb *pcb;

again:
  tcp_port++;
  if (tcp_port == TCP_LOCAL_PORT_RANGE_END) {
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
 800c0ea:	4b16      	ldr	r3, [pc, #88]	@ (800c144 <tcp_new_port+0x60>)
 800c0ec:	f44f 4240 	mov.w	r2, #49152	@ 0xc000
 800c0f0:	801a      	strh	r2, [r3, #0]
 800c0f2:	e00f      	b.n	800c114 <tcp_new_port+0x30>
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
      if (pcb->local_port == tcp_port) {
        n++;
 800c0f4:	f10c 0c01 	add.w	ip, ip, #1
 800c0f8:	fa1f fc8c 	uxth.w	ip, ip
        if (n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
 800c0fc:	f5bc 4f80 	cmp.w	ip, #16384	@ 0x4000
 800c100:	d21d      	bcs.n	800c13e <tcp_new_port+0x5a>
  tcp_port++;
 800c102:	4a10      	ldr	r2, [pc, #64]	@ (800c144 <tcp_new_port+0x60>)
 800c104:	8813      	ldrh	r3, [r2, #0]
 800c106:	3301      	adds	r3, #1
 800c108:	b29b      	uxth	r3, r3
 800c10a:	8013      	strh	r3, [r2, #0]
  if (tcp_port == TCP_LOCAL_PORT_RANGE_END) {
 800c10c:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800c110:	4293      	cmp	r3, r2
 800c112:	d0ea      	beq.n	800c0ea <tcp_new_port+0x6>
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 800c114:	2000      	movs	r0, #0
 800c116:	2803      	cmp	r0, #3
 800c118:	d80e      	bhi.n	800c138 <tcp_new_port+0x54>
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 800c11a:	4b0b      	ldr	r3, [pc, #44]	@ (800c148 <tcp_new_port+0x64>)
 800c11c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 800c120:	681b      	ldr	r3, [r3, #0]
 800c122:	b133      	cbz	r3, 800c132 <tcp_new_port+0x4e>
      if (pcb->local_port == tcp_port) {
 800c124:	8ad9      	ldrh	r1, [r3, #22]
 800c126:	4a07      	ldr	r2, [pc, #28]	@ (800c144 <tcp_new_port+0x60>)
 800c128:	8812      	ldrh	r2, [r2, #0]
 800c12a:	4291      	cmp	r1, r2
 800c12c:	d0e2      	beq.n	800c0f4 <tcp_new_port+0x10>
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 800c12e:	68db      	ldr	r3, [r3, #12]
 800c130:	e7f7      	b.n	800c122 <tcp_new_port+0x3e>
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 800c132:	3001      	adds	r0, #1
 800c134:	b2c0      	uxtb	r0, r0
 800c136:	e7ee      	b.n	800c116 <tcp_new_port+0x32>
        }
        goto again;
      }
    }
  }
  return tcp_port;
 800c138:	4b02      	ldr	r3, [pc, #8]	@ (800c144 <tcp_new_port+0x60>)
 800c13a:	8818      	ldrh	r0, [r3, #0]
 800c13c:	4770      	bx	lr
          return 0;
 800c13e:	2000      	movs	r0, #0
}
 800c140:	4770      	bx	lr
 800c142:	bf00      	nop
 800c144:	24000018 	.word	0x24000018
 800c148:	08018f74 	.word	0x08018f74

0800c14c <tcp_remove_listener>:
{
 800c14c:	b538      	push	{r3, r4, r5, lr}
 800c14e:	4604      	mov	r4, r0
  LWIP_ASSERT("tcp_remove_listener: invalid listener", lpcb != NULL);
 800c150:	460d      	mov	r5, r1
 800c152:	b939      	cbnz	r1, 800c164 <tcp_remove_listener+0x18>
 800c154:	4b07      	ldr	r3, [pc, #28]	@ (800c174 <tcp_remove_listener+0x28>)
 800c156:	22ff      	movs	r2, #255	@ 0xff
 800c158:	4907      	ldr	r1, [pc, #28]	@ (800c178 <tcp_remove_listener+0x2c>)
 800c15a:	4808      	ldr	r0, [pc, #32]	@ (800c17c <tcp_remove_listener+0x30>)
 800c15c:	f007 ff10 	bl	8013f80 <iprintf>
 800c160:	e000      	b.n	800c164 <tcp_remove_listener+0x18>
  for (pcb = list; pcb != NULL; pcb = pcb->next) {
 800c162:	68e4      	ldr	r4, [r4, #12]
 800c164:	b12c      	cbz	r4, 800c172 <tcp_remove_listener+0x26>
    if (pcb->listener == lpcb) {
 800c166:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
 800c168:	42ab      	cmp	r3, r5
 800c16a:	d1fa      	bne.n	800c162 <tcp_remove_listener+0x16>
      pcb->listener = NULL;
 800c16c:	2300      	movs	r3, #0
 800c16e:	67e3      	str	r3, [r4, #124]	@ 0x7c
 800c170:	e7f7      	b.n	800c162 <tcp_remove_listener+0x16>
}
 800c172:	bd38      	pop	{r3, r4, r5, pc}
 800c174:	080169a8 	.word	0x080169a8
 800c178:	080169d8 	.word	0x080169d8
 800c17c:	08015744 	.word	0x08015744

0800c180 <tcp_listen_closed>:
{
 800c180:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
 800c182:	4605      	mov	r5, r0
 800c184:	b120      	cbz	r0, 800c190 <tcp_listen_closed+0x10>
  LWIP_ASSERT("pcb->state == LISTEN", pcb->state == LISTEN);
 800c186:	7d2b      	ldrb	r3, [r5, #20]
 800c188:	2b01      	cmp	r3, #1
 800c18a:	d109      	bne.n	800c1a0 <tcp_listen_closed+0x20>
{
 800c18c:	2401      	movs	r4, #1
 800c18e:	e017      	b.n	800c1c0 <tcp_listen_closed+0x40>
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
 800c190:	4b0d      	ldr	r3, [pc, #52]	@ (800c1c8 <tcp_listen_closed+0x48>)
 800c192:	f240 1211 	movw	r2, #273	@ 0x111
 800c196:	490d      	ldr	r1, [pc, #52]	@ (800c1cc <tcp_listen_closed+0x4c>)
 800c198:	480d      	ldr	r0, [pc, #52]	@ (800c1d0 <tcp_listen_closed+0x50>)
 800c19a:	f007 fef1 	bl	8013f80 <iprintf>
 800c19e:	e7f2      	b.n	800c186 <tcp_listen_closed+0x6>
  LWIP_ASSERT("pcb->state == LISTEN", pcb->state == LISTEN);
 800c1a0:	4b09      	ldr	r3, [pc, #36]	@ (800c1c8 <tcp_listen_closed+0x48>)
 800c1a2:	f44f 7289 	mov.w	r2, #274	@ 0x112
 800c1a6:	490b      	ldr	r1, [pc, #44]	@ (800c1d4 <tcp_listen_closed+0x54>)
 800c1a8:	4809      	ldr	r0, [pc, #36]	@ (800c1d0 <tcp_listen_closed+0x50>)
 800c1aa:	f007 fee9 	bl	8013f80 <iprintf>
 800c1ae:	e7ed      	b.n	800c18c <tcp_listen_closed+0xc>
    tcp_remove_listener(*tcp_pcb_lists[i], (struct tcp_pcb_listen *)pcb);
 800c1b0:	4b09      	ldr	r3, [pc, #36]	@ (800c1d8 <tcp_listen_closed+0x58>)
 800c1b2:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 800c1b6:	4629      	mov	r1, r5
 800c1b8:	6818      	ldr	r0, [r3, #0]
 800c1ba:	f7ff ffc7 	bl	800c14c <tcp_remove_listener>
  for (i = 1; i < LWIP_ARRAYSIZE(tcp_pcb_lists); i++) {
 800c1be:	3401      	adds	r4, #1
 800c1c0:	2c03      	cmp	r4, #3
 800c1c2:	d9f5      	bls.n	800c1b0 <tcp_listen_closed+0x30>
}
 800c1c4:	bd38      	pop	{r3, r4, r5, pc}
 800c1c6:	bf00      	nop
 800c1c8:	080169a8 	.word	0x080169a8
 800c1cc:	08016a00 	.word	0x08016a00
 800c1d0:	08015744 	.word	0x08015744
 800c1d4:	08016a0c 	.word	0x08016a0c
 800c1d8:	08018f74 	.word	0x08018f74

0800c1dc <tcp_free_listen>:
{
 800c1dc:	b510      	push	{r4, lr}
 800c1de:	4604      	mov	r4, r0
  LWIP_ASSERT("tcp_free_listen: !LISTEN", pcb->state != LISTEN);
 800c1e0:	7d03      	ldrb	r3, [r0, #20]
 800c1e2:	2b01      	cmp	r3, #1
 800c1e4:	d004      	beq.n	800c1f0 <tcp_free_listen+0x14>
  memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 800c1e6:	4621      	mov	r1, r4
 800c1e8:	2002      	movs	r0, #2
 800c1ea:	f7ff f985 	bl	800b4f8 <memp_free>
}
 800c1ee:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("tcp_free_listen: !LISTEN", pcb->state != LISTEN);
 800c1f0:	4b03      	ldr	r3, [pc, #12]	@ (800c200 <tcp_free_listen+0x24>)
 800c1f2:	22df      	movs	r2, #223	@ 0xdf
 800c1f4:	4903      	ldr	r1, [pc, #12]	@ (800c204 <tcp_free_listen+0x28>)
 800c1f6:	4804      	ldr	r0, [pc, #16]	@ (800c208 <tcp_free_listen+0x2c>)
 800c1f8:	f007 fec2 	bl	8013f80 <iprintf>
 800c1fc:	e7f3      	b.n	800c1e6 <tcp_free_listen+0xa>
 800c1fe:	bf00      	nop
 800c200:	080169a8 	.word	0x080169a8
 800c204:	08016a24 	.word	0x08016a24
 800c208:	08015744 	.word	0x08015744

0800c20c <tcp_close_shutdown_fin>:
{
 800c20c:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
 800c20e:	4604      	mov	r4, r0
 800c210:	b190      	cbz	r0, 800c238 <tcp_close_shutdown_fin+0x2c>
  switch (pcb->state) {
 800c212:	7d23      	ldrb	r3, [r4, #20]
 800c214:	2b04      	cmp	r3, #4
 800c216:	d017      	beq.n	800c248 <tcp_close_shutdown_fin+0x3c>
 800c218:	2b07      	cmp	r3, #7
 800c21a:	d01d      	beq.n	800c258 <tcp_close_shutdown_fin+0x4c>
 800c21c:	2b03      	cmp	r3, #3
 800c21e:	d12c      	bne.n	800c27a <tcp_close_shutdown_fin+0x6e>
      err = tcp_send_fin(pcb);
 800c220:	4620      	mov	r0, r4
 800c222:	f003 fda7 	bl	800fd74 <tcp_send_fin>
      if (err == ERR_OK) {
 800c226:	4605      	mov	r5, r0
 800c228:	b9f0      	cbnz	r0, 800c268 <tcp_close_shutdown_fin+0x5c>
        pcb->state = FIN_WAIT_1;
 800c22a:	2305      	movs	r3, #5
 800c22c:	7523      	strb	r3, [r4, #20]
    tcp_output(pcb);
 800c22e:	4620      	mov	r0, r4
 800c230:	f003 ff26 	bl	8010080 <tcp_output>
}
 800c234:	4628      	mov	r0, r5
 800c236:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
 800c238:	4b11      	ldr	r3, [pc, #68]	@ (800c280 <tcp_close_shutdown_fin+0x74>)
 800c23a:	f44f 72ce 	mov.w	r2, #412	@ 0x19c
 800c23e:	4911      	ldr	r1, [pc, #68]	@ (800c284 <tcp_close_shutdown_fin+0x78>)
 800c240:	4811      	ldr	r0, [pc, #68]	@ (800c288 <tcp_close_shutdown_fin+0x7c>)
 800c242:	f007 fe9d 	bl	8013f80 <iprintf>
 800c246:	e7e4      	b.n	800c212 <tcp_close_shutdown_fin+0x6>
      err = tcp_send_fin(pcb);
 800c248:	4620      	mov	r0, r4
 800c24a:	f003 fd93 	bl	800fd74 <tcp_send_fin>
      if (err == ERR_OK) {
 800c24e:	4605      	mov	r5, r0
 800c250:	b950      	cbnz	r0, 800c268 <tcp_close_shutdown_fin+0x5c>
        pcb->state = FIN_WAIT_1;
 800c252:	2305      	movs	r3, #5
 800c254:	7523      	strb	r3, [r4, #20]
  if (err == ERR_OK) {
 800c256:	e7ea      	b.n	800c22e <tcp_close_shutdown_fin+0x22>
      err = tcp_send_fin(pcb);
 800c258:	4620      	mov	r0, r4
 800c25a:	f003 fd8b 	bl	800fd74 <tcp_send_fin>
      if (err == ERR_OK) {
 800c25e:	4605      	mov	r5, r0
 800c260:	b910      	cbnz	r0, 800c268 <tcp_close_shutdown_fin+0x5c>
        pcb->state = LAST_ACK;
 800c262:	2309      	movs	r3, #9
 800c264:	7523      	strb	r3, [r4, #20]
  if (err == ERR_OK) {
 800c266:	e7e2      	b.n	800c22e <tcp_close_shutdown_fin+0x22>
  } else if (err == ERR_MEM) {
 800c268:	f1b5 3fff 	cmp.w	r5, #4294967295
 800c26c:	d1e2      	bne.n	800c234 <tcp_close_shutdown_fin+0x28>
    tcp_set_flags(pcb, TF_CLOSEPEND);
 800c26e:	8b63      	ldrh	r3, [r4, #26]
 800c270:	f043 0308 	orr.w	r3, r3, #8
 800c274:	8363      	strh	r3, [r4, #26]
    return ERR_OK;
 800c276:	2500      	movs	r5, #0
 800c278:	e7dc      	b.n	800c234 <tcp_close_shutdown_fin+0x28>
  switch (pcb->state) {
 800c27a:	2500      	movs	r5, #0
 800c27c:	e7da      	b.n	800c234 <tcp_close_shutdown_fin+0x28>
 800c27e:	bf00      	nop
 800c280:	080169a8 	.word	0x080169a8
 800c284:	08016a00 	.word	0x08016a00
 800c288:	08015744 	.word	0x08015744

0800c28c <tcp_handle_closepend>:
 * OK for us to now free it.
 */
static void
tcp_handle_closepend(void)
{
  struct tcp_pcb *pcb = tcp_active_pcbs;
 800c28c:	4b09      	ldr	r3, [pc, #36]	@ (800c2b4 <tcp_handle_closepend+0x28>)
 800c28e:	6818      	ldr	r0, [r3, #0]

  while (pcb != NULL) {
 800c290:	b178      	cbz	r0, 800c2b2 <tcp_handle_closepend+0x26>
{
 800c292:	b510      	push	{r4, lr}
 800c294:	e001      	b.n	800c29a <tcp_handle_closepend+0xe>
 800c296:	4620      	mov	r0, r4
  while (pcb != NULL) {
 800c298:	b154      	cbz	r4, 800c2b0 <tcp_handle_closepend+0x24>
    struct tcp_pcb *next = pcb->next;
 800c29a:	68c4      	ldr	r4, [r0, #12]
    /* send pending FIN */
    if (pcb->flags & TF_CLOSEPEND) {
 800c29c:	8b43      	ldrh	r3, [r0, #26]
 800c29e:	f013 0f08 	tst.w	r3, #8
 800c2a2:	d0f8      	beq.n	800c296 <tcp_handle_closepend+0xa>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_handle_closepend: pending FIN\n"));
      tcp_clear_flags(pcb, TF_CLOSEPEND);
 800c2a4:	f023 0308 	bic.w	r3, r3, #8
 800c2a8:	8343      	strh	r3, [r0, #26]
      tcp_close_shutdown_fin(pcb);
 800c2aa:	f7ff ffaf 	bl	800c20c <tcp_close_shutdown_fin>
 800c2ae:	e7f2      	b.n	800c296 <tcp_handle_closepend+0xa>
    }
    pcb = next;
  }
}
 800c2b0:	bd10      	pop	{r4, pc}
 800c2b2:	4770      	bx	lr
 800c2b4:	240142dc 	.word	0x240142dc

0800c2b8 <tcp_init>:
{
 800c2b8:	b508      	push	{r3, lr}
  tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
 800c2ba:	f007 fd61 	bl	8013d80 <rand>
 800c2be:	4b02      	ldr	r3, [pc, #8]	@ (800c2c8 <tcp_init+0x10>)
 800c2c0:	4303      	orrs	r3, r0
 800c2c2:	4a02      	ldr	r2, [pc, #8]	@ (800c2cc <tcp_init+0x14>)
 800c2c4:	8013      	strh	r3, [r2, #0]
}
 800c2c6:	bd08      	pop	{r3, pc}
 800c2c8:	ffffc000 	.word	0xffffc000
 800c2cc:	24000018 	.word	0x24000018

0800c2d0 <tcp_free>:
{
 800c2d0:	b510      	push	{r4, lr}
 800c2d2:	4604      	mov	r4, r0
  LWIP_ASSERT("tcp_free: LISTEN", pcb->state != LISTEN);
 800c2d4:	7d03      	ldrb	r3, [r0, #20]
 800c2d6:	2b01      	cmp	r3, #1
 800c2d8:	d004      	beq.n	800c2e4 <tcp_free+0x14>
  memp_free(MEMP_TCP_PCB, pcb);
 800c2da:	4621      	mov	r1, r4
 800c2dc:	2001      	movs	r0, #1
 800c2de:	f7ff f90b 	bl	800b4f8 <memp_free>
}
 800c2e2:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("tcp_free: LISTEN", pcb->state != LISTEN);
 800c2e4:	4b03      	ldr	r3, [pc, #12]	@ (800c2f4 <tcp_free+0x24>)
 800c2e6:	22d4      	movs	r2, #212	@ 0xd4
 800c2e8:	4903      	ldr	r1, [pc, #12]	@ (800c2f8 <tcp_free+0x28>)
 800c2ea:	4804      	ldr	r0, [pc, #16]	@ (800c2fc <tcp_free+0x2c>)
 800c2ec:	f007 fe48 	bl	8013f80 <iprintf>
 800c2f0:	e7f3      	b.n	800c2da <tcp_free+0xa>
 800c2f2:	bf00      	nop
 800c2f4:	080169a8 	.word	0x080169a8
 800c2f8:	08016a40 	.word	0x08016a40
 800c2fc:	08015744 	.word	0x08015744

0800c300 <tcp_bind>:
{
 800c300:	b570      	push	{r4, r5, r6, lr}
 800c302:	4606      	mov	r6, r0
  if (ipaddr == NULL) {
 800c304:	460d      	mov	r5, r1
 800c306:	b159      	cbz	r1, 800c320 <tcp_bind+0x20>
  LWIP_ERROR("tcp_bind: invalid pcb", pcb != NULL, return ERR_ARG);
 800c308:	b166      	cbz	r6, 800c324 <tcp_bind+0x24>
  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
 800c30a:	7d33      	ldrb	r3, [r6, #20]
 800c30c:	b9a3      	cbnz	r3, 800c338 <tcp_bind+0x38>
  if (port == 0) {
 800c30e:	b1ea      	cbz	r2, 800c34c <tcp_bind+0x4c>
    for (i = 0; i < max_pcb_list; i++) {
 800c310:	2000      	movs	r0, #0
 800c312:	2803      	cmp	r0, #3
 800c314:	dc1e      	bgt.n	800c354 <tcp_bind+0x54>
      for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 800c316:	4b24      	ldr	r3, [pc, #144]	@ (800c3a8 <tcp_bind+0xa8>)
 800c318:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 800c31c:	681b      	ldr	r3, [r3, #0]
 800c31e:	e027      	b.n	800c370 <tcp_bind+0x70>
    ipaddr = IP4_ADDR_ANY;
 800c320:	4d22      	ldr	r5, [pc, #136]	@ (800c3ac <tcp_bind+0xac>)
 800c322:	e7f1      	b.n	800c308 <tcp_bind+0x8>
  LWIP_ERROR("tcp_bind: invalid pcb", pcb != NULL, return ERR_ARG);
 800c324:	4b22      	ldr	r3, [pc, #136]	@ (800c3b0 <tcp_bind+0xb0>)
 800c326:	f240 22a9 	movw	r2, #681	@ 0x2a9
 800c32a:	4922      	ldr	r1, [pc, #136]	@ (800c3b4 <tcp_bind+0xb4>)
 800c32c:	4822      	ldr	r0, [pc, #136]	@ (800c3b8 <tcp_bind+0xb8>)
 800c32e:	f007 fe27 	bl	8013f80 <iprintf>
 800c332:	f06f 000f 	mvn.w	r0, #15
 800c336:	e019      	b.n	800c36c <tcp_bind+0x6c>
  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
 800c338:	4b1d      	ldr	r3, [pc, #116]	@ (800c3b0 <tcp_bind+0xb0>)
 800c33a:	f240 22ab 	movw	r2, #683	@ 0x2ab
 800c33e:	491f      	ldr	r1, [pc, #124]	@ (800c3bc <tcp_bind+0xbc>)
 800c340:	481d      	ldr	r0, [pc, #116]	@ (800c3b8 <tcp_bind+0xb8>)
 800c342:	f007 fe1d 	bl	8013f80 <iprintf>
 800c346:	f06f 0005 	mvn.w	r0, #5
 800c34a:	e00f      	b.n	800c36c <tcp_bind+0x6c>
    port = tcp_new_port();
 800c34c:	f7ff feca 	bl	800c0e4 <tcp_new_port>
    if (port == 0) {
 800c350:	4602      	mov	r2, r0
 800c352:	b1e8      	cbz	r0, 800c390 <tcp_bind+0x90>
  if (!ip_addr_isany(ipaddr)
 800c354:	b115      	cbz	r5, 800c35c <tcp_bind+0x5c>
 800c356:	682b      	ldr	r3, [r5, #0]
 800c358:	b103      	cbz	r3, 800c35c <tcp_bind+0x5c>
    ip_addr_set(&pcb->local_ip, ipaddr);
 800c35a:	6033      	str	r3, [r6, #0]
  pcb->local_port = port;
 800c35c:	82f2      	strh	r2, [r6, #22]
  TCP_REG(&tcp_bound_pcbs, pcb);
 800c35e:	4b18      	ldr	r3, [pc, #96]	@ (800c3c0 <tcp_bind+0xc0>)
 800c360:	681a      	ldr	r2, [r3, #0]
 800c362:	60f2      	str	r2, [r6, #12]
 800c364:	601e      	str	r6, [r3, #0]
 800c366:	f004 f921 	bl	80105ac <tcp_timer_needed>
  return ERR_OK;
 800c36a:	2000      	movs	r0, #0
}
 800c36c:	bd70      	pop	{r4, r5, r6, pc}
      for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 800c36e:	68db      	ldr	r3, [r3, #12]
 800c370:	b163      	cbz	r3, 800c38c <tcp_bind+0x8c>
        if (cpcb->local_port == port) {
 800c372:	8ad9      	ldrh	r1, [r3, #22]
 800c374:	4291      	cmp	r1, r2
 800c376:	d1fa      	bne.n	800c36e <tcp_bind+0x6e>
                (ip_addr_isany(&cpcb->local_ip) ||
 800c378:	6819      	ldr	r1, [r3, #0]
 800c37a:	b161      	cbz	r1, 800c396 <tcp_bind+0x96>
 800c37c:	b175      	cbz	r5, 800c39c <tcp_bind+0x9c>
                 ip_addr_isany(ipaddr) ||
 800c37e:	682c      	ldr	r4, [r5, #0]
 800c380:	b17c      	cbz	r4, 800c3a2 <tcp_bind+0xa2>
            if ((IP_IS_V6(ipaddr) == IP_IS_V6_VAL(cpcb->local_ip)) &&
 800c382:	42a1      	cmp	r1, r4
 800c384:	d1f3      	bne.n	800c36e <tcp_bind+0x6e>
              return ERR_USE;
 800c386:	f06f 0007 	mvn.w	r0, #7
 800c38a:	e7ef      	b.n	800c36c <tcp_bind+0x6c>
    for (i = 0; i < max_pcb_list; i++) {
 800c38c:	3001      	adds	r0, #1
 800c38e:	e7c0      	b.n	800c312 <tcp_bind+0x12>
      return ERR_BUF;
 800c390:	f06f 0001 	mvn.w	r0, #1
 800c394:	e7ea      	b.n	800c36c <tcp_bind+0x6c>
              return ERR_USE;
 800c396:	f06f 0007 	mvn.w	r0, #7
 800c39a:	e7e7      	b.n	800c36c <tcp_bind+0x6c>
 800c39c:	f06f 0007 	mvn.w	r0, #7
 800c3a0:	e7e4      	b.n	800c36c <tcp_bind+0x6c>
 800c3a2:	f06f 0007 	mvn.w	r0, #7
 800c3a6:	e7e1      	b.n	800c36c <tcp_bind+0x6c>
 800c3a8:	08018f74 	.word	0x08018f74
 800c3ac:	08018fc0 	.word	0x08018fc0
 800c3b0:	080169a8 	.word	0x080169a8
 800c3b4:	08016a54 	.word	0x08016a54
 800c3b8:	08015744 	.word	0x08015744
 800c3bc:	08016a6c 	.word	0x08016a6c
 800c3c0:	240142e4 	.word	0x240142e4

0800c3c4 <tcp_listen_with_backlog_and_err>:
{
 800c3c4:	b570      	push	{r4, r5, r6, lr}
 800c3c6:	4616      	mov	r6, r2
  LWIP_ERROR("tcp_listen_with_backlog_and_err: invalid pcb", pcb != NULL, res = ERR_ARG; goto done);
 800c3c8:	4604      	mov	r4, r0
 800c3ca:	b340      	cbz	r0, 800c41e <tcp_listen_with_backlog_and_err+0x5a>
  LWIP_ERROR("tcp_listen_with_backlog_and_err: pcb already connected", pcb->state == CLOSED, res = ERR_CLSD; goto done);
 800c3cc:	7d03      	ldrb	r3, [r0, #20]
 800c3ce:	2b00      	cmp	r3, #0
 800c3d0:	d130      	bne.n	800c434 <tcp_listen_with_backlog_and_err+0x70>
  if (pcb->state == LISTEN) {
 800c3d2:	2b01      	cmp	r3, #1
 800c3d4:	d051      	beq.n	800c47a <tcp_listen_with_backlog_and_err+0xb6>
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
 800c3d6:	2002      	movs	r0, #2
 800c3d8:	f7ff f858 	bl	800b48c <memp_malloc>
  if (lpcb == NULL) {
 800c3dc:	4605      	mov	r5, r0
 800c3de:	2800      	cmp	r0, #0
 800c3e0:	d04f      	beq.n	800c482 <tcp_listen_with_backlog_and_err+0xbe>
  lpcb->callback_arg = pcb->callback_arg;
 800c3e2:	6923      	ldr	r3, [r4, #16]
 800c3e4:	6103      	str	r3, [r0, #16]
  lpcb->local_port = pcb->local_port;
 800c3e6:	8ae3      	ldrh	r3, [r4, #22]
 800c3e8:	82c3      	strh	r3, [r0, #22]
  lpcb->state = LISTEN;
 800c3ea:	2301      	movs	r3, #1
 800c3ec:	7503      	strb	r3, [r0, #20]
  lpcb->prio = pcb->prio;
 800c3ee:	7d63      	ldrb	r3, [r4, #21]
 800c3f0:	7543      	strb	r3, [r0, #21]
  lpcb->so_options = pcb->so_options;
 800c3f2:	7a63      	ldrb	r3, [r4, #9]
 800c3f4:	7243      	strb	r3, [r0, #9]
  lpcb->netif_idx = NETIF_NO_INDEX;
 800c3f6:	2300      	movs	r3, #0
 800c3f8:	7203      	strb	r3, [r0, #8]
  lpcb->ttl = pcb->ttl;
 800c3fa:	7ae3      	ldrb	r3, [r4, #11]
 800c3fc:	72c3      	strb	r3, [r0, #11]
  lpcb->tos = pcb->tos;
 800c3fe:	7aa3      	ldrb	r3, [r4, #10]
 800c400:	7283      	strb	r3, [r0, #10]
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
 800c402:	6823      	ldr	r3, [r4, #0]
 800c404:	6003      	str	r3, [r0, #0]
  if (pcb->local_port != 0) {
 800c406:	8ae3      	ldrh	r3, [r4, #22]
 800c408:	b33b      	cbz	r3, 800c45a <tcp_listen_with_backlog_and_err+0x96>
    TCP_RMV(&tcp_bound_pcbs, pcb);
 800c40a:	4b1f      	ldr	r3, [pc, #124]	@ (800c488 <tcp_listen_with_backlog_and_err+0xc4>)
 800c40c:	681b      	ldr	r3, [r3, #0]
 800c40e:	42a3      	cmp	r3, r4
 800c410:	d01b      	beq.n	800c44a <tcp_listen_with_backlog_and_err+0x86>
 800c412:	b303      	cbz	r3, 800c456 <tcp_listen_with_backlog_and_err+0x92>
 800c414:	68da      	ldr	r2, [r3, #12]
 800c416:	42a2      	cmp	r2, r4
 800c418:	d01b      	beq.n	800c452 <tcp_listen_with_backlog_and_err+0x8e>
 800c41a:	4613      	mov	r3, r2
 800c41c:	e7f9      	b.n	800c412 <tcp_listen_with_backlog_and_err+0x4e>
  LWIP_ERROR("tcp_listen_with_backlog_and_err: invalid pcb", pcb != NULL, res = ERR_ARG; goto done);
 800c41e:	4b1b      	ldr	r3, [pc, #108]	@ (800c48c <tcp_listen_with_backlog_and_err+0xc8>)
 800c420:	f240 3259 	movw	r2, #857	@ 0x359
 800c424:	491a      	ldr	r1, [pc, #104]	@ (800c490 <tcp_listen_with_backlog_and_err+0xcc>)
 800c426:	481b      	ldr	r0, [pc, #108]	@ (800c494 <tcp_listen_with_backlog_and_err+0xd0>)
 800c428:	f007 fdaa 	bl	8013f80 <iprintf>
  struct tcp_pcb_listen *lpcb = NULL;
 800c42c:	4625      	mov	r5, r4
  LWIP_ERROR("tcp_listen_with_backlog_and_err: invalid pcb", pcb != NULL, res = ERR_ARG; goto done);
 800c42e:	f06f 030f 	mvn.w	r3, #15
 800c432:	e01e      	b.n	800c472 <tcp_listen_with_backlog_and_err+0xae>
  LWIP_ERROR("tcp_listen_with_backlog_and_err: pcb already connected", pcb->state == CLOSED, res = ERR_CLSD; goto done);
 800c434:	4b15      	ldr	r3, [pc, #84]	@ (800c48c <tcp_listen_with_backlog_and_err+0xc8>)
 800c436:	f240 325a 	movw	r2, #858	@ 0x35a
 800c43a:	4917      	ldr	r1, [pc, #92]	@ (800c498 <tcp_listen_with_backlog_and_err+0xd4>)
 800c43c:	4815      	ldr	r0, [pc, #84]	@ (800c494 <tcp_listen_with_backlog_and_err+0xd0>)
 800c43e:	f007 fd9f 	bl	8013f80 <iprintf>
 800c442:	f06f 030e 	mvn.w	r3, #14
  struct tcp_pcb_listen *lpcb = NULL;
 800c446:	2500      	movs	r5, #0
  LWIP_ERROR("tcp_listen_with_backlog_and_err: pcb already connected", pcb->state == CLOSED, res = ERR_CLSD; goto done);
 800c448:	e013      	b.n	800c472 <tcp_listen_with_backlog_and_err+0xae>
    TCP_RMV(&tcp_bound_pcbs, pcb);
 800c44a:	68da      	ldr	r2, [r3, #12]
 800c44c:	4b0e      	ldr	r3, [pc, #56]	@ (800c488 <tcp_listen_with_backlog_and_err+0xc4>)
 800c44e:	601a      	str	r2, [r3, #0]
 800c450:	e001      	b.n	800c456 <tcp_listen_with_backlog_and_err+0x92>
 800c452:	68e2      	ldr	r2, [r4, #12]
 800c454:	60da      	str	r2, [r3, #12]
 800c456:	2300      	movs	r3, #0
 800c458:	60e3      	str	r3, [r4, #12]
  tcp_free(pcb);
 800c45a:	4620      	mov	r0, r4
 800c45c:	f7ff ff38 	bl	800c2d0 <tcp_free>
  lpcb->accept = tcp_accept_null;
 800c460:	4b0e      	ldr	r3, [pc, #56]	@ (800c49c <tcp_listen_with_backlog_and_err+0xd8>)
 800c462:	61ab      	str	r3, [r5, #24]
  TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
 800c464:	4b0e      	ldr	r3, [pc, #56]	@ (800c4a0 <tcp_listen_with_backlog_and_err+0xdc>)
 800c466:	681a      	ldr	r2, [r3, #0]
 800c468:	60ea      	str	r2, [r5, #12]
 800c46a:	601d      	str	r5, [r3, #0]
 800c46c:	f004 f89e 	bl	80105ac <tcp_timer_needed>
  res = ERR_OK;
 800c470:	2300      	movs	r3, #0
  if (err != NULL) {
 800c472:	b106      	cbz	r6, 800c476 <tcp_listen_with_backlog_and_err+0xb2>
    *err = res;
 800c474:	7033      	strb	r3, [r6, #0]
}
 800c476:	4628      	mov	r0, r5
 800c478:	bd70      	pop	{r4, r5, r6, pc}
    lpcb = (struct tcp_pcb_listen *)pcb;
 800c47a:	4605      	mov	r5, r0
    res = ERR_ALREADY;
 800c47c:	f06f 0308 	mvn.w	r3, #8
 800c480:	e7f7      	b.n	800c472 <tcp_listen_with_backlog_and_err+0xae>
    res = ERR_MEM;
 800c482:	f04f 33ff 	mov.w	r3, #4294967295
 800c486:	e7f4      	b.n	800c472 <tcp_listen_with_backlog_and_err+0xae>
 800c488:	240142e4 	.word	0x240142e4
 800c48c:	080169a8 	.word	0x080169a8
 800c490:	08016a94 	.word	0x08016a94
 800c494:	08015744 	.word	0x08015744
 800c498:	08016ac4 	.word	0x08016ac4
 800c49c:	0800c9e9 	.word	0x0800c9e9
 800c4a0:	240142e0 	.word	0x240142e0

0800c4a4 <tcp_update_rcv_ann_wnd>:
{
 800c4a4:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("tcp_update_rcv_ann_wnd: invalid pcb", pcb != NULL);
 800c4a6:	4604      	mov	r4, r0
 800c4a8:	b198      	cbz	r0, 800c4d2 <tcp_update_rcv_ann_wnd+0x2e>
  new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 800c4aa:	6a65      	ldr	r5, [r4, #36]	@ 0x24
 800c4ac:	8d21      	ldrh	r1, [r4, #40]	@ 0x28
 800c4ae:	1868      	adds	r0, r5, r1
  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 800c4b0:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 800c4b2:	f8b4 e032 	ldrh.w	lr, [r4, #50]	@ 0x32
 800c4b6:	f640 3c68 	movw	ip, #2920	@ 0xb68
 800c4ba:	45e6      	cmp	lr, ip
 800c4bc:	bf94      	ite	ls
 800c4be:	eb02 030e 	addls.w	r3, r2, lr
 800c4c2:	eb02 030c 	addhi.w	r3, r2, ip
 800c4c6:	1ac3      	subs	r3, r0, r3
 800c4c8:	2b00      	cmp	r3, #0
 800c4ca:	db0a      	blt.n	800c4e2 <tcp_update_rcv_ann_wnd+0x3e>
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 800c4cc:	8561      	strh	r1, [r4, #42]	@ 0x2a
    return new_right_edge - pcb->rcv_ann_right_edge;
 800c4ce:	1a80      	subs	r0, r0, r2
}
 800c4d0:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("tcp_update_rcv_ann_wnd: invalid pcb", pcb != NULL);
 800c4d2:	4b0e      	ldr	r3, [pc, #56]	@ (800c50c <tcp_update_rcv_ann_wnd+0x68>)
 800c4d4:	f240 32a6 	movw	r2, #934	@ 0x3a6
 800c4d8:	490d      	ldr	r1, [pc, #52]	@ (800c510 <tcp_update_rcv_ann_wnd+0x6c>)
 800c4da:	480e      	ldr	r0, [pc, #56]	@ (800c514 <tcp_update_rcv_ann_wnd+0x70>)
 800c4dc:	f007 fd50 	bl	8013f80 <iprintf>
 800c4e0:	e7e3      	b.n	800c4aa <tcp_update_rcv_ann_wnd+0x6>
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 800c4e2:	1aab      	subs	r3, r5, r2
 800c4e4:	2b00      	cmp	r3, #0
 800c4e6:	dd03      	ble.n	800c4f0 <tcp_update_rcv_ann_wnd+0x4c>
      pcb->rcv_ann_wnd = 0;
 800c4e8:	2300      	movs	r3, #0
 800c4ea:	8563      	strh	r3, [r4, #42]	@ 0x2a
    return 0;
 800c4ec:	2000      	movs	r0, #0
 800c4ee:	e7ef      	b.n	800c4d0 <tcp_update_rcv_ann_wnd+0x2c>
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
 800c4f0:	1b55      	subs	r5, r2, r5
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
 800c4f2:	f5b5 3f80 	cmp.w	r5, #65536	@ 0x10000
 800c4f6:	d201      	bcs.n	800c4fc <tcp_update_rcv_ann_wnd+0x58>
      pcb->rcv_ann_wnd = (tcpwnd_size_t)new_rcv_ann_wnd;
 800c4f8:	8565      	strh	r5, [r4, #42]	@ 0x2a
 800c4fa:	e7f7      	b.n	800c4ec <tcp_update_rcv_ann_wnd+0x48>
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
 800c4fc:	4b03      	ldr	r3, [pc, #12]	@ (800c50c <tcp_update_rcv_ann_wnd+0x68>)
 800c4fe:	f240 32b6 	movw	r2, #950	@ 0x3b6
 800c502:	4905      	ldr	r1, [pc, #20]	@ (800c518 <tcp_update_rcv_ann_wnd+0x74>)
 800c504:	4803      	ldr	r0, [pc, #12]	@ (800c514 <tcp_update_rcv_ann_wnd+0x70>)
 800c506:	f007 fd3b 	bl	8013f80 <iprintf>
 800c50a:	e7f5      	b.n	800c4f8 <tcp_update_rcv_ann_wnd+0x54>
 800c50c:	080169a8 	.word	0x080169a8
 800c510:	08016afc 	.word	0x08016afc
 800c514:	08015744 	.word	0x08015744
 800c518:	08016b20 	.word	0x08016b20

0800c51c <tcp_recved>:
{
 800c51c:	b538      	push	{r3, r4, r5, lr}
  LWIP_ERROR("tcp_recved: invalid pcb", pcb != NULL, return);
 800c51e:	b1c0      	cbz	r0, 800c552 <tcp_recved+0x36>
 800c520:	460c      	mov	r4, r1
 800c522:	4605      	mov	r5, r0
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
 800c524:	7d03      	ldrb	r3, [r0, #20]
 800c526:	2b01      	cmp	r3, #1
 800c528:	d01b      	beq.n	800c562 <tcp_recved+0x46>
  rcv_wnd = (tcpwnd_size_t)(pcb->rcv_wnd + len);
 800c52a:	8d2b      	ldrh	r3, [r5, #40]	@ 0x28
 800c52c:	1919      	adds	r1, r3, r4
 800c52e:	b289      	uxth	r1, r1
  if ((rcv_wnd > TCP_WND_MAX(pcb)) || (rcv_wnd < pcb->rcv_wnd)) {
 800c530:	f241 62d0 	movw	r2, #5840	@ 0x16d0
 800c534:	4291      	cmp	r1, r2
 800c536:	d801      	bhi.n	800c53c <tcp_recved+0x20>
 800c538:	428b      	cmp	r3, r1
 800c53a:	d91a      	bls.n	800c572 <tcp_recved+0x56>
    pcb->rcv_wnd = TCP_WND_MAX(pcb);
 800c53c:	f241 63d0 	movw	r3, #5840	@ 0x16d0
 800c540:	852b      	strh	r3, [r5, #40]	@ 0x28
  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
 800c542:	4628      	mov	r0, r5
 800c544:	f7ff ffae 	bl	800c4a4 <tcp_update_rcv_ann_wnd>
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 800c548:	f240 53b3 	movw	r3, #1459	@ 0x5b3
 800c54c:	4298      	cmp	r0, r3
 800c54e:	d812      	bhi.n	800c576 <tcp_recved+0x5a>
}
 800c550:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ERROR("tcp_recved: invalid pcb", pcb != NULL, return);
 800c552:	4b0d      	ldr	r3, [pc, #52]	@ (800c588 <tcp_recved+0x6c>)
 800c554:	f240 32cf 	movw	r2, #975	@ 0x3cf
 800c558:	490c      	ldr	r1, [pc, #48]	@ (800c58c <tcp_recved+0x70>)
 800c55a:	480d      	ldr	r0, [pc, #52]	@ (800c590 <tcp_recved+0x74>)
 800c55c:	f007 fd10 	bl	8013f80 <iprintf>
 800c560:	e7f6      	b.n	800c550 <tcp_recved+0x34>
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
 800c562:	4b09      	ldr	r3, [pc, #36]	@ (800c588 <tcp_recved+0x6c>)
 800c564:	f240 32d2 	movw	r2, #978	@ 0x3d2
 800c568:	490a      	ldr	r1, [pc, #40]	@ (800c594 <tcp_recved+0x78>)
 800c56a:	4809      	ldr	r0, [pc, #36]	@ (800c590 <tcp_recved+0x74>)
 800c56c:	f007 fd08 	bl	8013f80 <iprintf>
 800c570:	e7db      	b.n	800c52a <tcp_recved+0xe>
    pcb->rcv_wnd = rcv_wnd;
 800c572:	8529      	strh	r1, [r5, #40]	@ 0x28
 800c574:	e7e5      	b.n	800c542 <tcp_recved+0x26>
    tcp_ack_now(pcb);
 800c576:	8b6b      	ldrh	r3, [r5, #26]
 800c578:	f043 0302 	orr.w	r3, r3, #2
 800c57c:	836b      	strh	r3, [r5, #26]
    tcp_output(pcb);
 800c57e:	4628      	mov	r0, r5
 800c580:	f003 fd7e 	bl	8010080 <tcp_output>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: received %"U16_F" bytes, wnd %"TCPWNDSIZE_F" (%"TCPWNDSIZE_F").\n",
 800c584:	e7e4      	b.n	800c550 <tcp_recved+0x34>
 800c586:	bf00      	nop
 800c588:	080169a8 	.word	0x080169a8
 800c58c:	08016b3c 	.word	0x08016b3c
 800c590:	08015744 	.word	0x08015744
 800c594:	08016b54 	.word	0x08016b54

0800c598 <tcp_seg_free>:
  if (seg != NULL) {
 800c598:	b150      	cbz	r0, 800c5b0 <tcp_seg_free+0x18>
{
 800c59a:	b510      	push	{r4, lr}
 800c59c:	4604      	mov	r4, r0
    if (seg->p != NULL) {
 800c59e:	6840      	ldr	r0, [r0, #4]
 800c5a0:	b108      	cbz	r0, 800c5a6 <tcp_seg_free+0xe>
      pbuf_free(seg->p);
 800c5a2:	f7ff fac5 	bl	800bb30 <pbuf_free>
    memp_free(MEMP_TCP_SEG, seg);
 800c5a6:	4621      	mov	r1, r4
 800c5a8:	2003      	movs	r0, #3
 800c5aa:	f7fe ffa5 	bl	800b4f8 <memp_free>
}
 800c5ae:	bd10      	pop	{r4, pc}
 800c5b0:	4770      	bx	lr

0800c5b2 <tcp_segs_free>:
  while (seg != NULL) {
 800c5b2:	b138      	cbz	r0, 800c5c4 <tcp_segs_free+0x12>
{
 800c5b4:	b510      	push	{r4, lr}
    struct tcp_seg *next = seg->next;
 800c5b6:	6804      	ldr	r4, [r0, #0]
    tcp_seg_free(seg);
 800c5b8:	f7ff ffee 	bl	800c598 <tcp_seg_free>
    seg = next;
 800c5bc:	4620      	mov	r0, r4
  while (seg != NULL) {
 800c5be:	2c00      	cmp	r4, #0
 800c5c0:	d1f9      	bne.n	800c5b6 <tcp_segs_free+0x4>
}
 800c5c2:	bd10      	pop	{r4, pc}
 800c5c4:	4770      	bx	lr
	...

0800c5c8 <tcp_seg_copy>:
{
 800c5c8:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("tcp_seg_copy: invalid seg", seg != NULL);
 800c5ca:	4605      	mov	r5, r0
 800c5cc:	b198      	cbz	r0, 800c5f6 <tcp_seg_copy+0x2e>
  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
 800c5ce:	2003      	movs	r0, #3
 800c5d0:	f7fe ff5c 	bl	800b48c <memp_malloc>
  if (cseg == NULL) {
 800c5d4:	4604      	mov	r4, r0
 800c5d6:	b160      	cbz	r0, 800c5f2 <tcp_seg_copy+0x2a>
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg));
 800c5d8:	682b      	ldr	r3, [r5, #0]
 800c5da:	6868      	ldr	r0, [r5, #4]
 800c5dc:	68a9      	ldr	r1, [r5, #8]
 800c5de:	68ea      	ldr	r2, [r5, #12]
 800c5e0:	6023      	str	r3, [r4, #0]
 800c5e2:	6060      	str	r0, [r4, #4]
 800c5e4:	60a1      	str	r1, [r4, #8]
 800c5e6:	60e2      	str	r2, [r4, #12]
 800c5e8:	692b      	ldr	r3, [r5, #16]
 800c5ea:	6123      	str	r3, [r4, #16]
  pbuf_ref(cseg->p);
 800c5ec:	6860      	ldr	r0, [r4, #4]
 800c5ee:	f7ff fc11 	bl	800be14 <pbuf_ref>
}
 800c5f2:	4620      	mov	r0, r4
 800c5f4:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("tcp_seg_copy: invalid seg", seg != NULL);
 800c5f6:	4b04      	ldr	r3, [pc, #16]	@ (800c608 <tcp_seg_copy+0x40>)
 800c5f8:	f240 6282 	movw	r2, #1666	@ 0x682
 800c5fc:	4903      	ldr	r1, [pc, #12]	@ (800c60c <tcp_seg_copy+0x44>)
 800c5fe:	4804      	ldr	r0, [pc, #16]	@ (800c610 <tcp_seg_copy+0x48>)
 800c600:	f007 fcbe 	bl	8013f80 <iprintf>
 800c604:	e7e3      	b.n	800c5ce <tcp_seg_copy+0x6>
 800c606:	bf00      	nop
 800c608:	080169a8 	.word	0x080169a8
 800c60c:	08016b7c 	.word	0x08016b7c
 800c610:	08015744 	.word	0x08015744

0800c614 <tcp_arg>:
tcp_arg(struct tcp_pcb *pcb, void *arg)
{
  LWIP_ASSERT_CORE_LOCKED();
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  if (pcb != NULL) {
 800c614:	b100      	cbz	r0, 800c618 <tcp_arg+0x4>
    pcb->callback_arg = arg;
 800c616:	6101      	str	r1, [r0, #16]
  }
}
 800c618:	4770      	bx	lr
	...

0800c61c <tcp_recv>:
 */
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
 800c61c:	b180      	cbz	r0, 800c640 <tcp_recv+0x24>
{
 800c61e:	b538      	push	{r3, r4, r5, lr}
 800c620:	460c      	mov	r4, r1
 800c622:	4605      	mov	r5, r0
    LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
 800c624:	7d03      	ldrb	r3, [r0, #20]
 800c626:	2b01      	cmp	r3, #1
 800c628:	d002      	beq.n	800c630 <tcp_recv+0x14>
    pcb->recv = recv;
 800c62a:	f8c5 4084 	str.w	r4, [r5, #132]	@ 0x84
  }
}
 800c62e:	bd38      	pop	{r3, r4, r5, pc}
    LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
 800c630:	4b04      	ldr	r3, [pc, #16]	@ (800c644 <tcp_recv+0x28>)
 800c632:	f240 72df 	movw	r2, #2015	@ 0x7df
 800c636:	4904      	ldr	r1, [pc, #16]	@ (800c648 <tcp_recv+0x2c>)
 800c638:	4804      	ldr	r0, [pc, #16]	@ (800c64c <tcp_recv+0x30>)
 800c63a:	f007 fca1 	bl	8013f80 <iprintf>
 800c63e:	e7f4      	b.n	800c62a <tcp_recv+0xe>
 800c640:	4770      	bx	lr
 800c642:	bf00      	nop
 800c644:	080169a8 	.word	0x080169a8
 800c648:	08016b98 	.word	0x08016b98
 800c64c:	08015744 	.word	0x08015744

0800c650 <tcp_sent>:
 */
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
 800c650:	b180      	cbz	r0, 800c674 <tcp_sent+0x24>
{
 800c652:	b538      	push	{r3, r4, r5, lr}
 800c654:	460c      	mov	r4, r1
 800c656:	4605      	mov	r5, r0
    LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
 800c658:	7d03      	ldrb	r3, [r0, #20]
 800c65a:	2b01      	cmp	r3, #1
 800c65c:	d002      	beq.n	800c664 <tcp_sent+0x14>
    pcb->sent = sent;
 800c65e:	f8c5 4080 	str.w	r4, [r5, #128]	@ 0x80
  }
}
 800c662:	bd38      	pop	{r3, r4, r5, pc}
    LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
 800c664:	4b04      	ldr	r3, [pc, #16]	@ (800c678 <tcp_sent+0x28>)
 800c666:	f240 72f3 	movw	r2, #2035	@ 0x7f3
 800c66a:	4904      	ldr	r1, [pc, #16]	@ (800c67c <tcp_sent+0x2c>)
 800c66c:	4804      	ldr	r0, [pc, #16]	@ (800c680 <tcp_sent+0x30>)
 800c66e:	f007 fc87 	bl	8013f80 <iprintf>
 800c672:	e7f4      	b.n	800c65e <tcp_sent+0xe>
 800c674:	4770      	bx	lr
 800c676:	bf00      	nop
 800c678:	080169a8 	.word	0x080169a8
 800c67c:	08016bc0 	.word	0x08016bc0
 800c680:	08015744 	.word	0x08015744

0800c684 <tcp_err>:
 */
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
 800c684:	b180      	cbz	r0, 800c6a8 <tcp_err+0x24>
{
 800c686:	b538      	push	{r3, r4, r5, lr}
 800c688:	460c      	mov	r4, r1
 800c68a:	4605      	mov	r5, r0
    LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
 800c68c:	7d03      	ldrb	r3, [r0, #20]
 800c68e:	2b01      	cmp	r3, #1
 800c690:	d002      	beq.n	800c698 <tcp_err+0x14>
    pcb->errf = err;
 800c692:	f8c5 4090 	str.w	r4, [r5, #144]	@ 0x90
  }
}
 800c696:	bd38      	pop	{r3, r4, r5, pc}
    LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
 800c698:	4b04      	ldr	r3, [pc, #16]	@ (800c6ac <tcp_err+0x28>)
 800c69a:	f640 020d 	movw	r2, #2061	@ 0x80d
 800c69e:	4904      	ldr	r1, [pc, #16]	@ (800c6b0 <tcp_err+0x2c>)
 800c6a0:	4804      	ldr	r0, [pc, #16]	@ (800c6b4 <tcp_err+0x30>)
 800c6a2:	f007 fc6d 	bl	8013f80 <iprintf>
 800c6a6:	e7f4      	b.n	800c692 <tcp_err+0xe>
 800c6a8:	4770      	bx	lr
 800c6aa:	bf00      	nop
 800c6ac:	080169a8 	.word	0x080169a8
 800c6b0:	08016be8 	.word	0x08016be8
 800c6b4:	08015744 	.word	0x08015744

0800c6b8 <tcp_accept>:
 */
void
tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
{
  LWIP_ASSERT_CORE_LOCKED();
  if ((pcb != NULL) && (pcb->state == LISTEN)) {
 800c6b8:	b110      	cbz	r0, 800c6c0 <tcp_accept+0x8>
 800c6ba:	7d02      	ldrb	r2, [r0, #20]
 800c6bc:	2a01      	cmp	r2, #1
 800c6be:	d000      	beq.n	800c6c2 <tcp_accept+0xa>
    struct tcp_pcb_listen *lpcb = (struct tcp_pcb_listen *)pcb;
    lpcb->accept = accept;
  }
}
 800c6c0:	4770      	bx	lr
    lpcb->accept = accept;
 800c6c2:	6181      	str	r1, [r0, #24]
}
 800c6c4:	e7fc      	b.n	800c6c0 <tcp_accept+0x8>
	...

0800c6c8 <tcp_poll>:
 * the application may use the polling functionality to call tcp_write()
 * again when the connection has been idle for a while.
 */
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
 800c6c8:	b570      	push	{r4, r5, r6, lr}
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_poll: invalid pcb", pcb != NULL, return);
 800c6ca:	b148      	cbz	r0, 800c6e0 <tcp_poll+0x18>
 800c6cc:	460d      	mov	r5, r1
 800c6ce:	4614      	mov	r4, r2
 800c6d0:	4606      	mov	r6, r0
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
 800c6d2:	7d03      	ldrb	r3, [r0, #20]
 800c6d4:	2b01      	cmp	r3, #1
 800c6d6:	d00b      	beq.n	800c6f0 <tcp_poll+0x28>

#if LWIP_CALLBACK_API
  pcb->poll = poll;
 800c6d8:	f8c6 508c 	str.w	r5, [r6, #140]	@ 0x8c
#else /* LWIP_CALLBACK_API */
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */
  pcb->pollinterval = interval;
 800c6dc:	7774      	strb	r4, [r6, #29]
}
 800c6de:	bd70      	pop	{r4, r5, r6, pc}
  LWIP_ERROR("tcp_poll: invalid pcb", pcb != NULL, return);
 800c6e0:	4b07      	ldr	r3, [pc, #28]	@ (800c700 <tcp_poll+0x38>)
 800c6e2:	f640 023d 	movw	r2, #2109	@ 0x83d
 800c6e6:	4907      	ldr	r1, [pc, #28]	@ (800c704 <tcp_poll+0x3c>)
 800c6e8:	4807      	ldr	r0, [pc, #28]	@ (800c708 <tcp_poll+0x40>)
 800c6ea:	f007 fc49 	bl	8013f80 <iprintf>
 800c6ee:	e7f6      	b.n	800c6de <tcp_poll+0x16>
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
 800c6f0:	4b03      	ldr	r3, [pc, #12]	@ (800c700 <tcp_poll+0x38>)
 800c6f2:	f640 023e 	movw	r2, #2110	@ 0x83e
 800c6f6:	4905      	ldr	r1, [pc, #20]	@ (800c70c <tcp_poll+0x44>)
 800c6f8:	4803      	ldr	r0, [pc, #12]	@ (800c708 <tcp_poll+0x40>)
 800c6fa:	f007 fc41 	bl	8013f80 <iprintf>
 800c6fe:	e7eb      	b.n	800c6d8 <tcp_poll+0x10>
 800c700:	080169a8 	.word	0x080169a8
 800c704:	08016c10 	.word	0x08016c10
 800c708:	08015744 	.word	0x08015744
 800c70c:	08016c28 	.word	0x08016c28

0800c710 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(struct tcp_pcb *pcb)
{
 800c710:	b508      	push	{r3, lr}
  LWIP_ASSERT("tcp_next_iss: invalid pcb", pcb != NULL);
  return LWIP_HOOK_TCP_ISN(&pcb->local_ip, pcb->local_port, &pcb->remote_ip, pcb->remote_port);
#else /* LWIP_HOOK_TCP_ISN */
  static u32_t iss = 6510;

  LWIP_ASSERT("tcp_next_iss: invalid pcb", pcb != NULL);
 800c712:	b130      	cbz	r0, 800c722 <tcp_next_iss+0x12>
  LWIP_UNUSED_ARG(pcb);

  iss += tcp_ticks;       /* XXX */
 800c714:	4b07      	ldr	r3, [pc, #28]	@ (800c734 <tcp_next_iss+0x24>)
 800c716:	6818      	ldr	r0, [r3, #0]
 800c718:	4a07      	ldr	r2, [pc, #28]	@ (800c738 <tcp_next_iss+0x28>)
 800c71a:	6812      	ldr	r2, [r2, #0]
 800c71c:	4410      	add	r0, r2
 800c71e:	6018      	str	r0, [r3, #0]
  return iss;
#endif /* LWIP_HOOK_TCP_ISN */
}
 800c720:	bd08      	pop	{r3, pc}
  LWIP_ASSERT("tcp_next_iss: invalid pcb", pcb != NULL);
 800c722:	4b06      	ldr	r3, [pc, #24]	@ (800c73c <tcp_next_iss+0x2c>)
 800c724:	f640 02af 	movw	r2, #2223	@ 0x8af
 800c728:	4905      	ldr	r1, [pc, #20]	@ (800c740 <tcp_next_iss+0x30>)
 800c72a:	4806      	ldr	r0, [pc, #24]	@ (800c744 <tcp_next_iss+0x34>)
 800c72c:	f007 fc28 	bl	8013f80 <iprintf>
 800c730:	e7f0      	b.n	800c714 <tcp_next_iss+0x4>
 800c732:	bf00      	nop
 800c734:	24000014 	.word	0x24000014
 800c738:	240142e8 	.word	0x240142e8
 800c73c:	080169a8 	.word	0x080169a8
 800c740:	08016c48 	.word	0x08016c48
 800c744:	08015744 	.word	0x08015744

0800c748 <tcp_eff_send_mss_netif>:
 * by calculating the minimum of TCP_MSS and the mtu (if set) of the target
 * netif (if not NULL).
 */
u16_t
tcp_eff_send_mss_netif(u16_t sendmss, struct netif *outif, const ip_addr_t *dest)
{
 800c748:	b538      	push	{r3, r4, r5, lr}
 800c74a:	4605      	mov	r5, r0
 800c74c:	460c      	mov	r4, r1
  u16_t mss_s;
  u16_t mtu;

  LWIP_UNUSED_ARG(dest); /* in case IPv6 is disabled */

  LWIP_ASSERT("tcp_eff_send_mss_netif: invalid dst_ip", dest != NULL);
 800c74e:	b15a      	cbz	r2, 800c768 <tcp_eff_send_mss_netif+0x20>
  else
#endif /* LWIP_IPV4 */
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
  {
    if (outif == NULL) {
 800c750:	b144      	cbz	r4, 800c764 <tcp_eff_send_mss_netif+0x1c>
      return sendmss;
    }
    mtu = outif->mtu;
 800c752:	8ca3      	ldrh	r3, [r4, #36]	@ 0x24
  }
#endif /* LWIP_IPV4 */

  if (mtu != 0) {
 800c754:	b133      	cbz	r3, 800c764 <tcp_eff_send_mss_netif+0x1c>
#if LWIP_IPV4
    {
      offset = IP_HLEN + TCP_HLEN;
    }
#endif /* LWIP_IPV4 */
    mss_s = (mtu > offset) ? (u16_t)(mtu - offset) : 0;
 800c756:	2b28      	cmp	r3, #40	@ 0x28
 800c758:	d90e      	bls.n	800c778 <tcp_eff_send_mss_netif+0x30>
 800c75a:	3b28      	subs	r3, #40	@ 0x28
 800c75c:	b29b      	uxth	r3, r3
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
 800c75e:	429d      	cmp	r5, r3
 800c760:	bf28      	it	cs
 800c762:	461d      	movcs	r5, r3
  }
  return sendmss;
}
 800c764:	4628      	mov	r0, r5
 800c766:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("tcp_eff_send_mss_netif: invalid dst_ip", dest != NULL);
 800c768:	4b04      	ldr	r3, [pc, #16]	@ (800c77c <tcp_eff_send_mss_netif+0x34>)
 800c76a:	f640 02c5 	movw	r2, #2245	@ 0x8c5
 800c76e:	4904      	ldr	r1, [pc, #16]	@ (800c780 <tcp_eff_send_mss_netif+0x38>)
 800c770:	4804      	ldr	r0, [pc, #16]	@ (800c784 <tcp_eff_send_mss_netif+0x3c>)
 800c772:	f007 fc05 	bl	8013f80 <iprintf>
 800c776:	e7eb      	b.n	800c750 <tcp_eff_send_mss_netif+0x8>
    mss_s = (mtu > offset) ? (u16_t)(mtu - offset) : 0;
 800c778:	2300      	movs	r3, #0
 800c77a:	e7f0      	b.n	800c75e <tcp_eff_send_mss_netif+0x16>
 800c77c:	080169a8 	.word	0x080169a8
 800c780:	08016c64 	.word	0x08016c64
 800c784:	08015744 	.word	0x08015744

0800c788 <tcp_free_ooseq>:

#if TCP_QUEUE_OOSEQ
/* Free all ooseq pbufs (and possibly reset SACK state) */
void
tcp_free_ooseq(struct tcp_pcb *pcb)
{
 800c788:	b510      	push	{r4, lr}
 800c78a:	4604      	mov	r4, r0
  if (pcb->ooseq) {
 800c78c:	6f40      	ldr	r0, [r0, #116]	@ 0x74
 800c78e:	b118      	cbz	r0, 800c798 <tcp_free_ooseq+0x10>
    tcp_segs_free(pcb->ooseq);
 800c790:	f7ff ff0f 	bl	800c5b2 <tcp_segs_free>
    pcb->ooseq = NULL;
 800c794:	2300      	movs	r3, #0
 800c796:	6763      	str	r3, [r4, #116]	@ 0x74
#if LWIP_TCP_SACK_OUT
    memset(pcb->rcv_sacks, 0, sizeof(pcb->rcv_sacks));
#endif /* LWIP_TCP_SACK_OUT */
  }
}
 800c798:	bd10      	pop	{r4, pc}
	...

0800c79c <tcp_pcb_purge>:
{
 800c79c:	b510      	push	{r4, lr}
  LWIP_ERROR("tcp_pcb_purge: invalid pcb", pcb != NULL, return);
 800c79e:	b308      	cbz	r0, 800c7e4 <tcp_pcb_purge+0x48>
 800c7a0:	4604      	mov	r4, r0
  if (pcb->state != CLOSED &&
 800c7a2:	7d03      	ldrb	r3, [r0, #20]
 800c7a4:	2b00      	cmp	r3, #0
 800c7a6:	bf18      	it	ne
 800c7a8:	2b0a      	cmpne	r3, #10
 800c7aa:	d01a      	beq.n	800c7e2 <tcp_pcb_purge+0x46>
      pcb->state != TIME_WAIT &&
 800c7ac:	2b01      	cmp	r3, #1
 800c7ae:	d018      	beq.n	800c7e2 <tcp_pcb_purge+0x46>
    if (pcb->refused_data != NULL) {
 800c7b0:	6f80      	ldr	r0, [r0, #120]	@ 0x78
 800c7b2:	b118      	cbz	r0, 800c7bc <tcp_pcb_purge+0x20>
      pbuf_free(pcb->refused_data);
 800c7b4:	f7ff f9bc 	bl	800bb30 <pbuf_free>
      pcb->refused_data = NULL;
 800c7b8:	2300      	movs	r3, #0
 800c7ba:	67a3      	str	r3, [r4, #120]	@ 0x78
    if (pcb->ooseq != NULL) {
 800c7bc:	6f63      	ldr	r3, [r4, #116]	@ 0x74
 800c7be:	b113      	cbz	r3, 800c7c6 <tcp_pcb_purge+0x2a>
      tcp_free_ooseq(pcb);
 800c7c0:	4620      	mov	r0, r4
 800c7c2:	f7ff ffe1 	bl	800c788 <tcp_free_ooseq>
    pcb->rtime = -1;
 800c7c6:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 800c7ca:	8623      	strh	r3, [r4, #48]	@ 0x30
    tcp_segs_free(pcb->unsent);
 800c7cc:	6ee0      	ldr	r0, [r4, #108]	@ 0x6c
 800c7ce:	f7ff fef0 	bl	800c5b2 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
 800c7d2:	6f20      	ldr	r0, [r4, #112]	@ 0x70
 800c7d4:	f7ff feed 	bl	800c5b2 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
 800c7d8:	2300      	movs	r3, #0
 800c7da:	66e3      	str	r3, [r4, #108]	@ 0x6c
 800c7dc:	6723      	str	r3, [r4, #112]	@ 0x70
    pcb->unsent_oversize = 0;
 800c7de:	f8a4 3068 	strh.w	r3, [r4, #104]	@ 0x68
}
 800c7e2:	bd10      	pop	{r4, pc}
  LWIP_ERROR("tcp_pcb_purge: invalid pcb", pcb != NULL, return);
 800c7e4:	4b03      	ldr	r3, [pc, #12]	@ (800c7f4 <tcp_pcb_purge+0x58>)
 800c7e6:	f640 0251 	movw	r2, #2129	@ 0x851
 800c7ea:	4903      	ldr	r1, [pc, #12]	@ (800c7f8 <tcp_pcb_purge+0x5c>)
 800c7ec:	4803      	ldr	r0, [pc, #12]	@ (800c7fc <tcp_pcb_purge+0x60>)
 800c7ee:	f007 fbc7 	bl	8013f80 <iprintf>
 800c7f2:	e7f6      	b.n	800c7e2 <tcp_pcb_purge+0x46>
 800c7f4:	080169a8 	.word	0x080169a8
 800c7f8:	08016c8c 	.word	0x08016c8c
 800c7fc:	08015744 	.word	0x08015744

0800c800 <tcp_pcb_remove>:
{
 800c800:	b538      	push	{r3, r4, r5, lr}
 800c802:	4605      	mov	r5, r0
  LWIP_ASSERT("tcp_pcb_remove: invalid pcb", pcb != NULL);
 800c804:	460c      	mov	r4, r1
 800c806:	b149      	cbz	r1, 800c81c <tcp_pcb_remove+0x1c>
  LWIP_ASSERT("tcp_pcb_remove: invalid pcblist", pcblist != NULL);
 800c808:	b185      	cbz	r5, 800c82c <tcp_pcb_remove+0x2c>
  TCP_RMV(pcblist, pcb);
 800c80a:	682b      	ldr	r3, [r5, #0]
 800c80c:	42a3      	cmp	r3, r4
 800c80e:	d015      	beq.n	800c83c <tcp_pcb_remove+0x3c>
 800c810:	b1cb      	cbz	r3, 800c846 <tcp_pcb_remove+0x46>
 800c812:	68da      	ldr	r2, [r3, #12]
 800c814:	42a2      	cmp	r2, r4
 800c816:	d014      	beq.n	800c842 <tcp_pcb_remove+0x42>
 800c818:	4613      	mov	r3, r2
 800c81a:	e7f9      	b.n	800c810 <tcp_pcb_remove+0x10>
  LWIP_ASSERT("tcp_pcb_remove: invalid pcb", pcb != NULL);
 800c81c:	4b25      	ldr	r3, [pc, #148]	@ (800c8b4 <tcp_pcb_remove+0xb4>)
 800c81e:	f640 0283 	movw	r2, #2179	@ 0x883
 800c822:	4925      	ldr	r1, [pc, #148]	@ (800c8b8 <tcp_pcb_remove+0xb8>)
 800c824:	4825      	ldr	r0, [pc, #148]	@ (800c8bc <tcp_pcb_remove+0xbc>)
 800c826:	f007 fbab 	bl	8013f80 <iprintf>
 800c82a:	e7ed      	b.n	800c808 <tcp_pcb_remove+0x8>
  LWIP_ASSERT("tcp_pcb_remove: invalid pcblist", pcblist != NULL);
 800c82c:	4b21      	ldr	r3, [pc, #132]	@ (800c8b4 <tcp_pcb_remove+0xb4>)
 800c82e:	f640 0284 	movw	r2, #2180	@ 0x884
 800c832:	4923      	ldr	r1, [pc, #140]	@ (800c8c0 <tcp_pcb_remove+0xc0>)
 800c834:	4821      	ldr	r0, [pc, #132]	@ (800c8bc <tcp_pcb_remove+0xbc>)
 800c836:	f007 fba3 	bl	8013f80 <iprintf>
 800c83a:	e7e6      	b.n	800c80a <tcp_pcb_remove+0xa>
  TCP_RMV(pcblist, pcb);
 800c83c:	68db      	ldr	r3, [r3, #12]
 800c83e:	602b      	str	r3, [r5, #0]
 800c840:	e001      	b.n	800c846 <tcp_pcb_remove+0x46>
 800c842:	68e2      	ldr	r2, [r4, #12]
 800c844:	60da      	str	r2, [r3, #12]
 800c846:	2300      	movs	r3, #0
 800c848:	60e3      	str	r3, [r4, #12]
  tcp_pcb_purge(pcb);
 800c84a:	4620      	mov	r0, r4
 800c84c:	f7ff ffa6 	bl	800c79c <tcp_pcb_purge>
  if ((pcb->state != TIME_WAIT) &&
 800c850:	7d23      	ldrb	r3, [r4, #20]
 800c852:	2b0a      	cmp	r3, #10
 800c854:	bf18      	it	ne
 800c856:	2b01      	cmpne	r3, #1
 800c858:	d003      	beq.n	800c862 <tcp_pcb_remove+0x62>
      (pcb->flags & TF_ACK_DELAY)) {
 800c85a:	8b63      	ldrh	r3, [r4, #26]
      (pcb->state != LISTEN) &&
 800c85c:	f013 0f01 	tst.w	r3, #1
 800c860:	d121      	bne.n	800c8a6 <tcp_pcb_remove+0xa6>
  if (pcb->state != LISTEN) {
 800c862:	7d23      	ldrb	r3, [r4, #20]
 800c864:	2b01      	cmp	r3, #1
 800c866:	d01a      	beq.n	800c89e <tcp_pcb_remove+0x9e>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
 800c868:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
 800c86a:	b133      	cbz	r3, 800c87a <tcp_pcb_remove+0x7a>
 800c86c:	4b11      	ldr	r3, [pc, #68]	@ (800c8b4 <tcp_pcb_remove+0xb4>)
 800c86e:	f640 0293 	movw	r2, #2195	@ 0x893
 800c872:	4914      	ldr	r1, [pc, #80]	@ (800c8c4 <tcp_pcb_remove+0xc4>)
 800c874:	4811      	ldr	r0, [pc, #68]	@ (800c8bc <tcp_pcb_remove+0xbc>)
 800c876:	f007 fb83 	bl	8013f80 <iprintf>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
 800c87a:	6f23      	ldr	r3, [r4, #112]	@ 0x70
 800c87c:	b133      	cbz	r3, 800c88c <tcp_pcb_remove+0x8c>
 800c87e:	4b0d      	ldr	r3, [pc, #52]	@ (800c8b4 <tcp_pcb_remove+0xb4>)
 800c880:	f640 0294 	movw	r2, #2196	@ 0x894
 800c884:	4910      	ldr	r1, [pc, #64]	@ (800c8c8 <tcp_pcb_remove+0xc8>)
 800c886:	480d      	ldr	r0, [pc, #52]	@ (800c8bc <tcp_pcb_remove+0xbc>)
 800c888:	f007 fb7a 	bl	8013f80 <iprintf>
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
 800c88c:	6f63      	ldr	r3, [r4, #116]	@ 0x74
 800c88e:	b133      	cbz	r3, 800c89e <tcp_pcb_remove+0x9e>
 800c890:	4b08      	ldr	r3, [pc, #32]	@ (800c8b4 <tcp_pcb_remove+0xb4>)
 800c892:	f640 0296 	movw	r2, #2198	@ 0x896
 800c896:	490d      	ldr	r1, [pc, #52]	@ (800c8cc <tcp_pcb_remove+0xcc>)
 800c898:	4808      	ldr	r0, [pc, #32]	@ (800c8bc <tcp_pcb_remove+0xbc>)
 800c89a:	f007 fb71 	bl	8013f80 <iprintf>
  pcb->state = CLOSED;
 800c89e:	2300      	movs	r3, #0
 800c8a0:	7523      	strb	r3, [r4, #20]
  pcb->local_port = 0;
 800c8a2:	82e3      	strh	r3, [r4, #22]
}
 800c8a4:	bd38      	pop	{r3, r4, r5, pc}
    tcp_ack_now(pcb);
 800c8a6:	f043 0302 	orr.w	r3, r3, #2
 800c8aa:	8363      	strh	r3, [r4, #26]
    tcp_output(pcb);
 800c8ac:	4620      	mov	r0, r4
 800c8ae:	f003 fbe7 	bl	8010080 <tcp_output>
 800c8b2:	e7d6      	b.n	800c862 <tcp_pcb_remove+0x62>
 800c8b4:	080169a8 	.word	0x080169a8
 800c8b8:	08016ca8 	.word	0x08016ca8
 800c8bc:	08015744 	.word	0x08015744
 800c8c0:	08016cc4 	.word	0x08016cc4
 800c8c4:	08016ce4 	.word	0x08016ce4
 800c8c8:	08016cfc 	.word	0x08016cfc
 800c8cc:	08016d18 	.word	0x08016d18

0800c8d0 <tcp_abandon>:
{
 800c8d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800c8d4:	b084      	sub	sp, #16
  LWIP_ERROR("tcp_abandon: invalid pcb", pcb != NULL, return);
 800c8d6:	b1f8      	cbz	r0, 800c918 <tcp_abandon+0x48>
 800c8d8:	460d      	mov	r5, r1
 800c8da:	4604      	mov	r4, r0
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
 800c8dc:	7d03      	ldrb	r3, [r0, #20]
 800c8de:	2b01      	cmp	r3, #1
 800c8e0:	d022      	beq.n	800c928 <tcp_abandon+0x58>
  if (pcb->state == TIME_WAIT) {
 800c8e2:	7d23      	ldrb	r3, [r4, #20]
 800c8e4:	2b0a      	cmp	r3, #10
 800c8e6:	d027      	beq.n	800c938 <tcp_abandon+0x68>
    seqno = pcb->snd_nxt;
 800c8e8:	f8d4 8050 	ldr.w	r8, [r4, #80]	@ 0x50
    ackno = pcb->rcv_nxt;
 800c8ec:	f8d4 9024 	ldr.w	r9, [r4, #36]	@ 0x24
    errf = pcb->errf;
 800c8f0:	f8d4 6090 	ldr.w	r6, [r4, #144]	@ 0x90
    errf_arg = pcb->callback_arg;
 800c8f4:	6927      	ldr	r7, [r4, #16]
    if (pcb->state == CLOSED) {
 800c8f6:	2b00      	cmp	r3, #0
 800c8f8:	d147      	bne.n	800c98a <tcp_abandon+0xba>
      if (pcb->local_port != 0) {
 800c8fa:	f8b4 a016 	ldrh.w	sl, [r4, #22]
 800c8fe:	f1ba 0f00 	cmp.w	sl, #0
 800c902:	d04c      	beq.n	800c99e <tcp_abandon+0xce>
        TCP_RMV(&tcp_bound_pcbs, pcb);
 800c904:	4b2d      	ldr	r3, [pc, #180]	@ (800c9bc <tcp_abandon+0xec>)
 800c906:	681b      	ldr	r3, [r3, #0]
 800c908:	42a3      	cmp	r3, r4
 800c90a:	d01d      	beq.n	800c948 <tcp_abandon+0x78>
 800c90c:	b313      	cbz	r3, 800c954 <tcp_abandon+0x84>
 800c90e:	68da      	ldr	r2, [r3, #12]
 800c910:	42a2      	cmp	r2, r4
 800c912:	d01d      	beq.n	800c950 <tcp_abandon+0x80>
 800c914:	4613      	mov	r3, r2
 800c916:	e7f9      	b.n	800c90c <tcp_abandon+0x3c>
  LWIP_ERROR("tcp_abandon: invalid pcb", pcb != NULL, return);
 800c918:	4b29      	ldr	r3, [pc, #164]	@ (800c9c0 <tcp_abandon+0xf0>)
 800c91a:	f240 223d 	movw	r2, #573	@ 0x23d
 800c91e:	4929      	ldr	r1, [pc, #164]	@ (800c9c4 <tcp_abandon+0xf4>)
 800c920:	4829      	ldr	r0, [pc, #164]	@ (800c9c8 <tcp_abandon+0xf8>)
 800c922:	f007 fb2d 	bl	8013f80 <iprintf>
 800c926:	e02d      	b.n	800c984 <tcp_abandon+0xb4>
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
 800c928:	4b25      	ldr	r3, [pc, #148]	@ (800c9c0 <tcp_abandon+0xf0>)
 800c92a:	f44f 7210 	mov.w	r2, #576	@ 0x240
 800c92e:	4927      	ldr	r1, [pc, #156]	@ (800c9cc <tcp_abandon+0xfc>)
 800c930:	4825      	ldr	r0, [pc, #148]	@ (800c9c8 <tcp_abandon+0xf8>)
 800c932:	f007 fb25 	bl	8013f80 <iprintf>
 800c936:	e7d4      	b.n	800c8e2 <tcp_abandon+0x12>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 800c938:	4621      	mov	r1, r4
 800c93a:	4825      	ldr	r0, [pc, #148]	@ (800c9d0 <tcp_abandon+0x100>)
 800c93c:	f7ff ff60 	bl	800c800 <tcp_pcb_remove>
    tcp_free(pcb);
 800c940:	4620      	mov	r0, r4
 800c942:	f7ff fcc5 	bl	800c2d0 <tcp_free>
 800c946:	e01d      	b.n	800c984 <tcp_abandon+0xb4>
        TCP_RMV(&tcp_bound_pcbs, pcb);
 800c948:	68da      	ldr	r2, [r3, #12]
 800c94a:	4b1c      	ldr	r3, [pc, #112]	@ (800c9bc <tcp_abandon+0xec>)
 800c94c:	601a      	str	r2, [r3, #0]
 800c94e:	e001      	b.n	800c954 <tcp_abandon+0x84>
 800c950:	68e2      	ldr	r2, [r4, #12]
 800c952:	60da      	str	r2, [r3, #12]
 800c954:	2500      	movs	r5, #0
 800c956:	60e5      	str	r5, [r4, #12]
    u16_t local_port = 0;
 800c958:	46aa      	mov	sl, r5
    if (pcb->unacked != NULL) {
 800c95a:	6f20      	ldr	r0, [r4, #112]	@ 0x70
 800c95c:	b108      	cbz	r0, 800c962 <tcp_abandon+0x92>
      tcp_segs_free(pcb->unacked);
 800c95e:	f7ff fe28 	bl	800c5b2 <tcp_segs_free>
    if (pcb->unsent != NULL) {
 800c962:	6ee0      	ldr	r0, [r4, #108]	@ 0x6c
 800c964:	b108      	cbz	r0, 800c96a <tcp_abandon+0x9a>
      tcp_segs_free(pcb->unsent);
 800c966:	f7ff fe24 	bl	800c5b2 <tcp_segs_free>
    if (pcb->ooseq != NULL) {
 800c96a:	6f60      	ldr	r0, [r4, #116]	@ 0x74
 800c96c:	b108      	cbz	r0, 800c972 <tcp_abandon+0xa2>
      tcp_segs_free(pcb->ooseq);
 800c96e:	f7ff fe20 	bl	800c5b2 <tcp_segs_free>
    if (send_rst) {
 800c972:	b9b5      	cbnz	r5, 800c9a2 <tcp_abandon+0xd2>
    tcp_free(pcb);
 800c974:	4620      	mov	r0, r4
 800c976:	f7ff fcab 	bl	800c2d0 <tcp_free>
    TCP_EVENT_ERR(last_state, errf, errf_arg, ERR_ABRT);
 800c97a:	b11e      	cbz	r6, 800c984 <tcp_abandon+0xb4>
 800c97c:	f06f 010c 	mvn.w	r1, #12
 800c980:	4638      	mov	r0, r7
 800c982:	47b0      	blx	r6
}
 800c984:	b004      	add	sp, #16
 800c986:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      local_port = pcb->local_port;
 800c98a:	f8b4 a016 	ldrh.w	sl, [r4, #22]
      TCP_PCB_REMOVE_ACTIVE(pcb);
 800c98e:	4621      	mov	r1, r4
 800c990:	4810      	ldr	r0, [pc, #64]	@ (800c9d4 <tcp_abandon+0x104>)
 800c992:	f7ff ff35 	bl	800c800 <tcp_pcb_remove>
 800c996:	4b10      	ldr	r3, [pc, #64]	@ (800c9d8 <tcp_abandon+0x108>)
 800c998:	2201      	movs	r2, #1
 800c99a:	701a      	strb	r2, [r3, #0]
 800c99c:	e7dd      	b.n	800c95a <tcp_abandon+0x8a>
    int send_rst = 0;
 800c99e:	2500      	movs	r5, #0
 800c9a0:	e7db      	b.n	800c95a <tcp_abandon+0x8a>
      tcp_rst(pcb, seqno, ackno, &pcb->local_ip, &pcb->remote_ip, local_port, pcb->remote_port);
 800c9a2:	1d23      	adds	r3, r4, #4
 800c9a4:	8b22      	ldrh	r2, [r4, #24]
 800c9a6:	9202      	str	r2, [sp, #8]
 800c9a8:	f8cd a004 	str.w	sl, [sp, #4]
 800c9ac:	9300      	str	r3, [sp, #0]
 800c9ae:	4623      	mov	r3, r4
 800c9b0:	464a      	mov	r2, r9
 800c9b2:	4641      	mov	r1, r8
 800c9b4:	4620      	mov	r0, r4
 800c9b6:	f003 fae1 	bl	800ff7c <tcp_rst>
 800c9ba:	e7db      	b.n	800c974 <tcp_abandon+0xa4>
 800c9bc:	240142e4 	.word	0x240142e4
 800c9c0:	080169a8 	.word	0x080169a8
 800c9c4:	08016d30 	.word	0x08016d30
 800c9c8:	08015744 	.word	0x08015744
 800c9cc:	08016d4c 	.word	0x08016d4c
 800c9d0:	240142d8 	.word	0x240142d8
 800c9d4:	240142dc 	.word	0x240142dc
 800c9d8:	240142d6 	.word	0x240142d6

0800c9dc <tcp_abort>:
{
 800c9dc:	b508      	push	{r3, lr}
  tcp_abandon(pcb, 1);
 800c9de:	2101      	movs	r1, #1
 800c9e0:	f7ff ff76 	bl	800c8d0 <tcp_abandon>
}
 800c9e4:	bd08      	pop	{r3, pc}
	...

0800c9e8 <tcp_accept_null>:
{
 800c9e8:	b510      	push	{r4, lr}
  LWIP_ASSERT("tcp_accept_null: invalid pcb", pcb != NULL);
 800c9ea:	460c      	mov	r4, r1
 800c9ec:	b129      	cbz	r1, 800c9fa <tcp_accept_null+0x12>
  tcp_abort(pcb);
 800c9ee:	4620      	mov	r0, r4
 800c9f0:	f7ff fff4 	bl	800c9dc <tcp_abort>
}
 800c9f4:	f06f 000c 	mvn.w	r0, #12
 800c9f8:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("tcp_accept_null: invalid pcb", pcb != NULL);
 800c9fa:	4b04      	ldr	r3, [pc, #16]	@ (800ca0c <tcp_accept_null+0x24>)
 800c9fc:	f240 320f 	movw	r2, #783	@ 0x30f
 800ca00:	4903      	ldr	r1, [pc, #12]	@ (800ca10 <tcp_accept_null+0x28>)
 800ca02:	4804      	ldr	r0, [pc, #16]	@ (800ca14 <tcp_accept_null+0x2c>)
 800ca04:	f007 fabc 	bl	8013f80 <iprintf>
 800ca08:	e7f1      	b.n	800c9ee <tcp_accept_null+0x6>
 800ca0a:	bf00      	nop
 800ca0c:	080169a8 	.word	0x080169a8
 800ca10:	08016d80 	.word	0x08016d80
 800ca14:	08015744 	.word	0x08015744

0800ca18 <tcp_kill_timewait>:
{
 800ca18:	b508      	push	{r3, lr}
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800ca1a:	4b0a      	ldr	r3, [pc, #40]	@ (800ca44 <tcp_kill_timewait+0x2c>)
 800ca1c:	681b      	ldr	r3, [r3, #0]
  inactivity = 0;
 800ca1e:	f04f 0c00 	mov.w	ip, #0
  inactive = NULL;
 800ca22:	4660      	mov	r0, ip
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800ca24:	e000      	b.n	800ca28 <tcp_kill_timewait+0x10>
 800ca26:	68db      	ldr	r3, [r3, #12]
 800ca28:	b143      	cbz	r3, 800ca3c <tcp_kill_timewait+0x24>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800ca2a:	6a19      	ldr	r1, [r3, #32]
 800ca2c:	4a06      	ldr	r2, [pc, #24]	@ (800ca48 <tcp_kill_timewait+0x30>)
 800ca2e:	6812      	ldr	r2, [r2, #0]
 800ca30:	1a52      	subs	r2, r2, r1
 800ca32:	4562      	cmp	r2, ip
 800ca34:	d3f7      	bcc.n	800ca26 <tcp_kill_timewait+0xe>
      inactivity = tcp_ticks - pcb->tmr;
 800ca36:	4694      	mov	ip, r2
      inactive = pcb;
 800ca38:	4618      	mov	r0, r3
 800ca3a:	e7f4      	b.n	800ca26 <tcp_kill_timewait+0xe>
  if (inactive != NULL) {
 800ca3c:	b108      	cbz	r0, 800ca42 <tcp_kill_timewait+0x2a>
    tcp_abort(inactive);
 800ca3e:	f7ff ffcd 	bl	800c9dc <tcp_abort>
}
 800ca42:	bd08      	pop	{r3, pc}
 800ca44:	240142d8 	.word	0x240142d8
 800ca48:	240142e8 	.word	0x240142e8

0800ca4c <tcp_kill_prio>:
  mprio = LWIP_MIN(TCP_PRIO_MAX, prio);
 800ca4c:	f010 0f80 	tst.w	r0, #128	@ 0x80
 800ca50:	d101      	bne.n	800ca56 <tcp_kill_prio+0xa>
  if (mprio == 0) {
 800ca52:	b908      	cbnz	r0, 800ca58 <tcp_kill_prio+0xc>
 800ca54:	4770      	bx	lr
  mprio = LWIP_MIN(TCP_PRIO_MAX, prio);
 800ca56:	207f      	movs	r0, #127	@ 0x7f
{
 800ca58:	b538      	push	{r3, r4, r5, lr}
  mprio--;
 800ca5a:	3801      	subs	r0, #1
 800ca5c:	b2c2      	uxtb	r2, r0
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800ca5e:	4b0f      	ldr	r3, [pc, #60]	@ (800ca9c <tcp_kill_prio+0x50>)
 800ca60:	681b      	ldr	r3, [r3, #0]
  inactivity = 0;
 800ca62:	f04f 0c00 	mov.w	ip, #0
  inactive = NULL;
 800ca66:	4660      	mov	r0, ip
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800ca68:	e007      	b.n	800ca7a <tcp_kill_prio+0x2e>
      inactivity = tcp_ticks - pcb->tmr;
 800ca6a:	4a0d      	ldr	r2, [pc, #52]	@ (800caa0 <tcp_kill_prio+0x54>)
 800ca6c:	6812      	ldr	r2, [r2, #0]
 800ca6e:	6a18      	ldr	r0, [r3, #32]
 800ca70:	eba2 0c00 	sub.w	ip, r2, r0
      mprio      = pcb->prio;
 800ca74:	460a      	mov	r2, r1
      inactive   = pcb;
 800ca76:	4618      	mov	r0, r3
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800ca78:	68db      	ldr	r3, [r3, #12]
 800ca7a:	b15b      	cbz	r3, 800ca94 <tcp_kill_prio+0x48>
    if ((pcb->prio < mprio) ||
 800ca7c:	7d59      	ldrb	r1, [r3, #21]
 800ca7e:	4291      	cmp	r1, r2
 800ca80:	d3f3      	bcc.n	800ca6a <tcp_kill_prio+0x1e>
 800ca82:	d1f9      	bne.n	800ca78 <tcp_kill_prio+0x2c>
        ((pcb->prio == mprio) && ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity))) {
 800ca84:	4c06      	ldr	r4, [pc, #24]	@ (800caa0 <tcp_kill_prio+0x54>)
 800ca86:	6824      	ldr	r4, [r4, #0]
 800ca88:	6a1d      	ldr	r5, [r3, #32]
 800ca8a:	eba4 0e05 	sub.w	lr, r4, r5
 800ca8e:	45e6      	cmp	lr, ip
 800ca90:	d3f2      	bcc.n	800ca78 <tcp_kill_prio+0x2c>
 800ca92:	e7ea      	b.n	800ca6a <tcp_kill_prio+0x1e>
  if (inactive != NULL) {
 800ca94:	b108      	cbz	r0, 800ca9a <tcp_kill_prio+0x4e>
    tcp_abort(inactive);
 800ca96:	f7ff ffa1 	bl	800c9dc <tcp_abort>
}
 800ca9a:	bd38      	pop	{r3, r4, r5, pc}
 800ca9c:	240142dc 	.word	0x240142dc
 800caa0:	240142e8 	.word	0x240142e8

0800caa4 <tcp_netif_ip_addr_changed_pcblist>:
{
 800caa4:	b570      	push	{r4, r5, r6, lr}
 800caa6:	460c      	mov	r4, r1
  LWIP_ASSERT("tcp_netif_ip_addr_changed_pcblist: invalid old_addr", old_addr != NULL);
 800caa8:	4605      	mov	r5, r0
 800caaa:	b960      	cbnz	r0, 800cac6 <tcp_netif_ip_addr_changed_pcblist+0x22>
 800caac:	4b0a      	ldr	r3, [pc, #40]	@ (800cad8 <tcp_netif_ip_addr_changed_pcblist+0x34>)
 800caae:	f44f 6210 	mov.w	r2, #2304	@ 0x900
 800cab2:	490a      	ldr	r1, [pc, #40]	@ (800cadc <tcp_netif_ip_addr_changed_pcblist+0x38>)
 800cab4:	480a      	ldr	r0, [pc, #40]	@ (800cae0 <tcp_netif_ip_addr_changed_pcblist+0x3c>)
 800cab6:	f007 fa63 	bl	8013f80 <iprintf>
 800caba:	e004      	b.n	800cac6 <tcp_netif_ip_addr_changed_pcblist+0x22>
      struct tcp_pcb *next = pcb->next;
 800cabc:	68e6      	ldr	r6, [r4, #12]
      tcp_abort(pcb);
 800cabe:	4620      	mov	r0, r4
 800cac0:	f7ff ff8c 	bl	800c9dc <tcp_abort>
      pcb = next;
 800cac4:	4634      	mov	r4, r6
  while (pcb != NULL) {
 800cac6:	b12c      	cbz	r4, 800cad4 <tcp_netif_ip_addr_changed_pcblist+0x30>
    if (ip_addr_cmp(&pcb->local_ip, old_addr)
 800cac8:	6822      	ldr	r2, [r4, #0]
 800caca:	682b      	ldr	r3, [r5, #0]
 800cacc:	429a      	cmp	r2, r3
 800cace:	d0f5      	beq.n	800cabc <tcp_netif_ip_addr_changed_pcblist+0x18>
      pcb = pcb->next;
 800cad0:	68e4      	ldr	r4, [r4, #12]
 800cad2:	e7f8      	b.n	800cac6 <tcp_netif_ip_addr_changed_pcblist+0x22>
}
 800cad4:	bd70      	pop	{r4, r5, r6, pc}
 800cad6:	bf00      	nop
 800cad8:	080169a8 	.word	0x080169a8
 800cadc:	08016da0 	.word	0x08016da0
 800cae0:	08015744 	.word	0x08015744

0800cae4 <tcp_netif_ip_addr_changed>:
  if (!ip_addr_isany(old_addr)) {
 800cae4:	b300      	cbz	r0, 800cb28 <tcp_netif_ip_addr_changed+0x44>
{
 800cae6:	b538      	push	{r3, r4, r5, lr}
 800cae8:	460d      	mov	r5, r1
 800caea:	4604      	mov	r4, r0
  if (!ip_addr_isany(old_addr)) {
 800caec:	6803      	ldr	r3, [r0, #0]
 800caee:	b903      	cbnz	r3, 800caf2 <tcp_netif_ip_addr_changed+0xe>
}
 800caf0:	bd38      	pop	{r3, r4, r5, pc}
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_active_pcbs);
 800caf2:	4b0e      	ldr	r3, [pc, #56]	@ (800cb2c <tcp_netif_ip_addr_changed+0x48>)
 800caf4:	6819      	ldr	r1, [r3, #0]
 800caf6:	f7ff ffd5 	bl	800caa4 <tcp_netif_ip_addr_changed_pcblist>
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_bound_pcbs);
 800cafa:	4b0d      	ldr	r3, [pc, #52]	@ (800cb30 <tcp_netif_ip_addr_changed+0x4c>)
 800cafc:	6819      	ldr	r1, [r3, #0]
 800cafe:	4620      	mov	r0, r4
 800cb00:	f7ff ffd0 	bl	800caa4 <tcp_netif_ip_addr_changed_pcblist>
    if (!ip_addr_isany(new_addr)) {
 800cb04:	2d00      	cmp	r5, #0
 800cb06:	d0f3      	beq.n	800caf0 <tcp_netif_ip_addr_changed+0xc>
 800cb08:	682b      	ldr	r3, [r5, #0]
 800cb0a:	2b00      	cmp	r3, #0
 800cb0c:	d0f0      	beq.n	800caf0 <tcp_netif_ip_addr_changed+0xc>
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800cb0e:	4b09      	ldr	r3, [pc, #36]	@ (800cb34 <tcp_netif_ip_addr_changed+0x50>)
 800cb10:	681b      	ldr	r3, [r3, #0]
 800cb12:	e000      	b.n	800cb16 <tcp_netif_ip_addr_changed+0x32>
 800cb14:	68db      	ldr	r3, [r3, #12]
 800cb16:	2b00      	cmp	r3, #0
 800cb18:	d0ea      	beq.n	800caf0 <tcp_netif_ip_addr_changed+0xc>
        if (ip_addr_cmp(&lpcb->local_ip, old_addr)) {
 800cb1a:	6819      	ldr	r1, [r3, #0]
 800cb1c:	6822      	ldr	r2, [r4, #0]
 800cb1e:	4291      	cmp	r1, r2
 800cb20:	d1f8      	bne.n	800cb14 <tcp_netif_ip_addr_changed+0x30>
          ip_addr_copy(lpcb->local_ip, *new_addr);
 800cb22:	682a      	ldr	r2, [r5, #0]
 800cb24:	601a      	str	r2, [r3, #0]
 800cb26:	e7f5      	b.n	800cb14 <tcp_netif_ip_addr_changed+0x30>
 800cb28:	4770      	bx	lr
 800cb2a:	bf00      	nop
 800cb2c:	240142dc 	.word	0x240142dc
 800cb30:	240142e4 	.word	0x240142e4
 800cb34:	240142e0 	.word	0x240142e0

0800cb38 <tcp_kill_state>:
{
 800cb38:	b538      	push	{r3, r4, r5, lr}
 800cb3a:	4604      	mov	r4, r0
  LWIP_ASSERT("invalid state", (state == CLOSING) || (state == LAST_ACK));
 800cb3c:	f1a0 0308 	sub.w	r3, r0, #8
 800cb40:	b2db      	uxtb	r3, r3
 800cb42:	2b01      	cmp	r3, #1
 800cb44:	d804      	bhi.n	800cb50 <tcp_kill_state+0x18>
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800cb46:	4b10      	ldr	r3, [pc, #64]	@ (800cb88 <tcp_kill_state+0x50>)
 800cb48:	681b      	ldr	r3, [r3, #0]
  inactivity = 0;
 800cb4a:	2100      	movs	r1, #0
  inactive = NULL;
 800cb4c:	4608      	mov	r0, r1
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800cb4e:	e008      	b.n	800cb62 <tcp_kill_state+0x2a>
  LWIP_ASSERT("invalid state", (state == CLOSING) || (state == LAST_ACK));
 800cb50:	4b0e      	ldr	r3, [pc, #56]	@ (800cb8c <tcp_kill_state+0x54>)
 800cb52:	f240 62dd 	movw	r2, #1757	@ 0x6dd
 800cb56:	490e      	ldr	r1, [pc, #56]	@ (800cb90 <tcp_kill_state+0x58>)
 800cb58:	480e      	ldr	r0, [pc, #56]	@ (800cb94 <tcp_kill_state+0x5c>)
 800cb5a:	f007 fa11 	bl	8013f80 <iprintf>
 800cb5e:	e7f2      	b.n	800cb46 <tcp_kill_state+0xe>
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800cb60:	68db      	ldr	r3, [r3, #12]
 800cb62:	b15b      	cbz	r3, 800cb7c <tcp_kill_state+0x44>
    if (pcb->state == state) {
 800cb64:	7d1a      	ldrb	r2, [r3, #20]
 800cb66:	42a2      	cmp	r2, r4
 800cb68:	d1fa      	bne.n	800cb60 <tcp_kill_state+0x28>
      if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800cb6a:	4a0b      	ldr	r2, [pc, #44]	@ (800cb98 <tcp_kill_state+0x60>)
 800cb6c:	6812      	ldr	r2, [r2, #0]
 800cb6e:	6a1d      	ldr	r5, [r3, #32]
 800cb70:	1b52      	subs	r2, r2, r5
 800cb72:	428a      	cmp	r2, r1
 800cb74:	d3f4      	bcc.n	800cb60 <tcp_kill_state+0x28>
        inactivity = tcp_ticks - pcb->tmr;
 800cb76:	4611      	mov	r1, r2
        inactive = pcb;
 800cb78:	4618      	mov	r0, r3
 800cb7a:	e7f1      	b.n	800cb60 <tcp_kill_state+0x28>
  if (inactive != NULL) {
 800cb7c:	b110      	cbz	r0, 800cb84 <tcp_kill_state+0x4c>
    tcp_abandon(inactive, 0);
 800cb7e:	2100      	movs	r1, #0
 800cb80:	f7ff fea6 	bl	800c8d0 <tcp_abandon>
}
 800cb84:	bd38      	pop	{r3, r4, r5, pc}
 800cb86:	bf00      	nop
 800cb88:	240142dc 	.word	0x240142dc
 800cb8c:	080169a8 	.word	0x080169a8
 800cb90:	08016dd4 	.word	0x08016dd4
 800cb94:	08015744 	.word	0x08015744
 800cb98:	240142e8 	.word	0x240142e8

0800cb9c <tcp_alloc>:
{
 800cb9c:	b538      	push	{r3, r4, r5, lr}
 800cb9e:	4605      	mov	r5, r0
  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800cba0:	2001      	movs	r0, #1
 800cba2:	f7fe fc73 	bl	800b48c <memp_malloc>
  if (pcb == NULL) {
 800cba6:	4604      	mov	r4, r0
 800cba8:	b350      	cbz	r0, 800cc00 <tcp_alloc+0x64>
    memset(pcb, 0, sizeof(struct tcp_pcb));
 800cbaa:	229c      	movs	r2, #156	@ 0x9c
 800cbac:	2100      	movs	r1, #0
 800cbae:	4620      	mov	r0, r4
 800cbb0:	f007 fb82 	bl	80142b8 <memset>
    pcb->prio = prio;
 800cbb4:	7565      	strb	r5, [r4, #21]
    pcb->snd_buf = TCP_SND_BUF;
 800cbb6:	f241 63d0 	movw	r3, #5840	@ 0x16d0
 800cbba:	f8a4 3064 	strh.w	r3, [r4, #100]	@ 0x64
    pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
 800cbbe:	8563      	strh	r3, [r4, #42]	@ 0x2a
 800cbc0:	8523      	strh	r3, [r4, #40]	@ 0x28
    pcb->ttl = TCP_TTL;
 800cbc2:	22ff      	movs	r2, #255	@ 0xff
 800cbc4:	72e2      	strb	r2, [r4, #11]
    pcb->mss = INITIAL_MSS;
 800cbc6:	f44f 7206 	mov.w	r2, #536	@ 0x218
 800cbca:	8662      	strh	r2, [r4, #50]	@ 0x32
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 800cbcc:	2206      	movs	r2, #6
 800cbce:	f8a4 2040 	strh.w	r2, [r4, #64]	@ 0x40
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
 800cbd2:	87e2      	strh	r2, [r4, #62]	@ 0x3e
    pcb->rtime = -1;
 800cbd4:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800cbd8:	8622      	strh	r2, [r4, #48]	@ 0x30
    pcb->cwnd = 1;
 800cbda:	2201      	movs	r2, #1
 800cbdc:	f8a4 2048 	strh.w	r2, [r4, #72]	@ 0x48
    pcb->tmr = tcp_ticks;
 800cbe0:	4a29      	ldr	r2, [pc, #164]	@ (800cc88 <tcp_alloc+0xec>)
 800cbe2:	6812      	ldr	r2, [r2, #0]
 800cbe4:	6222      	str	r2, [r4, #32]
    pcb->last_timer = tcp_timer_ctr;
 800cbe6:	4a29      	ldr	r2, [pc, #164]	@ (800cc8c <tcp_alloc+0xf0>)
 800cbe8:	7812      	ldrb	r2, [r2, #0]
 800cbea:	77a2      	strb	r2, [r4, #30]
    pcb->ssthresh = TCP_SND_BUF;
 800cbec:	f8a4 304a 	strh.w	r3, [r4, #74]	@ 0x4a
    pcb->recv = tcp_recv_null;
 800cbf0:	4b27      	ldr	r3, [pc, #156]	@ (800cc90 <tcp_alloc+0xf4>)
 800cbf2:	f8c4 3084 	str.w	r3, [r4, #132]	@ 0x84
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 800cbf6:	4b27      	ldr	r3, [pc, #156]	@ (800cc94 <tcp_alloc+0xf8>)
 800cbf8:	f8c4 3094 	str.w	r3, [r4, #148]	@ 0x94
}
 800cbfc:	4620      	mov	r0, r4
 800cbfe:	bd38      	pop	{r3, r4, r5, pc}
    tcp_handle_closepend();
 800cc00:	f7ff fb44 	bl	800c28c <tcp_handle_closepend>
    tcp_kill_timewait();
 800cc04:	f7ff ff08 	bl	800ca18 <tcp_kill_timewait>
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800cc08:	2001      	movs	r0, #1
 800cc0a:	f7fe fc3f 	bl	800b48c <memp_malloc>
    if (pcb == NULL) {
 800cc0e:	4604      	mov	r4, r0
 800cc10:	b140      	cbz	r0, 800cc24 <tcp_alloc+0x88>
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
 800cc12:	4b21      	ldr	r3, [pc, #132]	@ (800cc98 <tcp_alloc+0xfc>)
 800cc14:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
 800cc18:	8893      	ldrh	r3, [r2, #4]
 800cc1a:	3b01      	subs	r3, #1
 800cc1c:	8093      	strh	r3, [r2, #4]
  if (pcb != NULL) {
 800cc1e:	2c00      	cmp	r4, #0
 800cc20:	d1c3      	bne.n	800cbaa <tcp_alloc+0xe>
 800cc22:	e7eb      	b.n	800cbfc <tcp_alloc+0x60>
      tcp_kill_state(LAST_ACK);
 800cc24:	2009      	movs	r0, #9
 800cc26:	f7ff ff87 	bl	800cb38 <tcp_kill_state>
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800cc2a:	2001      	movs	r0, #1
 800cc2c:	f7fe fc2e 	bl	800b48c <memp_malloc>
      if (pcb == NULL) {
 800cc30:	4604      	mov	r4, r0
 800cc32:	b140      	cbz	r0, 800cc46 <tcp_alloc+0xaa>
        MEMP_STATS_DEC(err, MEMP_TCP_PCB);
 800cc34:	4b18      	ldr	r3, [pc, #96]	@ (800cc98 <tcp_alloc+0xfc>)
 800cc36:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
 800cc3a:	8893      	ldrh	r3, [r2, #4]
 800cc3c:	3b01      	subs	r3, #1
 800cc3e:	8093      	strh	r3, [r2, #4]
    if (pcb != NULL) {
 800cc40:	2c00      	cmp	r4, #0
 800cc42:	d1e6      	bne.n	800cc12 <tcp_alloc+0x76>
 800cc44:	e7da      	b.n	800cbfc <tcp_alloc+0x60>
        tcp_kill_state(CLOSING);
 800cc46:	2008      	movs	r0, #8
 800cc48:	f7ff ff76 	bl	800cb38 <tcp_kill_state>
        pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800cc4c:	2001      	movs	r0, #1
 800cc4e:	f7fe fc1d 	bl	800b48c <memp_malloc>
        if (pcb == NULL) {
 800cc52:	4604      	mov	r4, r0
 800cc54:	b140      	cbz	r0, 800cc68 <tcp_alloc+0xcc>
          MEMP_STATS_DEC(err, MEMP_TCP_PCB);
 800cc56:	4b10      	ldr	r3, [pc, #64]	@ (800cc98 <tcp_alloc+0xfc>)
 800cc58:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
 800cc5c:	8893      	ldrh	r3, [r2, #4]
 800cc5e:	3b01      	subs	r3, #1
 800cc60:	8093      	strh	r3, [r2, #4]
      if (pcb != NULL) {
 800cc62:	2c00      	cmp	r4, #0
 800cc64:	d1e6      	bne.n	800cc34 <tcp_alloc+0x98>
 800cc66:	e7c9      	b.n	800cbfc <tcp_alloc+0x60>
          tcp_kill_prio(prio);
 800cc68:	4628      	mov	r0, r5
 800cc6a:	f7ff feef 	bl	800ca4c <tcp_kill_prio>
          pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800cc6e:	2001      	movs	r0, #1
 800cc70:	f7fe fc0c 	bl	800b48c <memp_malloc>
          if (pcb != NULL) {
 800cc74:	4604      	mov	r4, r0
 800cc76:	2800      	cmp	r0, #0
 800cc78:	d0c0      	beq.n	800cbfc <tcp_alloc+0x60>
            MEMP_STATS_DEC(err, MEMP_TCP_PCB);
 800cc7a:	4b07      	ldr	r3, [pc, #28]	@ (800cc98 <tcp_alloc+0xfc>)
 800cc7c:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
 800cc80:	8893      	ldrh	r3, [r2, #4]
 800cc82:	3b01      	subs	r3, #1
 800cc84:	8093      	strh	r3, [r2, #4]
        if (pcb != NULL) {
 800cc86:	e7e6      	b.n	800cc56 <tcp_alloc+0xba>
 800cc88:	240142e8 	.word	0x240142e8
 800cc8c:	240142d4 	.word	0x240142d4
 800cc90:	0800ce39 	.word	0x0800ce39
 800cc94:	006ddd00 	.word	0x006ddd00
 800cc98:	240141b4 	.word	0x240141b4

0800cc9c <tcp_new_ip_type>:
{
 800cc9c:	b508      	push	{r3, lr}
  pcb = tcp_alloc(TCP_PRIO_NORMAL);
 800cc9e:	2040      	movs	r0, #64	@ 0x40
 800cca0:	f7ff ff7c 	bl	800cb9c <tcp_alloc>
}
 800cca4:	bd08      	pop	{r3, pc}
	...

0800cca8 <tcp_close_shutdown>:
{
 800cca8:	b530      	push	{r4, r5, lr}
 800ccaa:	b085      	sub	sp, #20
 800ccac:	460d      	mov	r5, r1
  LWIP_ASSERT("tcp_close_shutdown: invalid pcb", pcb != NULL);
 800ccae:	4604      	mov	r4, r0
 800ccb0:	b330      	cbz	r0, 800cd00 <tcp_close_shutdown+0x58>
  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 800ccb2:	2d00      	cmp	r5, #0
 800ccb4:	d031      	beq.n	800cd1a <tcp_close_shutdown+0x72>
 800ccb6:	7d23      	ldrb	r3, [r4, #20]
 800ccb8:	2b07      	cmp	r3, #7
 800ccba:	bf18      	it	ne
 800ccbc:	2b04      	cmpne	r3, #4
 800ccbe:	d12c      	bne.n	800cd1a <tcp_close_shutdown+0x72>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND_MAX(pcb))) {
 800ccc0:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
 800ccc2:	b32b      	cbz	r3, 800cd10 <tcp_close_shutdown+0x68>
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
 800ccc4:	8b63      	ldrh	r3, [r4, #26]
 800ccc6:	f013 0f10 	tst.w	r3, #16
 800ccca:	d03a      	beq.n	800cd42 <tcp_close_shutdown+0x9a>
      tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 800cccc:	1d23      	adds	r3, r4, #4
 800ccce:	8b22      	ldrh	r2, [r4, #24]
 800ccd0:	9202      	str	r2, [sp, #8]
 800ccd2:	8ae2      	ldrh	r2, [r4, #22]
 800ccd4:	9201      	str	r2, [sp, #4]
 800ccd6:	9300      	str	r3, [sp, #0]
 800ccd8:	4623      	mov	r3, r4
 800ccda:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 800ccdc:	6d21      	ldr	r1, [r4, #80]	@ 0x50
 800ccde:	4620      	mov	r0, r4
 800cce0:	f003 f94c 	bl	800ff7c <tcp_rst>
      tcp_pcb_purge(pcb);
 800cce4:	4620      	mov	r0, r4
 800cce6:	f7ff fd59 	bl	800c79c <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 800ccea:	4b3a      	ldr	r3, [pc, #232]	@ (800cdd4 <tcp_close_shutdown+0x12c>)
 800ccec:	681b      	ldr	r3, [r3, #0]
 800ccee:	42a3      	cmp	r3, r4
 800ccf0:	d02f      	beq.n	800cd52 <tcp_close_shutdown+0xaa>
 800ccf2:	2b00      	cmp	r3, #0
 800ccf4:	d033      	beq.n	800cd5e <tcp_close_shutdown+0xb6>
 800ccf6:	68da      	ldr	r2, [r3, #12]
 800ccf8:	42a2      	cmp	r2, r4
 800ccfa:	d02e      	beq.n	800cd5a <tcp_close_shutdown+0xb2>
 800ccfc:	4613      	mov	r3, r2
 800ccfe:	e7f8      	b.n	800ccf2 <tcp_close_shutdown+0x4a>
  LWIP_ASSERT("tcp_close_shutdown: invalid pcb", pcb != NULL);
 800cd00:	4b35      	ldr	r3, [pc, #212]	@ (800cdd8 <tcp_close_shutdown+0x130>)
 800cd02:	f44f 72af 	mov.w	r2, #350	@ 0x15e
 800cd06:	4935      	ldr	r1, [pc, #212]	@ (800cddc <tcp_close_shutdown+0x134>)
 800cd08:	4835      	ldr	r0, [pc, #212]	@ (800cde0 <tcp_close_shutdown+0x138>)
 800cd0a:	f007 f939 	bl	8013f80 <iprintf>
 800cd0e:	e7d0      	b.n	800ccb2 <tcp_close_shutdown+0xa>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND_MAX(pcb))) {
 800cd10:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
 800cd12:	f241 63d0 	movw	r3, #5840	@ 0x16d0
 800cd16:	429a      	cmp	r2, r3
 800cd18:	d1d4      	bne.n	800ccc4 <tcp_close_shutdown+0x1c>
  switch (pcb->state) {
 800cd1a:	7d23      	ldrb	r3, [r4, #20]
 800cd1c:	2b01      	cmp	r3, #1
 800cd1e:	d03d      	beq.n	800cd9c <tcp_close_shutdown+0xf4>
 800cd20:	2b02      	cmp	r3, #2
 800cd22:	d047      	beq.n	800cdb4 <tcp_close_shutdown+0x10c>
 800cd24:	2b00      	cmp	r3, #0
 800cd26:	d151      	bne.n	800cdcc <tcp_close_shutdown+0x124>
      if (pcb->local_port != 0) {
 800cd28:	8ae3      	ldrh	r3, [r4, #22]
 800cd2a:	2b00      	cmp	r3, #0
 800cd2c:	d030      	beq.n	800cd90 <tcp_close_shutdown+0xe8>
        TCP_RMV(&tcp_bound_pcbs, pcb);
 800cd2e:	4b2d      	ldr	r3, [pc, #180]	@ (800cde4 <tcp_close_shutdown+0x13c>)
 800cd30:	681b      	ldr	r3, [r3, #0]
 800cd32:	42a3      	cmp	r3, r4
 800cd34:	d024      	beq.n	800cd80 <tcp_close_shutdown+0xd8>
 800cd36:	b34b      	cbz	r3, 800cd8c <tcp_close_shutdown+0xe4>
 800cd38:	68da      	ldr	r2, [r3, #12]
 800cd3a:	42a2      	cmp	r2, r4
 800cd3c:	d024      	beq.n	800cd88 <tcp_close_shutdown+0xe0>
 800cd3e:	4613      	mov	r3, r2
 800cd40:	e7f9      	b.n	800cd36 <tcp_close_shutdown+0x8e>
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
 800cd42:	4b25      	ldr	r3, [pc, #148]	@ (800cdd8 <tcp_close_shutdown+0x130>)
 800cd44:	f44f 72b2 	mov.w	r2, #356	@ 0x164
 800cd48:	4927      	ldr	r1, [pc, #156]	@ (800cde8 <tcp_close_shutdown+0x140>)
 800cd4a:	4825      	ldr	r0, [pc, #148]	@ (800cde0 <tcp_close_shutdown+0x138>)
 800cd4c:	f007 f918 	bl	8013f80 <iprintf>
 800cd50:	e7bc      	b.n	800cccc <tcp_close_shutdown+0x24>
      TCP_RMV_ACTIVE(pcb);
 800cd52:	68da      	ldr	r2, [r3, #12]
 800cd54:	4b1f      	ldr	r3, [pc, #124]	@ (800cdd4 <tcp_close_shutdown+0x12c>)
 800cd56:	601a      	str	r2, [r3, #0]
 800cd58:	e001      	b.n	800cd5e <tcp_close_shutdown+0xb6>
 800cd5a:	68e2      	ldr	r2, [r4, #12]
 800cd5c:	60da      	str	r2, [r3, #12]
 800cd5e:	2300      	movs	r3, #0
 800cd60:	60e3      	str	r3, [r4, #12]
 800cd62:	4b22      	ldr	r3, [pc, #136]	@ (800cdec <tcp_close_shutdown+0x144>)
 800cd64:	2201      	movs	r2, #1
 800cd66:	701a      	strb	r2, [r3, #0]
      if (tcp_input_pcb == pcb) {
 800cd68:	4b21      	ldr	r3, [pc, #132]	@ (800cdf0 <tcp_close_shutdown+0x148>)
 800cd6a:	681b      	ldr	r3, [r3, #0]
 800cd6c:	42a3      	cmp	r3, r4
 800cd6e:	d004      	beq.n	800cd7a <tcp_close_shutdown+0xd2>
        tcp_free(pcb);
 800cd70:	4620      	mov	r0, r4
 800cd72:	f7ff faad 	bl	800c2d0 <tcp_free>
      return ERR_OK;
 800cd76:	2000      	movs	r0, #0
 800cd78:	e00e      	b.n	800cd98 <tcp_close_shutdown+0xf0>
        tcp_trigger_input_pcb_close();
 800cd7a:	f002 f88d 	bl	800ee98 <tcp_trigger_input_pcb_close>
 800cd7e:	e7fa      	b.n	800cd76 <tcp_close_shutdown+0xce>
        TCP_RMV(&tcp_bound_pcbs, pcb);
 800cd80:	68da      	ldr	r2, [r3, #12]
 800cd82:	4b18      	ldr	r3, [pc, #96]	@ (800cde4 <tcp_close_shutdown+0x13c>)
 800cd84:	601a      	str	r2, [r3, #0]
 800cd86:	e001      	b.n	800cd8c <tcp_close_shutdown+0xe4>
 800cd88:	68e2      	ldr	r2, [r4, #12]
 800cd8a:	60da      	str	r2, [r3, #12]
 800cd8c:	2300      	movs	r3, #0
 800cd8e:	60e3      	str	r3, [r4, #12]
      tcp_free(pcb);
 800cd90:	4620      	mov	r0, r4
 800cd92:	f7ff fa9d 	bl	800c2d0 <tcp_free>
  return ERR_OK;
 800cd96:	2000      	movs	r0, #0
}
 800cd98:	b005      	add	sp, #20
 800cd9a:	bd30      	pop	{r4, r5, pc}
      tcp_listen_closed(pcb);
 800cd9c:	4620      	mov	r0, r4
 800cd9e:	f7ff f9ef 	bl	800c180 <tcp_listen_closed>
      tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
 800cda2:	4621      	mov	r1, r4
 800cda4:	4813      	ldr	r0, [pc, #76]	@ (800cdf4 <tcp_close_shutdown+0x14c>)
 800cda6:	f7ff fd2b 	bl	800c800 <tcp_pcb_remove>
      tcp_free_listen(pcb);
 800cdaa:	4620      	mov	r0, r4
 800cdac:	f7ff fa16 	bl	800c1dc <tcp_free_listen>
  return ERR_OK;
 800cdb0:	2000      	movs	r0, #0
      break;
 800cdb2:	e7f1      	b.n	800cd98 <tcp_close_shutdown+0xf0>
      TCP_PCB_REMOVE_ACTIVE(pcb);
 800cdb4:	4621      	mov	r1, r4
 800cdb6:	4807      	ldr	r0, [pc, #28]	@ (800cdd4 <tcp_close_shutdown+0x12c>)
 800cdb8:	f7ff fd22 	bl	800c800 <tcp_pcb_remove>
 800cdbc:	4b0b      	ldr	r3, [pc, #44]	@ (800cdec <tcp_close_shutdown+0x144>)
 800cdbe:	2201      	movs	r2, #1
 800cdc0:	701a      	strb	r2, [r3, #0]
      tcp_free(pcb);
 800cdc2:	4620      	mov	r0, r4
 800cdc4:	f7ff fa84 	bl	800c2d0 <tcp_free>
  return ERR_OK;
 800cdc8:	2000      	movs	r0, #0
      break;
 800cdca:	e7e5      	b.n	800cd98 <tcp_close_shutdown+0xf0>
      return tcp_close_shutdown_fin(pcb);
 800cdcc:	4620      	mov	r0, r4
 800cdce:	f7ff fa1d 	bl	800c20c <tcp_close_shutdown_fin>
 800cdd2:	e7e1      	b.n	800cd98 <tcp_close_shutdown+0xf0>
 800cdd4:	240142dc 	.word	0x240142dc
 800cdd8:	080169a8 	.word	0x080169a8
 800cddc:	08016de4 	.word	0x08016de4
 800cde0:	08015744 	.word	0x08015744
 800cde4:	240142e4 	.word	0x240142e4
 800cde8:	08016e04 	.word	0x08016e04
 800cdec:	240142d6 	.word	0x240142d6
 800cdf0:	240142ec 	.word	0x240142ec
 800cdf4:	240142e0 	.word	0x240142e0

0800cdf8 <tcp_close>:
{
 800cdf8:	b508      	push	{r3, lr}
  LWIP_ERROR("tcp_close: invalid pcb", pcb != NULL, return ERR_ARG);
 800cdfa:	b160      	cbz	r0, 800ce16 <tcp_close+0x1e>
 800cdfc:	4603      	mov	r3, r0
  if (pcb->state != LISTEN) {
 800cdfe:	7d02      	ldrb	r2, [r0, #20]
 800ce00:	2a01      	cmp	r2, #1
 800ce02:	d003      	beq.n	800ce0c <tcp_close+0x14>
    tcp_set_flags(pcb, TF_RXCLOSED);
 800ce04:	8b42      	ldrh	r2, [r0, #26]
 800ce06:	f042 0210 	orr.w	r2, r2, #16
 800ce0a:	8342      	strh	r2, [r0, #26]
  return tcp_close_shutdown(pcb, 1);
 800ce0c:	2101      	movs	r1, #1
 800ce0e:	4618      	mov	r0, r3
 800ce10:	f7ff ff4a 	bl	800cca8 <tcp_close_shutdown>
}
 800ce14:	bd08      	pop	{r3, pc}
  LWIP_ERROR("tcp_close: invalid pcb", pcb != NULL, return ERR_ARG);
 800ce16:	4b05      	ldr	r3, [pc, #20]	@ (800ce2c <tcp_close+0x34>)
 800ce18:	f44f 72f4 	mov.w	r2, #488	@ 0x1e8
 800ce1c:	4904      	ldr	r1, [pc, #16]	@ (800ce30 <tcp_close+0x38>)
 800ce1e:	4805      	ldr	r0, [pc, #20]	@ (800ce34 <tcp_close+0x3c>)
 800ce20:	f007 f8ae 	bl	8013f80 <iprintf>
 800ce24:	f06f 000f 	mvn.w	r0, #15
 800ce28:	e7f4      	b.n	800ce14 <tcp_close+0x1c>
 800ce2a:	bf00      	nop
 800ce2c:	080169a8 	.word	0x080169a8
 800ce30:	08016e20 	.word	0x08016e20
 800ce34:	08015744 	.word	0x08015744

0800ce38 <tcp_recv_null>:
{
 800ce38:	b510      	push	{r4, lr}
  LWIP_ERROR("tcp_recv_null: invalid pcb", pcb != NULL, return ERR_ARG);
 800ce3a:	b151      	cbz	r1, 800ce52 <tcp_recv_null+0x1a>
 800ce3c:	4614      	mov	r4, r2
 800ce3e:	4608      	mov	r0, r1
  if (p != NULL) {
 800ce40:	b18a      	cbz	r2, 800ce66 <tcp_recv_null+0x2e>
    tcp_recved(pcb, p->tot_len);
 800ce42:	8911      	ldrh	r1, [r2, #8]
 800ce44:	f7ff fb6a 	bl	800c51c <tcp_recved>
    pbuf_free(p);
 800ce48:	4620      	mov	r0, r4
 800ce4a:	f7fe fe71 	bl	800bb30 <pbuf_free>
  return ERR_OK;
 800ce4e:	2000      	movs	r0, #0
}
 800ce50:	bd10      	pop	{r4, pc}
  LWIP_ERROR("tcp_recv_null: invalid pcb", pcb != NULL, return ERR_ARG);
 800ce52:	4b08      	ldr	r3, [pc, #32]	@ (800ce74 <tcp_recv_null+0x3c>)
 800ce54:	f44f 62d3 	mov.w	r2, #1688	@ 0x698
 800ce58:	4907      	ldr	r1, [pc, #28]	@ (800ce78 <tcp_recv_null+0x40>)
 800ce5a:	4808      	ldr	r0, [pc, #32]	@ (800ce7c <tcp_recv_null+0x44>)
 800ce5c:	f007 f890 	bl	8013f80 <iprintf>
 800ce60:	f06f 000f 	mvn.w	r0, #15
 800ce64:	e7f4      	b.n	800ce50 <tcp_recv_null+0x18>
  } else if (err == ERR_OK) {
 800ce66:	b10b      	cbz	r3, 800ce6c <tcp_recv_null+0x34>
  return ERR_OK;
 800ce68:	2000      	movs	r0, #0
 800ce6a:	e7f1      	b.n	800ce50 <tcp_recv_null+0x18>
    return tcp_close(pcb);
 800ce6c:	f7ff ffc4 	bl	800cdf8 <tcp_close>
 800ce70:	e7ee      	b.n	800ce50 <tcp_recv_null+0x18>
 800ce72:	bf00      	nop
 800ce74:	080169a8 	.word	0x080169a8
 800ce78:	08016e38 	.word	0x08016e38
 800ce7c:	08015744 	.word	0x08015744

0800ce80 <tcp_process_refused_data>:
{
 800ce80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  LWIP_ERROR("tcp_process_refused_data: invalid pcb", pcb != NULL, return ERR_ARG);
 800ce82:	b320      	cbz	r0, 800cece <tcp_process_refused_data+0x4e>
 800ce84:	4604      	mov	r4, r0
    u8_t refused_flags = pcb->refused_data->flags;
 800ce86:	6f86      	ldr	r6, [r0, #120]	@ 0x78
 800ce88:	7b77      	ldrb	r7, [r6, #13]
    pcb->refused_data = NULL;
 800ce8a:	2300      	movs	r3, #0
 800ce8c:	6783      	str	r3, [r0, #120]	@ 0x78
    TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 800ce8e:	f8d0 5084 	ldr.w	r5, [r0, #132]	@ 0x84
 800ce92:	b335      	cbz	r5, 800cee2 <tcp_process_refused_data+0x62>
 800ce94:	4632      	mov	r2, r6
 800ce96:	4601      	mov	r1, r0
 800ce98:	6900      	ldr	r0, [r0, #16]
 800ce9a:	47a8      	blx	r5
 800ce9c:	4605      	mov	r5, r0
    if (err == ERR_OK) {
 800ce9e:	bb45      	cbnz	r5, 800cef2 <tcp_process_refused_data+0x72>
      if ((refused_flags & PBUF_FLAG_TCP_FIN)
 800cea0:	f017 0f20 	tst.w	r7, #32
 800cea4:	d02b      	beq.n	800cefe <tcp_process_refused_data+0x7e>
        if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 800cea6:	8d23      	ldrh	r3, [r4, #40]	@ 0x28
 800cea8:	f241 62d0 	movw	r2, #5840	@ 0x16d0
 800ceac:	4293      	cmp	r3, r2
 800ceae:	d001      	beq.n	800ceb4 <tcp_process_refused_data+0x34>
          pcb->rcv_wnd++;
 800ceb0:	3301      	adds	r3, #1
 800ceb2:	8523      	strh	r3, [r4, #40]	@ 0x28
        TCP_EVENT_CLOSED(pcb, err);
 800ceb4:	f8d4 6084 	ldr.w	r6, [r4, #132]	@ 0x84
 800ceb8:	b30e      	cbz	r6, 800cefe <tcp_process_refused_data+0x7e>
 800ceba:	2300      	movs	r3, #0
 800cebc:	461a      	mov	r2, r3
 800cebe:	4621      	mov	r1, r4
 800cec0:	6920      	ldr	r0, [r4, #16]
 800cec2:	47b0      	blx	r6
        if (err == ERR_ABRT) {
 800cec4:	f110 0f0d 	cmn.w	r0, #13
 800cec8:	d119      	bne.n	800cefe <tcp_process_refused_data+0x7e>
          return ERR_ABRT;
 800ceca:	4605      	mov	r5, r0
 800cecc:	e017      	b.n	800cefe <tcp_process_refused_data+0x7e>
  LWIP_ERROR("tcp_process_refused_data: invalid pcb", pcb != NULL, return ERR_ARG);
 800cece:	4b0d      	ldr	r3, [pc, #52]	@ (800cf04 <tcp_process_refused_data+0x84>)
 800ced0:	f240 6209 	movw	r2, #1545	@ 0x609
 800ced4:	490c      	ldr	r1, [pc, #48]	@ (800cf08 <tcp_process_refused_data+0x88>)
 800ced6:	480d      	ldr	r0, [pc, #52]	@ (800cf0c <tcp_process_refused_data+0x8c>)
 800ced8:	f007 f852 	bl	8013f80 <iprintf>
 800cedc:	f06f 050f 	mvn.w	r5, #15
 800cee0:	e00d      	b.n	800cefe <tcp_process_refused_data+0x7e>
    TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 800cee2:	2300      	movs	r3, #0
 800cee4:	4632      	mov	r2, r6
 800cee6:	4601      	mov	r1, r0
 800cee8:	4618      	mov	r0, r3
 800ceea:	f7ff ffa5 	bl	800ce38 <tcp_recv_null>
 800ceee:	4605      	mov	r5, r0
 800cef0:	e7d5      	b.n	800ce9e <tcp_process_refused_data+0x1e>
    } else if (err == ERR_ABRT) {
 800cef2:	f115 0f0d 	cmn.w	r5, #13
 800cef6:	d002      	beq.n	800cefe <tcp_process_refused_data+0x7e>
      pcb->refused_data = refused_data;
 800cef8:	67a6      	str	r6, [r4, #120]	@ 0x78
      return ERR_INPROGRESS;
 800cefa:	f06f 0504 	mvn.w	r5, #4
}
 800cefe:	4628      	mov	r0, r5
 800cf00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800cf02:	bf00      	nop
 800cf04:	080169a8 	.word	0x080169a8
 800cf08:	08016e54 	.word	0x08016e54
 800cf0c:	08015744 	.word	0x08015744

0800cf10 <tcp_fasttmr>:
{
 800cf10:	b570      	push	{r4, r5, r6, lr}
  ++tcp_timer_ctr;
 800cf12:	4a1c      	ldr	r2, [pc, #112]	@ (800cf84 <tcp_fasttmr+0x74>)
 800cf14:	7813      	ldrb	r3, [r2, #0]
 800cf16:	3301      	adds	r3, #1
 800cf18:	7013      	strb	r3, [r2, #0]
  pcb = tcp_active_pcbs;
 800cf1a:	4b1b      	ldr	r3, [pc, #108]	@ (800cf88 <tcp_fasttmr+0x78>)
 800cf1c:	681c      	ldr	r4, [r3, #0]
  while (pcb != NULL) {
 800cf1e:	e013      	b.n	800cf48 <tcp_fasttmr+0x38>
        tcp_ack_now(pcb);
 800cf20:	f043 0302 	orr.w	r3, r3, #2
 800cf24:	8363      	strh	r3, [r4, #26]
        tcp_output(pcb);
 800cf26:	4620      	mov	r0, r4
 800cf28:	f003 f8aa 	bl	8010080 <tcp_output>
        tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 800cf2c:	8b63      	ldrh	r3, [r4, #26]
 800cf2e:	f023 0303 	bic.w	r3, r3, #3
 800cf32:	8363      	strh	r3, [r4, #26]
 800cf34:	e013      	b.n	800cf5e <tcp_fasttmr+0x4e>
        tcp_clear_flags(pcb, TF_CLOSEPEND);
 800cf36:	f023 0308 	bic.w	r3, r3, #8
 800cf3a:	8363      	strh	r3, [r4, #26]
        tcp_close_shutdown_fin(pcb);
 800cf3c:	4620      	mov	r0, r4
 800cf3e:	f7ff f965 	bl	800c20c <tcp_close_shutdown_fin>
 800cf42:	e010      	b.n	800cf66 <tcp_fasttmr+0x56>
      pcb = pcb->next;
 800cf44:	68e5      	ldr	r5, [r4, #12]
{
 800cf46:	462c      	mov	r4, r5
  while (pcb != NULL) {
 800cf48:	b1dc      	cbz	r4, 800cf82 <tcp_fasttmr+0x72>
    if (pcb->last_timer != tcp_timer_ctr) {
 800cf4a:	7fa2      	ldrb	r2, [r4, #30]
 800cf4c:	4b0d      	ldr	r3, [pc, #52]	@ (800cf84 <tcp_fasttmr+0x74>)
 800cf4e:	781b      	ldrb	r3, [r3, #0]
 800cf50:	429a      	cmp	r2, r3
 800cf52:	d0f7      	beq.n	800cf44 <tcp_fasttmr+0x34>
      pcb->last_timer = tcp_timer_ctr;
 800cf54:	77a3      	strb	r3, [r4, #30]
      if (pcb->flags & TF_ACK_DELAY) {
 800cf56:	8b63      	ldrh	r3, [r4, #26]
 800cf58:	f013 0f01 	tst.w	r3, #1
 800cf5c:	d1e0      	bne.n	800cf20 <tcp_fasttmr+0x10>
      if (pcb->flags & TF_CLOSEPEND) {
 800cf5e:	8b63      	ldrh	r3, [r4, #26]
 800cf60:	f013 0f08 	tst.w	r3, #8
 800cf64:	d1e7      	bne.n	800cf36 <tcp_fasttmr+0x26>
      next = pcb->next;
 800cf66:	68e5      	ldr	r5, [r4, #12]
      if (pcb->refused_data != NULL) {
 800cf68:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
 800cf6a:	2b00      	cmp	r3, #0
 800cf6c:	d0eb      	beq.n	800cf46 <tcp_fasttmr+0x36>
        tcp_active_pcbs_changed = 0;
 800cf6e:	4e07      	ldr	r6, [pc, #28]	@ (800cf8c <tcp_fasttmr+0x7c>)
 800cf70:	2300      	movs	r3, #0
 800cf72:	7033      	strb	r3, [r6, #0]
        tcp_process_refused_data(pcb);
 800cf74:	4620      	mov	r0, r4
 800cf76:	f7ff ff83 	bl	800ce80 <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
 800cf7a:	7833      	ldrb	r3, [r6, #0]
 800cf7c:	2b00      	cmp	r3, #0
 800cf7e:	d0e2      	beq.n	800cf46 <tcp_fasttmr+0x36>
 800cf80:	e7cb      	b.n	800cf1a <tcp_fasttmr+0xa>
}
 800cf82:	bd70      	pop	{r4, r5, r6, pc}
 800cf84:	240142d4 	.word	0x240142d4
 800cf88:	240142dc 	.word	0x240142dc
 800cf8c:	240142d6 	.word	0x240142d6

0800cf90 <tcp_shutdown>:
{
 800cf90:	b570      	push	{r4, r5, r6, lr}
  LWIP_ERROR("tcp_shutdown: invalid pcb", pcb != NULL, return ERR_ARG);
 800cf92:	b1e0      	cbz	r0, 800cfce <tcp_shutdown+0x3e>
 800cf94:	460d      	mov	r5, r1
 800cf96:	4616      	mov	r6, r2
 800cf98:	4604      	mov	r4, r0
  if (pcb->state == LISTEN) {
 800cf9a:	7d03      	ldrb	r3, [r0, #20]
 800cf9c:	2b01      	cmp	r3, #1
 800cf9e:	d02c      	beq.n	800cffa <tcp_shutdown+0x6a>
  if (shut_rx) {
 800cfa0:	b151      	cbz	r1, 800cfb8 <tcp_shutdown+0x28>
    tcp_set_flags(pcb, TF_RXCLOSED);
 800cfa2:	8b43      	ldrh	r3, [r0, #26]
 800cfa4:	f043 0310 	orr.w	r3, r3, #16
 800cfa8:	8343      	strh	r3, [r0, #26]
    if (shut_tx) {
 800cfaa:	b9d2      	cbnz	r2, 800cfe2 <tcp_shutdown+0x52>
    if (pcb->refused_data != NULL) {
 800cfac:	6f80      	ldr	r0, [r0, #120]	@ 0x78
 800cfae:	b118      	cbz	r0, 800cfb8 <tcp_shutdown+0x28>
      pbuf_free(pcb->refused_data);
 800cfb0:	f7fe fdbe 	bl	800bb30 <pbuf_free>
      pcb->refused_data = NULL;
 800cfb4:	2300      	movs	r3, #0
 800cfb6:	67a3      	str	r3, [r4, #120]	@ 0x78
  if (shut_tx) {
 800cfb8:	b316      	cbz	r6, 800d000 <tcp_shutdown+0x70>
    switch (pcb->state) {
 800cfba:	7d23      	ldrb	r3, [r4, #20]
 800cfbc:	2b04      	cmp	r3, #4
 800cfbe:	d817      	bhi.n	800cff0 <tcp_shutdown+0x60>
 800cfc0:	2b03      	cmp	r3, #3
 800cfc2:	d312      	bcc.n	800cfea <tcp_shutdown+0x5a>
        return tcp_close_shutdown(pcb, (u8_t)shut_rx);
 800cfc4:	b2e9      	uxtb	r1, r5
 800cfc6:	4620      	mov	r0, r4
 800cfc8:	f7ff fe6e 	bl	800cca8 <tcp_close_shutdown>
 800cfcc:	e019      	b.n	800d002 <tcp_shutdown+0x72>
  LWIP_ERROR("tcp_shutdown: invalid pcb", pcb != NULL, return ERR_ARG);
 800cfce:	4b0d      	ldr	r3, [pc, #52]	@ (800d004 <tcp_shutdown+0x74>)
 800cfd0:	f240 2207 	movw	r2, #519	@ 0x207
 800cfd4:	490c      	ldr	r1, [pc, #48]	@ (800d008 <tcp_shutdown+0x78>)
 800cfd6:	480d      	ldr	r0, [pc, #52]	@ (800d00c <tcp_shutdown+0x7c>)
 800cfd8:	f006 ffd2 	bl	8013f80 <iprintf>
 800cfdc:	f06f 000f 	mvn.w	r0, #15
 800cfe0:	e00f      	b.n	800d002 <tcp_shutdown+0x72>
      return tcp_close_shutdown(pcb, 1);
 800cfe2:	2101      	movs	r1, #1
 800cfe4:	f7ff fe60 	bl	800cca8 <tcp_close_shutdown>
 800cfe8:	e00b      	b.n	800d002 <tcp_shutdown+0x72>
    switch (pcb->state) {
 800cfea:	f06f 000a 	mvn.w	r0, #10
 800cfee:	e008      	b.n	800d002 <tcp_shutdown+0x72>
 800cff0:	2b07      	cmp	r3, #7
 800cff2:	d0e7      	beq.n	800cfc4 <tcp_shutdown+0x34>
 800cff4:	f06f 000a 	mvn.w	r0, #10
 800cff8:	e003      	b.n	800d002 <tcp_shutdown+0x72>
    return ERR_CONN;
 800cffa:	f06f 000a 	mvn.w	r0, #10
 800cffe:	e000      	b.n	800d002 <tcp_shutdown+0x72>
  return ERR_OK;
 800d000:	2000      	movs	r0, #0
}
 800d002:	bd70      	pop	{r4, r5, r6, pc}
 800d004:	080169a8 	.word	0x080169a8
 800d008:	08016e7c 	.word	0x08016e7c
 800d00c:	08015744 	.word	0x08015744

0800d010 <tcp_slowtmr>:
{
 800d010:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d014:	b084      	sub	sp, #16
  ++tcp_ticks;
 800d016:	4a99      	ldr	r2, [pc, #612]	@ (800d27c <tcp_slowtmr+0x26c>)
 800d018:	6813      	ldr	r3, [r2, #0]
 800d01a:	3301      	adds	r3, #1
 800d01c:	6013      	str	r3, [r2, #0]
  ++tcp_timer_ctr;
 800d01e:	4a98      	ldr	r2, [pc, #608]	@ (800d280 <tcp_slowtmr+0x270>)
 800d020:	7813      	ldrb	r3, [r2, #0]
 800d022:	3301      	adds	r3, #1
 800d024:	7013      	strb	r3, [r2, #0]
  pcb = tcp_active_pcbs;
 800d026:	4b97      	ldr	r3, [pc, #604]	@ (800d284 <tcp_slowtmr+0x274>)
 800d028:	681c      	ldr	r4, [r3, #0]
  prev = NULL;
 800d02a:	2500      	movs	r5, #0
 800d02c:	e193      	b.n	800d356 <tcp_slowtmr+0x346>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
 800d02e:	4b96      	ldr	r3, [pc, #600]	@ (800d288 <tcp_slowtmr+0x278>)
 800d030:	f240 42be 	movw	r2, #1214	@ 0x4be
 800d034:	4995      	ldr	r1, [pc, #596]	@ (800d28c <tcp_slowtmr+0x27c>)
 800d036:	4896      	ldr	r0, [pc, #600]	@ (800d290 <tcp_slowtmr+0x280>)
 800d038:	f006 ffa2 	bl	8013f80 <iprintf>
 800d03c:	e191      	b.n	800d362 <tcp_slowtmr+0x352>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
 800d03e:	4b92      	ldr	r3, [pc, #584]	@ (800d288 <tcp_slowtmr+0x278>)
 800d040:	f240 42bf 	movw	r2, #1215	@ 0x4bf
 800d044:	4993      	ldr	r1, [pc, #588]	@ (800d294 <tcp_slowtmr+0x284>)
 800d046:	4892      	ldr	r0, [pc, #584]	@ (800d290 <tcp_slowtmr+0x280>)
 800d048:	f006 ff9a 	bl	8013f80 <iprintf>
 800d04c:	e18d      	b.n	800d36a <tcp_slowtmr+0x35a>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
 800d04e:	4b8e      	ldr	r3, [pc, #568]	@ (800d288 <tcp_slowtmr+0x278>)
 800d050:	f44f 6298 	mov.w	r2, #1216	@ 0x4c0
 800d054:	4990      	ldr	r1, [pc, #576]	@ (800d298 <tcp_slowtmr+0x288>)
 800d056:	488e      	ldr	r0, [pc, #568]	@ (800d290 <tcp_slowtmr+0x280>)
 800d058:	f006 ff92 	bl	8013f80 <iprintf>
 800d05c:	e189      	b.n	800d372 <tcp_slowtmr+0x362>
      prev = pcb;
 800d05e:	4625      	mov	r5, r4
      pcb = pcb->next;
 800d060:	68e4      	ldr	r4, [r4, #12]
      continue;
 800d062:	e178      	b.n	800d356 <tcp_slowtmr+0x346>
    if (pcb->state == SYN_SENT && pcb->nrtx >= TCP_SYNMAXRTX) {
 800d064:	f894 3042 	ldrb.w	r3, [r4, #66]	@ 0x42
 800d068:	2b05      	cmp	r3, #5
 800d06a:	f240 818d 	bls.w	800d388 <tcp_slowtmr+0x378>
      ++pcb_remove;
 800d06e:	2601      	movs	r6, #1
 800d070:	e06e      	b.n	800d150 <tcp_slowtmr+0x140>
        LWIP_ASSERT("tcp_slowtimr: persist ticking with empty send buffer", pcb->unsent != NULL);
 800d072:	4b85      	ldr	r3, [pc, #532]	@ (800d288 <tcp_slowtmr+0x278>)
 800d074:	f240 42d5 	movw	r2, #1237	@ 0x4d5
 800d078:	4988      	ldr	r1, [pc, #544]	@ (800d29c <tcp_slowtmr+0x28c>)
 800d07a:	4885      	ldr	r0, [pc, #532]	@ (800d290 <tcp_slowtmr+0x280>)
 800d07c:	f006 ff80 	bl	8013f80 <iprintf>
 800d080:	e199      	b.n	800d3b6 <tcp_slowtmr+0x3a6>
              if (tcp_split_unsent_seg(pcb, (u16_t)pcb->snd_wnd) == ERR_OK) {
 800d082:	4620      	mov	r0, r4
 800d084:	f002 fcd2 	bl	800fa2c <tcp_split_unsent_seg>
 800d088:	b158      	cbz	r0, 800d0a2 <tcp_slowtmr+0x92>
              pcb->persist_cnt = 0;
 800d08a:	2300      	movs	r3, #0
 800d08c:	f884 3098 	strb.w	r3, [r4, #152]	@ 0x98
              if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 800d090:	f894 3099 	ldrb.w	r3, [r4, #153]	@ 0x99
 800d094:	2b06      	cmp	r3, #6
 800d096:	d87c      	bhi.n	800d192 <tcp_slowtmr+0x182>
                pcb->persist_backoff++;
 800d098:	3301      	adds	r3, #1
 800d09a:	f884 3099 	strb.w	r3, [r4, #153]	@ 0x99
    pcb_remove = 0;
 800d09e:	2600      	movs	r6, #0
 800d0a0:	e056      	b.n	800d150 <tcp_slowtmr+0x140>
                if (tcp_output(pcb) == ERR_OK) {
 800d0a2:	4620      	mov	r0, r4
 800d0a4:	f002 ffec 	bl	8010080 <tcp_output>
 800d0a8:	2800      	cmp	r0, #0
 800d0aa:	d1ee      	bne.n	800d08a <tcp_slowtmr+0x7a>
    pcb_remove = 0;
 800d0ac:	2600      	movs	r6, #0
 800d0ae:	e04f      	b.n	800d150 <tcp_slowtmr+0x140>
        if ((pcb->rtime >= 0) && (pcb->rtime < 0x7FFF)) {
 800d0b0:	f9b4 3030 	ldrsh.w	r3, [r4, #48]	@ 0x30
 800d0b4:	b29b      	uxth	r3, r3
 800d0b6:	f647 72fe 	movw	r2, #32766	@ 0x7ffe
 800d0ba:	4293      	cmp	r3, r2
 800d0bc:	d801      	bhi.n	800d0c2 <tcp_slowtmr+0xb2>
          ++pcb->rtime;
 800d0be:	3301      	adds	r3, #1
 800d0c0:	8623      	strh	r3, [r4, #48]	@ 0x30
        if (pcb->rtime >= pcb->rto) {
 800d0c2:	f9b4 2030 	ldrsh.w	r2, [r4, #48]	@ 0x30
 800d0c6:	f9b4 3040 	ldrsh.w	r3, [r4, #64]	@ 0x40
 800d0ca:	429a      	cmp	r2, r3
 800d0cc:	db40      	blt.n	800d150 <tcp_slowtmr+0x140>
          if ((tcp_rexmit_rto_prepare(pcb) == ERR_OK) || ((pcb->unacked == NULL) && (pcb->unsent != NULL))) {
 800d0ce:	4620      	mov	r0, r4
 800d0d0:	f002 fe82 	bl	800fdd8 <tcp_rexmit_rto_prepare>
 800d0d4:	b120      	cbz	r0, 800d0e0 <tcp_slowtmr+0xd0>
 800d0d6:	6f23      	ldr	r3, [r4, #112]	@ 0x70
 800d0d8:	2b00      	cmp	r3, #0
 800d0da:	d139      	bne.n	800d150 <tcp_slowtmr+0x140>
 800d0dc:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
 800d0de:	b3bb      	cbz	r3, 800d150 <tcp_slowtmr+0x140>
            if (pcb->state != SYN_SENT) {
 800d0e0:	7d23      	ldrb	r3, [r4, #20]
 800d0e2:	2b02      	cmp	r3, #2
 800d0e4:	d014      	beq.n	800d110 <tcp_slowtmr+0x100>
              u8_t backoff_idx = LWIP_MIN(pcb->nrtx, sizeof(tcp_backoff) - 1);
 800d0e6:	f894 2042 	ldrb.w	r2, [r4, #66]	@ 0x42
 800d0ea:	2a0c      	cmp	r2, #12
 800d0ec:	bf28      	it	cs
 800d0ee:	220c      	movcs	r2, #12
              int calc_rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[backoff_idx];
 800d0f0:	f9b4 103c 	ldrsh.w	r1, [r4, #60]	@ 0x3c
 800d0f4:	f9b4 303e 	ldrsh.w	r3, [r4, #62]	@ 0x3e
 800d0f8:	eb03 03e1 	add.w	r3, r3, r1, asr #3
 800d0fc:	4968      	ldr	r1, [pc, #416]	@ (800d2a0 <tcp_slowtmr+0x290>)
 800d0fe:	5c8a      	ldrb	r2, [r1, r2]
 800d100:	4093      	lsls	r3, r2
              pcb->rto = (s16_t)LWIP_MIN(calc_rto, 0x7FFF);
 800d102:	f647 72fe 	movw	r2, #32766	@ 0x7ffe
 800d106:	4293      	cmp	r3, r2
 800d108:	dc1e      	bgt.n	800d148 <tcp_slowtmr+0x138>
 800d10a:	b21b      	sxth	r3, r3
 800d10c:	f8a4 3040 	strh.w	r3, [r4, #64]	@ 0x40
            pcb->rtime = 0;
 800d110:	2300      	movs	r3, #0
 800d112:	8623      	strh	r3, [r4, #48]	@ 0x30
            eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
 800d114:	f8b4 3060 	ldrh.w	r3, [r4, #96]	@ 0x60
 800d118:	f8b4 2048 	ldrh.w	r2, [r4, #72]	@ 0x48
 800d11c:	4293      	cmp	r3, r2
 800d11e:	bf28      	it	cs
 800d120:	4613      	movcs	r3, r2
            pcb->ssthresh = eff_wnd >> 1;
 800d122:	085b      	lsrs	r3, r3, #1
 800d124:	f8a4 304a 	strh.w	r3, [r4, #74]	@ 0x4a
            if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
 800d128:	8e61      	ldrh	r1, [r4, #50]	@ 0x32
 800d12a:	004a      	lsls	r2, r1, #1
 800d12c:	b292      	uxth	r2, r2
 800d12e:	4293      	cmp	r3, r2
 800d130:	d201      	bcs.n	800d136 <tcp_slowtmr+0x126>
              pcb->ssthresh = (tcpwnd_size_t)(pcb->mss << 1);
 800d132:	f8a4 204a 	strh.w	r2, [r4, #74]	@ 0x4a
            pcb->cwnd = pcb->mss;
 800d136:	f8a4 1048 	strh.w	r1, [r4, #72]	@ 0x48
            pcb->bytes_acked = 0;
 800d13a:	2300      	movs	r3, #0
 800d13c:	f8a4 306a 	strh.w	r3, [r4, #106]	@ 0x6a
            tcp_rexmit_rto_commit(pcb);
 800d140:	4620      	mov	r0, r4
 800d142:	f003 f8eb 	bl	801031c <tcp_rexmit_rto_commit>
 800d146:	e003      	b.n	800d150 <tcp_slowtmr+0x140>
              pcb->rto = (s16_t)LWIP_MIN(calc_rto, 0x7FFF);
 800d148:	f647 73ff 	movw	r3, #32767	@ 0x7fff
 800d14c:	e7de      	b.n	800d10c <tcp_slowtmr+0xfc>
      ++pcb_remove;
 800d14e:	2601      	movs	r6, #1
    if (pcb->state == FIN_WAIT_2) {
 800d150:	7d23      	ldrb	r3, [r4, #20]
 800d152:	2b06      	cmp	r3, #6
 800d154:	d01f      	beq.n	800d196 <tcp_slowtmr+0x186>
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
 800d156:	7a62      	ldrb	r2, [r4, #9]
 800d158:	f012 0708 	ands.w	r7, r2, #8
 800d15c:	d042      	beq.n	800d1e4 <tcp_slowtmr+0x1d4>
 800d15e:	2b07      	cmp	r3, #7
 800d160:	bf18      	it	ne
 800d162:	2b04      	cmpne	r3, #4
 800d164:	d13d      	bne.n	800d1e2 <tcp_slowtmr+0x1d2>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 800d166:	4b45      	ldr	r3, [pc, #276]	@ (800d27c <tcp_slowtmr+0x26c>)
 800d168:	681a      	ldr	r2, [r3, #0]
 800d16a:	6a23      	ldr	r3, [r4, #32]
 800d16c:	1ad2      	subs	r2, r2, r3
          (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL) {
 800d16e:	f8d4 1094 	ldr.w	r1, [r4, #148]	@ 0x94
 800d172:	4b4c      	ldr	r3, [pc, #304]	@ (800d2a4 <tcp_slowtmr+0x294>)
 800d174:	440b      	add	r3, r1
 800d176:	484c      	ldr	r0, [pc, #304]	@ (800d2a8 <tcp_slowtmr+0x298>)
 800d178:	fba0 0303 	umull	r0, r3, r0, r3
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 800d17c:	ebb2 1f53 	cmp.w	r2, r3, lsr #5
 800d180:	d916      	bls.n	800d1b0 <tcp_slowtmr+0x1a0>
        ++pcb_remove;
 800d182:	3601      	adds	r6, #1
 800d184:	b2f6      	uxtb	r6, r6
        ++pcb_reset;
 800d186:	2701      	movs	r7, #1
 800d188:	e02c      	b.n	800d1e4 <tcp_slowtmr+0x1d4>
          ++pcb_remove; /* max probes reached */
 800d18a:	2601      	movs	r6, #1
 800d18c:	e7e0      	b.n	800d150 <tcp_slowtmr+0x140>
    pcb_remove = 0;
 800d18e:	2600      	movs	r6, #0
 800d190:	e7de      	b.n	800d150 <tcp_slowtmr+0x140>
 800d192:	2600      	movs	r6, #0
 800d194:	e7dc      	b.n	800d150 <tcp_slowtmr+0x140>
      if (pcb->flags & TF_RXCLOSED) {
 800d196:	8b62      	ldrh	r2, [r4, #26]
 800d198:	f012 0f10 	tst.w	r2, #16
 800d19c:	d0db      	beq.n	800d156 <tcp_slowtmr+0x146>
        if ((u32_t)(tcp_ticks - pcb->tmr) >
 800d19e:	6a21      	ldr	r1, [r4, #32]
 800d1a0:	4a36      	ldr	r2, [pc, #216]	@ (800d27c <tcp_slowtmr+0x26c>)
 800d1a2:	6812      	ldr	r2, [r2, #0]
 800d1a4:	1a52      	subs	r2, r2, r1
 800d1a6:	2a28      	cmp	r2, #40	@ 0x28
 800d1a8:	d9d5      	bls.n	800d156 <tcp_slowtmr+0x146>
          ++pcb_remove;
 800d1aa:	3601      	adds	r6, #1
 800d1ac:	b2f6      	uxtb	r6, r6
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
 800d1ae:	e7d2      	b.n	800d156 <tcp_slowtmr+0x146>
                 (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
 800d1b0:	f894 309b 	ldrb.w	r3, [r4, #155]	@ 0x9b
 800d1b4:	483d      	ldr	r0, [pc, #244]	@ (800d2ac <tcp_slowtmr+0x29c>)
 800d1b6:	fb00 1103 	mla	r1, r0, r3, r1
                 / TCP_SLOW_INTERVAL) {
 800d1ba:	4b3b      	ldr	r3, [pc, #236]	@ (800d2a8 <tcp_slowtmr+0x298>)
 800d1bc:	fba3 3101 	umull	r3, r1, r3, r1
      } else if ((u32_t)(tcp_ticks - pcb->tmr) >
 800d1c0:	ebb2 1f51 	cmp.w	r2, r1, lsr #5
 800d1c4:	d801      	bhi.n	800d1ca <tcp_slowtmr+0x1ba>
    pcb_reset = 0;
 800d1c6:	2700      	movs	r7, #0
 800d1c8:	e00c      	b.n	800d1e4 <tcp_slowtmr+0x1d4>
        err = tcp_keepalive(pcb);
 800d1ca:	4620      	mov	r0, r4
 800d1cc:	f003 f8dc 	bl	8010388 <tcp_keepalive>
        if (err == ERR_OK) {
 800d1d0:	2800      	cmp	r0, #0
 800d1d2:	d13b      	bne.n	800d24c <tcp_slowtmr+0x23c>
          pcb->keep_cnt_sent++;
 800d1d4:	f894 309b 	ldrb.w	r3, [r4, #155]	@ 0x9b
 800d1d8:	3301      	adds	r3, #1
 800d1da:	f884 309b 	strb.w	r3, [r4, #155]	@ 0x9b
    pcb_reset = 0;
 800d1de:	2700      	movs	r7, #0
 800d1e0:	e000      	b.n	800d1e4 <tcp_slowtmr+0x1d4>
 800d1e2:	2700      	movs	r7, #0
    if (pcb->ooseq != NULL &&
 800d1e4:	6f63      	ldr	r3, [r4, #116]	@ 0x74
 800d1e6:	b153      	cbz	r3, 800d1fe <tcp_slowtmr+0x1ee>
        (tcp_ticks - pcb->tmr >= (u32_t)pcb->rto * TCP_OOSEQ_TIMEOUT)) {
 800d1e8:	6a23      	ldr	r3, [r4, #32]
 800d1ea:	4a24      	ldr	r2, [pc, #144]	@ (800d27c <tcp_slowtmr+0x26c>)
 800d1ec:	6812      	ldr	r2, [r2, #0]
 800d1ee:	1ad2      	subs	r2, r2, r3
 800d1f0:	f9b4 3040 	ldrsh.w	r3, [r4, #64]	@ 0x40
 800d1f4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    if (pcb->ooseq != NULL &&
 800d1f8:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
 800d1fc:	d228      	bcs.n	800d250 <tcp_slowtmr+0x240>
    if (pcb->state == SYN_RCVD) {
 800d1fe:	7d23      	ldrb	r3, [r4, #20]
 800d200:	2b03      	cmp	r3, #3
 800d202:	d029      	beq.n	800d258 <tcp_slowtmr+0x248>
    if (pcb->state == LAST_ACK) {
 800d204:	2b09      	cmp	r3, #9
 800d206:	d030      	beq.n	800d26a <tcp_slowtmr+0x25a>
    if (pcb_remove) {
 800d208:	2e00      	cmp	r6, #0
 800d20a:	d153      	bne.n	800d2b4 <tcp_slowtmr+0x2a4>
      pcb = pcb->next;
 800d20c:	68e6      	ldr	r6, [r4, #12]
      ++prev->polltmr;
 800d20e:	7f23      	ldrb	r3, [r4, #28]
 800d210:	3301      	adds	r3, #1
 800d212:	b2db      	uxtb	r3, r3
 800d214:	7723      	strb	r3, [r4, #28]
      if (prev->polltmr >= prev->pollinterval) {
 800d216:	7f62      	ldrb	r2, [r4, #29]
 800d218:	4293      	cmp	r3, r2
 800d21a:	f0c0 809a 	bcc.w	800d352 <tcp_slowtmr+0x342>
        prev->polltmr = 0;
 800d21e:	2300      	movs	r3, #0
 800d220:	7723      	strb	r3, [r4, #28]
        tcp_active_pcbs_changed = 0;
 800d222:	4a23      	ldr	r2, [pc, #140]	@ (800d2b0 <tcp_slowtmr+0x2a0>)
 800d224:	7013      	strb	r3, [r2, #0]
        TCP_EVENT_POLL(prev, err);
 800d226:	f8d4 308c 	ldr.w	r3, [r4, #140]	@ 0x8c
 800d22a:	2b00      	cmp	r3, #0
 800d22c:	f000 8089 	beq.w	800d342 <tcp_slowtmr+0x332>
 800d230:	4621      	mov	r1, r4
 800d232:	6920      	ldr	r0, [r4, #16]
 800d234:	4798      	blx	r3
        if (tcp_active_pcbs_changed) {
 800d236:	4b1e      	ldr	r3, [pc, #120]	@ (800d2b0 <tcp_slowtmr+0x2a0>)
 800d238:	781b      	ldrb	r3, [r3, #0]
 800d23a:	2b00      	cmp	r3, #0
 800d23c:	f47f aef3 	bne.w	800d026 <tcp_slowtmr+0x16>
        if (err == ERR_OK) {
 800d240:	2800      	cmp	r0, #0
 800d242:	f000 8080 	beq.w	800d346 <tcp_slowtmr+0x336>
      prev = pcb;
 800d246:	4625      	mov	r5, r4
      pcb = pcb->next;
 800d248:	4634      	mov	r4, r6
 800d24a:	e084      	b.n	800d356 <tcp_slowtmr+0x346>
    pcb_reset = 0;
 800d24c:	2700      	movs	r7, #0
 800d24e:	e7c9      	b.n	800d1e4 <tcp_slowtmr+0x1d4>
      tcp_free_ooseq(pcb);
 800d250:	4620      	mov	r0, r4
 800d252:	f7ff fa99 	bl	800c788 <tcp_free_ooseq>
 800d256:	e7d2      	b.n	800d1fe <tcp_slowtmr+0x1ee>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 800d258:	6a21      	ldr	r1, [r4, #32]
 800d25a:	4a08      	ldr	r2, [pc, #32]	@ (800d27c <tcp_slowtmr+0x26c>)
 800d25c:	6812      	ldr	r2, [r2, #0]
 800d25e:	1a52      	subs	r2, r2, r1
 800d260:	2a28      	cmp	r2, #40	@ 0x28
 800d262:	d9cf      	bls.n	800d204 <tcp_slowtmr+0x1f4>
        ++pcb_remove;
 800d264:	3601      	adds	r6, #1
 800d266:	b2f6      	uxtb	r6, r6
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
 800d268:	e7cc      	b.n	800d204 <tcp_slowtmr+0x1f4>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 800d26a:	6a22      	ldr	r2, [r4, #32]
 800d26c:	4b03      	ldr	r3, [pc, #12]	@ (800d27c <tcp_slowtmr+0x26c>)
 800d26e:	681b      	ldr	r3, [r3, #0]
 800d270:	1a9b      	subs	r3, r3, r2
 800d272:	2bf0      	cmp	r3, #240	@ 0xf0
 800d274:	d9c8      	bls.n	800d208 <tcp_slowtmr+0x1f8>
        ++pcb_remove;
 800d276:	3601      	adds	r6, #1
 800d278:	b2f6      	uxtb	r6, r6
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
 800d27a:	e7c5      	b.n	800d208 <tcp_slowtmr+0x1f8>
 800d27c:	240142e8 	.word	0x240142e8
 800d280:	240142d4 	.word	0x240142d4
 800d284:	240142dc 	.word	0x240142dc
 800d288:	080169a8 	.word	0x080169a8
 800d28c:	08016e98 	.word	0x08016e98
 800d290:	08015744 	.word	0x08015744
 800d294:	08016ec4 	.word	0x08016ec4
 800d298:	08016ef0 	.word	0x08016ef0
 800d29c:	08016f54 	.word	0x08016f54
 800d2a0:	08018f8c 	.word	0x08018f8c
 800d2a4:	000a4cb8 	.word	0x000a4cb8
 800d2a8:	10624dd3 	.word	0x10624dd3
 800d2ac:	000124f8 	.word	0x000124f8
 800d2b0:	240142d6 	.word	0x240142d6
      tcp_err_fn err_fn = pcb->errf;
 800d2b4:	f8d4 8090 	ldr.w	r8, [r4, #144]	@ 0x90
      tcp_pcb_purge(pcb);
 800d2b8:	4620      	mov	r0, r4
 800d2ba:	f7ff fa6f 	bl	800c79c <tcp_pcb_purge>
      if (prev != NULL) {
 800d2be:	b325      	cbz	r5, 800d30a <tcp_slowtmr+0x2fa>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
 800d2c0:	4b6f      	ldr	r3, [pc, #444]	@ (800d480 <tcp_slowtmr+0x470>)
 800d2c2:	681b      	ldr	r3, [r3, #0]
 800d2c4:	429c      	cmp	r4, r3
 800d2c6:	d018      	beq.n	800d2fa <tcp_slowtmr+0x2ea>
        prev->next = pcb->next;
 800d2c8:	68e3      	ldr	r3, [r4, #12]
 800d2ca:	60eb      	str	r3, [r5, #12]
      if (pcb_reset) {
 800d2cc:	bb67      	cbnz	r7, 800d328 <tcp_slowtmr+0x318>
      err_arg = pcb->callback_arg;
 800d2ce:	6926      	ldr	r6, [r4, #16]
      pcb = pcb->next;
 800d2d0:	68e7      	ldr	r7, [r4, #12]
      tcp_free(pcb2);
 800d2d2:	4620      	mov	r0, r4
 800d2d4:	f7fe fffc 	bl	800c2d0 <tcp_free>
      tcp_active_pcbs_changed = 0;
 800d2d8:	4b6a      	ldr	r3, [pc, #424]	@ (800d484 <tcp_slowtmr+0x474>)
 800d2da:	2200      	movs	r2, #0
 800d2dc:	701a      	strb	r2, [r3, #0]
      TCP_EVENT_ERR(last_state, err_fn, err_arg, ERR_ABRT);
 800d2de:	f1b8 0f00 	cmp.w	r8, #0
 800d2e2:	d003      	beq.n	800d2ec <tcp_slowtmr+0x2dc>
 800d2e4:	f06f 010c 	mvn.w	r1, #12
 800d2e8:	4630      	mov	r0, r6
 800d2ea:	47c0      	blx	r8
      if (tcp_active_pcbs_changed) {
 800d2ec:	4b65      	ldr	r3, [pc, #404]	@ (800d484 <tcp_slowtmr+0x474>)
 800d2ee:	781b      	ldrb	r3, [r3, #0]
 800d2f0:	2b00      	cmp	r3, #0
 800d2f2:	f47f ae98 	bne.w	800d026 <tcp_slowtmr+0x16>
      pcb = pcb->next;
 800d2f6:	463c      	mov	r4, r7
 800d2f8:	e02d      	b.n	800d356 <tcp_slowtmr+0x346>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
 800d2fa:	4b63      	ldr	r3, [pc, #396]	@ (800d488 <tcp_slowtmr+0x478>)
 800d2fc:	f240 526d 	movw	r2, #1389	@ 0x56d
 800d300:	4962      	ldr	r1, [pc, #392]	@ (800d48c <tcp_slowtmr+0x47c>)
 800d302:	4863      	ldr	r0, [pc, #396]	@ (800d490 <tcp_slowtmr+0x480>)
 800d304:	f006 fe3c 	bl	8013f80 <iprintf>
 800d308:	e7de      	b.n	800d2c8 <tcp_slowtmr+0x2b8>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
 800d30a:	4b5d      	ldr	r3, [pc, #372]	@ (800d480 <tcp_slowtmr+0x470>)
 800d30c:	681b      	ldr	r3, [r3, #0]
 800d30e:	429c      	cmp	r4, r3
 800d310:	d006      	beq.n	800d320 <tcp_slowtmr+0x310>
 800d312:	4b5d      	ldr	r3, [pc, #372]	@ (800d488 <tcp_slowtmr+0x478>)
 800d314:	f240 5271 	movw	r2, #1393	@ 0x571
 800d318:	495e      	ldr	r1, [pc, #376]	@ (800d494 <tcp_slowtmr+0x484>)
 800d31a:	485d      	ldr	r0, [pc, #372]	@ (800d490 <tcp_slowtmr+0x480>)
 800d31c:	f006 fe30 	bl	8013f80 <iprintf>
        tcp_active_pcbs = pcb->next;
 800d320:	68e2      	ldr	r2, [r4, #12]
 800d322:	4b57      	ldr	r3, [pc, #348]	@ (800d480 <tcp_slowtmr+0x470>)
 800d324:	601a      	str	r2, [r3, #0]
 800d326:	e7d1      	b.n	800d2cc <tcp_slowtmr+0x2bc>
        tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 800d328:	1d23      	adds	r3, r4, #4
 800d32a:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 800d32c:	6d21      	ldr	r1, [r4, #80]	@ 0x50
 800d32e:	8b20      	ldrh	r0, [r4, #24]
 800d330:	9002      	str	r0, [sp, #8]
 800d332:	8ae0      	ldrh	r0, [r4, #22]
 800d334:	9001      	str	r0, [sp, #4]
 800d336:	9300      	str	r3, [sp, #0]
 800d338:	4623      	mov	r3, r4
 800d33a:	4620      	mov	r0, r4
 800d33c:	f002 fe1e 	bl	800ff7c <tcp_rst>
 800d340:	e7c5      	b.n	800d2ce <tcp_slowtmr+0x2be>
        TCP_EVENT_POLL(prev, err);
 800d342:	2000      	movs	r0, #0
 800d344:	e777      	b.n	800d236 <tcp_slowtmr+0x226>
          tcp_output(prev);
 800d346:	4620      	mov	r0, r4
 800d348:	f002 fe9a 	bl	8010080 <tcp_output>
      prev = pcb;
 800d34c:	4625      	mov	r5, r4
      pcb = pcb->next;
 800d34e:	4634      	mov	r4, r6
 800d350:	e001      	b.n	800d356 <tcp_slowtmr+0x346>
      prev = pcb;
 800d352:	4625      	mov	r5, r4
      pcb = pcb->next;
 800d354:	4634      	mov	r4, r6
  while (pcb != NULL) {
 800d356:	2c00      	cmp	r4, #0
 800d358:	d050      	beq.n	800d3fc <tcp_slowtmr+0x3ec>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
 800d35a:	7d23      	ldrb	r3, [r4, #20]
 800d35c:	2b00      	cmp	r3, #0
 800d35e:	f43f ae66 	beq.w	800d02e <tcp_slowtmr+0x1e>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
 800d362:	7d23      	ldrb	r3, [r4, #20]
 800d364:	2b01      	cmp	r3, #1
 800d366:	f43f ae6a 	beq.w	800d03e <tcp_slowtmr+0x2e>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
 800d36a:	7d23      	ldrb	r3, [r4, #20]
 800d36c:	2b0a      	cmp	r3, #10
 800d36e:	f43f ae6e 	beq.w	800d04e <tcp_slowtmr+0x3e>
    if (pcb->last_timer == tcp_timer_ctr) {
 800d372:	7fa2      	ldrb	r2, [r4, #30]
 800d374:	4b48      	ldr	r3, [pc, #288]	@ (800d498 <tcp_slowtmr+0x488>)
 800d376:	781b      	ldrb	r3, [r3, #0]
 800d378:	429a      	cmp	r2, r3
 800d37a:	f43f ae70 	beq.w	800d05e <tcp_slowtmr+0x4e>
    pcb->last_timer = tcp_timer_ctr;
 800d37e:	77a3      	strb	r3, [r4, #30]
    if (pcb->state == SYN_SENT && pcb->nrtx >= TCP_SYNMAXRTX) {
 800d380:	7d23      	ldrb	r3, [r4, #20]
 800d382:	2b02      	cmp	r3, #2
 800d384:	f43f ae6e 	beq.w	800d064 <tcp_slowtmr+0x54>
    } else if (pcb->nrtx >= TCP_MAXRTX) {
 800d388:	f894 3042 	ldrb.w	r3, [r4, #66]	@ 0x42
 800d38c:	2b0b      	cmp	r3, #11
 800d38e:	f63f aede 	bhi.w	800d14e <tcp_slowtmr+0x13e>
      if (pcb->persist_backoff > 0) {
 800d392:	f894 6099 	ldrb.w	r6, [r4, #153]	@ 0x99
 800d396:	2e00      	cmp	r6, #0
 800d398:	f43f ae8a 	beq.w	800d0b0 <tcp_slowtmr+0xa0>
        LWIP_ASSERT("tcp_slowtimr: persist ticking with in-flight data", pcb->unacked == NULL);
 800d39c:	6f23      	ldr	r3, [r4, #112]	@ 0x70
 800d39e:	b133      	cbz	r3, 800d3ae <tcp_slowtmr+0x39e>
 800d3a0:	4b39      	ldr	r3, [pc, #228]	@ (800d488 <tcp_slowtmr+0x478>)
 800d3a2:	f240 42d4 	movw	r2, #1236	@ 0x4d4
 800d3a6:	493d      	ldr	r1, [pc, #244]	@ (800d49c <tcp_slowtmr+0x48c>)
 800d3a8:	4839      	ldr	r0, [pc, #228]	@ (800d490 <tcp_slowtmr+0x480>)
 800d3aa:	f006 fde9 	bl	8013f80 <iprintf>
        LWIP_ASSERT("tcp_slowtimr: persist ticking with empty send buffer", pcb->unsent != NULL);
 800d3ae:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
 800d3b0:	2b00      	cmp	r3, #0
 800d3b2:	f43f ae5e 	beq.w	800d072 <tcp_slowtmr+0x62>
        if (pcb->persist_probe >= TCP_MAXRTX) {
 800d3b6:	f894 309a 	ldrb.w	r3, [r4, #154]	@ 0x9a
 800d3ba:	2b0b      	cmp	r3, #11
 800d3bc:	f63f aee5 	bhi.w	800d18a <tcp_slowtmr+0x17a>
          u8_t backoff_cnt = tcp_persist_backoff[pcb->persist_backoff - 1];
 800d3c0:	f894 3099 	ldrb.w	r3, [r4, #153]	@ 0x99
 800d3c4:	3b01      	subs	r3, #1
 800d3c6:	4a36      	ldr	r2, [pc, #216]	@ (800d4a0 <tcp_slowtmr+0x490>)
 800d3c8:	5cd2      	ldrb	r2, [r2, r3]
          if (pcb->persist_cnt < backoff_cnt) {
 800d3ca:	f894 3098 	ldrb.w	r3, [r4, #152]	@ 0x98
 800d3ce:	4293      	cmp	r3, r2
 800d3d0:	d202      	bcs.n	800d3d8 <tcp_slowtmr+0x3c8>
            pcb->persist_cnt++;
 800d3d2:	3301      	adds	r3, #1
 800d3d4:	f884 3098 	strb.w	r3, [r4, #152]	@ 0x98
          if (pcb->persist_cnt >= backoff_cnt) {
 800d3d8:	f894 3098 	ldrb.w	r3, [r4, #152]	@ 0x98
 800d3dc:	4293      	cmp	r3, r2
 800d3de:	f4ff aed6 	bcc.w	800d18e <tcp_slowtmr+0x17e>
            if (pcb->snd_wnd == 0) {
 800d3e2:	f8b4 1060 	ldrh.w	r1, [r4, #96]	@ 0x60
 800d3e6:	2900      	cmp	r1, #0
 800d3e8:	f47f ae4b 	bne.w	800d082 <tcp_slowtmr+0x72>
              if (tcp_zero_window_probe(pcb) != ERR_OK) {
 800d3ec:	4620      	mov	r0, r4
 800d3ee:	f002 fff9 	bl	80103e4 <tcp_zero_window_probe>
 800d3f2:	2800      	cmp	r0, #0
 800d3f4:	f43f ae49 	beq.w	800d08a <tcp_slowtmr+0x7a>
    pcb_remove = 0;
 800d3f8:	2600      	movs	r6, #0
 800d3fa:	e6a9      	b.n	800d150 <tcp_slowtmr+0x140>
  pcb = tcp_tw_pcbs;
 800d3fc:	4b29      	ldr	r3, [pc, #164]	@ (800d4a4 <tcp_slowtmr+0x494>)
 800d3fe:	681d      	ldr	r5, [r3, #0]
  while (pcb != NULL) {
 800d400:	e007      	b.n	800d412 <tcp_slowtmr+0x402>
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 800d402:	6a2a      	ldr	r2, [r5, #32]
 800d404:	4b28      	ldr	r3, [pc, #160]	@ (800d4a8 <tcp_slowtmr+0x498>)
 800d406:	681b      	ldr	r3, [r3, #0]
 800d408:	1a9b      	subs	r3, r3, r2
 800d40a:	2bf0      	cmp	r3, #240	@ 0xf0
 800d40c:	d80e      	bhi.n	800d42c <tcp_slowtmr+0x41c>
      prev = pcb;
 800d40e:	462c      	mov	r4, r5
      pcb = pcb->next;
 800d410:	68ed      	ldr	r5, [r5, #12]
  while (pcb != NULL) {
 800d412:	2d00      	cmp	r5, #0
 800d414:	d031      	beq.n	800d47a <tcp_slowtmr+0x46a>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 800d416:	7d2b      	ldrb	r3, [r5, #20]
 800d418:	2b0a      	cmp	r3, #10
 800d41a:	d0f2      	beq.n	800d402 <tcp_slowtmr+0x3f2>
 800d41c:	4b1a      	ldr	r3, [pc, #104]	@ (800d488 <tcp_slowtmr+0x478>)
 800d41e:	f240 52a1 	movw	r2, #1441	@ 0x5a1
 800d422:	4922      	ldr	r1, [pc, #136]	@ (800d4ac <tcp_slowtmr+0x49c>)
 800d424:	481a      	ldr	r0, [pc, #104]	@ (800d490 <tcp_slowtmr+0x480>)
 800d426:	f006 fdab 	bl	8013f80 <iprintf>
 800d42a:	e7ea      	b.n	800d402 <tcp_slowtmr+0x3f2>
      tcp_pcb_purge(pcb);
 800d42c:	4628      	mov	r0, r5
 800d42e:	f7ff f9b5 	bl	800c79c <tcp_pcb_purge>
      if (prev != NULL) {
 800d432:	b19c      	cbz	r4, 800d45c <tcp_slowtmr+0x44c>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
 800d434:	4b1b      	ldr	r3, [pc, #108]	@ (800d4a4 <tcp_slowtmr+0x494>)
 800d436:	681b      	ldr	r3, [r3, #0]
 800d438:	429d      	cmp	r5, r3
 800d43a:	d007      	beq.n	800d44c <tcp_slowtmr+0x43c>
        prev->next = pcb->next;
 800d43c:	68eb      	ldr	r3, [r5, #12]
 800d43e:	60e3      	str	r3, [r4, #12]
      pcb = pcb->next;
 800d440:	68ee      	ldr	r6, [r5, #12]
      tcp_free(pcb2);
 800d442:	4628      	mov	r0, r5
 800d444:	f7fe ff44 	bl	800c2d0 <tcp_free>
      pcb = pcb->next;
 800d448:	4635      	mov	r5, r6
 800d44a:	e7e2      	b.n	800d412 <tcp_slowtmr+0x402>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
 800d44c:	4b0e      	ldr	r3, [pc, #56]	@ (800d488 <tcp_slowtmr+0x478>)
 800d44e:	f240 52af 	movw	r2, #1455	@ 0x5af
 800d452:	4917      	ldr	r1, [pc, #92]	@ (800d4b0 <tcp_slowtmr+0x4a0>)
 800d454:	480e      	ldr	r0, [pc, #56]	@ (800d490 <tcp_slowtmr+0x480>)
 800d456:	f006 fd93 	bl	8013f80 <iprintf>
 800d45a:	e7ef      	b.n	800d43c <tcp_slowtmr+0x42c>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
 800d45c:	4b11      	ldr	r3, [pc, #68]	@ (800d4a4 <tcp_slowtmr+0x494>)
 800d45e:	681b      	ldr	r3, [r3, #0]
 800d460:	429d      	cmp	r5, r3
 800d462:	d006      	beq.n	800d472 <tcp_slowtmr+0x462>
 800d464:	4b08      	ldr	r3, [pc, #32]	@ (800d488 <tcp_slowtmr+0x478>)
 800d466:	f240 52b3 	movw	r2, #1459	@ 0x5b3
 800d46a:	4912      	ldr	r1, [pc, #72]	@ (800d4b4 <tcp_slowtmr+0x4a4>)
 800d46c:	4808      	ldr	r0, [pc, #32]	@ (800d490 <tcp_slowtmr+0x480>)
 800d46e:	f006 fd87 	bl	8013f80 <iprintf>
        tcp_tw_pcbs = pcb->next;
 800d472:	68ea      	ldr	r2, [r5, #12]
 800d474:	4b0b      	ldr	r3, [pc, #44]	@ (800d4a4 <tcp_slowtmr+0x494>)
 800d476:	601a      	str	r2, [r3, #0]
 800d478:	e7e2      	b.n	800d440 <tcp_slowtmr+0x430>
}
 800d47a:	b004      	add	sp, #16
 800d47c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d480:	240142dc 	.word	0x240142dc
 800d484:	240142d6 	.word	0x240142d6
 800d488:	080169a8 	.word	0x080169a8
 800d48c:	08016f8c 	.word	0x08016f8c
 800d490:	08015744 	.word	0x08015744
 800d494:	08016fb8 	.word	0x08016fb8
 800d498:	240142d4 	.word	0x240142d4
 800d49c:	08016f20 	.word	0x08016f20
 800d4a0:	08018f84 	.word	0x08018f84
 800d4a4:	240142d8 	.word	0x240142d8
 800d4a8:	240142e8 	.word	0x240142e8
 800d4ac:	08016fe4 	.word	0x08016fe4
 800d4b0:	08017014 	.word	0x08017014
 800d4b4:	0801703c 	.word	0x0801703c

0800d4b8 <tcp_tmr>:
{
 800d4b8:	b508      	push	{r3, lr}
  tcp_fasttmr();
 800d4ba:	f7ff fd29 	bl	800cf10 <tcp_fasttmr>
  if (++tcp_timer & 1) {
 800d4be:	4a06      	ldr	r2, [pc, #24]	@ (800d4d8 <tcp_tmr+0x20>)
 800d4c0:	7813      	ldrb	r3, [r2, #0]
 800d4c2:	3301      	adds	r3, #1
 800d4c4:	b2db      	uxtb	r3, r3
 800d4c6:	7013      	strb	r3, [r2, #0]
 800d4c8:	f013 0f01 	tst.w	r3, #1
 800d4cc:	d100      	bne.n	800d4d0 <tcp_tmr+0x18>
}
 800d4ce:	bd08      	pop	{r3, pc}
    tcp_slowtmr();
 800d4d0:	f7ff fd9e 	bl	800d010 <tcp_slowtmr>
}
 800d4d4:	e7fb      	b.n	800d4ce <tcp_tmr+0x16>
 800d4d6:	bf00      	nop
 800d4d8:	240142d5 	.word	0x240142d5

0800d4dc <tcp_get_next_optbyte>:
}

static u8_t
tcp_get_next_optbyte(void)
{
  u16_t optidx = tcp_optidx++;
 800d4dc:	4a0a      	ldr	r2, [pc, #40]	@ (800d508 <tcp_get_next_optbyte+0x2c>)
 800d4de:	8813      	ldrh	r3, [r2, #0]
 800d4e0:	1c59      	adds	r1, r3, #1
 800d4e2:	8011      	strh	r1, [r2, #0]
  if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 800d4e4:	4a09      	ldr	r2, [pc, #36]	@ (800d50c <tcp_get_next_optbyte+0x30>)
 800d4e6:	6811      	ldr	r1, [r2, #0]
 800d4e8:	b119      	cbz	r1, 800d4f2 <tcp_get_next_optbyte+0x16>
 800d4ea:	4a09      	ldr	r2, [pc, #36]	@ (800d510 <tcp_get_next_optbyte+0x34>)
 800d4ec:	8812      	ldrh	r2, [r2, #0]
 800d4ee:	4293      	cmp	r3, r2
 800d4f0:	d204      	bcs.n	800d4fc <tcp_get_next_optbyte+0x20>
    u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 800d4f2:	4a08      	ldr	r2, [pc, #32]	@ (800d514 <tcp_get_next_optbyte+0x38>)
 800d4f4:	6812      	ldr	r2, [r2, #0]
    return opts[optidx];
 800d4f6:	4413      	add	r3, r2
 800d4f8:	7d18      	ldrb	r0, [r3, #20]
 800d4fa:	4770      	bx	lr
  } else {
    u8_t idx = (u8_t)(optidx - tcphdr_opt1len);
 800d4fc:	b2db      	uxtb	r3, r3
 800d4fe:	b2d2      	uxtb	r2, r2
 800d500:	1a9b      	subs	r3, r3, r2
 800d502:	b2db      	uxtb	r3, r3
    return tcphdr_opt2[idx];
 800d504:	5cc8      	ldrb	r0, [r1, r3]
  }
}
 800d506:	4770      	bx	lr
 800d508:	24014304 	.word	0x24014304
 800d50c:	24014308 	.word	0x24014308
 800d510:	2401430c 	.word	0x2401430c
 800d514:	24014310 	.word	0x24014310

0800d518 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
 800d518:	b538      	push	{r3, r4, r5, lr}
  u16_t mss;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  LWIP_ASSERT("tcp_parseopt: invalid pcb", pcb != NULL);
 800d51a:	4604      	mov	r4, r0
 800d51c:	b1e8      	cbz	r0, 800d55a <tcp_parseopt+0x42>

  /* Parse the TCP MSS option, if present. */
  if (tcphdr_optlen != 0) {
 800d51e:	4b22      	ldr	r3, [pc, #136]	@ (800d5a8 <tcp_parseopt+0x90>)
 800d520:	881b      	ldrh	r3, [r3, #0]
 800d522:	2b00      	cmp	r3, #0
 800d524:	d03e      	beq.n	800d5a4 <tcp_parseopt+0x8c>
    for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
 800d526:	4b21      	ldr	r3, [pc, #132]	@ (800d5ac <tcp_parseopt+0x94>)
 800d528:	2200      	movs	r2, #0
 800d52a:	801a      	strh	r2, [r3, #0]
 800d52c:	4b1f      	ldr	r3, [pc, #124]	@ (800d5ac <tcp_parseopt+0x94>)
 800d52e:	881a      	ldrh	r2, [r3, #0]
 800d530:	4b1d      	ldr	r3, [pc, #116]	@ (800d5a8 <tcp_parseopt+0x90>)
 800d532:	881b      	ldrh	r3, [r3, #0]
 800d534:	429a      	cmp	r2, r3
 800d536:	d235      	bcs.n	800d5a4 <tcp_parseopt+0x8c>
      u8_t opt = tcp_get_next_optbyte();
 800d538:	f7ff ffd0 	bl	800d4dc <tcp_get_next_optbyte>
      switch (opt) {
 800d53c:	2801      	cmp	r0, #1
 800d53e:	d0f5      	beq.n	800d52c <tcp_parseopt+0x14>
 800d540:	2802      	cmp	r0, #2
 800d542:	d012      	beq.n	800d56a <tcp_parseopt+0x52>
 800d544:	b370      	cbz	r0, 800d5a4 <tcp_parseopt+0x8c>
          }
          break;
#endif /* LWIP_TCP_SACK_OUT */
        default:
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
          data = tcp_get_next_optbyte();
 800d546:	f7ff ffc9 	bl	800d4dc <tcp_get_next_optbyte>
          if (data < 2) {
 800d54a:	2801      	cmp	r0, #1
 800d54c:	d92a      	bls.n	800d5a4 <tcp_parseopt+0x8c>
               and we don't process them further. */
            return;
          }
          /* All other options have a length field, so that we easily
             can skip past them. */
          tcp_optidx += data - 2;
 800d54e:	4b17      	ldr	r3, [pc, #92]	@ (800d5ac <tcp_parseopt+0x94>)
 800d550:	881a      	ldrh	r2, [r3, #0]
 800d552:	4410      	add	r0, r2
 800d554:	3802      	subs	r0, #2
 800d556:	8018      	strh	r0, [r3, #0]
 800d558:	e7e8      	b.n	800d52c <tcp_parseopt+0x14>
  LWIP_ASSERT("tcp_parseopt: invalid pcb", pcb != NULL);
 800d55a:	4b15      	ldr	r3, [pc, #84]	@ (800d5b0 <tcp_parseopt+0x98>)
 800d55c:	f240 727d 	movw	r2, #1917	@ 0x77d
 800d560:	4914      	ldr	r1, [pc, #80]	@ (800d5b4 <tcp_parseopt+0x9c>)
 800d562:	4815      	ldr	r0, [pc, #84]	@ (800d5b8 <tcp_parseopt+0xa0>)
 800d564:	f006 fd0c 	bl	8013f80 <iprintf>
 800d568:	e7d9      	b.n	800d51e <tcp_parseopt+0x6>
          if (tcp_get_next_optbyte() != LWIP_TCP_OPT_LEN_MSS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_MSS) > tcphdr_optlen) {
 800d56a:	f7ff ffb7 	bl	800d4dc <tcp_get_next_optbyte>
 800d56e:	2804      	cmp	r0, #4
 800d570:	d118      	bne.n	800d5a4 <tcp_parseopt+0x8c>
 800d572:	4b0e      	ldr	r3, [pc, #56]	@ (800d5ac <tcp_parseopt+0x94>)
 800d574:	881b      	ldrh	r3, [r3, #0]
 800d576:	3301      	adds	r3, #1
 800d578:	4a0b      	ldr	r2, [pc, #44]	@ (800d5a8 <tcp_parseopt+0x90>)
 800d57a:	8812      	ldrh	r2, [r2, #0]
 800d57c:	4293      	cmp	r3, r2
 800d57e:	da11      	bge.n	800d5a4 <tcp_parseopt+0x8c>
          mss = (u16_t)(tcp_get_next_optbyte() << 8);
 800d580:	f7ff ffac 	bl	800d4dc <tcp_get_next_optbyte>
 800d584:	0205      	lsls	r5, r0, #8
 800d586:	b2ad      	uxth	r5, r5
          mss |= tcp_get_next_optbyte();
 800d588:	f7ff ffa8 	bl	800d4dc <tcp_get_next_optbyte>
 800d58c:	4328      	orrs	r0, r5
 800d58e:	b280      	uxth	r0, r0
          pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 800d590:	1e43      	subs	r3, r0, #1
 800d592:	b29b      	uxth	r3, r3
 800d594:	f240 52b3 	movw	r2, #1459	@ 0x5b3
 800d598:	4293      	cmp	r3, r2
 800d59a:	d901      	bls.n	800d5a0 <tcp_parseopt+0x88>
 800d59c:	f240 50b4 	movw	r0, #1460	@ 0x5b4
 800d5a0:	8660      	strh	r0, [r4, #50]	@ 0x32
          break;
 800d5a2:	e7c3      	b.n	800d52c <tcp_parseopt+0x14>
      }
    }
  }
}
 800d5a4:	bd38      	pop	{r3, r4, r5, pc}
 800d5a6:	bf00      	nop
 800d5a8:	2401430e 	.word	0x2401430e
 800d5ac:	24014304 	.word	0x24014304
 800d5b0:	08017064 	.word	0x08017064
 800d5b4:	08017098 	.word	0x08017098
 800d5b8:	08015744 	.word	0x08015744

0800d5bc <tcp_input_delayed_close>:
{
 800d5bc:	b510      	push	{r4, lr}
  LWIP_ASSERT("tcp_input_delayed_close: invalid pcb", pcb != NULL);
 800d5be:	4604      	mov	r4, r0
 800d5c0:	b130      	cbz	r0, 800d5d0 <tcp_input_delayed_close+0x14>
  if (recv_flags & TF_CLOSED) {
 800d5c2:	4b11      	ldr	r3, [pc, #68]	@ (800d608 <tcp_input_delayed_close+0x4c>)
 800d5c4:	781b      	ldrb	r3, [r3, #0]
 800d5c6:	f013 0f10 	tst.w	r3, #16
 800d5ca:	d109      	bne.n	800d5e0 <tcp_input_delayed_close+0x24>
  return 0;
 800d5cc:	2000      	movs	r0, #0
}
 800d5ce:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("tcp_input_delayed_close: invalid pcb", pcb != NULL);
 800d5d0:	4b0e      	ldr	r3, [pc, #56]	@ (800d60c <tcp_input_delayed_close+0x50>)
 800d5d2:	f240 225a 	movw	r2, #602	@ 0x25a
 800d5d6:	490e      	ldr	r1, [pc, #56]	@ (800d610 <tcp_input_delayed_close+0x54>)
 800d5d8:	480e      	ldr	r0, [pc, #56]	@ (800d614 <tcp_input_delayed_close+0x58>)
 800d5da:	f006 fcd1 	bl	8013f80 <iprintf>
 800d5de:	e7f0      	b.n	800d5c2 <tcp_input_delayed_close+0x6>
    if (!(pcb->flags & TF_RXCLOSED)) {
 800d5e0:	8b63      	ldrh	r3, [r4, #26]
 800d5e2:	f013 0f10 	tst.w	r3, #16
 800d5e6:	d106      	bne.n	800d5f6 <tcp_input_delayed_close+0x3a>
      TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_CLSD);
 800d5e8:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 800d5ec:	b11b      	cbz	r3, 800d5f6 <tcp_input_delayed_close+0x3a>
 800d5ee:	f06f 010e 	mvn.w	r1, #14
 800d5f2:	6920      	ldr	r0, [r4, #16]
 800d5f4:	4798      	blx	r3
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
 800d5f6:	4621      	mov	r1, r4
 800d5f8:	4807      	ldr	r0, [pc, #28]	@ (800d618 <tcp_input_delayed_close+0x5c>)
 800d5fa:	f7ff f901 	bl	800c800 <tcp_pcb_remove>
    tcp_free(pcb);
 800d5fe:	4620      	mov	r0, r4
 800d600:	f7fe fe66 	bl	800c2d0 <tcp_free>
    return 1;
 800d604:	2001      	movs	r0, #1
 800d606:	e7e2      	b.n	800d5ce <tcp_input_delayed_close+0x12>
 800d608:	240142f4 	.word	0x240142f4
 800d60c:	08017064 	.word	0x08017064
 800d610:	080170b4 	.word	0x080170b4
 800d614:	08015744 	.word	0x08015744
 800d618:	240142dc 	.word	0x240142dc

0800d61c <tcp_timewait_input>:
  if (flags & TCP_RST) {
 800d61c:	4b23      	ldr	r3, [pc, #140]	@ (800d6ac <tcp_timewait_input+0x90>)
 800d61e:	781b      	ldrb	r3, [r3, #0]
 800d620:	f013 0f04 	tst.w	r3, #4
 800d624:	d141      	bne.n	800d6aa <tcp_timewait_input+0x8e>
{
 800d626:	b530      	push	{r4, r5, lr}
 800d628:	b085      	sub	sp, #20
 800d62a:	4604      	mov	r4, r0
  LWIP_ASSERT("tcp_timewait_input: invalid pcb", pcb != NULL);
 800d62c:	b1a0      	cbz	r0, 800d658 <tcp_timewait_input+0x3c>
  if (flags & TCP_SYN) {
 800d62e:	4b1f      	ldr	r3, [pc, #124]	@ (800d6ac <tcp_timewait_input+0x90>)
 800d630:	781b      	ldrb	r3, [r3, #0]
 800d632:	f013 0f02 	tst.w	r3, #2
 800d636:	d029      	beq.n	800d68c <tcp_timewait_input+0x70>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
 800d638:	4b1d      	ldr	r3, [pc, #116]	@ (800d6b0 <tcp_timewait_input+0x94>)
 800d63a:	681a      	ldr	r2, [r3, #0]
 800d63c:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 800d63e:	1ad1      	subs	r1, r2, r3
 800d640:	2900      	cmp	r1, #0
 800d642:	db04      	blt.n	800d64e <tcp_timewait_input+0x32>
 800d644:	8d21      	ldrh	r1, [r4, #40]	@ 0x28
 800d646:	440b      	add	r3, r1
 800d648:	1ad3      	subs	r3, r2, r3
 800d64a:	2b00      	cmp	r3, #0
 800d64c:	dd0c      	ble.n	800d668 <tcp_timewait_input+0x4c>
  if ((tcplen > 0)) {
 800d64e:	4b19      	ldr	r3, [pc, #100]	@ (800d6b4 <tcp_timewait_input+0x98>)
 800d650:	881b      	ldrh	r3, [r3, #0]
 800d652:	bb13      	cbnz	r3, 800d69a <tcp_timewait_input+0x7e>
}
 800d654:	b005      	add	sp, #20
 800d656:	bd30      	pop	{r4, r5, pc}
  LWIP_ASSERT("tcp_timewait_input: invalid pcb", pcb != NULL);
 800d658:	4b17      	ldr	r3, [pc, #92]	@ (800d6b8 <tcp_timewait_input+0x9c>)
 800d65a:	f240 22ee 	movw	r2, #750	@ 0x2ee
 800d65e:	4917      	ldr	r1, [pc, #92]	@ (800d6bc <tcp_timewait_input+0xa0>)
 800d660:	4817      	ldr	r0, [pc, #92]	@ (800d6c0 <tcp_timewait_input+0xa4>)
 800d662:	f006 fc8d 	bl	8013f80 <iprintf>
 800d666:	e7e2      	b.n	800d62e <tcp_timewait_input+0x12>
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d668:	4b16      	ldr	r3, [pc, #88]	@ (800d6c4 <tcp_timewait_input+0xa8>)
 800d66a:	6819      	ldr	r1, [r3, #0]
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d66c:	4b16      	ldr	r3, [pc, #88]	@ (800d6c8 <tcp_timewait_input+0xac>)
 800d66e:	4811      	ldr	r0, [pc, #68]	@ (800d6b4 <tcp_timewait_input+0x98>)
 800d670:	8800      	ldrh	r0, [r0, #0]
 800d672:	880d      	ldrh	r5, [r1, #0]
 800d674:	9502      	str	r5, [sp, #8]
 800d676:	8849      	ldrh	r1, [r1, #2]
 800d678:	9101      	str	r1, [sp, #4]
 800d67a:	1f19      	subs	r1, r3, #4
 800d67c:	9100      	str	r1, [sp, #0]
 800d67e:	4402      	add	r2, r0
 800d680:	4912      	ldr	r1, [pc, #72]	@ (800d6cc <tcp_timewait_input+0xb0>)
 800d682:	6809      	ldr	r1, [r1, #0]
 800d684:	4620      	mov	r0, r4
 800d686:	f002 fc79 	bl	800ff7c <tcp_rst>
      return;
 800d68a:	e7e3      	b.n	800d654 <tcp_timewait_input+0x38>
  } else if (flags & TCP_FIN) {
 800d68c:	f013 0f01 	tst.w	r3, #1
 800d690:	d0dd      	beq.n	800d64e <tcp_timewait_input+0x32>
    pcb->tmr = tcp_ticks;
 800d692:	4b0f      	ldr	r3, [pc, #60]	@ (800d6d0 <tcp_timewait_input+0xb4>)
 800d694:	681b      	ldr	r3, [r3, #0]
 800d696:	6223      	str	r3, [r4, #32]
 800d698:	e7d9      	b.n	800d64e <tcp_timewait_input+0x32>
    tcp_ack_now(pcb);
 800d69a:	8b63      	ldrh	r3, [r4, #26]
 800d69c:	f043 0302 	orr.w	r3, r3, #2
 800d6a0:	8363      	strh	r3, [r4, #26]
    tcp_output(pcb);
 800d6a2:	4620      	mov	r0, r4
 800d6a4:	f002 fcec 	bl	8010080 <tcp_output>
 800d6a8:	e7d4      	b.n	800d654 <tcp_timewait_input+0x38>
 800d6aa:	4770      	bx	lr
 800d6ac:	240142f5 	.word	0x240142f5
 800d6b0:	24014300 	.word	0x24014300
 800d6b4:	240142f6 	.word	0x240142f6
 800d6b8:	08017064 	.word	0x08017064
 800d6bc:	080170dc 	.word	0x080170dc
 800d6c0:	08015744 	.word	0x08015744
 800d6c4:	24014310 	.word	0x24014310
 800d6c8:	2400c4c4 	.word	0x2400c4c4
 800d6cc:	240142fc 	.word	0x240142fc
 800d6d0:	240142e8 	.word	0x240142e8

0800d6d4 <tcp_listen_input>:
  if (flags & TCP_RST) {
 800d6d4:	4b4a      	ldr	r3, [pc, #296]	@ (800d800 <tcp_listen_input+0x12c>)
 800d6d6:	781b      	ldrb	r3, [r3, #0]
 800d6d8:	f013 0f04 	tst.w	r3, #4
 800d6dc:	f040 808e 	bne.w	800d7fc <tcp_listen_input+0x128>
{
 800d6e0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d6e2:	b085      	sub	sp, #20
 800d6e4:	4604      	mov	r4, r0
  LWIP_ASSERT("tcp_listen_input: invalid pcb", pcb != NULL);
 800d6e6:	b148      	cbz	r0, 800d6fc <tcp_listen_input+0x28>
  if (flags & TCP_ACK) {
 800d6e8:	4b45      	ldr	r3, [pc, #276]	@ (800d800 <tcp_listen_input+0x12c>)
 800d6ea:	781b      	ldrb	r3, [r3, #0]
 800d6ec:	f013 0f10 	tst.w	r3, #16
 800d6f0:	d10c      	bne.n	800d70c <tcp_listen_input+0x38>
  } else if (flags & TCP_SYN) {
 800d6f2:	f013 0f02 	tst.w	r3, #2
 800d6f6:	d11d      	bne.n	800d734 <tcp_listen_input+0x60>
}
 800d6f8:	b005      	add	sp, #20
 800d6fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
  LWIP_ASSERT("tcp_listen_input: invalid pcb", pcb != NULL);
 800d6fc:	4b41      	ldr	r3, [pc, #260]	@ (800d804 <tcp_listen_input+0x130>)
 800d6fe:	f240 2281 	movw	r2, #641	@ 0x281
 800d702:	4941      	ldr	r1, [pc, #260]	@ (800d808 <tcp_listen_input+0x134>)
 800d704:	4841      	ldr	r0, [pc, #260]	@ (800d80c <tcp_listen_input+0x138>)
 800d706:	f006 fc3b 	bl	8013f80 <iprintf>
 800d70a:	e7ed      	b.n	800d6e8 <tcp_listen_input+0x14>
            ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d70c:	4b40      	ldr	r3, [pc, #256]	@ (800d810 <tcp_listen_input+0x13c>)
 800d70e:	6819      	ldr	r1, [r3, #0]
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d710:	4b40      	ldr	r3, [pc, #256]	@ (800d814 <tcp_listen_input+0x140>)
 800d712:	4a41      	ldr	r2, [pc, #260]	@ (800d818 <tcp_listen_input+0x144>)
 800d714:	8810      	ldrh	r0, [r2, #0]
 800d716:	4a41      	ldr	r2, [pc, #260]	@ (800d81c <tcp_listen_input+0x148>)
 800d718:	6812      	ldr	r2, [r2, #0]
 800d71a:	880d      	ldrh	r5, [r1, #0]
 800d71c:	9502      	str	r5, [sp, #8]
 800d71e:	8849      	ldrh	r1, [r1, #2]
 800d720:	9101      	str	r1, [sp, #4]
 800d722:	1f19      	subs	r1, r3, #4
 800d724:	9100      	str	r1, [sp, #0]
 800d726:	4402      	add	r2, r0
 800d728:	493d      	ldr	r1, [pc, #244]	@ (800d820 <tcp_listen_input+0x14c>)
 800d72a:	6809      	ldr	r1, [r1, #0]
 800d72c:	4620      	mov	r0, r4
 800d72e:	f002 fc25 	bl	800ff7c <tcp_rst>
 800d732:	e7e1      	b.n	800d6f8 <tcp_listen_input+0x24>
    npcb = tcp_alloc(pcb->prio);
 800d734:	7d60      	ldrb	r0, [r4, #21]
 800d736:	f7ff fa31 	bl	800cb9c <tcp_alloc>
    if (npcb == NULL) {
 800d73a:	4605      	mov	r5, r0
 800d73c:	2800      	cmp	r0, #0
 800d73e:	d049      	beq.n	800d7d4 <tcp_listen_input+0x100>
    ip_addr_copy(npcb->local_ip, *ip_current_dest_addr());
 800d740:	4b38      	ldr	r3, [pc, #224]	@ (800d824 <tcp_listen_input+0x150>)
 800d742:	695a      	ldr	r2, [r3, #20]
 800d744:	6002      	str	r2, [r0, #0]
    ip_addr_copy(npcb->remote_ip, *ip_current_src_addr());
 800d746:	691b      	ldr	r3, [r3, #16]
 800d748:	6043      	str	r3, [r0, #4]
    npcb->local_port = pcb->local_port;
 800d74a:	8ae3      	ldrh	r3, [r4, #22]
 800d74c:	82c3      	strh	r3, [r0, #22]
    npcb->remote_port = tcphdr->src;
 800d74e:	4e30      	ldr	r6, [pc, #192]	@ (800d810 <tcp_listen_input+0x13c>)
 800d750:	6833      	ldr	r3, [r6, #0]
 800d752:	881b      	ldrh	r3, [r3, #0]
 800d754:	8303      	strh	r3, [r0, #24]
    npcb->state = SYN_RCVD;
 800d756:	2303      	movs	r3, #3
 800d758:	7503      	strb	r3, [r0, #20]
    npcb->rcv_nxt = seqno + 1;
 800d75a:	4f30      	ldr	r7, [pc, #192]	@ (800d81c <tcp_listen_input+0x148>)
 800d75c:	683b      	ldr	r3, [r7, #0]
 800d75e:	3301      	adds	r3, #1
 800d760:	6243      	str	r3, [r0, #36]	@ 0x24
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 800d762:	62c3      	str	r3, [r0, #44]	@ 0x2c
    iss = tcp_next_iss(npcb);
 800d764:	f7fe ffd4 	bl	800c710 <tcp_next_iss>
    npcb->snd_wl2 = iss;
 800d768:	65a8      	str	r0, [r5, #88]	@ 0x58
    npcb->snd_nxt = iss;
 800d76a:	6528      	str	r0, [r5, #80]	@ 0x50
    npcb->lastack = iss;
 800d76c:	6468      	str	r0, [r5, #68]	@ 0x44
    npcb->snd_lbb = iss;
 800d76e:	65e8      	str	r0, [r5, #92]	@ 0x5c
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 800d770:	683b      	ldr	r3, [r7, #0]
 800d772:	3b01      	subs	r3, #1
 800d774:	656b      	str	r3, [r5, #84]	@ 0x54
    npcb->callback_arg = pcb->callback_arg;
 800d776:	6923      	ldr	r3, [r4, #16]
 800d778:	612b      	str	r3, [r5, #16]
    npcb->listener = pcb;
 800d77a:	67ec      	str	r4, [r5, #124]	@ 0x7c
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 800d77c:	7a63      	ldrb	r3, [r4, #9]
 800d77e:	f003 030c 	and.w	r3, r3, #12
 800d782:	726b      	strb	r3, [r5, #9]
    npcb->netif_idx = pcb->netif_idx;
 800d784:	7a23      	ldrb	r3, [r4, #8]
 800d786:	722b      	strb	r3, [r5, #8]
    TCP_REG_ACTIVE(npcb);
 800d788:	4b27      	ldr	r3, [pc, #156]	@ (800d828 <tcp_listen_input+0x154>)
 800d78a:	681a      	ldr	r2, [r3, #0]
 800d78c:	60ea      	str	r2, [r5, #12]
 800d78e:	601d      	str	r5, [r3, #0]
 800d790:	f002 ff0c 	bl	80105ac <tcp_timer_needed>
 800d794:	4b25      	ldr	r3, [pc, #148]	@ (800d82c <tcp_listen_input+0x158>)
 800d796:	2201      	movs	r2, #1
 800d798:	701a      	strb	r2, [r3, #0]
    tcp_parseopt(npcb);
 800d79a:	4628      	mov	r0, r5
 800d79c:	f7ff febc 	bl	800d518 <tcp_parseopt>
    npcb->snd_wnd = tcphdr->wnd;
 800d7a0:	6833      	ldr	r3, [r6, #0]
 800d7a2:	89db      	ldrh	r3, [r3, #14]
 800d7a4:	f8a5 3060 	strh.w	r3, [r5, #96]	@ 0x60
    npcb->snd_wnd_max = npcb->snd_wnd;
 800d7a8:	f8a5 3062 	strh.w	r3, [r5, #98]	@ 0x62
    npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip, &npcb->remote_ip);
 800d7ac:	8e6e      	ldrh	r6, [r5, #50]	@ 0x32
 800d7ae:	1d2c      	adds	r4, r5, #4
 800d7b0:	4620      	mov	r0, r4
 800d7b2:	f004 fd23 	bl	80121fc <ip4_route>
 800d7b6:	4601      	mov	r1, r0
 800d7b8:	4622      	mov	r2, r4
 800d7ba:	4630      	mov	r0, r6
 800d7bc:	f7fe ffc4 	bl	800c748 <tcp_eff_send_mss_netif>
 800d7c0:	8668      	strh	r0, [r5, #50]	@ 0x32
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 800d7c2:	2112      	movs	r1, #18
 800d7c4:	4628      	mov	r0, r5
 800d7c6:	f002 fa17 	bl	800fbf8 <tcp_enqueue_flags>
    if (rc != ERR_OK) {
 800d7ca:	b990      	cbnz	r0, 800d7f2 <tcp_listen_input+0x11e>
    tcp_output(npcb);
 800d7cc:	4628      	mov	r0, r5
 800d7ce:	f002 fc57 	bl	8010080 <tcp_output>
 800d7d2:	e791      	b.n	800d6f8 <tcp_listen_input+0x24>
      TCP_STATS_INC(tcp.memerr);
 800d7d4:	4a16      	ldr	r2, [pc, #88]	@ (800d830 <tcp_listen_input+0x15c>)
 800d7d6:	f8b2 30b8 	ldrh.w	r3, [r2, #184]	@ 0xb8
 800d7da:	3301      	adds	r3, #1
 800d7dc:	f8a2 30b8 	strh.w	r3, [r2, #184]	@ 0xb8
      TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
 800d7e0:	69a3      	ldr	r3, [r4, #24]
 800d7e2:	2b00      	cmp	r3, #0
 800d7e4:	d088      	beq.n	800d6f8 <tcp_listen_input+0x24>
 800d7e6:	f04f 32ff 	mov.w	r2, #4294967295
 800d7ea:	2100      	movs	r1, #0
 800d7ec:	6920      	ldr	r0, [r4, #16]
 800d7ee:	4798      	blx	r3
      return;
 800d7f0:	e782      	b.n	800d6f8 <tcp_listen_input+0x24>
      tcp_abandon(npcb, 0);
 800d7f2:	2100      	movs	r1, #0
 800d7f4:	4628      	mov	r0, r5
 800d7f6:	f7ff f86b 	bl	800c8d0 <tcp_abandon>
      return;
 800d7fa:	e77d      	b.n	800d6f8 <tcp_listen_input+0x24>
 800d7fc:	4770      	bx	lr
 800d7fe:	bf00      	nop
 800d800:	240142f5 	.word	0x240142f5
 800d804:	08017064 	.word	0x08017064
 800d808:	080170fc 	.word	0x080170fc
 800d80c:	08015744 	.word	0x08015744
 800d810:	24014310 	.word	0x24014310
 800d814:	2400c4c4 	.word	0x2400c4c4
 800d818:	240142f6 	.word	0x240142f6
 800d81c:	24014300 	.word	0x24014300
 800d820:	240142fc 	.word	0x240142fc
 800d824:	2400c4b0 	.word	0x2400c4b0
 800d828:	240142dc 	.word	0x240142dc
 800d82c:	240142d6 	.word	0x240142d6
 800d830:	240141b4 	.word	0x240141b4

0800d834 <tcp_free_acked_segments>:
{
 800d834:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d838:	4606      	mov	r6, r0
 800d83a:	460c      	mov	r4, r1
 800d83c:	461f      	mov	r7, r3
  while (seg_list != NULL &&
 800d83e:	e008      	b.n	800d852 <tcp_free_acked_segments+0x1e>
    LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= clen));
 800d840:	4b26      	ldr	r3, [pc, #152]	@ (800d8dc <tcp_free_acked_segments+0xa8>)
 800d842:	f240 4257 	movw	r2, #1111	@ 0x457
 800d846:	4926      	ldr	r1, [pc, #152]	@ (800d8e0 <tcp_free_acked_segments+0xac>)
 800d848:	4826      	ldr	r0, [pc, #152]	@ (800d8e4 <tcp_free_acked_segments+0xb0>)
 800d84a:	f006 fb99 	bl	8013f80 <iprintf>
 800d84e:	e022      	b.n	800d896 <tcp_free_acked_segments+0x62>
{
 800d850:	4644      	mov	r4, r8
  while (seg_list != NULL &&
 800d852:	2c00      	cmp	r4, #0
 800d854:	d03f      	beq.n	800d8d6 <tcp_free_acked_segments+0xa2>
         TCP_SEQ_LEQ(lwip_ntohl(seg_list->tcphdr->seqno) +
 800d856:	6923      	ldr	r3, [r4, #16]
 800d858:	6858      	ldr	r0, [r3, #4]
 800d85a:	f7fd f986 	bl	800ab6a <lwip_htonl>
 800d85e:	4605      	mov	r5, r0
 800d860:	f8b4 8008 	ldrh.w	r8, [r4, #8]
 800d864:	6923      	ldr	r3, [r4, #16]
 800d866:	8998      	ldrh	r0, [r3, #12]
 800d868:	f7fd f97a 	bl	800ab60 <lwip_htons>
 800d86c:	f010 0f03 	tst.w	r0, #3
 800d870:	d02f      	beq.n	800d8d2 <tcp_free_acked_segments+0x9e>
 800d872:	2301      	movs	r3, #1
 800d874:	4443      	add	r3, r8
 800d876:	441d      	add	r5, r3
 800d878:	4b1b      	ldr	r3, [pc, #108]	@ (800d8e8 <tcp_free_acked_segments+0xb4>)
 800d87a:	681b      	ldr	r3, [r3, #0]
 800d87c:	1aed      	subs	r5, r5, r3
  while (seg_list != NULL &&
 800d87e:	2d00      	cmp	r5, #0
 800d880:	dc29      	bgt.n	800d8d6 <tcp_free_acked_segments+0xa2>
    seg_list = seg_list->next;
 800d882:	f8d4 8000 	ldr.w	r8, [r4]
    clen = pbuf_clen(next->p);
 800d886:	6860      	ldr	r0, [r4, #4]
 800d888:	f7fe faba 	bl	800be00 <pbuf_clen>
 800d88c:	4605      	mov	r5, r0
    LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= clen));
 800d88e:	f8b6 3066 	ldrh.w	r3, [r6, #102]	@ 0x66
 800d892:	4298      	cmp	r0, r3
 800d894:	d8d4      	bhi.n	800d840 <tcp_free_acked_segments+0xc>
    pcb->snd_queuelen = (u16_t)(pcb->snd_queuelen - clen);
 800d896:	f8b6 3066 	ldrh.w	r3, [r6, #102]	@ 0x66
 800d89a:	1b5b      	subs	r3, r3, r5
 800d89c:	f8a6 3066 	strh.w	r3, [r6, #102]	@ 0x66
    recv_acked = (tcpwnd_size_t)(recv_acked + next->len);
 800d8a0:	8923      	ldrh	r3, [r4, #8]
 800d8a2:	4a12      	ldr	r2, [pc, #72]	@ (800d8ec <tcp_free_acked_segments+0xb8>)
 800d8a4:	8811      	ldrh	r1, [r2, #0]
 800d8a6:	440b      	add	r3, r1
 800d8a8:	8013      	strh	r3, [r2, #0]
    tcp_seg_free(next);
 800d8aa:	4620      	mov	r0, r4
 800d8ac:	f7fe fe74 	bl	800c598 <tcp_seg_free>
    if (pcb->snd_queuelen != 0) {
 800d8b0:	f8b6 3066 	ldrh.w	r3, [r6, #102]	@ 0x66
 800d8b4:	2b00      	cmp	r3, #0
 800d8b6:	d0cb      	beq.n	800d850 <tcp_free_acked_segments+0x1c>
      LWIP_ASSERT("tcp_receive: valid queue length",
 800d8b8:	f1b8 0f00 	cmp.w	r8, #0
 800d8bc:	bf08      	it	eq
 800d8be:	2f00      	cmpeq	r7, #0
 800d8c0:	d1c6      	bne.n	800d850 <tcp_free_acked_segments+0x1c>
 800d8c2:	4b06      	ldr	r3, [pc, #24]	@ (800d8dc <tcp_free_acked_segments+0xa8>)
 800d8c4:	f240 4261 	movw	r2, #1121	@ 0x461
 800d8c8:	4909      	ldr	r1, [pc, #36]	@ (800d8f0 <tcp_free_acked_segments+0xbc>)
 800d8ca:	4806      	ldr	r0, [pc, #24]	@ (800d8e4 <tcp_free_acked_segments+0xb0>)
 800d8cc:	f006 fb58 	bl	8013f80 <iprintf>
 800d8d0:	e7be      	b.n	800d850 <tcp_free_acked_segments+0x1c>
         TCP_SEQ_LEQ(lwip_ntohl(seg_list->tcphdr->seqno) +
 800d8d2:	2300      	movs	r3, #0
 800d8d4:	e7ce      	b.n	800d874 <tcp_free_acked_segments+0x40>
}
 800d8d6:	4620      	mov	r0, r4
 800d8d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d8dc:	08017064 	.word	0x08017064
 800d8e0:	0801711c 	.word	0x0801711c
 800d8e4:	08015744 	.word	0x08015744
 800d8e8:	240142fc 	.word	0x240142fc
 800d8ec:	240142f8 	.word	0x240142f8
 800d8f0:	08017144 	.word	0x08017144

0800d8f4 <tcp_oos_insert_segment>:
{
 800d8f4:	b570      	push	{r4, r5, r6, lr}
 800d8f6:	460c      	mov	r4, r1
  LWIP_ASSERT("tcp_oos_insert_segment: invalid cseg", cseg != NULL);
 800d8f8:	4605      	mov	r5, r0
 800d8fa:	b160      	cbz	r0, 800d916 <tcp_oos_insert_segment+0x22>
  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 800d8fc:	692b      	ldr	r3, [r5, #16]
 800d8fe:	8998      	ldrh	r0, [r3, #12]
 800d900:	f7fd f92e 	bl	800ab60 <lwip_htons>
 800d904:	f010 0f01 	tst.w	r0, #1
 800d908:	d012      	beq.n	800d930 <tcp_oos_insert_segment+0x3c>
    tcp_segs_free(next);
 800d90a:	4620      	mov	r0, r4
 800d90c:	f7fe fe51 	bl	800c5b2 <tcp_segs_free>
    next = NULL;
 800d910:	2400      	movs	r4, #0
  cseg->next = next;
 800d912:	602c      	str	r4, [r5, #0]
}
 800d914:	bd70      	pop	{r4, r5, r6, pc}
  LWIP_ASSERT("tcp_oos_insert_segment: invalid cseg", cseg != NULL);
 800d916:	4b1d      	ldr	r3, [pc, #116]	@ (800d98c <tcp_oos_insert_segment+0x98>)
 800d918:	f240 421f 	movw	r2, #1055	@ 0x41f
 800d91c:	491c      	ldr	r1, [pc, #112]	@ (800d990 <tcp_oos_insert_segment+0x9c>)
 800d91e:	481d      	ldr	r0, [pc, #116]	@ (800d994 <tcp_oos_insert_segment+0xa0>)
 800d920:	f006 fb2e 	bl	8013f80 <iprintf>
 800d924:	e7ea      	b.n	800d8fc <tcp_oos_insert_segment+0x8>
      next = next->next;
 800d926:	6826      	ldr	r6, [r4, #0]
      tcp_seg_free(old_seg);
 800d928:	4620      	mov	r0, r4
 800d92a:	f7fe fe35 	bl	800c598 <tcp_seg_free>
      next = next->next;
 800d92e:	4634      	mov	r4, r6
    while (next &&
 800d930:	b1cc      	cbz	r4, 800d966 <tcp_oos_insert_segment+0x72>
           TCP_SEQ_GEQ((seqno + cseg->len),
 800d932:	892b      	ldrh	r3, [r5, #8]
 800d934:	4a18      	ldr	r2, [pc, #96]	@ (800d998 <tcp_oos_insert_segment+0xa4>)
 800d936:	6812      	ldr	r2, [r2, #0]
 800d938:	4413      	add	r3, r2
 800d93a:	6921      	ldr	r1, [r4, #16]
 800d93c:	684a      	ldr	r2, [r1, #4]
 800d93e:	8920      	ldrh	r0, [r4, #8]
 800d940:	4402      	add	r2, r0
 800d942:	1a9b      	subs	r3, r3, r2
    while (next &&
 800d944:	2b00      	cmp	r3, #0
 800d946:	db0e      	blt.n	800d966 <tcp_oos_insert_segment+0x72>
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 800d948:	8988      	ldrh	r0, [r1, #12]
 800d94a:	f7fd f909 	bl	800ab60 <lwip_htons>
 800d94e:	f010 0f01 	tst.w	r0, #1
 800d952:	d0e8      	beq.n	800d926 <tcp_oos_insert_segment+0x32>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
 800d954:	692b      	ldr	r3, [r5, #16]
 800d956:	899e      	ldrh	r6, [r3, #12]
 800d958:	2001      	movs	r0, #1
 800d95a:	f7fd f901 	bl	800ab60 <lwip_htons>
 800d95e:	692b      	ldr	r3, [r5, #16]
 800d960:	4306      	orrs	r6, r0
 800d962:	819e      	strh	r6, [r3, #12]
 800d964:	e7df      	b.n	800d926 <tcp_oos_insert_segment+0x32>
    if (next &&
 800d966:	2c00      	cmp	r4, #0
 800d968:	d0d3      	beq.n	800d912 <tcp_oos_insert_segment+0x1e>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
 800d96a:	892b      	ldrh	r3, [r5, #8]
 800d96c:	4a0a      	ldr	r2, [pc, #40]	@ (800d998 <tcp_oos_insert_segment+0xa4>)
 800d96e:	6811      	ldr	r1, [r2, #0]
 800d970:	440b      	add	r3, r1
 800d972:	6922      	ldr	r2, [r4, #16]
 800d974:	6852      	ldr	r2, [r2, #4]
 800d976:	1a9b      	subs	r3, r3, r2
    if (next &&
 800d978:	2b00      	cmp	r3, #0
 800d97a:	ddca      	ble.n	800d912 <tcp_oos_insert_segment+0x1e>
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
 800d97c:	1a52      	subs	r2, r2, r1
 800d97e:	b291      	uxth	r1, r2
 800d980:	8129      	strh	r1, [r5, #8]
      pbuf_realloc(cseg->p, cseg->len);
 800d982:	6868      	ldr	r0, [r5, #4]
 800d984:	f7fe f9e8 	bl	800bd58 <pbuf_realloc>
 800d988:	e7c3      	b.n	800d912 <tcp_oos_insert_segment+0x1e>
 800d98a:	bf00      	nop
 800d98c:	08017064 	.word	0x08017064
 800d990:	08017164 	.word	0x08017164
 800d994:	08015744 	.word	0x08015744
 800d998:	24014300 	.word	0x24014300

0800d99c <tcp_receive>:
{
 800d99c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  LWIP_ASSERT("tcp_receive: invalid pcb", pcb != NULL);
 800d99e:	4604      	mov	r4, r0
 800d9a0:	2800      	cmp	r0, #0
 800d9a2:	d06f      	beq.n	800da84 <tcp_receive+0xe8>
  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 800d9a4:	7d23      	ldrb	r3, [r4, #20]
 800d9a6:	2b03      	cmp	r3, #3
 800d9a8:	d974      	bls.n	800da94 <tcp_receive+0xf8>
  if (flags & TCP_ACK) {
 800d9aa:	4ba8      	ldr	r3, [pc, #672]	@ (800dc4c <tcp_receive+0x2b0>)
 800d9ac:	781b      	ldrb	r3, [r3, #0]
 800d9ae:	f013 0f10 	tst.w	r3, #16
 800d9b2:	d03c      	beq.n	800da2e <tcp_receive+0x92>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 800d9b4:	f8b4 0060 	ldrh.w	r0, [r4, #96]	@ 0x60
 800d9b8:	6da2      	ldr	r2, [r4, #88]	@ 0x58
 800d9ba:	1886      	adds	r6, r0, r2
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 800d9bc:	6d61      	ldr	r1, [r4, #84]	@ 0x54
 800d9be:	4ba4      	ldr	r3, [pc, #656]	@ (800dc50 <tcp_receive+0x2b4>)
 800d9c0:	681b      	ldr	r3, [r3, #0]
 800d9c2:	1acd      	subs	r5, r1, r3
 800d9c4:	2d00      	cmp	r5, #0
 800d9c6:	db0a      	blt.n	800d9de <tcp_receive+0x42>
 800d9c8:	4299      	cmp	r1, r3
 800d9ca:	d06b      	beq.n	800daa4 <tcp_receive+0x108>
        (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 800d9cc:	49a1      	ldr	r1, [pc, #644]	@ (800dc54 <tcp_receive+0x2b8>)
 800d9ce:	6809      	ldr	r1, [r1, #0]
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 800d9d0:	428a      	cmp	r2, r1
 800d9d2:	d114      	bne.n	800d9fe <tcp_receive+0x62>
        (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 800d9d4:	4aa0      	ldr	r2, [pc, #640]	@ (800dc58 <tcp_receive+0x2bc>)
 800d9d6:	6812      	ldr	r2, [r2, #0]
 800d9d8:	89d2      	ldrh	r2, [r2, #14]
 800d9da:	4290      	cmp	r0, r2
 800d9dc:	d20f      	bcs.n	800d9fe <tcp_receive+0x62>
      pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
 800d9de:	4a9e      	ldr	r2, [pc, #632]	@ (800dc58 <tcp_receive+0x2bc>)
 800d9e0:	6812      	ldr	r2, [r2, #0]
 800d9e2:	89d2      	ldrh	r2, [r2, #14]
 800d9e4:	b290      	uxth	r0, r2
 800d9e6:	f8a4 2060 	strh.w	r2, [r4, #96]	@ 0x60
      if (pcb->snd_wnd_max < pcb->snd_wnd) {
 800d9ea:	f8b4 1062 	ldrh.w	r1, [r4, #98]	@ 0x62
 800d9ee:	4288      	cmp	r0, r1
 800d9f0:	d901      	bls.n	800d9f6 <tcp_receive+0x5a>
        pcb->snd_wnd_max = pcb->snd_wnd;
 800d9f2:	f8a4 2062 	strh.w	r2, [r4, #98]	@ 0x62
      pcb->snd_wl1 = seqno;
 800d9f6:	6563      	str	r3, [r4, #84]	@ 0x54
      pcb->snd_wl2 = ackno;
 800d9f8:	4b96      	ldr	r3, [pc, #600]	@ (800dc54 <tcp_receive+0x2b8>)
 800d9fa:	681b      	ldr	r3, [r3, #0]
 800d9fc:	65a3      	str	r3, [r4, #88]	@ 0x58
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
 800d9fe:	4b95      	ldr	r3, [pc, #596]	@ (800dc54 <tcp_receive+0x2b8>)
 800da00:	681b      	ldr	r3, [r3, #0]
 800da02:	6c61      	ldr	r1, [r4, #68]	@ 0x44
 800da04:	1a5a      	subs	r2, r3, r1
 800da06:	2a00      	cmp	r2, #0
 800da08:	dd52      	ble.n	800dab0 <tcp_receive+0x114>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 800da0a:	2a01      	cmp	r2, #1
 800da0c:	d403      	bmi.n	800da16 <tcp_receive+0x7a>
 800da0e:	6d22      	ldr	r2, [r4, #80]	@ 0x50
 800da10:	1a9a      	subs	r2, r3, r2
 800da12:	2a00      	cmp	r2, #0
 800da14:	dd7e      	ble.n	800db14 <tcp_receive+0x178>
      tcp_send_empty_ack(pcb);
 800da16:	4620      	mov	r0, r4
 800da18:	f002 faf8 	bl	801000c <tcp_send_empty_ack>
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 800da1c:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 800da1e:	b133      	cbz	r3, 800da2e <tcp_receive+0x92>
 800da20:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 800da22:	498c      	ldr	r1, [pc, #560]	@ (800dc54 <tcp_receive+0x2b8>)
 800da24:	6809      	ldr	r1, [r1, #0]
 800da26:	1a52      	subs	r2, r2, r1
 800da28:	2a00      	cmp	r2, #0
 800da2a:	f2c0 8136 	blt.w	800dc9a <tcp_receive+0x2fe>
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
 800da2e:	4b8b      	ldr	r3, [pc, #556]	@ (800dc5c <tcp_receive+0x2c0>)
 800da30:	881b      	ldrh	r3, [r3, #0]
 800da32:	2b00      	cmp	r3, #0
 800da34:	f000 8435 	beq.w	800e2a2 <tcp_receive+0x906>
 800da38:	7d22      	ldrb	r2, [r4, #20]
 800da3a:	2a06      	cmp	r2, #6
 800da3c:	f200 8431 	bhi.w	800e2a2 <tcp_receive+0x906>
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
 800da40:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 800da42:	4a83      	ldr	r2, [pc, #524]	@ (800dc50 <tcp_receive+0x2b4>)
 800da44:	6812      	ldr	r2, [r2, #0]
 800da46:	1a8e      	subs	r6, r1, r2
 800da48:	2e01      	cmp	r6, #1
 800da4a:	d405      	bmi.n	800da58 <tcp_receive+0xbc>
 800da4c:	4413      	add	r3, r2
 800da4e:	1acb      	subs	r3, r1, r3
 800da50:	3301      	adds	r3, #1
 800da52:	2b00      	cmp	r3, #0
 800da54:	f340 8147 	ble.w	800dce6 <tcp_receive+0x34a>
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
 800da58:	1a52      	subs	r2, r2, r1
 800da5a:	2a00      	cmp	r2, #0
 800da5c:	f2c0 8185 	blt.w	800dd6a <tcp_receive+0x3ce>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 800da60:	4b7b      	ldr	r3, [pc, #492]	@ (800dc50 <tcp_receive+0x2b4>)
 800da62:	681b      	ldr	r3, [r3, #0]
 800da64:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 800da66:	1a5a      	subs	r2, r3, r1
 800da68:	2a00      	cmp	r2, #0
 800da6a:	db06      	blt.n	800da7a <tcp_receive+0xde>
 800da6c:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
 800da6e:	440a      	add	r2, r1
 800da70:	1a9a      	subs	r2, r3, r2
 800da72:	3201      	adds	r2, #1
 800da74:	2a00      	cmp	r2, #0
 800da76:	f340 817d 	ble.w	800dd74 <tcp_receive+0x3d8>
      tcp_send_empty_ack(pcb);
 800da7a:	4620      	mov	r0, r4
 800da7c:	f002 fac6 	bl	801000c <tcp_send_empty_ack>
 800da80:	f000 bc1f 	b.w	800e2c2 <tcp_receive+0x926>
  LWIP_ASSERT("tcp_receive: invalid pcb", pcb != NULL);
 800da84:	4b76      	ldr	r3, [pc, #472]	@ (800dc60 <tcp_receive+0x2c4>)
 800da86:	f240 427b 	movw	r2, #1147	@ 0x47b
 800da8a:	4976      	ldr	r1, [pc, #472]	@ (800dc64 <tcp_receive+0x2c8>)
 800da8c:	4876      	ldr	r0, [pc, #472]	@ (800dc68 <tcp_receive+0x2cc>)
 800da8e:	f006 fa77 	bl	8013f80 <iprintf>
 800da92:	e787      	b.n	800d9a4 <tcp_receive+0x8>
  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 800da94:	4b72      	ldr	r3, [pc, #456]	@ (800dc60 <tcp_receive+0x2c4>)
 800da96:	f240 427c 	movw	r2, #1148	@ 0x47c
 800da9a:	4974      	ldr	r1, [pc, #464]	@ (800dc6c <tcp_receive+0x2d0>)
 800da9c:	4872      	ldr	r0, [pc, #456]	@ (800dc68 <tcp_receive+0x2cc>)
 800da9e:	f006 fa6f 	bl	8013f80 <iprintf>
 800daa2:	e782      	b.n	800d9aa <tcp_receive+0xe>
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 800daa4:	496b      	ldr	r1, [pc, #428]	@ (800dc54 <tcp_receive+0x2b8>)
 800daa6:	6809      	ldr	r1, [r1, #0]
 800daa8:	1a51      	subs	r1, r2, r1
 800daaa:	2900      	cmp	r1, #0
 800daac:	da8e      	bge.n	800d9cc <tcp_receive+0x30>
 800daae:	e796      	b.n	800d9de <tcp_receive+0x42>
      if (tcplen == 0) {
 800dab0:	4a6a      	ldr	r2, [pc, #424]	@ (800dc5c <tcp_receive+0x2c0>)
 800dab2:	8812      	ldrh	r2, [r2, #0]
 800dab4:	b92a      	cbnz	r2, 800dac2 <tcp_receive+0x126>
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
 800dab6:	6da2      	ldr	r2, [r4, #88]	@ 0x58
 800dab8:	f8b4 0060 	ldrh.w	r0, [r4, #96]	@ 0x60
 800dabc:	4402      	add	r2, r0
 800dabe:	42b2      	cmp	r2, r6
 800dac0:	d003      	beq.n	800daca <tcp_receive+0x12e>
        pcb->dupacks = 0;
 800dac2:	2300      	movs	r3, #0
 800dac4:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 800dac8:	e7a8      	b.n	800da1c <tcp_receive+0x80>
          if (pcb->rtime >= 0) {
 800daca:	f9b4 2030 	ldrsh.w	r2, [r4, #48]	@ 0x30
 800dace:	2a00      	cmp	r2, #0
 800dad0:	dbf7      	blt.n	800dac2 <tcp_receive+0x126>
            if (pcb->lastack == ackno) {
 800dad2:	428b      	cmp	r3, r1
 800dad4:	d1f5      	bne.n	800dac2 <tcp_receive+0x126>
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
 800dad6:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 800dada:	2bff      	cmp	r3, #255	@ 0xff
 800dadc:	d002      	beq.n	800dae4 <tcp_receive+0x148>
                ++pcb->dupacks;
 800dade:	3301      	adds	r3, #1
 800dae0:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
              if (pcb->dupacks > 3) {
 800dae4:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 800dae8:	2b03      	cmp	r3, #3
 800daea:	d908      	bls.n	800dafe <tcp_receive+0x162>
                TCP_WND_INC(pcb->cwnd, pcb->mss);
 800daec:	f8b4 1048 	ldrh.w	r1, [r4, #72]	@ 0x48
 800daf0:	8e62      	ldrh	r2, [r4, #50]	@ 0x32
 800daf2:	440a      	add	r2, r1
 800daf4:	b292      	uxth	r2, r2
 800daf6:	4291      	cmp	r1, r2
 800daf8:	d807      	bhi.n	800db0a <tcp_receive+0x16e>
 800dafa:	f8a4 2048 	strh.w	r2, [r4, #72]	@ 0x48
              if (pcb->dupacks >= 3) {
 800dafe:	2b02      	cmp	r3, #2
 800db00:	d98c      	bls.n	800da1c <tcp_receive+0x80>
                tcp_rexmit_fast(pcb);
 800db02:	4620      	mov	r0, r4
 800db04:	f002 f9fc 	bl	800ff00 <tcp_rexmit_fast>
      if (!found_dupack) {
 800db08:	e788      	b.n	800da1c <tcp_receive+0x80>
                TCP_WND_INC(pcb->cwnd, pcb->mss);
 800db0a:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800db0e:	f8a4 2048 	strh.w	r2, [r4, #72]	@ 0x48
 800db12:	e7f4      	b.n	800dafe <tcp_receive+0x162>
      if (pcb->flags & TF_INFR) {
 800db14:	8b62      	ldrh	r2, [r4, #26]
 800db16:	f012 0f04 	tst.w	r2, #4
 800db1a:	d009      	beq.n	800db30 <tcp_receive+0x194>
        tcp_clear_flags(pcb, TF_INFR);
 800db1c:	f022 0204 	bic.w	r2, r2, #4
 800db20:	8362      	strh	r2, [r4, #26]
        pcb->cwnd = pcb->ssthresh;
 800db22:	f8b4 204a 	ldrh.w	r2, [r4, #74]	@ 0x4a
 800db26:	f8a4 2048 	strh.w	r2, [r4, #72]	@ 0x48
        pcb->bytes_acked = 0;
 800db2a:	2200      	movs	r2, #0
 800db2c:	f8a4 206a 	strh.w	r2, [r4, #106]	@ 0x6a
      pcb->nrtx = 0;
 800db30:	2000      	movs	r0, #0
 800db32:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
      pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
 800db36:	f9b4 503c 	ldrsh.w	r5, [r4, #60]	@ 0x3c
 800db3a:	8fe2      	ldrh	r2, [r4, #62]	@ 0x3e
 800db3c:	eb02 02e5 	add.w	r2, r2, r5, asr #3
 800db40:	f8a4 2040 	strh.w	r2, [r4, #64]	@ 0x40
      acked = (tcpwnd_size_t)(ackno - pcb->lastack);
 800db44:	b29a      	uxth	r2, r3
 800db46:	b289      	uxth	r1, r1
 800db48:	1a52      	subs	r2, r2, r1
 800db4a:	b292      	uxth	r2, r2
      pcb->dupacks = 0;
 800db4c:	f884 0043 	strb.w	r0, [r4, #67]	@ 0x43
      pcb->lastack = ackno;
 800db50:	6463      	str	r3, [r4, #68]	@ 0x44
      if (pcb->state >= ESTABLISHED) {
 800db52:	7d23      	ldrb	r3, [r4, #20]
 800db54:	2b03      	cmp	r3, #3
 800db56:	d917      	bls.n	800db88 <tcp_receive+0x1ec>
        if (pcb->cwnd < pcb->ssthresh) {
 800db58:	f8b4 3048 	ldrh.w	r3, [r4, #72]	@ 0x48
 800db5c:	f8b4 104a 	ldrh.w	r1, [r4, #74]	@ 0x4a
 800db60:	428b      	cmp	r3, r1
 800db62:	d24b      	bcs.n	800dbfc <tcp_receive+0x260>
          u8_t num_seg = (pcb->flags & TF_RTO) ? 1 : 2;
 800db64:	8b61      	ldrh	r1, [r4, #26]
 800db66:	f411 6f00 	tst.w	r1, #2048	@ 0x800
 800db6a:	d040      	beq.n	800dbee <tcp_receive+0x252>
 800db6c:	2101      	movs	r1, #1
          increase = LWIP_MIN(acked, (tcpwnd_size_t)(num_seg * pcb->mss));
 800db6e:	8e60      	ldrh	r0, [r4, #50]	@ 0x32
 800db70:	fb11 f100 	smulbb	r1, r1, r0
 800db74:	b289      	uxth	r1, r1
          TCP_WND_INC(pcb->cwnd, increase);
 800db76:	4291      	cmp	r1, r2
 800db78:	bf94      	ite	ls
 800db7a:	1858      	addls	r0, r3, r1
 800db7c:	1898      	addhi	r0, r3, r2
 800db7e:	b282      	uxth	r2, r0
 800db80:	4293      	cmp	r3, r2
 800db82:	d836      	bhi.n	800dbf2 <tcp_receive+0x256>
 800db84:	f8a4 2048 	strh.w	r2, [r4, #72]	@ 0x48
      pcb->unacked = tcp_free_acked_segments(pcb, pcb->unacked, "unacked", pcb->unsent);
 800db88:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
 800db8a:	4a39      	ldr	r2, [pc, #228]	@ (800dc70 <tcp_receive+0x2d4>)
 800db8c:	6f21      	ldr	r1, [r4, #112]	@ 0x70
 800db8e:	4620      	mov	r0, r4
 800db90:	f7ff fe50 	bl	800d834 <tcp_free_acked_segments>
 800db94:	4603      	mov	r3, r0
 800db96:	6720      	str	r0, [r4, #112]	@ 0x70
      pcb->unsent = tcp_free_acked_segments(pcb, pcb->unsent, "unsent", pcb->unacked);
 800db98:	4a36      	ldr	r2, [pc, #216]	@ (800dc74 <tcp_receive+0x2d8>)
 800db9a:	6ee1      	ldr	r1, [r4, #108]	@ 0x6c
 800db9c:	4620      	mov	r0, r4
 800db9e:	f7ff fe49 	bl	800d834 <tcp_free_acked_segments>
 800dba2:	66e0      	str	r0, [r4, #108]	@ 0x6c
      if (pcb->unacked == NULL) {
 800dba4:	6f22      	ldr	r2, [r4, #112]	@ 0x70
 800dba6:	2a00      	cmp	r2, #0
 800dba8:	d049      	beq.n	800dc3e <tcp_receive+0x2a2>
        pcb->rtime = 0;
 800dbaa:	2300      	movs	r3, #0
 800dbac:	8623      	strh	r3, [r4, #48]	@ 0x30
      pcb->polltmr = 0;
 800dbae:	2300      	movs	r3, #0
 800dbb0:	7723      	strb	r3, [r4, #28]
      if (pcb->unsent == NULL) {
 800dbb2:	2800      	cmp	r0, #0
 800dbb4:	d047      	beq.n	800dc46 <tcp_receive+0x2aa>
      pcb->snd_buf = (tcpwnd_size_t)(pcb->snd_buf + recv_acked);
 800dbb6:	f8b4 3064 	ldrh.w	r3, [r4, #100]	@ 0x64
 800dbba:	492f      	ldr	r1, [pc, #188]	@ (800dc78 <tcp_receive+0x2dc>)
 800dbbc:	8809      	ldrh	r1, [r1, #0]
 800dbbe:	440b      	add	r3, r1
 800dbc0:	f8a4 3064 	strh.w	r3, [r4, #100]	@ 0x64
      if (pcb->flags & TF_RTO) {
 800dbc4:	8b63      	ldrh	r3, [r4, #26]
 800dbc6:	f413 6f00 	tst.w	r3, #2048	@ 0x800
 800dbca:	f43f af27 	beq.w	800da1c <tcp_receive+0x80>
        if (pcb->unacked == NULL) {
 800dbce:	2a00      	cmp	r2, #0
 800dbd0:	d054      	beq.n	800dc7c <tcp_receive+0x2e0>
        } else if (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unacked->tcphdr->seqno))) {
 800dbd2:	6ce5      	ldr	r5, [r4, #76]	@ 0x4c
 800dbd4:	6913      	ldr	r3, [r2, #16]
 800dbd6:	6858      	ldr	r0, [r3, #4]
 800dbd8:	f7fc ffc7 	bl	800ab6a <lwip_htonl>
 800dbdc:	1a2d      	subs	r5, r5, r0
 800dbde:	2d00      	cmp	r5, #0
 800dbe0:	f73f af1c 	bgt.w	800da1c <tcp_receive+0x80>
          tcp_clear_flags(pcb, TF_RTO);
 800dbe4:	8b63      	ldrh	r3, [r4, #26]
 800dbe6:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
 800dbea:	8363      	strh	r3, [r4, #26]
 800dbec:	e716      	b.n	800da1c <tcp_receive+0x80>
          u8_t num_seg = (pcb->flags & TF_RTO) ? 1 : 2;
 800dbee:	2102      	movs	r1, #2
 800dbf0:	e7bd      	b.n	800db6e <tcp_receive+0x1d2>
          TCP_WND_INC(pcb->cwnd, increase);
 800dbf2:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 800dbf6:	f8a4 3048 	strh.w	r3, [r4, #72]	@ 0x48
 800dbfa:	e7c5      	b.n	800db88 <tcp_receive+0x1ec>
          TCP_WND_INC(pcb->bytes_acked, acked);
 800dbfc:	f8b4 106a 	ldrh.w	r1, [r4, #106]	@ 0x6a
 800dc00:	440a      	add	r2, r1
 800dc02:	b292      	uxth	r2, r2
 800dc04:	4291      	cmp	r1, r2
 800dc06:	d810      	bhi.n	800dc2a <tcp_receive+0x28e>
 800dc08:	f8a4 206a 	strh.w	r2, [r4, #106]	@ 0x6a
          if (pcb->bytes_acked >= pcb->cwnd) {
 800dc0c:	f8b4 206a 	ldrh.w	r2, [r4, #106]	@ 0x6a
 800dc10:	4293      	cmp	r3, r2
 800dc12:	d8b9      	bhi.n	800db88 <tcp_receive+0x1ec>
            pcb->bytes_acked = (tcpwnd_size_t)(pcb->bytes_acked - pcb->cwnd);
 800dc14:	1ad2      	subs	r2, r2, r3
 800dc16:	f8a4 206a 	strh.w	r2, [r4, #106]	@ 0x6a
            TCP_WND_INC(pcb->cwnd, pcb->mss);
 800dc1a:	8e62      	ldrh	r2, [r4, #50]	@ 0x32
 800dc1c:	441a      	add	r2, r3
 800dc1e:	b292      	uxth	r2, r2
 800dc20:	4293      	cmp	r3, r2
 800dc22:	d807      	bhi.n	800dc34 <tcp_receive+0x298>
 800dc24:	f8a4 2048 	strh.w	r2, [r4, #72]	@ 0x48
 800dc28:	e7ae      	b.n	800db88 <tcp_receive+0x1ec>
          TCP_WND_INC(pcb->bytes_acked, acked);
 800dc2a:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800dc2e:	f8a4 206a 	strh.w	r2, [r4, #106]	@ 0x6a
 800dc32:	e7eb      	b.n	800dc0c <tcp_receive+0x270>
            TCP_WND_INC(pcb->cwnd, pcb->mss);
 800dc34:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 800dc38:	f8a4 3048 	strh.w	r3, [r4, #72]	@ 0x48
 800dc3c:	e7a4      	b.n	800db88 <tcp_receive+0x1ec>
        pcb->rtime = -1;
 800dc3e:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 800dc42:	8623      	strh	r3, [r4, #48]	@ 0x30
 800dc44:	e7b3      	b.n	800dbae <tcp_receive+0x212>
        pcb->unsent_oversize = 0;
 800dc46:	f8a4 3068 	strh.w	r3, [r4, #104]	@ 0x68
 800dc4a:	e7b4      	b.n	800dbb6 <tcp_receive+0x21a>
 800dc4c:	240142f5 	.word	0x240142f5
 800dc50:	24014300 	.word	0x24014300
 800dc54:	240142fc 	.word	0x240142fc
 800dc58:	24014310 	.word	0x24014310
 800dc5c:	240142f6 	.word	0x240142f6
 800dc60:	08017064 	.word	0x08017064
 800dc64:	0801718c 	.word	0x0801718c
 800dc68:	08015744 	.word	0x08015744
 800dc6c:	080171a8 	.word	0x080171a8
 800dc70:	080171c4 	.word	0x080171c4
 800dc74:	080171cc 	.word	0x080171cc
 800dc78:	240142f8 	.word	0x240142f8
          if ((pcb->unsent == NULL) ||
 800dc7c:	b140      	cbz	r0, 800dc90 <tcp_receive+0x2f4>
              (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unsent->tcphdr->seqno)))) {
 800dc7e:	6ce5      	ldr	r5, [r4, #76]	@ 0x4c
 800dc80:	6903      	ldr	r3, [r0, #16]
 800dc82:	6858      	ldr	r0, [r3, #4]
 800dc84:	f7fc ff71 	bl	800ab6a <lwip_htonl>
 800dc88:	1a2d      	subs	r5, r5, r0
          if ((pcb->unsent == NULL) ||
 800dc8a:	2d00      	cmp	r5, #0
 800dc8c:	f73f aec6 	bgt.w	800da1c <tcp_receive+0x80>
            tcp_clear_flags(pcb, TF_RTO);
 800dc90:	8b63      	ldrh	r3, [r4, #26]
 800dc92:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
 800dc96:	8363      	strh	r3, [r4, #26]
 800dc98:	e6c0      	b.n	800da1c <tcp_receive+0x80>
      m = (s16_t)(tcp_ticks - pcb->rttest);
 800dc9a:	4a88      	ldr	r2, [pc, #544]	@ (800debc <tcp_receive+0x520>)
 800dc9c:	8816      	ldrh	r6, [r2, #0]
 800dc9e:	b29b      	uxth	r3, r3
 800dca0:	1af2      	subs	r2, r6, r3
 800dca2:	b292      	uxth	r2, r2
      m = (s16_t)(m - (pcb->sa >> 3));
 800dca4:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	@ 0x3c
 800dca8:	f3c0 05cf 	ubfx	r5, r0, #3, #16
 800dcac:	1b52      	subs	r2, r2, r5
 800dcae:	b211      	sxth	r1, r2
      pcb->sa = (s16_t)(pcb->sa + m);
 800dcb0:	b280      	uxth	r0, r0
 800dcb2:	fa10 f282 	uxtah	r2, r0, r2
 800dcb6:	b212      	sxth	r2, r2
 800dcb8:	87a2      	strh	r2, [r4, #60]	@ 0x3c
      if (m < 0) {
 800dcba:	2900      	cmp	r1, #0
 800dcbc:	db0f      	blt.n	800dcde <tcp_receive+0x342>
      m = (s16_t)(m - (pcb->sv >> 2));
 800dcbe:	f9b4 303e 	ldrsh.w	r3, [r4, #62]	@ 0x3e
 800dcc2:	eba1 01a3 	sub.w	r1, r1, r3, asr #2
      pcb->sv = (s16_t)(pcb->sv + m);
 800dcc6:	b29b      	uxth	r3, r3
 800dcc8:	fa13 f181 	uxtah	r1, r3, r1
 800dccc:	87e1      	strh	r1, [r4, #62]	@ 0x3e
      pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
 800dcce:	10d2      	asrs	r2, r2, #3
 800dcd0:	fa12 f181 	uxtah	r1, r2, r1
 800dcd4:	f8a4 1040 	strh.w	r1, [r4, #64]	@ 0x40
      pcb->rttest = 0;
 800dcd8:	2300      	movs	r3, #0
 800dcda:	6363      	str	r3, [r4, #52]	@ 0x34
 800dcdc:	e6a7      	b.n	800da2e <tcp_receive+0x92>
        m = (s16_t) - m;
 800dcde:	1b9b      	subs	r3, r3, r6
 800dce0:	441d      	add	r5, r3
 800dce2:	b229      	sxth	r1, r5
 800dce4:	e7eb      	b.n	800dcbe <tcp_receive+0x322>
      struct pbuf *p = inseg.p;
 800dce6:	4b76      	ldr	r3, [pc, #472]	@ (800dec0 <tcp_receive+0x524>)
 800dce8:	685d      	ldr	r5, [r3, #4]
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
 800dcea:	b1dd      	cbz	r5, 800dd24 <tcp_receive+0x388>
      LWIP_ASSERT("insane offset!", (off32 < 0xffff));
 800dcec:	f64f 73fe 	movw	r3, #65534	@ 0xfffe
 800dcf0:	429e      	cmp	r6, r3
 800dcf2:	d81f      	bhi.n	800dd34 <tcp_receive+0x398>
      off = (u16_t)off32;
 800dcf4:	b2b6      	uxth	r6, r6
      LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
 800dcf6:	4b72      	ldr	r3, [pc, #456]	@ (800dec0 <tcp_receive+0x524>)
 800dcf8:	685b      	ldr	r3, [r3, #4]
 800dcfa:	891b      	ldrh	r3, [r3, #8]
 800dcfc:	42b3      	cmp	r3, r6
 800dcfe:	d321      	bcc.n	800dd44 <tcp_receive+0x3a8>
      inseg.len -= off;
 800dd00:	4b6f      	ldr	r3, [pc, #444]	@ (800dec0 <tcp_receive+0x524>)
 800dd02:	891a      	ldrh	r2, [r3, #8]
 800dd04:	1b92      	subs	r2, r2, r6
 800dd06:	811a      	strh	r2, [r3, #8]
      new_tot_len = (u16_t)(inseg.p->tot_len - off);
 800dd08:	685b      	ldr	r3, [r3, #4]
 800dd0a:	891a      	ldrh	r2, [r3, #8]
 800dd0c:	1b92      	subs	r2, r2, r6
 800dd0e:	b292      	uxth	r2, r2
      while (p->len < off) {
 800dd10:	896b      	ldrh	r3, [r5, #10]
 800dd12:	42b3      	cmp	r3, r6
 800dd14:	d21e      	bcs.n	800dd54 <tcp_receive+0x3b8>
        off -= p->len;
 800dd16:	1af3      	subs	r3, r6, r3
 800dd18:	b29e      	uxth	r6, r3
        p->tot_len = new_tot_len;
 800dd1a:	812a      	strh	r2, [r5, #8]
        p->len = 0;
 800dd1c:	2300      	movs	r3, #0
 800dd1e:	816b      	strh	r3, [r5, #10]
        p = p->next;
 800dd20:	682d      	ldr	r5, [r5, #0]
 800dd22:	e7f5      	b.n	800dd10 <tcp_receive+0x374>
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
 800dd24:	4b67      	ldr	r3, [pc, #412]	@ (800dec4 <tcp_receive+0x528>)
 800dd26:	f240 5294 	movw	r2, #1428	@ 0x594
 800dd2a:	4967      	ldr	r1, [pc, #412]	@ (800dec8 <tcp_receive+0x52c>)
 800dd2c:	4867      	ldr	r0, [pc, #412]	@ (800decc <tcp_receive+0x530>)
 800dd2e:	f006 f927 	bl	8013f80 <iprintf>
 800dd32:	e7db      	b.n	800dcec <tcp_receive+0x350>
      LWIP_ASSERT("insane offset!", (off32 < 0xffff));
 800dd34:	4b63      	ldr	r3, [pc, #396]	@ (800dec4 <tcp_receive+0x528>)
 800dd36:	f240 5295 	movw	r2, #1429	@ 0x595
 800dd3a:	4965      	ldr	r1, [pc, #404]	@ (800ded0 <tcp_receive+0x534>)
 800dd3c:	4863      	ldr	r0, [pc, #396]	@ (800decc <tcp_receive+0x530>)
 800dd3e:	f006 f91f 	bl	8013f80 <iprintf>
 800dd42:	e7d7      	b.n	800dcf4 <tcp_receive+0x358>
      LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
 800dd44:	4b5f      	ldr	r3, [pc, #380]	@ (800dec4 <tcp_receive+0x528>)
 800dd46:	f240 5297 	movw	r2, #1431	@ 0x597
 800dd4a:	4962      	ldr	r1, [pc, #392]	@ (800ded4 <tcp_receive+0x538>)
 800dd4c:	485f      	ldr	r0, [pc, #380]	@ (800decc <tcp_receive+0x530>)
 800dd4e:	f006 f917 	bl	8013f80 <iprintf>
 800dd52:	e7d5      	b.n	800dd00 <tcp_receive+0x364>
      pbuf_remove_header(p, off);
 800dd54:	4631      	mov	r1, r6
 800dd56:	4628      	mov	r0, r5
 800dd58:	f7fd fea4 	bl	800baa4 <pbuf_remove_header>
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 800dd5c:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 800dd5e:	4a5e      	ldr	r2, [pc, #376]	@ (800ded8 <tcp_receive+0x53c>)
 800dd60:	6013      	str	r3, [r2, #0]
 800dd62:	4a57      	ldr	r2, [pc, #348]	@ (800dec0 <tcp_receive+0x524>)
 800dd64:	6912      	ldr	r2, [r2, #16]
 800dd66:	6053      	str	r3, [r2, #4]
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
 800dd68:	e67a      	b.n	800da60 <tcp_receive+0xc4>
        tcp_ack_now(pcb);
 800dd6a:	8b63      	ldrh	r3, [r4, #26]
 800dd6c:	f043 0302 	orr.w	r3, r3, #2
 800dd70:	8363      	strh	r3, [r4, #26]
 800dd72:	e675      	b.n	800da60 <tcp_receive+0xc4>
      if (pcb->rcv_nxt == seqno) {
 800dd74:	428b      	cmp	r3, r1
 800dd76:	d005      	beq.n	800dd84 <tcp_receive+0x3e8>
        if (pcb->ooseq == NULL) {
 800dd78:	6f65      	ldr	r5, [r4, #116]	@ 0x74
 800dd7a:	2d00      	cmp	r5, #0
 800dd7c:	f000 81aa 	beq.w	800e0d4 <tcp_receive+0x738>
          struct tcp_seg *next, *prev = NULL;
 800dd80:	2600      	movs	r6, #0
 800dd82:	e1cc      	b.n	800e11e <tcp_receive+0x782>
        tcplen = TCP_TCPLEN(&inseg);
 800dd84:	4b4e      	ldr	r3, [pc, #312]	@ (800dec0 <tcp_receive+0x524>)
 800dd86:	891d      	ldrh	r5, [r3, #8]
 800dd88:	691b      	ldr	r3, [r3, #16]
 800dd8a:	8998      	ldrh	r0, [r3, #12]
 800dd8c:	f7fc fee8 	bl	800ab60 <lwip_htons>
 800dd90:	f010 0f03 	tst.w	r0, #3
 800dd94:	d014      	beq.n	800ddc0 <tcp_receive+0x424>
 800dd96:	2301      	movs	r3, #1
 800dd98:	442b      	add	r3, r5
 800dd9a:	b29b      	uxth	r3, r3
 800dd9c:	4a4f      	ldr	r2, [pc, #316]	@ (800dedc <tcp_receive+0x540>)
 800dd9e:	8013      	strh	r3, [r2, #0]
        if (tcplen > pcb->rcv_wnd) {
 800dda0:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
 800dda2:	4293      	cmp	r3, r2
 800dda4:	d80e      	bhi.n	800ddc4 <tcp_receive+0x428>
        if (pcb->ooseq != NULL) {
 800dda6:	6f63      	ldr	r3, [r4, #116]	@ 0x74
 800dda8:	2b00      	cmp	r3, #0
 800ddaa:	d05d      	beq.n	800de68 <tcp_receive+0x4cc>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800ddac:	4b44      	ldr	r3, [pc, #272]	@ (800dec0 <tcp_receive+0x524>)
 800ddae:	691b      	ldr	r3, [r3, #16]
 800ddb0:	8998      	ldrh	r0, [r3, #12]
 800ddb2:	f7fc fed5 	bl	800ab60 <lwip_htons>
 800ddb6:	f010 0f01 	tst.w	r0, #1
 800ddba:	d152      	bne.n	800de62 <tcp_receive+0x4c6>
            struct tcp_seg *next = pcb->ooseq;
 800ddbc:	6f65      	ldr	r5, [r4, #116]	@ 0x74
            while (next &&
 800ddbe:	e09e      	b.n	800defe <tcp_receive+0x562>
        tcplen = TCP_TCPLEN(&inseg);
 800ddc0:	2300      	movs	r3, #0
 800ddc2:	e7e9      	b.n	800dd98 <tcp_receive+0x3fc>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800ddc4:	4b3e      	ldr	r3, [pc, #248]	@ (800dec0 <tcp_receive+0x524>)
 800ddc6:	691b      	ldr	r3, [r3, #16]
 800ddc8:	8998      	ldrh	r0, [r3, #12]
 800ddca:	f7fc fec9 	bl	800ab60 <lwip_htons>
 800ddce:	f010 0f01 	tst.w	r0, #1
 800ddd2:	d12f      	bne.n	800de34 <tcp_receive+0x498>
          inseg.len = (u16_t)pcb->rcv_wnd;
 800ddd4:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
 800ddd6:	4b3a      	ldr	r3, [pc, #232]	@ (800dec0 <tcp_receive+0x524>)
 800ddd8:	811a      	strh	r2, [r3, #8]
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 800ddda:	691b      	ldr	r3, [r3, #16]
 800dddc:	8998      	ldrh	r0, [r3, #12]
 800ddde:	f7fc febf 	bl	800ab60 <lwip_htons>
 800dde2:	f010 0f02 	tst.w	r0, #2
 800dde6:	d003      	beq.n	800ddf0 <tcp_receive+0x454>
            inseg.len -= 1;
 800dde8:	4a35      	ldr	r2, [pc, #212]	@ (800dec0 <tcp_receive+0x524>)
 800ddea:	8913      	ldrh	r3, [r2, #8]
 800ddec:	3b01      	subs	r3, #1
 800ddee:	8113      	strh	r3, [r2, #8]
          pbuf_realloc(inseg.p, inseg.len);
 800ddf0:	4d33      	ldr	r5, [pc, #204]	@ (800dec0 <tcp_receive+0x524>)
 800ddf2:	8929      	ldrh	r1, [r5, #8]
 800ddf4:	6868      	ldr	r0, [r5, #4]
 800ddf6:	f7fd ffaf 	bl	800bd58 <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
 800ddfa:	892e      	ldrh	r6, [r5, #8]
 800ddfc:	692b      	ldr	r3, [r5, #16]
 800ddfe:	8998      	ldrh	r0, [r3, #12]
 800de00:	f7fc feae 	bl	800ab60 <lwip_htons>
 800de04:	f010 0f03 	tst.w	r0, #3
 800de08:	d025      	beq.n	800de56 <tcp_receive+0x4ba>
 800de0a:	2301      	movs	r3, #1
 800de0c:	4433      	add	r3, r6
 800de0e:	b29b      	uxth	r3, r3
 800de10:	4a32      	ldr	r2, [pc, #200]	@ (800dedc <tcp_receive+0x540>)
 800de12:	8013      	strh	r3, [r2, #0]
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 800de14:	4a30      	ldr	r2, [pc, #192]	@ (800ded8 <tcp_receive+0x53c>)
 800de16:	6812      	ldr	r2, [r2, #0]
 800de18:	4413      	add	r3, r2
 800de1a:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 800de1c:	8d21      	ldrh	r1, [r4, #40]	@ 0x28
 800de1e:	440a      	add	r2, r1
 800de20:	4293      	cmp	r3, r2
 800de22:	d0c0      	beq.n	800dda6 <tcp_receive+0x40a>
 800de24:	4b27      	ldr	r3, [pc, #156]	@ (800dec4 <tcp_receive+0x528>)
 800de26:	f240 52cb 	movw	r2, #1483	@ 0x5cb
 800de2a:	492d      	ldr	r1, [pc, #180]	@ (800dee0 <tcp_receive+0x544>)
 800de2c:	4827      	ldr	r0, [pc, #156]	@ (800decc <tcp_receive+0x530>)
 800de2e:	f006 f8a7 	bl	8013f80 <iprintf>
 800de32:	e7b8      	b.n	800dda6 <tcp_receive+0x40a>
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) & ~(unsigned int)TCP_FIN);
 800de34:	4e22      	ldr	r6, [pc, #136]	@ (800dec0 <tcp_receive+0x524>)
 800de36:	6933      	ldr	r3, [r6, #16]
 800de38:	899d      	ldrh	r5, [r3, #12]
 800de3a:	4628      	mov	r0, r5
 800de3c:	f7fc fe90 	bl	800ab60 <lwip_htons>
 800de40:	f000 003e 	and.w	r0, r0, #62	@ 0x3e
 800de44:	f7fc fe8c 	bl	800ab60 <lwip_htons>
 800de48:	6932      	ldr	r2, [r6, #16]
 800de4a:	f425 557c 	bic.w	r5, r5, #16128	@ 0x3f00
 800de4e:	ea40 0305 	orr.w	r3, r0, r5
 800de52:	8193      	strh	r3, [r2, #12]
 800de54:	e7be      	b.n	800ddd4 <tcp_receive+0x438>
          tcplen = TCP_TCPLEN(&inseg);
 800de56:	2300      	movs	r3, #0
 800de58:	e7d8      	b.n	800de0c <tcp_receive+0x470>
              pcb->ooseq = pcb->ooseq->next;
 800de5a:	6803      	ldr	r3, [r0, #0]
 800de5c:	6763      	str	r3, [r4, #116]	@ 0x74
              tcp_seg_free(old_ooseq);
 800de5e:	f7fe fb9b 	bl	800c598 <tcp_seg_free>
            while (pcb->ooseq != NULL) {
 800de62:	6f60      	ldr	r0, [r4, #116]	@ 0x74
 800de64:	2800      	cmp	r0, #0
 800de66:	d1f8      	bne.n	800de5a <tcp_receive+0x4be>
        pcb->rcv_nxt = seqno + tcplen;
 800de68:	4b1c      	ldr	r3, [pc, #112]	@ (800dedc <tcp_receive+0x540>)
 800de6a:	881a      	ldrh	r2, [r3, #0]
 800de6c:	4b1a      	ldr	r3, [pc, #104]	@ (800ded8 <tcp_receive+0x53c>)
 800de6e:	681b      	ldr	r3, [r3, #0]
 800de70:	4413      	add	r3, r2
 800de72:	6263      	str	r3, [r4, #36]	@ 0x24
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
 800de74:	8d23      	ldrh	r3, [r4, #40]	@ 0x28
 800de76:	429a      	cmp	r2, r3
 800de78:	f200 80ad 	bhi.w	800dfd6 <tcp_receive+0x63a>
        pcb->rcv_wnd -= tcplen;
 800de7c:	8d23      	ldrh	r3, [r4, #40]	@ 0x28
 800de7e:	4a17      	ldr	r2, [pc, #92]	@ (800dedc <tcp_receive+0x540>)
 800de80:	8812      	ldrh	r2, [r2, #0]
 800de82:	1a9b      	subs	r3, r3, r2
 800de84:	8523      	strh	r3, [r4, #40]	@ 0x28
        tcp_update_rcv_ann_wnd(pcb);
 800de86:	4620      	mov	r0, r4
 800de88:	f7fe fb0c 	bl	800c4a4 <tcp_update_rcv_ann_wnd>
        if (inseg.p->tot_len > 0) {
 800de8c:	4b0c      	ldr	r3, [pc, #48]	@ (800dec0 <tcp_receive+0x524>)
 800de8e:	685b      	ldr	r3, [r3, #4]
 800de90:	891a      	ldrh	r2, [r3, #8]
 800de92:	b122      	cbz	r2, 800de9e <tcp_receive+0x502>
          recv_data = inseg.p;
 800de94:	4a13      	ldr	r2, [pc, #76]	@ (800dee4 <tcp_receive+0x548>)
 800de96:	6013      	str	r3, [r2, #0]
          inseg.p = NULL;
 800de98:	4b09      	ldr	r3, [pc, #36]	@ (800dec0 <tcp_receive+0x524>)
 800de9a:	2200      	movs	r2, #0
 800de9c:	605a      	str	r2, [r3, #4]
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800de9e:	4b08      	ldr	r3, [pc, #32]	@ (800dec0 <tcp_receive+0x524>)
 800dea0:	691b      	ldr	r3, [r3, #16]
 800dea2:	8998      	ldrh	r0, [r3, #12]
 800dea4:	f7fc fe5c 	bl	800ab60 <lwip_htons>
 800dea8:	f010 0f01 	tst.w	r0, #1
 800deac:	f000 80c1 	beq.w	800e032 <tcp_receive+0x696>
          recv_flags |= TF_GOT_FIN;
 800deb0:	4a0d      	ldr	r2, [pc, #52]	@ (800dee8 <tcp_receive+0x54c>)
 800deb2:	7813      	ldrb	r3, [r2, #0]
 800deb4:	f043 0320 	orr.w	r3, r3, #32
 800deb8:	7013      	strb	r3, [r2, #0]
 800deba:	e0ba      	b.n	800e032 <tcp_receive+0x696>
 800debc:	240142e8 	.word	0x240142e8
 800dec0:	24014314 	.word	0x24014314
 800dec4:	08017064 	.word	0x08017064
 800dec8:	080171d4 	.word	0x080171d4
 800decc:	08015744 	.word	0x08015744
 800ded0:	080171e4 	.word	0x080171e4
 800ded4:	080171f4 	.word	0x080171f4
 800ded8:	24014300 	.word	0x24014300
 800dedc:	240142f6 	.word	0x240142f6
 800dee0:	08017204 	.word	0x08017204
 800dee4:	240142f0 	.word	0x240142f0
 800dee8:	240142f4 	.word	0x240142f4
                tcplen = TCP_TCPLEN(&inseg);
 800deec:	2300      	movs	r3, #0
 800deee:	443b      	add	r3, r7
 800def0:	4a9e      	ldr	r2, [pc, #632]	@ (800e16c <tcp_receive+0x7d0>)
 800def2:	8013      	strh	r3, [r2, #0]
              next = next->next;
 800def4:	682e      	ldr	r6, [r5, #0]
              tcp_seg_free(tmp);
 800def6:	4628      	mov	r0, r5
 800def8:	f7fe fb4e 	bl	800c598 <tcp_seg_free>
              next = next->next;
 800defc:	4635      	mov	r5, r6
            while (next &&
 800defe:	b365      	cbz	r5, 800df5a <tcp_receive+0x5be>
                   TCP_SEQ_GEQ(seqno + tcplen,
 800df00:	4b9a      	ldr	r3, [pc, #616]	@ (800e16c <tcp_receive+0x7d0>)
 800df02:	881b      	ldrh	r3, [r3, #0]
 800df04:	4a9a      	ldr	r2, [pc, #616]	@ (800e170 <tcp_receive+0x7d4>)
 800df06:	6812      	ldr	r2, [r2, #0]
 800df08:	4413      	add	r3, r2
 800df0a:	6929      	ldr	r1, [r5, #16]
 800df0c:	684a      	ldr	r2, [r1, #4]
 800df0e:	8928      	ldrh	r0, [r5, #8]
 800df10:	4402      	add	r2, r0
 800df12:	1a9b      	subs	r3, r3, r2
            while (next &&
 800df14:	2b00      	cmp	r3, #0
 800df16:	db20      	blt.n	800df5a <tcp_receive+0x5be>
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
 800df18:	8988      	ldrh	r0, [r1, #12]
 800df1a:	f7fc fe21 	bl	800ab60 <lwip_htons>
 800df1e:	f010 0f01 	tst.w	r0, #1
 800df22:	d0e7      	beq.n	800def4 <tcp_receive+0x558>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
 800df24:	4b93      	ldr	r3, [pc, #588]	@ (800e174 <tcp_receive+0x7d8>)
 800df26:	691b      	ldr	r3, [r3, #16]
 800df28:	8998      	ldrh	r0, [r3, #12]
 800df2a:	f7fc fe19 	bl	800ab60 <lwip_htons>
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
 800df2e:	f010 0f02 	tst.w	r0, #2
 800df32:	d1df      	bne.n	800def4 <tcp_receive+0x558>
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
 800df34:	4e8f      	ldr	r6, [pc, #572]	@ (800e174 <tcp_receive+0x7d8>)
 800df36:	6933      	ldr	r3, [r6, #16]
 800df38:	899f      	ldrh	r7, [r3, #12]
 800df3a:	2001      	movs	r0, #1
 800df3c:	f7fc fe10 	bl	800ab60 <lwip_htons>
 800df40:	6933      	ldr	r3, [r6, #16]
 800df42:	4307      	orrs	r7, r0
 800df44:	819f      	strh	r7, [r3, #12]
                tcplen = TCP_TCPLEN(&inseg);
 800df46:	8937      	ldrh	r7, [r6, #8]
 800df48:	6933      	ldr	r3, [r6, #16]
 800df4a:	8998      	ldrh	r0, [r3, #12]
 800df4c:	f7fc fe08 	bl	800ab60 <lwip_htons>
 800df50:	f010 0f03 	tst.w	r0, #3
 800df54:	d0ca      	beq.n	800deec <tcp_receive+0x550>
 800df56:	2301      	movs	r3, #1
 800df58:	e7c9      	b.n	800deee <tcp_receive+0x552>
            if (next &&
 800df5a:	b14d      	cbz	r5, 800df70 <tcp_receive+0x5d4>
                TCP_SEQ_GT(seqno + tcplen,
 800df5c:	4b84      	ldr	r3, [pc, #528]	@ (800e170 <tcp_receive+0x7d4>)
 800df5e:	6819      	ldr	r1, [r3, #0]
 800df60:	4b82      	ldr	r3, [pc, #520]	@ (800e16c <tcp_receive+0x7d0>)
 800df62:	881b      	ldrh	r3, [r3, #0]
 800df64:	440b      	add	r3, r1
 800df66:	692a      	ldr	r2, [r5, #16]
 800df68:	6852      	ldr	r2, [r2, #4]
 800df6a:	1a9b      	subs	r3, r3, r2
            if (next &&
 800df6c:	2b00      	cmp	r3, #0
 800df6e:	dc01      	bgt.n	800df74 <tcp_receive+0x5d8>
            pcb->ooseq = next;
 800df70:	6765      	str	r5, [r4, #116]	@ 0x74
 800df72:	e779      	b.n	800de68 <tcp_receive+0x4cc>
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
 800df74:	1a52      	subs	r2, r2, r1
 800df76:	4b7f      	ldr	r3, [pc, #508]	@ (800e174 <tcp_receive+0x7d8>)
 800df78:	811a      	strh	r2, [r3, #8]
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 800df7a:	691b      	ldr	r3, [r3, #16]
 800df7c:	8998      	ldrh	r0, [r3, #12]
 800df7e:	f7fc fdef 	bl	800ab60 <lwip_htons>
 800df82:	f010 0f02 	tst.w	r0, #2
 800df86:	d003      	beq.n	800df90 <tcp_receive+0x5f4>
                inseg.len -= 1;
 800df88:	4a7a      	ldr	r2, [pc, #488]	@ (800e174 <tcp_receive+0x7d8>)
 800df8a:	8913      	ldrh	r3, [r2, #8]
 800df8c:	3b01      	subs	r3, #1
 800df8e:	8113      	strh	r3, [r2, #8]
              pbuf_realloc(inseg.p, inseg.len);
 800df90:	4e78      	ldr	r6, [pc, #480]	@ (800e174 <tcp_receive+0x7d8>)
 800df92:	8931      	ldrh	r1, [r6, #8]
 800df94:	6870      	ldr	r0, [r6, #4]
 800df96:	f7fd fedf 	bl	800bd58 <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
 800df9a:	8937      	ldrh	r7, [r6, #8]
 800df9c:	6933      	ldr	r3, [r6, #16]
 800df9e:	8998      	ldrh	r0, [r3, #12]
 800dfa0:	f7fc fdde 	bl	800ab60 <lwip_htons>
 800dfa4:	f010 0f03 	tst.w	r0, #3
 800dfa8:	d013      	beq.n	800dfd2 <tcp_receive+0x636>
 800dfaa:	2301      	movs	r3, #1
 800dfac:	443b      	add	r3, r7
 800dfae:	b29b      	uxth	r3, r3
 800dfb0:	4a6e      	ldr	r2, [pc, #440]	@ (800e16c <tcp_receive+0x7d0>)
 800dfb2:	8013      	strh	r3, [r2, #0]
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
 800dfb4:	4a6e      	ldr	r2, [pc, #440]	@ (800e170 <tcp_receive+0x7d4>)
 800dfb6:	6812      	ldr	r2, [r2, #0]
 800dfb8:	4413      	add	r3, r2
 800dfba:	692a      	ldr	r2, [r5, #16]
 800dfbc:	6852      	ldr	r2, [r2, #4]
 800dfbe:	4293      	cmp	r3, r2
 800dfc0:	d0d6      	beq.n	800df70 <tcp_receive+0x5d4>
 800dfc2:	4b6d      	ldr	r3, [pc, #436]	@ (800e178 <tcp_receive+0x7dc>)
 800dfc4:	f240 52fc 	movw	r2, #1532	@ 0x5fc
 800dfc8:	496c      	ldr	r1, [pc, #432]	@ (800e17c <tcp_receive+0x7e0>)
 800dfca:	486d      	ldr	r0, [pc, #436]	@ (800e180 <tcp_receive+0x7e4>)
 800dfcc:	f005 ffd8 	bl	8013f80 <iprintf>
 800dfd0:	e7ce      	b.n	800df70 <tcp_receive+0x5d4>
              tcplen = TCP_TCPLEN(&inseg);
 800dfd2:	2300      	movs	r3, #0
 800dfd4:	e7ea      	b.n	800dfac <tcp_receive+0x610>
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
 800dfd6:	4b68      	ldr	r3, [pc, #416]	@ (800e178 <tcp_receive+0x7dc>)
 800dfd8:	f240 6207 	movw	r2, #1543	@ 0x607
 800dfdc:	4969      	ldr	r1, [pc, #420]	@ (800e184 <tcp_receive+0x7e8>)
 800dfde:	4868      	ldr	r0, [pc, #416]	@ (800e180 <tcp_receive+0x7e4>)
 800dfe0:	f005 ffce 	bl	8013f80 <iprintf>
 800dfe4:	e74a      	b.n	800de7c <tcp_receive+0x4e0>
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
 800dfe6:	2200      	movs	r2, #0
 800dfe8:	e035      	b.n	800e056 <tcp_receive+0x6ba>
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
 800dfea:	2300      	movs	r3, #0
 800dfec:	e041      	b.n	800e072 <tcp_receive+0x6d6>
 800dfee:	4b62      	ldr	r3, [pc, #392]	@ (800e178 <tcp_receive+0x7dc>)
 800dff0:	f240 622b 	movw	r2, #1579	@ 0x62b
 800dff4:	4964      	ldr	r1, [pc, #400]	@ (800e188 <tcp_receive+0x7ec>)
 800dff6:	4862      	ldr	r0, [pc, #392]	@ (800e180 <tcp_receive+0x7e4>)
 800dff8:	f005 ffc2 	bl	8013f80 <iprintf>
 800dffc:	e03c      	b.n	800e078 <tcp_receive+0x6dc>
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
 800dffe:	2200      	movs	r2, #0
 800e000:	e043      	b.n	800e08a <tcp_receive+0x6ee>
              recv_data = cseg->p;
 800e002:	4b62      	ldr	r3, [pc, #392]	@ (800e18c <tcp_receive+0x7f0>)
 800e004:	6019      	str	r1, [r3, #0]
            cseg->p = NULL;
 800e006:	2300      	movs	r3, #0
 800e008:	606b      	str	r3, [r5, #4]
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 800e00a:	692b      	ldr	r3, [r5, #16]
 800e00c:	8998      	ldrh	r0, [r3, #12]
 800e00e:	f7fc fda7 	bl	800ab60 <lwip_htons>
 800e012:	f010 0f01 	tst.w	r0, #1
 800e016:	d007      	beq.n	800e028 <tcp_receive+0x68c>
            recv_flags |= TF_GOT_FIN;
 800e018:	4a5d      	ldr	r2, [pc, #372]	@ (800e190 <tcp_receive+0x7f4>)
 800e01a:	7813      	ldrb	r3, [r2, #0]
 800e01c:	f043 0320 	orr.w	r3, r3, #32
 800e020:	7013      	strb	r3, [r2, #0]
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
 800e022:	7d23      	ldrb	r3, [r4, #20]
 800e024:	2b04      	cmp	r3, #4
 800e026:	d042      	beq.n	800e0ae <tcp_receive+0x712>
          pcb->ooseq = cseg->next;
 800e028:	682b      	ldr	r3, [r5, #0]
 800e02a:	6763      	str	r3, [r4, #116]	@ 0x74
          tcp_seg_free(cseg);
 800e02c:	4628      	mov	r0, r5
 800e02e:	f7fe fab3 	bl	800c598 <tcp_seg_free>
        while (pcb->ooseq != NULL &&
 800e032:	6f65      	ldr	r5, [r4, #116]	@ 0x74
 800e034:	2d00      	cmp	r5, #0
 800e036:	d03d      	beq.n	800e0b4 <tcp_receive+0x718>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
 800e038:	692a      	ldr	r2, [r5, #16]
 800e03a:	6853      	ldr	r3, [r2, #4]
 800e03c:	6a61      	ldr	r1, [r4, #36]	@ 0x24
        while (pcb->ooseq != NULL &&
 800e03e:	428b      	cmp	r3, r1
 800e040:	d138      	bne.n	800e0b4 <tcp_receive+0x718>
          seqno = pcb->ooseq->tcphdr->seqno;
 800e042:	494b      	ldr	r1, [pc, #300]	@ (800e170 <tcp_receive+0x7d4>)
 800e044:	600b      	str	r3, [r1, #0]
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
 800e046:	892e      	ldrh	r6, [r5, #8]
 800e048:	8990      	ldrh	r0, [r2, #12]
 800e04a:	f7fc fd89 	bl	800ab60 <lwip_htons>
 800e04e:	f010 0f03 	tst.w	r0, #3
 800e052:	d0c8      	beq.n	800dfe6 <tcp_receive+0x64a>
 800e054:	2201      	movs	r2, #1
 800e056:	4432      	add	r2, r6
 800e058:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 800e05a:	4413      	add	r3, r2
 800e05c:	6263      	str	r3, [r4, #36]	@ 0x24
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
 800e05e:	8d26      	ldrh	r6, [r4, #40]	@ 0x28
 800e060:	892f      	ldrh	r7, [r5, #8]
 800e062:	692b      	ldr	r3, [r5, #16]
 800e064:	8998      	ldrh	r0, [r3, #12]
 800e066:	f7fc fd7b 	bl	800ab60 <lwip_htons>
 800e06a:	f010 0f03 	tst.w	r0, #3
 800e06e:	d0bc      	beq.n	800dfea <tcp_receive+0x64e>
 800e070:	2301      	movs	r3, #1
 800e072:	443b      	add	r3, r7
 800e074:	429e      	cmp	r6, r3
 800e076:	d3ba      	bcc.n	800dfee <tcp_receive+0x652>
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
 800e078:	892e      	ldrh	r6, [r5, #8]
 800e07a:	692b      	ldr	r3, [r5, #16]
 800e07c:	8998      	ldrh	r0, [r3, #12]
 800e07e:	f7fc fd6f 	bl	800ab60 <lwip_htons>
 800e082:	f010 0f03 	tst.w	r0, #3
 800e086:	d0ba      	beq.n	800dffe <tcp_receive+0x662>
 800e088:	2201      	movs	r2, #1
 800e08a:	4432      	add	r2, r6
 800e08c:	8d23      	ldrh	r3, [r4, #40]	@ 0x28
 800e08e:	1a9b      	subs	r3, r3, r2
 800e090:	8523      	strh	r3, [r4, #40]	@ 0x28
          tcp_update_rcv_ann_wnd(pcb);
 800e092:	4620      	mov	r0, r4
 800e094:	f7fe fa06 	bl	800c4a4 <tcp_update_rcv_ann_wnd>
          if (cseg->p->tot_len > 0) {
 800e098:	6869      	ldr	r1, [r5, #4]
 800e09a:	890b      	ldrh	r3, [r1, #8]
 800e09c:	2b00      	cmp	r3, #0
 800e09e:	d0b4      	beq.n	800e00a <tcp_receive+0x66e>
            if (recv_data) {
 800e0a0:	4b3a      	ldr	r3, [pc, #232]	@ (800e18c <tcp_receive+0x7f0>)
 800e0a2:	6818      	ldr	r0, [r3, #0]
 800e0a4:	2800      	cmp	r0, #0
 800e0a6:	d0ac      	beq.n	800e002 <tcp_receive+0x666>
              pbuf_cat(recv_data, cseg->p);
 800e0a8:	f7fd fed0 	bl	800be4c <pbuf_cat>
 800e0ac:	e7ab      	b.n	800e006 <tcp_receive+0x66a>
              pcb->state = CLOSE_WAIT;
 800e0ae:	2307      	movs	r3, #7
 800e0b0:	7523      	strb	r3, [r4, #20]
 800e0b2:	e7b9      	b.n	800e028 <tcp_receive+0x68c>
        tcp_ack(pcb);
 800e0b4:	8b63      	ldrh	r3, [r4, #26]
 800e0b6:	f013 0f01 	tst.w	r3, #1
 800e0ba:	d007      	beq.n	800e0cc <tcp_receive+0x730>
 800e0bc:	f023 0301 	bic.w	r3, r3, #1
 800e0c0:	b29b      	uxth	r3, r3
 800e0c2:	8363      	strh	r3, [r4, #26]
 800e0c4:	f043 0302 	orr.w	r3, r3, #2
 800e0c8:	8363      	strh	r3, [r4, #26]
 800e0ca:	e0fa      	b.n	800e2c2 <tcp_receive+0x926>
 800e0cc:	f043 0301 	orr.w	r3, r3, #1
 800e0d0:	8363      	strh	r3, [r4, #26]
 800e0d2:	e0f6      	b.n	800e2c2 <tcp_receive+0x926>
          pcb->ooseq = tcp_seg_copy(&inseg);
 800e0d4:	4827      	ldr	r0, [pc, #156]	@ (800e174 <tcp_receive+0x7d8>)
 800e0d6:	f7fe fa77 	bl	800c5c8 <tcp_seg_copy>
 800e0da:	6760      	str	r0, [r4, #116]	@ 0x74
 800e0dc:	e004      	b.n	800e0e8 <tcp_receive+0x74c>
              if (inseg.len > next->len) {
 800e0de:	4b25      	ldr	r3, [pc, #148]	@ (800e174 <tcp_receive+0x7d8>)
 800e0e0:	891a      	ldrh	r2, [r3, #8]
 800e0e2:	892b      	ldrh	r3, [r5, #8]
 800e0e4:	429a      	cmp	r2, r3
 800e0e6:	d803      	bhi.n	800e0f0 <tcp_receive+0x754>
        tcp_send_empty_ack(pcb);
 800e0e8:	4620      	mov	r0, r4
 800e0ea:	f001 ff8f 	bl	801000c <tcp_send_empty_ack>
 800e0ee:	e0e8      	b.n	800e2c2 <tcp_receive+0x926>
                struct tcp_seg *cseg = tcp_seg_copy(&inseg);
 800e0f0:	4820      	ldr	r0, [pc, #128]	@ (800e174 <tcp_receive+0x7d8>)
 800e0f2:	f7fe fa69 	bl	800c5c8 <tcp_seg_copy>
                if (cseg != NULL) {
 800e0f6:	4603      	mov	r3, r0
 800e0f8:	2800      	cmp	r0, #0
 800e0fa:	d0f5      	beq.n	800e0e8 <tcp_receive+0x74c>
                  if (prev != NULL) {
 800e0fc:	b12e      	cbz	r6, 800e10a <tcp_receive+0x76e>
                    prev->next = cseg;
 800e0fe:	6030      	str	r0, [r6, #0]
                  tcp_oos_insert_segment(cseg, next);
 800e100:	4629      	mov	r1, r5
 800e102:	4618      	mov	r0, r3
 800e104:	f7ff fbf6 	bl	800d8f4 <tcp_oos_insert_segment>
 800e108:	e7ee      	b.n	800e0e8 <tcp_receive+0x74c>
                    pcb->ooseq = cseg;
 800e10a:	6760      	str	r0, [r4, #116]	@ 0x74
 800e10c:	e7f8      	b.n	800e100 <tcp_receive+0x764>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
 800e10e:	1a99      	subs	r1, r3, r2
 800e110:	2900      	cmp	r1, #0
 800e112:	db3f      	blt.n	800e194 <tcp_receive+0x7f8>
              if (next->next == NULL &&
 800e114:	6829      	ldr	r1, [r5, #0]
 800e116:	462e      	mov	r6, r5
 800e118:	2900      	cmp	r1, #0
 800e11a:	d04c      	beq.n	800e1b6 <tcp_receive+0x81a>
 800e11c:	460d      	mov	r5, r1
          for (next = pcb->ooseq; next != NULL; next = next->next) {
 800e11e:	2d00      	cmp	r5, #0
 800e120:	d0e2      	beq.n	800e0e8 <tcp_receive+0x74c>
            if (seqno == next->tcphdr->seqno) {
 800e122:	6928      	ldr	r0, [r5, #16]
 800e124:	6842      	ldr	r2, [r0, #4]
 800e126:	4293      	cmp	r3, r2
 800e128:	d0d9      	beq.n	800e0de <tcp_receive+0x742>
              if (prev == NULL) {
 800e12a:	2e00      	cmp	r6, #0
 800e12c:	d0ef      	beq.n	800e10e <tcp_receive+0x772>
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno + 1, next->tcphdr->seqno - 1)) {
 800e12e:	6931      	ldr	r1, [r6, #16]
 800e130:	6849      	ldr	r1, [r1, #4]
 800e132:	1a59      	subs	r1, r3, r1
 800e134:	2901      	cmp	r1, #1
 800e136:	d4ed      	bmi.n	800e114 <tcp_receive+0x778>
 800e138:	1a99      	subs	r1, r3, r2
 800e13a:	3101      	adds	r1, #1
 800e13c:	2900      	cmp	r1, #0
 800e13e:	dce9      	bgt.n	800e114 <tcp_receive+0x778>
                  struct tcp_seg *cseg = tcp_seg_copy(&inseg);
 800e140:	480c      	ldr	r0, [pc, #48]	@ (800e174 <tcp_receive+0x7d8>)
 800e142:	f7fe fa41 	bl	800c5c8 <tcp_seg_copy>
                  if (cseg != NULL) {
 800e146:	4607      	mov	r7, r0
 800e148:	2800      	cmp	r0, #0
 800e14a:	d0cd      	beq.n	800e0e8 <tcp_receive+0x74c>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
 800e14c:	6933      	ldr	r3, [r6, #16]
 800e14e:	6859      	ldr	r1, [r3, #4]
 800e150:	8933      	ldrh	r3, [r6, #8]
 800e152:	440b      	add	r3, r1
 800e154:	4a06      	ldr	r2, [pc, #24]	@ (800e170 <tcp_receive+0x7d4>)
 800e156:	6812      	ldr	r2, [r2, #0]
 800e158:	1a9b      	subs	r3, r3, r2
 800e15a:	2b00      	cmp	r3, #0
 800e15c:	dc24      	bgt.n	800e1a8 <tcp_receive+0x80c>
                    prev->next = cseg;
 800e15e:	6037      	str	r7, [r6, #0]
                    tcp_oos_insert_segment(cseg, next);
 800e160:	4629      	mov	r1, r5
 800e162:	4638      	mov	r0, r7
 800e164:	f7ff fbc6 	bl	800d8f4 <tcp_oos_insert_segment>
 800e168:	e7be      	b.n	800e0e8 <tcp_receive+0x74c>
 800e16a:	bf00      	nop
 800e16c:	240142f6 	.word	0x240142f6
 800e170:	24014300 	.word	0x24014300
 800e174:	24014314 	.word	0x24014314
 800e178:	08017064 	.word	0x08017064
 800e17c:	0801723c 	.word	0x0801723c
 800e180:	08015744 	.word	0x08015744
 800e184:	08017278 	.word	0x08017278
 800e188:	08017298 	.word	0x08017298
 800e18c:	240142f0 	.word	0x240142f0
 800e190:	240142f4 	.word	0x240142f4
                  struct tcp_seg *cseg = tcp_seg_copy(&inseg);
 800e194:	484b      	ldr	r0, [pc, #300]	@ (800e2c4 <tcp_receive+0x928>)
 800e196:	f7fe fa17 	bl	800c5c8 <tcp_seg_copy>
                  if (cseg != NULL) {
 800e19a:	2800      	cmp	r0, #0
 800e19c:	d0a4      	beq.n	800e0e8 <tcp_receive+0x74c>
                    pcb->ooseq = cseg;
 800e19e:	6760      	str	r0, [r4, #116]	@ 0x74
                    tcp_oos_insert_segment(cseg, next);
 800e1a0:	4629      	mov	r1, r5
 800e1a2:	f7ff fba7 	bl	800d8f4 <tcp_oos_insert_segment>
 800e1a6:	e79f      	b.n	800e0e8 <tcp_receive+0x74c>
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
 800e1a8:	1a52      	subs	r2, r2, r1
 800e1aa:	b291      	uxth	r1, r2
 800e1ac:	8131      	strh	r1, [r6, #8]
                      pbuf_realloc(prev->p, prev->len);
 800e1ae:	6870      	ldr	r0, [r6, #4]
 800e1b0:	f7fd fdd2 	bl	800bd58 <pbuf_realloc>
 800e1b4:	e7d3      	b.n	800e15e <tcp_receive+0x7c2>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
 800e1b6:	1a9a      	subs	r2, r3, r2
              if (next->next == NULL &&
 800e1b8:	2a00      	cmp	r2, #0
 800e1ba:	dc01      	bgt.n	800e1c0 <tcp_receive+0x824>
 800e1bc:	460d      	mov	r5, r1
 800e1be:	e7ae      	b.n	800e11e <tcp_receive+0x782>
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 800e1c0:	8980      	ldrh	r0, [r0, #12]
 800e1c2:	f7fc fccd 	bl	800ab60 <lwip_htons>
 800e1c6:	f010 0f01 	tst.w	r0, #1
 800e1ca:	d18d      	bne.n	800e0e8 <tcp_receive+0x74c>
                next->next = tcp_seg_copy(&inseg);
 800e1cc:	483d      	ldr	r0, [pc, #244]	@ (800e2c4 <tcp_receive+0x928>)
 800e1ce:	f7fe f9fb 	bl	800c5c8 <tcp_seg_copy>
 800e1d2:	6028      	str	r0, [r5, #0]
                if (next->next != NULL) {
 800e1d4:	2800      	cmp	r0, #0
 800e1d6:	d087      	beq.n	800e0e8 <tcp_receive+0x74c>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
 800e1d8:	692b      	ldr	r3, [r5, #16]
 800e1da:	6859      	ldr	r1, [r3, #4]
 800e1dc:	892a      	ldrh	r2, [r5, #8]
 800e1de:	440a      	add	r2, r1
 800e1e0:	4b39      	ldr	r3, [pc, #228]	@ (800e2c8 <tcp_receive+0x92c>)
 800e1e2:	681b      	ldr	r3, [r3, #0]
 800e1e4:	1ad2      	subs	r2, r2, r3
 800e1e6:	2a00      	cmp	r2, #0
 800e1e8:	dc40      	bgt.n	800e26c <tcp_receive+0x8d0>
                  if (TCP_SEQ_GT((u32_t)tcplen + seqno, pcb->rcv_nxt + (u32_t)pcb->rcv_wnd)) {
 800e1ea:	4b38      	ldr	r3, [pc, #224]	@ (800e2cc <tcp_receive+0x930>)
 800e1ec:	881b      	ldrh	r3, [r3, #0]
 800e1ee:	4a36      	ldr	r2, [pc, #216]	@ (800e2c8 <tcp_receive+0x92c>)
 800e1f0:	6812      	ldr	r2, [r2, #0]
 800e1f2:	4413      	add	r3, r2
 800e1f4:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 800e1f6:	8d21      	ldrh	r1, [r4, #40]	@ 0x28
 800e1f8:	440a      	add	r2, r1
 800e1fa:	1a9b      	subs	r3, r3, r2
 800e1fc:	2b00      	cmp	r3, #0
 800e1fe:	f77f af73 	ble.w	800e0e8 <tcp_receive+0x74c>
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
 800e202:	682b      	ldr	r3, [r5, #0]
 800e204:	691b      	ldr	r3, [r3, #16]
 800e206:	8998      	ldrh	r0, [r3, #12]
 800e208:	f7fc fcaa 	bl	800ab60 <lwip_htons>
 800e20c:	f010 0f01 	tst.w	r0, #1
 800e210:	d133      	bne.n	800e27a <tcp_receive+0x8de>
                    next->next->len = (u16_t)(pcb->rcv_nxt + pcb->rcv_wnd - seqno);
 800e212:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 800e214:	8d23      	ldrh	r3, [r4, #40]	@ 0x28
 800e216:	4413      	add	r3, r2
 800e218:	b29b      	uxth	r3, r3
 800e21a:	682a      	ldr	r2, [r5, #0]
 800e21c:	492a      	ldr	r1, [pc, #168]	@ (800e2c8 <tcp_receive+0x92c>)
 800e21e:	6809      	ldr	r1, [r1, #0]
 800e220:	1a5b      	subs	r3, r3, r1
 800e222:	8113      	strh	r3, [r2, #8]
                    pbuf_realloc(next->next->p, next->next->len);
 800e224:	682b      	ldr	r3, [r5, #0]
 800e226:	8919      	ldrh	r1, [r3, #8]
 800e228:	6858      	ldr	r0, [r3, #4]
 800e22a:	f7fd fd95 	bl	800bd58 <pbuf_realloc>
                    tcplen = TCP_TCPLEN(next->next);
 800e22e:	682b      	ldr	r3, [r5, #0]
 800e230:	891d      	ldrh	r5, [r3, #8]
 800e232:	691b      	ldr	r3, [r3, #16]
 800e234:	8998      	ldrh	r0, [r3, #12]
 800e236:	f7fc fc93 	bl	800ab60 <lwip_htons>
 800e23a:	f010 0f03 	tst.w	r0, #3
 800e23e:	d02e      	beq.n	800e29e <tcp_receive+0x902>
 800e240:	2301      	movs	r3, #1
 800e242:	442b      	add	r3, r5
 800e244:	b29b      	uxth	r3, r3
 800e246:	4a21      	ldr	r2, [pc, #132]	@ (800e2cc <tcp_receive+0x930>)
 800e248:	8013      	strh	r3, [r2, #0]
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 800e24a:	4a1f      	ldr	r2, [pc, #124]	@ (800e2c8 <tcp_receive+0x92c>)
 800e24c:	6812      	ldr	r2, [r2, #0]
 800e24e:	4413      	add	r3, r2
 800e250:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 800e252:	8d21      	ldrh	r1, [r4, #40]	@ 0x28
 800e254:	440a      	add	r2, r1
 800e256:	4293      	cmp	r3, r2
 800e258:	f43f af46 	beq.w	800e0e8 <tcp_receive+0x74c>
 800e25c:	4b1c      	ldr	r3, [pc, #112]	@ (800e2d0 <tcp_receive+0x934>)
 800e25e:	f44f 62df 	mov.w	r2, #1784	@ 0x6f8
 800e262:	491c      	ldr	r1, [pc, #112]	@ (800e2d4 <tcp_receive+0x938>)
 800e264:	481c      	ldr	r0, [pc, #112]	@ (800e2d8 <tcp_receive+0x93c>)
 800e266:	f005 fe8b 	bl	8013f80 <iprintf>
 800e26a:	e73d      	b.n	800e0e8 <tcp_receive+0x74c>
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
 800e26c:	1a5b      	subs	r3, r3, r1
 800e26e:	b299      	uxth	r1, r3
 800e270:	8129      	strh	r1, [r5, #8]
                    pbuf_realloc(next->p, next->len);
 800e272:	6868      	ldr	r0, [r5, #4]
 800e274:	f7fd fd70 	bl	800bd58 <pbuf_realloc>
 800e278:	e7b7      	b.n	800e1ea <tcp_receive+0x84e>
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) & ~TCP_FIN);
 800e27a:	682b      	ldr	r3, [r5, #0]
 800e27c:	691b      	ldr	r3, [r3, #16]
 800e27e:	899e      	ldrh	r6, [r3, #12]
 800e280:	4630      	mov	r0, r6
 800e282:	f7fc fc6d 	bl	800ab60 <lwip_htons>
 800e286:	f000 003e 	and.w	r0, r0, #62	@ 0x3e
 800e28a:	f7fc fc69 	bl	800ab60 <lwip_htons>
 800e28e:	682b      	ldr	r3, [r5, #0]
 800e290:	691a      	ldr	r2, [r3, #16]
 800e292:	f426 567c 	bic.w	r6, r6, #16128	@ 0x3f00
 800e296:	ea40 0306 	orr.w	r3, r0, r6
 800e29a:	8193      	strh	r3, [r2, #12]
 800e29c:	e7b9      	b.n	800e212 <tcp_receive+0x876>
                    tcplen = TCP_TCPLEN(next->next);
 800e29e:	2300      	movs	r3, #0
 800e2a0:	e7cf      	b.n	800e242 <tcp_receive+0x8a6>
    if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
 800e2a2:	4b09      	ldr	r3, [pc, #36]	@ (800e2c8 <tcp_receive+0x92c>)
 800e2a4:	681b      	ldr	r3, [r3, #0]
 800e2a6:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 800e2a8:	1a99      	subs	r1, r3, r2
 800e2aa:	2900      	cmp	r1, #0
 800e2ac:	db05      	blt.n	800e2ba <tcp_receive+0x91e>
 800e2ae:	8d21      	ldrh	r1, [r4, #40]	@ 0x28
 800e2b0:	440a      	add	r2, r1
 800e2b2:	1a9b      	subs	r3, r3, r2
 800e2b4:	3301      	adds	r3, #1
 800e2b6:	2b00      	cmp	r3, #0
 800e2b8:	dd03      	ble.n	800e2c2 <tcp_receive+0x926>
      tcp_ack_now(pcb);
 800e2ba:	8b63      	ldrh	r3, [r4, #26]
 800e2bc:	f043 0302 	orr.w	r3, r3, #2
 800e2c0:	8363      	strh	r3, [r4, #26]
}
 800e2c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800e2c4:	24014314 	.word	0x24014314
 800e2c8:	24014300 	.word	0x24014300
 800e2cc:	240142f6 	.word	0x240142f6
 800e2d0:	08017064 	.word	0x08017064
 800e2d4:	08017204 	.word	0x08017204
 800e2d8:	08015744 	.word	0x08015744

0800e2dc <tcp_process>:
{
 800e2dc:	b570      	push	{r4, r5, r6, lr}
 800e2de:	b084      	sub	sp, #16
  LWIP_ASSERT("tcp_process: invalid pcb", pcb != NULL);
 800e2e0:	4604      	mov	r4, r0
 800e2e2:	b1c8      	cbz	r0, 800e318 <tcp_process+0x3c>
  if (flags & TCP_RST) {
 800e2e4:	4b99      	ldr	r3, [pc, #612]	@ (800e54c <tcp_process+0x270>)
 800e2e6:	781b      	ldrb	r3, [r3, #0]
 800e2e8:	f013 0f04 	tst.w	r3, #4
 800e2ec:	d03a      	beq.n	800e364 <tcp_process+0x88>
    if (pcb->state == SYN_SENT) {
 800e2ee:	7d21      	ldrb	r1, [r4, #20]
 800e2f0:	2902      	cmp	r1, #2
 800e2f2:	d019      	beq.n	800e328 <tcp_process+0x4c>
      if (seqno == pcb->rcv_nxt) {
 800e2f4:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 800e2f6:	4b96      	ldr	r3, [pc, #600]	@ (800e550 <tcp_process+0x274>)
 800e2f8:	681b      	ldr	r3, [r3, #0]
 800e2fa:	429a      	cmp	r2, r3
 800e2fc:	d01d      	beq.n	800e33a <tcp_process+0x5e>
      } else  if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 800e2fe:	1a99      	subs	r1, r3, r2
 800e300:	2900      	cmp	r1, #0
 800e302:	db16      	blt.n	800e332 <tcp_process+0x56>
 800e304:	8d21      	ldrh	r1, [r4, #40]	@ 0x28
 800e306:	440a      	add	r2, r1
 800e308:	1a9b      	subs	r3, r3, r2
 800e30a:	2b00      	cmp	r3, #0
 800e30c:	dc11      	bgt.n	800e332 <tcp_process+0x56>
        tcp_ack_now(pcb);
 800e30e:	8b63      	ldrh	r3, [r4, #26]
 800e310:	f043 0302 	orr.w	r3, r3, #2
 800e314:	8363      	strh	r3, [r4, #26]
    if (acceptable) {
 800e316:	e00c      	b.n	800e332 <tcp_process+0x56>
  LWIP_ASSERT("tcp_process: invalid pcb", pcb != NULL);
 800e318:	4b8e      	ldr	r3, [pc, #568]	@ (800e554 <tcp_process+0x278>)
 800e31a:	f44f 7247 	mov.w	r2, #796	@ 0x31c
 800e31e:	498e      	ldr	r1, [pc, #568]	@ (800e558 <tcp_process+0x27c>)
 800e320:	488e      	ldr	r0, [pc, #568]	@ (800e55c <tcp_process+0x280>)
 800e322:	f005 fe2d 	bl	8013f80 <iprintf>
 800e326:	e7dd      	b.n	800e2e4 <tcp_process+0x8>
      if (ackno == pcb->snd_nxt) {
 800e328:	6d22      	ldr	r2, [r4, #80]	@ 0x50
 800e32a:	4b8d      	ldr	r3, [pc, #564]	@ (800e560 <tcp_process+0x284>)
 800e32c:	681b      	ldr	r3, [r3, #0]
 800e32e:	429a      	cmp	r2, r3
 800e330:	d003      	beq.n	800e33a <tcp_process+0x5e>
      return ERR_OK;
 800e332:	2500      	movs	r5, #0
}
 800e334:	4628      	mov	r0, r5
 800e336:	b004      	add	sp, #16
 800e338:	bd70      	pop	{r4, r5, r6, pc}
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
 800e33a:	b159      	cbz	r1, 800e354 <tcp_process+0x78>
      recv_flags |= TF_RESET;
 800e33c:	4a89      	ldr	r2, [pc, #548]	@ (800e564 <tcp_process+0x288>)
 800e33e:	7813      	ldrb	r3, [r2, #0]
 800e340:	f043 0308 	orr.w	r3, r3, #8
 800e344:	7013      	strb	r3, [r2, #0]
      tcp_clear_flags(pcb, TF_ACK_DELAY);
 800e346:	8b63      	ldrh	r3, [r4, #26]
 800e348:	f023 0301 	bic.w	r3, r3, #1
 800e34c:	8363      	strh	r3, [r4, #26]
      return ERR_RST;
 800e34e:	f06f 050d 	mvn.w	r5, #13
 800e352:	e7ef      	b.n	800e334 <tcp_process+0x58>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
 800e354:	4b7f      	ldr	r3, [pc, #508]	@ (800e554 <tcp_process+0x278>)
 800e356:	f44f 724e 	mov.w	r2, #824	@ 0x338
 800e35a:	4983      	ldr	r1, [pc, #524]	@ (800e568 <tcp_process+0x28c>)
 800e35c:	487f      	ldr	r0, [pc, #508]	@ (800e55c <tcp_process+0x280>)
 800e35e:	f005 fe0f 	bl	8013f80 <iprintf>
 800e362:	e7eb      	b.n	800e33c <tcp_process+0x60>
  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
 800e364:	f013 0f02 	tst.w	r3, #2
 800e368:	d004      	beq.n	800e374 <tcp_process+0x98>
 800e36a:	7d23      	ldrb	r3, [r4, #20]
 800e36c:	3b02      	subs	r3, #2
 800e36e:	b2db      	uxtb	r3, r3
 800e370:	2b01      	cmp	r3, #1
 800e372:	d81d      	bhi.n	800e3b0 <tcp_process+0xd4>
  if ((pcb->flags & TF_RXCLOSED) == 0) {
 800e374:	8b63      	ldrh	r3, [r4, #26]
 800e376:	f013 0f10 	tst.w	r3, #16
 800e37a:	d102      	bne.n	800e382 <tcp_process+0xa6>
    pcb->tmr = tcp_ticks;
 800e37c:	4b7b      	ldr	r3, [pc, #492]	@ (800e56c <tcp_process+0x290>)
 800e37e:	681b      	ldr	r3, [r3, #0]
 800e380:	6223      	str	r3, [r4, #32]
  pcb->keep_cnt_sent = 0;
 800e382:	2300      	movs	r3, #0
 800e384:	f884 309b 	strb.w	r3, [r4, #155]	@ 0x9b
  pcb->persist_probe = 0;
 800e388:	f884 309a 	strb.w	r3, [r4, #154]	@ 0x9a
  tcp_parseopt(pcb);
 800e38c:	4620      	mov	r0, r4
 800e38e:	f7ff f8c3 	bl	800d518 <tcp_parseopt>
  switch (pcb->state) {
 800e392:	7d23      	ldrb	r3, [r4, #20]
 800e394:	3b02      	subs	r3, #2
 800e396:	2b07      	cmp	r3, #7
 800e398:	f200 8240 	bhi.w	800e81c <tcp_process+0x540>
 800e39c:	e8df f013 	tbh	[pc, r3, lsl #1]
 800e3a0:	00b2000e 	.word	0x00b2000e
 800e3a4:	016a0159 	.word	0x016a0159
 800e3a8:	015901c1 	.word	0x015901c1
 800e3ac:	022401f0 	.word	0x022401f0
    tcp_ack_now(pcb);
 800e3b0:	8b63      	ldrh	r3, [r4, #26]
 800e3b2:	f043 0302 	orr.w	r3, r3, #2
 800e3b6:	8363      	strh	r3, [r4, #26]
    return ERR_OK;
 800e3b8:	2500      	movs	r5, #0
 800e3ba:	e7bb      	b.n	800e334 <tcp_process+0x58>
      if ((flags & TCP_ACK) && (flags & TCP_SYN)
 800e3bc:	4b63      	ldr	r3, [pc, #396]	@ (800e54c <tcp_process+0x270>)
 800e3be:	781b      	ldrb	r3, [r3, #0]
 800e3c0:	f003 0212 	and.w	r2, r3, #18
 800e3c4:	2a12      	cmp	r2, #18
 800e3c6:	d004      	beq.n	800e3d2 <tcp_process+0xf6>
      else if (flags & TCP_ACK) {
 800e3c8:	f013 0f10 	tst.w	r3, #16
 800e3cc:	d17b      	bne.n	800e4c6 <tcp_process+0x1ea>
  return ERR_OK;
 800e3ce:	2500      	movs	r5, #0
 800e3d0:	e7b0      	b.n	800e334 <tcp_process+0x58>
          && (ackno == pcb->lastack + 1)) {
 800e3d2:	6c62      	ldr	r2, [r4, #68]	@ 0x44
 800e3d4:	3201      	adds	r2, #1
 800e3d6:	4962      	ldr	r1, [pc, #392]	@ (800e560 <tcp_process+0x284>)
 800e3d8:	6809      	ldr	r1, [r1, #0]
 800e3da:	428a      	cmp	r2, r1
 800e3dc:	d1f4      	bne.n	800e3c8 <tcp_process+0xec>
        pcb->rcv_nxt = seqno + 1;
 800e3de:	4b5c      	ldr	r3, [pc, #368]	@ (800e550 <tcp_process+0x274>)
 800e3e0:	681b      	ldr	r3, [r3, #0]
 800e3e2:	1c5a      	adds	r2, r3, #1
 800e3e4:	6262      	str	r2, [r4, #36]	@ 0x24
        pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 800e3e6:	62e2      	str	r2, [r4, #44]	@ 0x2c
        pcb->lastack = ackno;
 800e3e8:	6461      	str	r1, [r4, #68]	@ 0x44
        pcb->snd_wnd = tcphdr->wnd;
 800e3ea:	4a61      	ldr	r2, [pc, #388]	@ (800e570 <tcp_process+0x294>)
 800e3ec:	6812      	ldr	r2, [r2, #0]
 800e3ee:	89d2      	ldrh	r2, [r2, #14]
 800e3f0:	f8a4 2060 	strh.w	r2, [r4, #96]	@ 0x60
        pcb->snd_wnd_max = pcb->snd_wnd;
 800e3f4:	f8a4 2062 	strh.w	r2, [r4, #98]	@ 0x62
        pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 800e3f8:	3b01      	subs	r3, #1
 800e3fa:	6563      	str	r3, [r4, #84]	@ 0x54
        pcb->state = ESTABLISHED;
 800e3fc:	2304      	movs	r3, #4
 800e3fe:	7523      	strb	r3, [r4, #20]
        pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
 800e400:	8e66      	ldrh	r6, [r4, #50]	@ 0x32
 800e402:	18e5      	adds	r5, r4, r3
 800e404:	4628      	mov	r0, r5
 800e406:	f003 fef9 	bl	80121fc <ip4_route>
 800e40a:	4601      	mov	r1, r0
 800e40c:	462a      	mov	r2, r5
 800e40e:	4630      	mov	r0, r6
 800e410:	f7fe f99a 	bl	800c748 <tcp_eff_send_mss_netif>
 800e414:	8660      	strh	r0, [r4, #50]	@ 0x32
        pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 800e416:	0042      	lsls	r2, r0, #1
 800e418:	f241 131c 	movw	r3, #4380	@ 0x111c
 800e41c:	4293      	cmp	r3, r2
 800e41e:	bf38      	it	cc
 800e420:	4613      	movcc	r3, r2
 800e422:	ebb3 0f80 	cmp.w	r3, r0, lsl #2
 800e426:	d92b      	bls.n	800e480 <tcp_process+0x1a4>
 800e428:	0083      	lsls	r3, r0, #2
 800e42a:	b29b      	uxth	r3, r3
 800e42c:	f8a4 3048 	strh.w	r3, [r4, #72]	@ 0x48
        LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
 800e430:	f8b4 3066 	ldrh.w	r3, [r4, #102]	@ 0x66
 800e434:	b373      	cbz	r3, 800e494 <tcp_process+0x1b8>
        --pcb->snd_queuelen;
 800e436:	f8b4 3066 	ldrh.w	r3, [r4, #102]	@ 0x66
 800e43a:	3b01      	subs	r3, #1
 800e43c:	f8a4 3066 	strh.w	r3, [r4, #102]	@ 0x66
        rseg = pcb->unacked;
 800e440:	6f25      	ldr	r5, [r4, #112]	@ 0x70
        if (rseg == NULL) {
 800e442:	b37d      	cbz	r5, 800e4a4 <tcp_process+0x1c8>
          pcb->unacked = rseg->next;
 800e444:	682b      	ldr	r3, [r5, #0]
 800e446:	6723      	str	r3, [r4, #112]	@ 0x70
        tcp_seg_free(rseg);
 800e448:	4628      	mov	r0, r5
 800e44a:	f7fe f8a5 	bl	800c598 <tcp_seg_free>
        if (pcb->unacked == NULL) {
 800e44e:	6f23      	ldr	r3, [r4, #112]	@ 0x70
 800e450:	2b00      	cmp	r3, #0
 800e452:	d034      	beq.n	800e4be <tcp_process+0x1e2>
          pcb->rtime = 0;
 800e454:	2300      	movs	r3, #0
 800e456:	8623      	strh	r3, [r4, #48]	@ 0x30
          pcb->nrtx = 0;
 800e458:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
        TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 800e45c:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
 800e460:	b143      	cbz	r3, 800e474 <tcp_process+0x198>
 800e462:	2200      	movs	r2, #0
 800e464:	4621      	mov	r1, r4
 800e466:	6920      	ldr	r0, [r4, #16]
 800e468:	4798      	blx	r3
 800e46a:	4605      	mov	r5, r0
        if (err == ERR_ABRT) {
 800e46c:	f110 0f0d 	cmn.w	r0, #13
 800e470:	f43f af60 	beq.w	800e334 <tcp_process+0x58>
        tcp_ack_now(pcb);
 800e474:	8b63      	ldrh	r3, [r4, #26]
 800e476:	f043 0302 	orr.w	r3, r3, #2
 800e47a:	8363      	strh	r3, [r4, #26]
  return ERR_OK;
 800e47c:	2500      	movs	r5, #0
        tcp_ack_now(pcb);
 800e47e:	e759      	b.n	800e334 <tcp_process+0x58>
        pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 800e480:	f241 131c 	movw	r3, #4380	@ 0x111c
 800e484:	429a      	cmp	r2, r3
 800e486:	d902      	bls.n	800e48e <tcp_process+0x1b2>
 800e488:	0043      	lsls	r3, r0, #1
 800e48a:	b29b      	uxth	r3, r3
 800e48c:	e7ce      	b.n	800e42c <tcp_process+0x150>
 800e48e:	f241 131c 	movw	r3, #4380	@ 0x111c
 800e492:	e7cb      	b.n	800e42c <tcp_process+0x150>
        LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
 800e494:	4b2f      	ldr	r3, [pc, #188]	@ (800e554 <tcp_process+0x278>)
 800e496:	f44f 725b 	mov.w	r2, #876	@ 0x36c
 800e49a:	4936      	ldr	r1, [pc, #216]	@ (800e574 <tcp_process+0x298>)
 800e49c:	482f      	ldr	r0, [pc, #188]	@ (800e55c <tcp_process+0x280>)
 800e49e:	f005 fd6f 	bl	8013f80 <iprintf>
 800e4a2:	e7c8      	b.n	800e436 <tcp_process+0x15a>
          rseg = pcb->unsent;
 800e4a4:	6ee5      	ldr	r5, [r4, #108]	@ 0x6c
          LWIP_ASSERT("no segment to free", rseg != NULL);
 800e4a6:	b115      	cbz	r5, 800e4ae <tcp_process+0x1d2>
          pcb->unsent = rseg->next;
 800e4a8:	682b      	ldr	r3, [r5, #0]
 800e4aa:	66e3      	str	r3, [r4, #108]	@ 0x6c
 800e4ac:	e7cc      	b.n	800e448 <tcp_process+0x16c>
          LWIP_ASSERT("no segment to free", rseg != NULL);
 800e4ae:	4b29      	ldr	r3, [pc, #164]	@ (800e554 <tcp_process+0x278>)
 800e4b0:	f44f 725d 	mov.w	r2, #884	@ 0x374
 800e4b4:	4930      	ldr	r1, [pc, #192]	@ (800e578 <tcp_process+0x29c>)
 800e4b6:	4829      	ldr	r0, [pc, #164]	@ (800e55c <tcp_process+0x280>)
 800e4b8:	f005 fd62 	bl	8013f80 <iprintf>
 800e4bc:	e7f4      	b.n	800e4a8 <tcp_process+0x1cc>
          pcb->rtime = -1;
 800e4be:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 800e4c2:	8623      	strh	r3, [r4, #48]	@ 0x30
 800e4c4:	e7ca      	b.n	800e45c <tcp_process+0x180>
                ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800e4c6:	4b2a      	ldr	r3, [pc, #168]	@ (800e570 <tcp_process+0x294>)
 800e4c8:	6819      	ldr	r1, [r3, #0]
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800e4ca:	4b2c      	ldr	r3, [pc, #176]	@ (800e57c <tcp_process+0x2a0>)
 800e4cc:	4a2c      	ldr	r2, [pc, #176]	@ (800e580 <tcp_process+0x2a4>)
 800e4ce:	8810      	ldrh	r0, [r2, #0]
 800e4d0:	4a1f      	ldr	r2, [pc, #124]	@ (800e550 <tcp_process+0x274>)
 800e4d2:	6812      	ldr	r2, [r2, #0]
 800e4d4:	880d      	ldrh	r5, [r1, #0]
 800e4d6:	9502      	str	r5, [sp, #8]
 800e4d8:	8849      	ldrh	r1, [r1, #2]
 800e4da:	9101      	str	r1, [sp, #4]
 800e4dc:	1f19      	subs	r1, r3, #4
 800e4de:	9100      	str	r1, [sp, #0]
 800e4e0:	4402      	add	r2, r0
 800e4e2:	491f      	ldr	r1, [pc, #124]	@ (800e560 <tcp_process+0x284>)
 800e4e4:	6809      	ldr	r1, [r1, #0]
 800e4e6:	4620      	mov	r0, r4
 800e4e8:	f001 fd48 	bl	800ff7c <tcp_rst>
        if (pcb->nrtx < TCP_SYNMAXRTX) {
 800e4ec:	f894 3042 	ldrb.w	r3, [r4, #66]	@ 0x42
 800e4f0:	2b05      	cmp	r3, #5
 800e4f2:	d901      	bls.n	800e4f8 <tcp_process+0x21c>
  return ERR_OK;
 800e4f4:	2500      	movs	r5, #0
 800e4f6:	e71d      	b.n	800e334 <tcp_process+0x58>
          pcb->rtime = 0;
 800e4f8:	2500      	movs	r5, #0
 800e4fa:	8625      	strh	r5, [r4, #48]	@ 0x30
          tcp_rexmit_rto(pcb);
 800e4fc:	4620      	mov	r0, r4
 800e4fe:	f001 ff29 	bl	8010354 <tcp_rexmit_rto>
 800e502:	e717      	b.n	800e334 <tcp_process+0x58>
      if (flags & TCP_ACK) {
 800e504:	4b11      	ldr	r3, [pc, #68]	@ (800e54c <tcp_process+0x270>)
 800e506:	781b      	ldrb	r3, [r3, #0]
 800e508:	f013 0f10 	tst.w	r3, #16
 800e50c:	f000 8090 	beq.w	800e630 <tcp_process+0x354>
        if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 800e510:	4b13      	ldr	r3, [pc, #76]	@ (800e560 <tcp_process+0x284>)
 800e512:	6819      	ldr	r1, [r3, #0]
 800e514:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 800e516:	1acb      	subs	r3, r1, r3
 800e518:	2b01      	cmp	r3, #1
 800e51a:	d403      	bmi.n	800e524 <tcp_process+0x248>
 800e51c:	6d23      	ldr	r3, [r4, #80]	@ 0x50
 800e51e:	1acb      	subs	r3, r1, r3
 800e520:	2b00      	cmp	r3, #0
 800e522:	dd2f      	ble.n	800e584 <tcp_process+0x2a8>
                  ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800e524:	4b12      	ldr	r3, [pc, #72]	@ (800e570 <tcp_process+0x294>)
 800e526:	6818      	ldr	r0, [r3, #0]
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800e528:	4b14      	ldr	r3, [pc, #80]	@ (800e57c <tcp_process+0x2a0>)
 800e52a:	4a15      	ldr	r2, [pc, #84]	@ (800e580 <tcp_process+0x2a4>)
 800e52c:	8815      	ldrh	r5, [r2, #0]
 800e52e:	4a08      	ldr	r2, [pc, #32]	@ (800e550 <tcp_process+0x274>)
 800e530:	6812      	ldr	r2, [r2, #0]
 800e532:	8806      	ldrh	r6, [r0, #0]
 800e534:	9602      	str	r6, [sp, #8]
 800e536:	8840      	ldrh	r0, [r0, #2]
 800e538:	9001      	str	r0, [sp, #4]
 800e53a:	1f18      	subs	r0, r3, #4
 800e53c:	9000      	str	r0, [sp, #0]
 800e53e:	442a      	add	r2, r5
 800e540:	4620      	mov	r0, r4
 800e542:	f001 fd1b 	bl	800ff7c <tcp_rst>
  return ERR_OK;
 800e546:	2500      	movs	r5, #0
 800e548:	e6f4      	b.n	800e334 <tcp_process+0x58>
 800e54a:	bf00      	nop
 800e54c:	240142f5 	.word	0x240142f5
 800e550:	24014300 	.word	0x24014300
 800e554:	08017064 	.word	0x08017064
 800e558:	080172c0 	.word	0x080172c0
 800e55c:	08015744 	.word	0x08015744
 800e560:	240142fc 	.word	0x240142fc
 800e564:	240142f4 	.word	0x240142f4
 800e568:	080172dc 	.word	0x080172dc
 800e56c:	240142e8 	.word	0x240142e8
 800e570:	24014310 	.word	0x24014310
 800e574:	080172fc 	.word	0x080172fc
 800e578:	08017314 	.word	0x08017314
 800e57c:	2400c4c4 	.word	0x2400c4c4
 800e580:	240142f6 	.word	0x240142f6
          pcb->state = ESTABLISHED;
 800e584:	2304      	movs	r3, #4
 800e586:	7523      	strb	r3, [r4, #20]
          if (pcb->listener == NULL) {
 800e588:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
 800e58a:	2b00      	cmp	r3, #0
 800e58c:	d037      	beq.n	800e5fe <tcp_process+0x322>
            LWIP_ASSERT("pcb->listener->accept != NULL", pcb->listener->accept != NULL);
 800e58e:	699b      	ldr	r3, [r3, #24]
 800e590:	b36b      	cbz	r3, 800e5ee <tcp_process+0x312>
            TCP_EVENT_ACCEPT(pcb->listener, pcb, pcb->callback_arg, ERR_OK, err);
 800e592:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
 800e594:	699b      	ldr	r3, [r3, #24]
 800e596:	2b00      	cmp	r3, #0
 800e598:	d039      	beq.n	800e60e <tcp_process+0x332>
 800e59a:	2200      	movs	r2, #0
 800e59c:	4621      	mov	r1, r4
 800e59e:	6920      	ldr	r0, [r4, #16]
 800e5a0:	4798      	blx	r3
          if (err != ERR_OK) {
 800e5a2:	4605      	mov	r5, r0
 800e5a4:	bb68      	cbnz	r0, 800e602 <tcp_process+0x326>
          tcp_receive(pcb);
 800e5a6:	4620      	mov	r0, r4
 800e5a8:	f7ff f9f8 	bl	800d99c <tcp_receive>
          if (recv_acked != 0) {
 800e5ac:	4b9c      	ldr	r3, [pc, #624]	@ (800e820 <tcp_process+0x544>)
 800e5ae:	881b      	ldrh	r3, [r3, #0]
 800e5b0:	b113      	cbz	r3, 800e5b8 <tcp_process+0x2dc>
            recv_acked--;
 800e5b2:	3b01      	subs	r3, #1
 800e5b4:	4a9a      	ldr	r2, [pc, #616]	@ (800e820 <tcp_process+0x544>)
 800e5b6:	8013      	strh	r3, [r2, #0]
          pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 800e5b8:	8e63      	ldrh	r3, [r4, #50]	@ 0x32
 800e5ba:	0059      	lsls	r1, r3, #1
 800e5bc:	f241 121c 	movw	r2, #4380	@ 0x111c
 800e5c0:	428a      	cmp	r2, r1
 800e5c2:	bf38      	it	cc
 800e5c4:	460a      	movcc	r2, r1
 800e5c6:	ebb2 0f83 	cmp.w	r2, r3, lsl #2
 800e5ca:	d927      	bls.n	800e61c <tcp_process+0x340>
 800e5cc:	009b      	lsls	r3, r3, #2
 800e5ce:	b29b      	uxth	r3, r3
 800e5d0:	f8a4 3048 	strh.w	r3, [r4, #72]	@ 0x48
          if (recv_flags & TF_GOT_FIN) {
 800e5d4:	4b93      	ldr	r3, [pc, #588]	@ (800e824 <tcp_process+0x548>)
 800e5d6:	781b      	ldrb	r3, [r3, #0]
 800e5d8:	f013 0f20 	tst.w	r3, #32
 800e5dc:	f43f aeaa 	beq.w	800e334 <tcp_process+0x58>
            tcp_ack_now(pcb);
 800e5e0:	8b63      	ldrh	r3, [r4, #26]
 800e5e2:	f043 0302 	orr.w	r3, r3, #2
 800e5e6:	8363      	strh	r3, [r4, #26]
            pcb->state = CLOSE_WAIT;
 800e5e8:	2307      	movs	r3, #7
 800e5ea:	7523      	strb	r3, [r4, #20]
 800e5ec:	e6a2      	b.n	800e334 <tcp_process+0x58>
            LWIP_ASSERT("pcb->listener->accept != NULL", pcb->listener->accept != NULL);
 800e5ee:	4b8e      	ldr	r3, [pc, #568]	@ (800e828 <tcp_process+0x54c>)
 800e5f0:	f44f 726a 	mov.w	r2, #936	@ 0x3a8
 800e5f4:	498d      	ldr	r1, [pc, #564]	@ (800e82c <tcp_process+0x550>)
 800e5f6:	488e      	ldr	r0, [pc, #568]	@ (800e830 <tcp_process+0x554>)
 800e5f8:	f005 fcc2 	bl	8013f80 <iprintf>
 800e5fc:	e7c9      	b.n	800e592 <tcp_process+0x2b6>
            err = ERR_VAL;
 800e5fe:	f06f 0505 	mvn.w	r5, #5
            if (err != ERR_ABRT) {
 800e602:	f115 0f0d 	cmn.w	r5, #13
 800e606:	d105      	bne.n	800e614 <tcp_process+0x338>
            return ERR_ABRT;
 800e608:	f06f 050c 	mvn.w	r5, #12
 800e60c:	e692      	b.n	800e334 <tcp_process+0x58>
            TCP_EVENT_ACCEPT(pcb->listener, pcb, pcb->callback_arg, ERR_OK, err);
 800e60e:	f06f 050f 	mvn.w	r5, #15
 800e612:	e7f6      	b.n	800e602 <tcp_process+0x326>
              tcp_abort(pcb);
 800e614:	4620      	mov	r0, r4
 800e616:	f7fe f9e1 	bl	800c9dc <tcp_abort>
 800e61a:	e7f5      	b.n	800e608 <tcp_process+0x32c>
          pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 800e61c:	f241 121c 	movw	r2, #4380	@ 0x111c
 800e620:	4291      	cmp	r1, r2
 800e622:	d902      	bls.n	800e62a <tcp_process+0x34e>
 800e624:	005b      	lsls	r3, r3, #1
 800e626:	b29b      	uxth	r3, r3
 800e628:	e7d2      	b.n	800e5d0 <tcp_process+0x2f4>
 800e62a:	f241 131c 	movw	r3, #4380	@ 0x111c
 800e62e:	e7cf      	b.n	800e5d0 <tcp_process+0x2f4>
      } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
 800e630:	f013 0f02 	tst.w	r3, #2
 800e634:	f000 810a 	beq.w	800e84c <tcp_process+0x570>
 800e638:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 800e63a:	3b01      	subs	r3, #1
 800e63c:	4a7d      	ldr	r2, [pc, #500]	@ (800e834 <tcp_process+0x558>)
 800e63e:	6812      	ldr	r2, [r2, #0]
 800e640:	4293      	cmp	r3, r2
 800e642:	d001      	beq.n	800e648 <tcp_process+0x36c>
  return ERR_OK;
 800e644:	2500      	movs	r5, #0
 800e646:	e675      	b.n	800e334 <tcp_process+0x58>
        tcp_rexmit(pcb);
 800e648:	4620      	mov	r0, r4
 800e64a:	f001 fc15 	bl	800fe78 <tcp_rexmit>
  return ERR_OK;
 800e64e:	2500      	movs	r5, #0
 800e650:	e670      	b.n	800e334 <tcp_process+0x58>
      tcp_receive(pcb);
 800e652:	4620      	mov	r0, r4
 800e654:	f7ff f9a2 	bl	800d99c <tcp_receive>
      if (recv_flags & TF_GOT_FIN) { /* passive close */
 800e658:	4b72      	ldr	r3, [pc, #456]	@ (800e824 <tcp_process+0x548>)
 800e65a:	781b      	ldrb	r3, [r3, #0]
 800e65c:	f013 0f20 	tst.w	r3, #32
 800e660:	f000 80f6 	beq.w	800e850 <tcp_process+0x574>
        tcp_ack_now(pcb);
 800e664:	8b63      	ldrh	r3, [r4, #26]
 800e666:	f043 0302 	orr.w	r3, r3, #2
 800e66a:	8363      	strh	r3, [r4, #26]
        pcb->state = CLOSE_WAIT;
 800e66c:	2307      	movs	r3, #7
 800e66e:	7523      	strb	r3, [r4, #20]
  return ERR_OK;
 800e670:	2500      	movs	r5, #0
 800e672:	e65f      	b.n	800e334 <tcp_process+0x58>
      tcp_receive(pcb);
 800e674:	4620      	mov	r0, r4
 800e676:	f7ff f991 	bl	800d99c <tcp_receive>
      if (recv_flags & TF_GOT_FIN) {
 800e67a:	4b6a      	ldr	r3, [pc, #424]	@ (800e824 <tcp_process+0x548>)
 800e67c:	781b      	ldrb	r3, [r3, #0]
 800e67e:	f013 0f20 	tst.w	r3, #32
 800e682:	d039      	beq.n	800e6f8 <tcp_process+0x41c>
        if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 800e684:	4b6c      	ldr	r3, [pc, #432]	@ (800e838 <tcp_process+0x55c>)
 800e686:	781b      	ldrb	r3, [r3, #0]
 800e688:	f013 0f10 	tst.w	r3, #16
 800e68c:	d004      	beq.n	800e698 <tcp_process+0x3bc>
 800e68e:	6d22      	ldr	r2, [r4, #80]	@ 0x50
 800e690:	4b6a      	ldr	r3, [pc, #424]	@ (800e83c <tcp_process+0x560>)
 800e692:	681b      	ldr	r3, [r3, #0]
 800e694:	429a      	cmp	r2, r3
 800e696:	d007      	beq.n	800e6a8 <tcp_process+0x3cc>
          tcp_ack_now(pcb);
 800e698:	8b63      	ldrh	r3, [r4, #26]
 800e69a:	f043 0302 	orr.w	r3, r3, #2
 800e69e:	8363      	strh	r3, [r4, #26]
          pcb->state = CLOSING;
 800e6a0:	2308      	movs	r3, #8
 800e6a2:	7523      	strb	r3, [r4, #20]
  return ERR_OK;
 800e6a4:	2500      	movs	r5, #0
 800e6a6:	e645      	b.n	800e334 <tcp_process+0x58>
            pcb->unsent == NULL) {
 800e6a8:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
        if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 800e6aa:	2b00      	cmp	r3, #0
 800e6ac:	d1f4      	bne.n	800e698 <tcp_process+0x3bc>
          tcp_ack_now(pcb);
 800e6ae:	8b63      	ldrh	r3, [r4, #26]
 800e6b0:	f043 0302 	orr.w	r3, r3, #2
 800e6b4:	8363      	strh	r3, [r4, #26]
          tcp_pcb_purge(pcb);
 800e6b6:	4620      	mov	r0, r4
 800e6b8:	f7fe f870 	bl	800c79c <tcp_pcb_purge>
          TCP_RMV_ACTIVE(pcb);
 800e6bc:	4b60      	ldr	r3, [pc, #384]	@ (800e840 <tcp_process+0x564>)
 800e6be:	681b      	ldr	r3, [r3, #0]
 800e6c0:	429c      	cmp	r4, r3
 800e6c2:	d005      	beq.n	800e6d0 <tcp_process+0x3f4>
 800e6c4:	b153      	cbz	r3, 800e6dc <tcp_process+0x400>
 800e6c6:	68da      	ldr	r2, [r3, #12]
 800e6c8:	4294      	cmp	r4, r2
 800e6ca:	d005      	beq.n	800e6d8 <tcp_process+0x3fc>
 800e6cc:	4613      	mov	r3, r2
 800e6ce:	e7f9      	b.n	800e6c4 <tcp_process+0x3e8>
 800e6d0:	68da      	ldr	r2, [r3, #12]
 800e6d2:	4b5b      	ldr	r3, [pc, #364]	@ (800e840 <tcp_process+0x564>)
 800e6d4:	601a      	str	r2, [r3, #0]
 800e6d6:	e001      	b.n	800e6dc <tcp_process+0x400>
 800e6d8:	68e2      	ldr	r2, [r4, #12]
 800e6da:	60da      	str	r2, [r3, #12]
 800e6dc:	2500      	movs	r5, #0
 800e6de:	60e5      	str	r5, [r4, #12]
 800e6e0:	4b58      	ldr	r3, [pc, #352]	@ (800e844 <tcp_process+0x568>)
 800e6e2:	2201      	movs	r2, #1
 800e6e4:	701a      	strb	r2, [r3, #0]
          pcb->state = TIME_WAIT;
 800e6e6:	230a      	movs	r3, #10
 800e6e8:	7523      	strb	r3, [r4, #20]
          TCP_REG(&tcp_tw_pcbs, pcb);
 800e6ea:	4b57      	ldr	r3, [pc, #348]	@ (800e848 <tcp_process+0x56c>)
 800e6ec:	681a      	ldr	r2, [r3, #0]
 800e6ee:	60e2      	str	r2, [r4, #12]
 800e6f0:	601c      	str	r4, [r3, #0]
 800e6f2:	f001 ff5b 	bl	80105ac <tcp_timer_needed>
 800e6f6:	e61d      	b.n	800e334 <tcp_process+0x58>
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 800e6f8:	4b4f      	ldr	r3, [pc, #316]	@ (800e838 <tcp_process+0x55c>)
 800e6fa:	781b      	ldrb	r3, [r3, #0]
 800e6fc:	f013 0f10 	tst.w	r3, #16
 800e700:	f000 80a8 	beq.w	800e854 <tcp_process+0x578>
 800e704:	6d22      	ldr	r2, [r4, #80]	@ 0x50
 800e706:	4b4d      	ldr	r3, [pc, #308]	@ (800e83c <tcp_process+0x560>)
 800e708:	681b      	ldr	r3, [r3, #0]
 800e70a:	429a      	cmp	r2, r3
 800e70c:	d001      	beq.n	800e712 <tcp_process+0x436>
  return ERR_OK;
 800e70e:	2500      	movs	r5, #0
 800e710:	e610      	b.n	800e334 <tcp_process+0x58>
                 pcb->unsent == NULL) {
 800e712:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 800e714:	b10b      	cbz	r3, 800e71a <tcp_process+0x43e>
  return ERR_OK;
 800e716:	2500      	movs	r5, #0
 800e718:	e60c      	b.n	800e334 <tcp_process+0x58>
        pcb->state = FIN_WAIT_2;
 800e71a:	2306      	movs	r3, #6
 800e71c:	7523      	strb	r3, [r4, #20]
  return ERR_OK;
 800e71e:	2500      	movs	r5, #0
 800e720:	e608      	b.n	800e334 <tcp_process+0x58>
      tcp_receive(pcb);
 800e722:	4620      	mov	r0, r4
 800e724:	f7ff f93a 	bl	800d99c <tcp_receive>
      if (recv_flags & TF_GOT_FIN) {
 800e728:	4b3e      	ldr	r3, [pc, #248]	@ (800e824 <tcp_process+0x548>)
 800e72a:	781b      	ldrb	r3, [r3, #0]
 800e72c:	f013 0f20 	tst.w	r3, #32
 800e730:	d101      	bne.n	800e736 <tcp_process+0x45a>
  return ERR_OK;
 800e732:	2500      	movs	r5, #0
 800e734:	e5fe      	b.n	800e334 <tcp_process+0x58>
        tcp_ack_now(pcb);
 800e736:	8b63      	ldrh	r3, [r4, #26]
 800e738:	f043 0302 	orr.w	r3, r3, #2
 800e73c:	8363      	strh	r3, [r4, #26]
        tcp_pcb_purge(pcb);
 800e73e:	4620      	mov	r0, r4
 800e740:	f7fe f82c 	bl	800c79c <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 800e744:	4b3e      	ldr	r3, [pc, #248]	@ (800e840 <tcp_process+0x564>)
 800e746:	681b      	ldr	r3, [r3, #0]
 800e748:	429c      	cmp	r4, r3
 800e74a:	d005      	beq.n	800e758 <tcp_process+0x47c>
 800e74c:	b153      	cbz	r3, 800e764 <tcp_process+0x488>
 800e74e:	68da      	ldr	r2, [r3, #12]
 800e750:	4294      	cmp	r4, r2
 800e752:	d005      	beq.n	800e760 <tcp_process+0x484>
 800e754:	4613      	mov	r3, r2
 800e756:	e7f9      	b.n	800e74c <tcp_process+0x470>
 800e758:	68da      	ldr	r2, [r3, #12]
 800e75a:	4b39      	ldr	r3, [pc, #228]	@ (800e840 <tcp_process+0x564>)
 800e75c:	601a      	str	r2, [r3, #0]
 800e75e:	e001      	b.n	800e764 <tcp_process+0x488>
 800e760:	68e2      	ldr	r2, [r4, #12]
 800e762:	60da      	str	r2, [r3, #12]
 800e764:	2500      	movs	r5, #0
 800e766:	60e5      	str	r5, [r4, #12]
 800e768:	4b36      	ldr	r3, [pc, #216]	@ (800e844 <tcp_process+0x568>)
 800e76a:	2201      	movs	r2, #1
 800e76c:	701a      	strb	r2, [r3, #0]
        pcb->state = TIME_WAIT;
 800e76e:	230a      	movs	r3, #10
 800e770:	7523      	strb	r3, [r4, #20]
        TCP_REG(&tcp_tw_pcbs, pcb);
 800e772:	4b35      	ldr	r3, [pc, #212]	@ (800e848 <tcp_process+0x56c>)
 800e774:	681a      	ldr	r2, [r3, #0]
 800e776:	60e2      	str	r2, [r4, #12]
 800e778:	601c      	str	r4, [r3, #0]
 800e77a:	f001 ff17 	bl	80105ac <tcp_timer_needed>
 800e77e:	e5d9      	b.n	800e334 <tcp_process+0x58>
      tcp_receive(pcb);
 800e780:	4620      	mov	r0, r4
 800e782:	f7ff f90b 	bl	800d99c <tcp_receive>
      if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 800e786:	4b2c      	ldr	r3, [pc, #176]	@ (800e838 <tcp_process+0x55c>)
 800e788:	781b      	ldrb	r3, [r3, #0]
 800e78a:	f013 0f10 	tst.w	r3, #16
 800e78e:	d063      	beq.n	800e858 <tcp_process+0x57c>
 800e790:	6d22      	ldr	r2, [r4, #80]	@ 0x50
 800e792:	4b2a      	ldr	r3, [pc, #168]	@ (800e83c <tcp_process+0x560>)
 800e794:	681b      	ldr	r3, [r3, #0]
 800e796:	429a      	cmp	r2, r3
 800e798:	d001      	beq.n	800e79e <tcp_process+0x4c2>
  return ERR_OK;
 800e79a:	2500      	movs	r5, #0
 800e79c:	e5ca      	b.n	800e334 <tcp_process+0x58>
      if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 800e79e:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
 800e7a0:	b10b      	cbz	r3, 800e7a6 <tcp_process+0x4ca>
  return ERR_OK;
 800e7a2:	2500      	movs	r5, #0
 800e7a4:	e5c6      	b.n	800e334 <tcp_process+0x58>
        tcp_pcb_purge(pcb);
 800e7a6:	4620      	mov	r0, r4
 800e7a8:	f7fd fff8 	bl	800c79c <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 800e7ac:	4b24      	ldr	r3, [pc, #144]	@ (800e840 <tcp_process+0x564>)
 800e7ae:	681b      	ldr	r3, [r3, #0]
 800e7b0:	429c      	cmp	r4, r3
 800e7b2:	d005      	beq.n	800e7c0 <tcp_process+0x4e4>
 800e7b4:	b153      	cbz	r3, 800e7cc <tcp_process+0x4f0>
 800e7b6:	68da      	ldr	r2, [r3, #12]
 800e7b8:	4294      	cmp	r4, r2
 800e7ba:	d005      	beq.n	800e7c8 <tcp_process+0x4ec>
 800e7bc:	4613      	mov	r3, r2
 800e7be:	e7f9      	b.n	800e7b4 <tcp_process+0x4d8>
 800e7c0:	68da      	ldr	r2, [r3, #12]
 800e7c2:	4b1f      	ldr	r3, [pc, #124]	@ (800e840 <tcp_process+0x564>)
 800e7c4:	601a      	str	r2, [r3, #0]
 800e7c6:	e001      	b.n	800e7cc <tcp_process+0x4f0>
 800e7c8:	68e2      	ldr	r2, [r4, #12]
 800e7ca:	60da      	str	r2, [r3, #12]
 800e7cc:	2500      	movs	r5, #0
 800e7ce:	60e5      	str	r5, [r4, #12]
 800e7d0:	4b1c      	ldr	r3, [pc, #112]	@ (800e844 <tcp_process+0x568>)
 800e7d2:	2201      	movs	r2, #1
 800e7d4:	701a      	strb	r2, [r3, #0]
        pcb->state = TIME_WAIT;
 800e7d6:	230a      	movs	r3, #10
 800e7d8:	7523      	strb	r3, [r4, #20]
        TCP_REG(&tcp_tw_pcbs, pcb);
 800e7da:	4b1b      	ldr	r3, [pc, #108]	@ (800e848 <tcp_process+0x56c>)
 800e7dc:	681a      	ldr	r2, [r3, #0]
 800e7de:	60e2      	str	r2, [r4, #12]
 800e7e0:	601c      	str	r4, [r3, #0]
 800e7e2:	f001 fee3 	bl	80105ac <tcp_timer_needed>
 800e7e6:	e5a5      	b.n	800e334 <tcp_process+0x58>
      tcp_receive(pcb);
 800e7e8:	4620      	mov	r0, r4
 800e7ea:	f7ff f8d7 	bl	800d99c <tcp_receive>
      if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 800e7ee:	4b12      	ldr	r3, [pc, #72]	@ (800e838 <tcp_process+0x55c>)
 800e7f0:	781b      	ldrb	r3, [r3, #0]
 800e7f2:	f013 0f10 	tst.w	r3, #16
 800e7f6:	d031      	beq.n	800e85c <tcp_process+0x580>
 800e7f8:	6d22      	ldr	r2, [r4, #80]	@ 0x50
 800e7fa:	4b10      	ldr	r3, [pc, #64]	@ (800e83c <tcp_process+0x560>)
 800e7fc:	681b      	ldr	r3, [r3, #0]
 800e7fe:	429a      	cmp	r2, r3
 800e800:	d001      	beq.n	800e806 <tcp_process+0x52a>
  return ERR_OK;
 800e802:	2500      	movs	r5, #0
 800e804:	e596      	b.n	800e334 <tcp_process+0x58>
      if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 800e806:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
 800e808:	b10b      	cbz	r3, 800e80e <tcp_process+0x532>
  return ERR_OK;
 800e80a:	2500      	movs	r5, #0
 800e80c:	e592      	b.n	800e334 <tcp_process+0x58>
        recv_flags |= TF_CLOSED;
 800e80e:	4a05      	ldr	r2, [pc, #20]	@ (800e824 <tcp_process+0x548>)
 800e810:	7813      	ldrb	r3, [r2, #0]
 800e812:	f043 0310 	orr.w	r3, r3, #16
 800e816:	7013      	strb	r3, [r2, #0]
  return ERR_OK;
 800e818:	2500      	movs	r5, #0
 800e81a:	e58b      	b.n	800e334 <tcp_process+0x58>
  switch (pcb->state) {
 800e81c:	2500      	movs	r5, #0
 800e81e:	e589      	b.n	800e334 <tcp_process+0x58>
 800e820:	240142f8 	.word	0x240142f8
 800e824:	240142f4 	.word	0x240142f4
 800e828:	08017064 	.word	0x08017064
 800e82c:	08017328 	.word	0x08017328
 800e830:	08015744 	.word	0x08015744
 800e834:	24014300 	.word	0x24014300
 800e838:	240142f5 	.word	0x240142f5
 800e83c:	240142fc 	.word	0x240142fc
 800e840:	240142dc 	.word	0x240142dc
 800e844:	240142d6 	.word	0x240142d6
 800e848:	240142d8 	.word	0x240142d8
  return ERR_OK;
 800e84c:	2500      	movs	r5, #0
 800e84e:	e571      	b.n	800e334 <tcp_process+0x58>
 800e850:	2500      	movs	r5, #0
 800e852:	e56f      	b.n	800e334 <tcp_process+0x58>
 800e854:	2500      	movs	r5, #0
 800e856:	e56d      	b.n	800e334 <tcp_process+0x58>
 800e858:	2500      	movs	r5, #0
 800e85a:	e56b      	b.n	800e334 <tcp_process+0x58>
 800e85c:	2500      	movs	r5, #0
 800e85e:	e569      	b.n	800e334 <tcp_process+0x58>

0800e860 <tcp_input>:
{
 800e860:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e862:	b085      	sub	sp, #20
  LWIP_ASSERT("tcp_input: invalid pbuf", p != NULL);
 800e864:	4605      	mov	r5, r0
 800e866:	b1e0      	cbz	r0, 800e8a2 <tcp_input+0x42>
  TCP_STATS_INC(tcp.recv);
 800e868:	4a9d      	ldr	r2, [pc, #628]	@ (800eae0 <tcp_input+0x280>)
 800e86a:	f8b2 30ae 	ldrh.w	r3, [r2, #174]	@ 0xae
 800e86e:	3301      	adds	r3, #1
 800e870:	f8a2 30ae 	strh.w	r3, [r2, #174]	@ 0xae
  tcphdr = (struct tcp_hdr *)p->payload;
 800e874:	686a      	ldr	r2, [r5, #4]
 800e876:	4b9b      	ldr	r3, [pc, #620]	@ (800eae4 <tcp_input+0x284>)
 800e878:	601a      	str	r2, [r3, #0]
  if (p->len < TCP_HLEN) {
 800e87a:	896b      	ldrh	r3, [r5, #10]
 800e87c:	2b13      	cmp	r3, #19
 800e87e:	d817      	bhi.n	800e8b0 <tcp_input+0x50>
    TCP_STATS_INC(tcp.lenerr);
 800e880:	4a97      	ldr	r2, [pc, #604]	@ (800eae0 <tcp_input+0x280>)
 800e882:	f8b2 30b6 	ldrh.w	r3, [r2, #182]	@ 0xb6
 800e886:	3301      	adds	r3, #1
 800e888:	f8a2 30b6 	strh.w	r3, [r2, #182]	@ 0xb6
  TCP_STATS_INC(tcp.drop);
 800e88c:	4a94      	ldr	r2, [pc, #592]	@ (800eae0 <tcp_input+0x280>)
 800e88e:	f8b2 30b2 	ldrh.w	r3, [r2, #178]	@ 0xb2
 800e892:	3301      	adds	r3, #1
 800e894:	f8a2 30b2 	strh.w	r3, [r2, #178]	@ 0xb2
  pbuf_free(p);
 800e898:	4628      	mov	r0, r5
 800e89a:	f7fd f949 	bl	800bb30 <pbuf_free>
}
 800e89e:	b005      	add	sp, #20
 800e8a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  LWIP_ASSERT("tcp_input: invalid pbuf", p != NULL);
 800e8a2:	4b91      	ldr	r3, [pc, #580]	@ (800eae8 <tcp_input+0x288>)
 800e8a4:	2283      	movs	r2, #131	@ 0x83
 800e8a6:	4991      	ldr	r1, [pc, #580]	@ (800eaec <tcp_input+0x28c>)
 800e8a8:	4891      	ldr	r0, [pc, #580]	@ (800eaf0 <tcp_input+0x290>)
 800e8aa:	f005 fb69 	bl	8013f80 <iprintf>
 800e8ae:	e7db      	b.n	800e868 <tcp_input+0x8>
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
 800e8b0:	4b90      	ldr	r3, [pc, #576]	@ (800eaf4 <tcp_input+0x294>)
 800e8b2:	6819      	ldr	r1, [r3, #0]
 800e8b4:	6958      	ldr	r0, [r3, #20]
 800e8b6:	f003 ff15 	bl	80126e4 <ip4_addr_isbroadcast_u32>
 800e8ba:	2800      	cmp	r0, #0
 800e8bc:	d13b      	bne.n	800e936 <tcp_input+0xd6>
      ip_addr_ismulticast(ip_current_dest_addr())) {
 800e8be:	4b8d      	ldr	r3, [pc, #564]	@ (800eaf4 <tcp_input+0x294>)
 800e8c0:	695b      	ldr	r3, [r3, #20]
 800e8c2:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
 800e8c6:	2be0      	cmp	r3, #224	@ 0xe0
 800e8c8:	d035      	beq.n	800e936 <tcp_input+0xd6>
  hdrlen_bytes = TCPH_HDRLEN_BYTES(tcphdr);
 800e8ca:	4b86      	ldr	r3, [pc, #536]	@ (800eae4 <tcp_input+0x284>)
 800e8cc:	681b      	ldr	r3, [r3, #0]
 800e8ce:	8998      	ldrh	r0, [r3, #12]
 800e8d0:	f7fc f946 	bl	800ab60 <lwip_htons>
 800e8d4:	f3c0 3107 	ubfx	r1, r0, #12, #8
 800e8d8:	0089      	lsls	r1, r1, #2
 800e8da:	b2c9      	uxtb	r1, r1
  if ((hdrlen_bytes < TCP_HLEN) || (hdrlen_bytes > p->tot_len)) {
 800e8dc:	2913      	cmp	r1, #19
 800e8de:	d931      	bls.n	800e944 <tcp_input+0xe4>
 800e8e0:	892b      	ldrh	r3, [r5, #8]
 800e8e2:	4299      	cmp	r1, r3
 800e8e4:	d82e      	bhi.n	800e944 <tcp_input+0xe4>
  tcphdr_optlen = (u16_t)(hdrlen_bytes - TCP_HLEN);
 800e8e6:	f1a1 0314 	sub.w	r3, r1, #20
 800e8ea:	b29b      	uxth	r3, r3
 800e8ec:	4a82      	ldr	r2, [pc, #520]	@ (800eaf8 <tcp_input+0x298>)
 800e8ee:	8013      	strh	r3, [r2, #0]
  tcphdr_opt2 = NULL;
 800e8f0:	4a82      	ldr	r2, [pc, #520]	@ (800eafc <tcp_input+0x29c>)
 800e8f2:	2000      	movs	r0, #0
 800e8f4:	6010      	str	r0, [r2, #0]
  if (p->len >= hdrlen_bytes) {
 800e8f6:	896a      	ldrh	r2, [r5, #10]
 800e8f8:	4291      	cmp	r1, r2
 800e8fa:	d92a      	bls.n	800e952 <tcp_input+0xf2>
    LWIP_ASSERT("p->next != NULL", p->next != NULL);
 800e8fc:	682b      	ldr	r3, [r5, #0]
 800e8fe:	2b00      	cmp	r3, #0
 800e900:	d062      	beq.n	800e9c8 <tcp_input+0x168>
    pbuf_remove_header(p, TCP_HLEN);
 800e902:	2114      	movs	r1, #20
 800e904:	4628      	mov	r0, r5
 800e906:	f7fd f8cd 	bl	800baa4 <pbuf_remove_header>
    tcphdr_opt1len = p->len;
 800e90a:	896c      	ldrh	r4, [r5, #10]
 800e90c:	4b7c      	ldr	r3, [pc, #496]	@ (800eb00 <tcp_input+0x2a0>)
 800e90e:	801c      	strh	r4, [r3, #0]
    opt2len = (u16_t)(tcphdr_optlen - tcphdr_opt1len);
 800e910:	4b79      	ldr	r3, [pc, #484]	@ (800eaf8 <tcp_input+0x298>)
 800e912:	881f      	ldrh	r7, [r3, #0]
 800e914:	1b3e      	subs	r6, r7, r4
 800e916:	b2b6      	uxth	r6, r6
    pbuf_remove_header(p, tcphdr_opt1len);
 800e918:	4621      	mov	r1, r4
 800e91a:	4628      	mov	r0, r5
 800e91c:	f7fd f8c2 	bl	800baa4 <pbuf_remove_header>
    if (opt2len > p->next->len) {
 800e920:	6828      	ldr	r0, [r5, #0]
 800e922:	8943      	ldrh	r3, [r0, #10]
 800e924:	42b3      	cmp	r3, r6
 800e926:	d256      	bcs.n	800e9d6 <tcp_input+0x176>
      TCP_STATS_INC(tcp.lenerr);
 800e928:	4a6d      	ldr	r2, [pc, #436]	@ (800eae0 <tcp_input+0x280>)
 800e92a:	f8b2 30b6 	ldrh.w	r3, [r2, #182]	@ 0xb6
 800e92e:	3301      	adds	r3, #1
 800e930:	f8a2 30b6 	strh.w	r3, [r2, #182]	@ 0xb6
      goto dropped;
 800e934:	e7aa      	b.n	800e88c <tcp_input+0x2c>
    TCP_STATS_INC(tcp.proterr);
 800e936:	4a6a      	ldr	r2, [pc, #424]	@ (800eae0 <tcp_input+0x280>)
 800e938:	f8b2 30bc 	ldrh.w	r3, [r2, #188]	@ 0xbc
 800e93c:	3301      	adds	r3, #1
 800e93e:	f8a2 30bc 	strh.w	r3, [r2, #188]	@ 0xbc
    goto dropped;
 800e942:	e7a3      	b.n	800e88c <tcp_input+0x2c>
    TCP_STATS_INC(tcp.lenerr);
 800e944:	4a66      	ldr	r2, [pc, #408]	@ (800eae0 <tcp_input+0x280>)
 800e946:	f8b2 30b6 	ldrh.w	r3, [r2, #182]	@ 0xb6
 800e94a:	3301      	adds	r3, #1
 800e94c:	f8a2 30b6 	strh.w	r3, [r2, #182]	@ 0xb6
    goto dropped;
 800e950:	e79c      	b.n	800e88c <tcp_input+0x2c>
    tcphdr_opt1len = tcphdr_optlen;
 800e952:	4a6b      	ldr	r2, [pc, #428]	@ (800eb00 <tcp_input+0x2a0>)
 800e954:	8013      	strh	r3, [r2, #0]
    pbuf_remove_header(p, hdrlen_bytes); /* cannot fail */
 800e956:	4628      	mov	r0, r5
 800e958:	f7fd f8a4 	bl	800baa4 <pbuf_remove_header>
  tcphdr->src = lwip_ntohs(tcphdr->src);
 800e95c:	4c61      	ldr	r4, [pc, #388]	@ (800eae4 <tcp_input+0x284>)
 800e95e:	6826      	ldr	r6, [r4, #0]
 800e960:	8830      	ldrh	r0, [r6, #0]
 800e962:	f7fc f8fd 	bl	800ab60 <lwip_htons>
 800e966:	8030      	strh	r0, [r6, #0]
  tcphdr->dest = lwip_ntohs(tcphdr->dest);
 800e968:	6826      	ldr	r6, [r4, #0]
 800e96a:	8870      	ldrh	r0, [r6, #2]
 800e96c:	f7fc f8f8 	bl	800ab60 <lwip_htons>
 800e970:	8070      	strh	r0, [r6, #2]
  seqno = tcphdr->seqno = lwip_ntohl(tcphdr->seqno);
 800e972:	6826      	ldr	r6, [r4, #0]
 800e974:	6870      	ldr	r0, [r6, #4]
 800e976:	f7fc f8f8 	bl	800ab6a <lwip_htonl>
 800e97a:	6070      	str	r0, [r6, #4]
 800e97c:	4b61      	ldr	r3, [pc, #388]	@ (800eb04 <tcp_input+0x2a4>)
 800e97e:	6018      	str	r0, [r3, #0]
  ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
 800e980:	6826      	ldr	r6, [r4, #0]
 800e982:	68b0      	ldr	r0, [r6, #8]
 800e984:	f7fc f8f1 	bl	800ab6a <lwip_htonl>
 800e988:	60b0      	str	r0, [r6, #8]
 800e98a:	4b5f      	ldr	r3, [pc, #380]	@ (800eb08 <tcp_input+0x2a8>)
 800e98c:	6018      	str	r0, [r3, #0]
  tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
 800e98e:	6826      	ldr	r6, [r4, #0]
 800e990:	89f0      	ldrh	r0, [r6, #14]
 800e992:	f7fc f8e5 	bl	800ab60 <lwip_htons>
 800e996:	81f0      	strh	r0, [r6, #14]
  flags = TCPH_FLAGS(tcphdr);
 800e998:	6823      	ldr	r3, [r4, #0]
 800e99a:	8998      	ldrh	r0, [r3, #12]
 800e99c:	f7fc f8e0 	bl	800ab60 <lwip_htons>
 800e9a0:	f000 023f 	and.w	r2, r0, #63	@ 0x3f
 800e9a4:	4b59      	ldr	r3, [pc, #356]	@ (800eb0c <tcp_input+0x2ac>)
 800e9a6:	701a      	strb	r2, [r3, #0]
  tcplen = p->tot_len;
 800e9a8:	892b      	ldrh	r3, [r5, #8]
 800e9aa:	4a59      	ldr	r2, [pc, #356]	@ (800eb10 <tcp_input+0x2b0>)
 800e9ac:	8013      	strh	r3, [r2, #0]
  if (flags & (TCP_FIN | TCP_SYN)) {
 800e9ae:	f010 0f03 	tst.w	r0, #3
 800e9b2:	d005      	beq.n	800e9c0 <tcp_input+0x160>
    tcplen++;
 800e9b4:	1c5a      	adds	r2, r3, #1
 800e9b6:	b292      	uxth	r2, r2
 800e9b8:	4955      	ldr	r1, [pc, #340]	@ (800eb10 <tcp_input+0x2b0>)
 800e9ba:	800a      	strh	r2, [r1, #0]
    if (tcplen < p->tot_len) {
 800e9bc:	4293      	cmp	r3, r2
 800e9be:	d829      	bhi.n	800ea14 <tcp_input+0x1b4>
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800e9c0:	4b54      	ldr	r3, [pc, #336]	@ (800eb14 <tcp_input+0x2b4>)
 800e9c2:	681c      	ldr	r4, [r3, #0]
  prev = NULL;
 800e9c4:	2600      	movs	r6, #0
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800e9c6:	e049      	b.n	800ea5c <tcp_input+0x1fc>
    LWIP_ASSERT("p->next != NULL", p->next != NULL);
 800e9c8:	4b47      	ldr	r3, [pc, #284]	@ (800eae8 <tcp_input+0x288>)
 800e9ca:	22c2      	movs	r2, #194	@ 0xc2
 800e9cc:	4952      	ldr	r1, [pc, #328]	@ (800eb18 <tcp_input+0x2b8>)
 800e9ce:	4848      	ldr	r0, [pc, #288]	@ (800eaf0 <tcp_input+0x290>)
 800e9d0:	f005 fad6 	bl	8013f80 <iprintf>
 800e9d4:	e795      	b.n	800e902 <tcp_input+0xa2>
    tcphdr_opt2 = (u8_t *)p->next->payload;
 800e9d6:	6842      	ldr	r2, [r0, #4]
 800e9d8:	4b48      	ldr	r3, [pc, #288]	@ (800eafc <tcp_input+0x29c>)
 800e9da:	601a      	str	r2, [r3, #0]
    pbuf_remove_header(p->next, opt2len);
 800e9dc:	4631      	mov	r1, r6
 800e9de:	f7fd f861 	bl	800baa4 <pbuf_remove_header>
    p->tot_len = (u16_t)(p->tot_len - opt2len);
 800e9e2:	892b      	ldrh	r3, [r5, #8]
 800e9e4:	1be4      	subs	r4, r4, r7
 800e9e6:	4423      	add	r3, r4
 800e9e8:	812b      	strh	r3, [r5, #8]
    LWIP_ASSERT("p->len == 0", p->len == 0);
 800e9ea:	896b      	ldrh	r3, [r5, #10]
 800e9ec:	b95b      	cbnz	r3, 800ea06 <tcp_input+0x1a6>
    LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
 800e9ee:	892a      	ldrh	r2, [r5, #8]
 800e9f0:	682b      	ldr	r3, [r5, #0]
 800e9f2:	891b      	ldrh	r3, [r3, #8]
 800e9f4:	429a      	cmp	r2, r3
 800e9f6:	d0b1      	beq.n	800e95c <tcp_input+0xfc>
 800e9f8:	4b3b      	ldr	r3, [pc, #236]	@ (800eae8 <tcp_input+0x288>)
 800e9fa:	22e0      	movs	r2, #224	@ 0xe0
 800e9fc:	4947      	ldr	r1, [pc, #284]	@ (800eb1c <tcp_input+0x2bc>)
 800e9fe:	483c      	ldr	r0, [pc, #240]	@ (800eaf0 <tcp_input+0x290>)
 800ea00:	f005 fabe 	bl	8013f80 <iprintf>
 800ea04:	e7aa      	b.n	800e95c <tcp_input+0xfc>
    LWIP_ASSERT("p->len == 0", p->len == 0);
 800ea06:	4b38      	ldr	r3, [pc, #224]	@ (800eae8 <tcp_input+0x288>)
 800ea08:	22df      	movs	r2, #223	@ 0xdf
 800ea0a:	4945      	ldr	r1, [pc, #276]	@ (800eb20 <tcp_input+0x2c0>)
 800ea0c:	4838      	ldr	r0, [pc, #224]	@ (800eaf0 <tcp_input+0x290>)
 800ea0e:	f005 fab7 	bl	8013f80 <iprintf>
 800ea12:	e7ec      	b.n	800e9ee <tcp_input+0x18e>
      TCP_STATS_INC(tcp.lenerr);
 800ea14:	4a32      	ldr	r2, [pc, #200]	@ (800eae0 <tcp_input+0x280>)
 800ea16:	f8b2 30b6 	ldrh.w	r3, [r2, #182]	@ 0xb6
 800ea1a:	3301      	adds	r3, #1
 800ea1c:	f8a2 30b6 	strh.w	r3, [r2, #182]	@ 0xb6
      goto dropped;
 800ea20:	e734      	b.n	800e88c <tcp_input+0x2c>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 800ea22:	4b31      	ldr	r3, [pc, #196]	@ (800eae8 <tcp_input+0x288>)
 800ea24:	22fb      	movs	r2, #251	@ 0xfb
 800ea26:	493f      	ldr	r1, [pc, #252]	@ (800eb24 <tcp_input+0x2c4>)
 800ea28:	4831      	ldr	r0, [pc, #196]	@ (800eaf0 <tcp_input+0x290>)
 800ea2a:	f005 faa9 	bl	8013f80 <iprintf>
 800ea2e:	e01a      	b.n	800ea66 <tcp_input+0x206>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 800ea30:	4b2d      	ldr	r3, [pc, #180]	@ (800eae8 <tcp_input+0x288>)
 800ea32:	22fc      	movs	r2, #252	@ 0xfc
 800ea34:	493c      	ldr	r1, [pc, #240]	@ (800eb28 <tcp_input+0x2c8>)
 800ea36:	482e      	ldr	r0, [pc, #184]	@ (800eaf0 <tcp_input+0x290>)
 800ea38:	f005 faa2 	bl	8013f80 <iprintf>
 800ea3c:	e016      	b.n	800ea6c <tcp_input+0x20c>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 800ea3e:	4b2a      	ldr	r3, [pc, #168]	@ (800eae8 <tcp_input+0x288>)
 800ea40:	22fd      	movs	r2, #253	@ 0xfd
 800ea42:	493a      	ldr	r1, [pc, #232]	@ (800eb2c <tcp_input+0x2cc>)
 800ea44:	482a      	ldr	r0, [pc, #168]	@ (800eaf0 <tcp_input+0x290>)
 800ea46:	f005 fa9b 	bl	8013f80 <iprintf>
 800ea4a:	e012      	b.n	800ea72 <tcp_input+0x212>
    if (pcb->remote_port == tcphdr->src &&
 800ea4c:	8b21      	ldrh	r1, [r4, #24]
 800ea4e:	4b25      	ldr	r3, [pc, #148]	@ (800eae4 <tcp_input+0x284>)
 800ea50:	681b      	ldr	r3, [r3, #0]
 800ea52:	881a      	ldrh	r2, [r3, #0]
 800ea54:	4291      	cmp	r1, r2
 800ea56:	d018      	beq.n	800ea8a <tcp_input+0x22a>
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800ea58:	4626      	mov	r6, r4
 800ea5a:	68e4      	ldr	r4, [r4, #12]
 800ea5c:	2c00      	cmp	r4, #0
 800ea5e:	d07d      	beq.n	800eb5c <tcp_input+0x2fc>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 800ea60:	7d23      	ldrb	r3, [r4, #20]
 800ea62:	2b00      	cmp	r3, #0
 800ea64:	d0dd      	beq.n	800ea22 <tcp_input+0x1c2>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 800ea66:	7d23      	ldrb	r3, [r4, #20]
 800ea68:	2b0a      	cmp	r3, #10
 800ea6a:	d0e1      	beq.n	800ea30 <tcp_input+0x1d0>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 800ea6c:	7d23      	ldrb	r3, [r4, #20]
 800ea6e:	2b01      	cmp	r3, #1
 800ea70:	d0e5      	beq.n	800ea3e <tcp_input+0x1de>
    if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 800ea72:	7a22      	ldrb	r2, [r4, #8]
 800ea74:	2a00      	cmp	r2, #0
 800ea76:	d0e9      	beq.n	800ea4c <tcp_input+0x1ec>
        (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 800ea78:	4b1e      	ldr	r3, [pc, #120]	@ (800eaf4 <tcp_input+0x294>)
 800ea7a:	685b      	ldr	r3, [r3, #4]
 800ea7c:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 800ea80:	3301      	adds	r3, #1
 800ea82:	b2db      	uxtb	r3, r3
    if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 800ea84:	429a      	cmp	r2, r3
 800ea86:	d0e1      	beq.n	800ea4c <tcp_input+0x1ec>
 800ea88:	e7e6      	b.n	800ea58 <tcp_input+0x1f8>
        pcb->local_port == tcphdr->dest &&
 800ea8a:	8ae2      	ldrh	r2, [r4, #22]
 800ea8c:	885b      	ldrh	r3, [r3, #2]
    if (pcb->remote_port == tcphdr->src &&
 800ea8e:	429a      	cmp	r2, r3
 800ea90:	d1e2      	bne.n	800ea58 <tcp_input+0x1f8>
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 800ea92:	6862      	ldr	r2, [r4, #4]
 800ea94:	4b17      	ldr	r3, [pc, #92]	@ (800eaf4 <tcp_input+0x294>)
 800ea96:	691b      	ldr	r3, [r3, #16]
        pcb->local_port == tcphdr->dest &&
 800ea98:	429a      	cmp	r2, r3
 800ea9a:	d1dd      	bne.n	800ea58 <tcp_input+0x1f8>
        ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 800ea9c:	6822      	ldr	r2, [r4, #0]
 800ea9e:	4b15      	ldr	r3, [pc, #84]	@ (800eaf4 <tcp_input+0x294>)
 800eaa0:	695b      	ldr	r3, [r3, #20]
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 800eaa2:	429a      	cmp	r2, r3
 800eaa4:	d1d8      	bne.n	800ea58 <tcp_input+0x1f8>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
 800eaa6:	68e3      	ldr	r3, [r4, #12]
 800eaa8:	429c      	cmp	r4, r3
 800eaaa:	d041      	beq.n	800eb30 <tcp_input+0x2d0>
      if (prev != NULL) {
 800eaac:	2e00      	cmp	r6, #0
 800eaae:	d047      	beq.n	800eb40 <tcp_input+0x2e0>
        prev->next = pcb->next;
 800eab0:	68e3      	ldr	r3, [r4, #12]
 800eab2:	60f3      	str	r3, [r6, #12]
        pcb->next = tcp_active_pcbs;
 800eab4:	4b17      	ldr	r3, [pc, #92]	@ (800eb14 <tcp_input+0x2b4>)
 800eab6:	681a      	ldr	r2, [r3, #0]
 800eab8:	60e2      	str	r2, [r4, #12]
        tcp_active_pcbs = pcb;
 800eaba:	601c      	str	r4, [r3, #0]
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
 800eabc:	68e3      	ldr	r3, [r4, #12]
 800eabe:	429c      	cmp	r4, r3
 800eac0:	d045      	beq.n	800eb4e <tcp_input+0x2ee>
  if (pcb != NULL) {
 800eac2:	2c00      	cmp	r4, #0
 800eac4:	d14c      	bne.n	800eb60 <tcp_input+0x300>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 800eac6:	4b07      	ldr	r3, [pc, #28]	@ (800eae4 <tcp_input+0x284>)
 800eac8:	681b      	ldr	r3, [r3, #0]
 800eaca:	8998      	ldrh	r0, [r3, #12]
 800eacc:	f7fc f848 	bl	800ab60 <lwip_htons>
 800ead0:	f010 0f04 	tst.w	r0, #4
 800ead4:	f000 81a7 	beq.w	800ee26 <tcp_input+0x5c6>
    pbuf_free(p);
 800ead8:	4628      	mov	r0, r5
 800eada:	f7fd f829 	bl	800bb30 <pbuf_free>
 800eade:	e6de      	b.n	800e89e <tcp_input+0x3e>
 800eae0:	240141b4 	.word	0x240141b4
 800eae4:	24014310 	.word	0x24014310
 800eae8:	08017064 	.word	0x08017064
 800eaec:	08017348 	.word	0x08017348
 800eaf0:	08015744 	.word	0x08015744
 800eaf4:	2400c4b0 	.word	0x2400c4b0
 800eaf8:	2401430e 	.word	0x2401430e
 800eafc:	24014308 	.word	0x24014308
 800eb00:	2401430c 	.word	0x2401430c
 800eb04:	24014300 	.word	0x24014300
 800eb08:	240142fc 	.word	0x240142fc
 800eb0c:	240142f5 	.word	0x240142f5
 800eb10:	240142f6 	.word	0x240142f6
 800eb14:	240142dc 	.word	0x240142dc
 800eb18:	08017360 	.word	0x08017360
 800eb1c:	0801737c 	.word	0x0801737c
 800eb20:	08017370 	.word	0x08017370
 800eb24:	0801739c 	.word	0x0801739c
 800eb28:	080173c4 	.word	0x080173c4
 800eb2c:	080173f0 	.word	0x080173f0
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
 800eb30:	4b73      	ldr	r3, [pc, #460]	@ (800ed00 <tcp_input+0x4a0>)
 800eb32:	f240 120d 	movw	r2, #269	@ 0x10d
 800eb36:	4973      	ldr	r1, [pc, #460]	@ (800ed04 <tcp_input+0x4a4>)
 800eb38:	4873      	ldr	r0, [pc, #460]	@ (800ed08 <tcp_input+0x4a8>)
 800eb3a:	f005 fa21 	bl	8013f80 <iprintf>
 800eb3e:	e7b5      	b.n	800eaac <tcp_input+0x24c>
        TCP_STATS_INC(tcp.cachehit);
 800eb40:	4a72      	ldr	r2, [pc, #456]	@ (800ed0c <tcp_input+0x4ac>)
 800eb42:	f8b2 30c2 	ldrh.w	r3, [r2, #194]	@ 0xc2
 800eb46:	3301      	adds	r3, #1
 800eb48:	f8a2 30c2 	strh.w	r3, [r2, #194]	@ 0xc2
 800eb4c:	e7b6      	b.n	800eabc <tcp_input+0x25c>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
 800eb4e:	4b6c      	ldr	r3, [pc, #432]	@ (800ed00 <tcp_input+0x4a0>)
 800eb50:	f240 1215 	movw	r2, #277	@ 0x115
 800eb54:	496e      	ldr	r1, [pc, #440]	@ (800ed10 <tcp_input+0x4b0>)
 800eb56:	486c      	ldr	r0, [pc, #432]	@ (800ed08 <tcp_input+0x4a8>)
 800eb58:	f005 fa12 	bl	8013f80 <iprintf>
  if (pcb == NULL) {
 800eb5c:	2c00      	cmp	r4, #0
 800eb5e:	d045      	beq.n	800ebec <tcp_input+0x38c>
    inseg.next = NULL;
 800eb60:	4a6c      	ldr	r2, [pc, #432]	@ (800ed14 <tcp_input+0x4b4>)
 800eb62:	2300      	movs	r3, #0
 800eb64:	6013      	str	r3, [r2, #0]
    inseg.len = p->tot_len;
 800eb66:	8929      	ldrh	r1, [r5, #8]
 800eb68:	8111      	strh	r1, [r2, #8]
    inseg.p = p;
 800eb6a:	6055      	str	r5, [r2, #4]
    inseg.tcphdr = tcphdr;
 800eb6c:	496a      	ldr	r1, [pc, #424]	@ (800ed18 <tcp_input+0x4b8>)
 800eb6e:	6809      	ldr	r1, [r1, #0]
 800eb70:	6111      	str	r1, [r2, #16]
    recv_data = NULL;
 800eb72:	4a6a      	ldr	r2, [pc, #424]	@ (800ed1c <tcp_input+0x4bc>)
 800eb74:	6013      	str	r3, [r2, #0]
    recv_flags = 0;
 800eb76:	4a6a      	ldr	r2, [pc, #424]	@ (800ed20 <tcp_input+0x4c0>)
 800eb78:	7013      	strb	r3, [r2, #0]
    recv_acked = 0;
 800eb7a:	4a6a      	ldr	r2, [pc, #424]	@ (800ed24 <tcp_input+0x4c4>)
 800eb7c:	8013      	strh	r3, [r2, #0]
    if (flags & TCP_PSH) {
 800eb7e:	4b6a      	ldr	r3, [pc, #424]	@ (800ed28 <tcp_input+0x4c8>)
 800eb80:	781b      	ldrb	r3, [r3, #0]
 800eb82:	f013 0f08 	tst.w	r3, #8
 800eb86:	d003      	beq.n	800eb90 <tcp_input+0x330>
      p->flags |= PBUF_FLAG_PUSH;
 800eb88:	7b6b      	ldrb	r3, [r5, #13]
 800eb8a:	f043 0301 	orr.w	r3, r3, #1
 800eb8e:	736b      	strb	r3, [r5, #13]
    if (pcb->refused_data != NULL) {
 800eb90:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
 800eb92:	b16b      	cbz	r3, 800ebb0 <tcp_input+0x350>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 800eb94:	4620      	mov	r0, r4
 800eb96:	f7fe f973 	bl	800ce80 <tcp_process_refused_data>
 800eb9a:	f110 0f0d 	cmn.w	r0, #13
 800eb9e:	f000 8093 	beq.w	800ecc8 <tcp_input+0x468>
          ((pcb->refused_data != NULL) && (tcplen > 0))) {
 800eba2:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 800eba4:	b123      	cbz	r3, 800ebb0 <tcp_input+0x350>
          ((pcb->refused_data != NULL) && (tcplen > 0))) {
 800eba6:	4b61      	ldr	r3, [pc, #388]	@ (800ed2c <tcp_input+0x4cc>)
 800eba8:	881b      	ldrh	r3, [r3, #0]
 800ebaa:	2b00      	cmp	r3, #0
 800ebac:	f040 808c 	bne.w	800ecc8 <tcp_input+0x468>
    tcp_input_pcb = pcb;
 800ebb0:	4b5f      	ldr	r3, [pc, #380]	@ (800ed30 <tcp_input+0x4d0>)
 800ebb2:	601c      	str	r4, [r3, #0]
    err = tcp_process(pcb);
 800ebb4:	4620      	mov	r0, r4
 800ebb6:	f7ff fb91 	bl	800e2dc <tcp_process>
    if (err != ERR_ABRT) {
 800ebba:	f110 0f0d 	cmn.w	r0, #13
 800ebbe:	f000 808b 	beq.w	800ecd8 <tcp_input+0x478>
      if (recv_flags & TF_RESET) {
 800ebc2:	4b57      	ldr	r3, [pc, #348]	@ (800ed20 <tcp_input+0x4c0>)
 800ebc4:	781b      	ldrb	r3, [r3, #0]
 800ebc6:	f013 0f08 	tst.w	r3, #8
 800ebca:	f000 80bd 	beq.w	800ed48 <tcp_input+0x4e8>
        TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_RST);
 800ebce:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 800ebd2:	b11b      	cbz	r3, 800ebdc <tcp_input+0x37c>
 800ebd4:	f06f 010d 	mvn.w	r1, #13
 800ebd8:	6920      	ldr	r0, [r4, #16]
 800ebda:	4798      	blx	r3
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 800ebdc:	4621      	mov	r1, r4
 800ebde:	4855      	ldr	r0, [pc, #340]	@ (800ed34 <tcp_input+0x4d4>)
 800ebe0:	f7fd fe0e 	bl	800c800 <tcp_pcb_remove>
        tcp_free(pcb);
 800ebe4:	4620      	mov	r0, r4
 800ebe6:	f7fd fb73 	bl	800c2d0 <tcp_free>
 800ebea:	e075      	b.n	800ecd8 <tcp_input+0x478>
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800ebec:	4b52      	ldr	r3, [pc, #328]	@ (800ed38 <tcp_input+0x4d8>)
 800ebee:	681c      	ldr	r4, [r3, #0]
 800ebf0:	e00e      	b.n	800ec10 <tcp_input+0x3b0>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 800ebf2:	4b43      	ldr	r3, [pc, #268]	@ (800ed00 <tcp_input+0x4a0>)
 800ebf4:	f240 121f 	movw	r2, #287	@ 0x11f
 800ebf8:	4950      	ldr	r1, [pc, #320]	@ (800ed3c <tcp_input+0x4dc>)
 800ebfa:	4843      	ldr	r0, [pc, #268]	@ (800ed08 <tcp_input+0x4a8>)
 800ebfc:	f005 f9c0 	bl	8013f80 <iprintf>
 800ec00:	e00a      	b.n	800ec18 <tcp_input+0x3b8>
      if (pcb->remote_port == tcphdr->src &&
 800ec02:	8b21      	ldrh	r1, [r4, #24]
 800ec04:	4b44      	ldr	r3, [pc, #272]	@ (800ed18 <tcp_input+0x4b8>)
 800ec06:	681b      	ldr	r3, [r3, #0]
 800ec08:	881a      	ldrh	r2, [r3, #0]
 800ec0a:	4291      	cmp	r1, r2
 800ec0c:	d010      	beq.n	800ec30 <tcp_input+0x3d0>
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800ec0e:	68e4      	ldr	r4, [r4, #12]
 800ec10:	b31c      	cbz	r4, 800ec5a <tcp_input+0x3fa>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 800ec12:	7d23      	ldrb	r3, [r4, #20]
 800ec14:	2b0a      	cmp	r3, #10
 800ec16:	d1ec      	bne.n	800ebf2 <tcp_input+0x392>
      if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 800ec18:	7a22      	ldrb	r2, [r4, #8]
 800ec1a:	2a00      	cmp	r2, #0
 800ec1c:	d0f1      	beq.n	800ec02 <tcp_input+0x3a2>
          (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 800ec1e:	4b48      	ldr	r3, [pc, #288]	@ (800ed40 <tcp_input+0x4e0>)
 800ec20:	685b      	ldr	r3, [r3, #4]
 800ec22:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 800ec26:	3301      	adds	r3, #1
 800ec28:	b2db      	uxtb	r3, r3
      if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 800ec2a:	429a      	cmp	r2, r3
 800ec2c:	d0e9      	beq.n	800ec02 <tcp_input+0x3a2>
 800ec2e:	e7ee      	b.n	800ec0e <tcp_input+0x3ae>
          pcb->local_port == tcphdr->dest &&
 800ec30:	8ae2      	ldrh	r2, [r4, #22]
 800ec32:	885b      	ldrh	r3, [r3, #2]
      if (pcb->remote_port == tcphdr->src &&
 800ec34:	429a      	cmp	r2, r3
 800ec36:	d1ea      	bne.n	800ec0e <tcp_input+0x3ae>
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 800ec38:	6862      	ldr	r2, [r4, #4]
 800ec3a:	4b41      	ldr	r3, [pc, #260]	@ (800ed40 <tcp_input+0x4e0>)
 800ec3c:	691b      	ldr	r3, [r3, #16]
          pcb->local_port == tcphdr->dest &&
 800ec3e:	429a      	cmp	r2, r3
 800ec40:	d1e5      	bne.n	800ec0e <tcp_input+0x3ae>
          ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 800ec42:	6822      	ldr	r2, [r4, #0]
 800ec44:	4b3e      	ldr	r3, [pc, #248]	@ (800ed40 <tcp_input+0x4e0>)
 800ec46:	695b      	ldr	r3, [r3, #20]
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 800ec48:	429a      	cmp	r2, r3
 800ec4a:	d1e0      	bne.n	800ec0e <tcp_input+0x3ae>
          tcp_timewait_input(pcb);
 800ec4c:	4620      	mov	r0, r4
 800ec4e:	f7fe fce5 	bl	800d61c <tcp_timewait_input>
        pbuf_free(p);
 800ec52:	4628      	mov	r0, r5
 800ec54:	f7fc ff6c 	bl	800bb30 <pbuf_free>
        return;
 800ec58:	e621      	b.n	800e89e <tcp_input+0x3e>
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800ec5a:	4b3a      	ldr	r3, [pc, #232]	@ (800ed44 <tcp_input+0x4e4>)
 800ec5c:	681e      	ldr	r6, [r3, #0]
 800ec5e:	4630      	mov	r0, r6
    prev = NULL;
 800ec60:	4621      	mov	r1, r4
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800ec62:	e007      	b.n	800ec74 <tcp_input+0x414>
      if (lpcb->local_port == tcphdr->dest) {
 800ec64:	8ac2      	ldrh	r2, [r0, #22]
 800ec66:	4b2c      	ldr	r3, [pc, #176]	@ (800ed18 <tcp_input+0x4b8>)
 800ec68:	681b      	ldr	r3, [r3, #0]
 800ec6a:	885b      	ldrh	r3, [r3, #2]
 800ec6c:	429a      	cmp	r2, r3
 800ec6e:	d00e      	beq.n	800ec8e <tcp_input+0x42e>
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800ec70:	4601      	mov	r1, r0
 800ec72:	68c0      	ldr	r0, [r0, #12]
 800ec74:	b190      	cbz	r0, 800ec9c <tcp_input+0x43c>
      if ((lpcb->netif_idx != NETIF_NO_INDEX) &&
 800ec76:	7a02      	ldrb	r2, [r0, #8]
 800ec78:	2a00      	cmp	r2, #0
 800ec7a:	d0f3      	beq.n	800ec64 <tcp_input+0x404>
          (lpcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 800ec7c:	4b30      	ldr	r3, [pc, #192]	@ (800ed40 <tcp_input+0x4e0>)
 800ec7e:	685b      	ldr	r3, [r3, #4]
 800ec80:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 800ec84:	3301      	adds	r3, #1
 800ec86:	b2db      	uxtb	r3, r3
      if ((lpcb->netif_idx != NETIF_NO_INDEX) &&
 800ec88:	429a      	cmp	r2, r3
 800ec8a:	d0eb      	beq.n	800ec64 <tcp_input+0x404>
 800ec8c:	e7f0      	b.n	800ec70 <tcp_input+0x410>
          if (ip_addr_cmp(&lpcb->local_ip, ip_current_dest_addr())) {
 800ec8e:	6803      	ldr	r3, [r0, #0]
 800ec90:	4a2b      	ldr	r2, [pc, #172]	@ (800ed40 <tcp_input+0x4e0>)
 800ec92:	6952      	ldr	r2, [r2, #20]
 800ec94:	4293      	cmp	r3, r2
 800ec96:	d001      	beq.n	800ec9c <tcp_input+0x43c>
          } else if (ip_addr_isany(&lpcb->local_ip)) {
 800ec98:	2b00      	cmp	r3, #0
 800ec9a:	d1e9      	bne.n	800ec70 <tcp_input+0x410>
    if (lpcb != NULL) {
 800ec9c:	2800      	cmp	r0, #0
 800ec9e:	f43f af10 	beq.w	800eac2 <tcp_input+0x262>
      if (prev != NULL) {
 800eca2:	b151      	cbz	r1, 800ecba <tcp_input+0x45a>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 800eca4:	68c3      	ldr	r3, [r0, #12]
 800eca6:	60cb      	str	r3, [r1, #12]
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
 800eca8:	60c6      	str	r6, [r0, #12]
        tcp_listen_pcbs.listen_pcbs = lpcb;
 800ecaa:	4b26      	ldr	r3, [pc, #152]	@ (800ed44 <tcp_input+0x4e4>)
 800ecac:	6018      	str	r0, [r3, #0]
        tcp_listen_input(lpcb);
 800ecae:	f7fe fd11 	bl	800d6d4 <tcp_listen_input>
      pbuf_free(p);
 800ecb2:	4628      	mov	r0, r5
 800ecb4:	f7fc ff3c 	bl	800bb30 <pbuf_free>
      return;
 800ecb8:	e5f1      	b.n	800e89e <tcp_input+0x3e>
        TCP_STATS_INC(tcp.cachehit);
 800ecba:	4a14      	ldr	r2, [pc, #80]	@ (800ed0c <tcp_input+0x4ac>)
 800ecbc:	f8b2 30c2 	ldrh.w	r3, [r2, #194]	@ 0xc2
 800ecc0:	3301      	adds	r3, #1
 800ecc2:	f8a2 30c2 	strh.w	r3, [r2, #194]	@ 0xc2
 800ecc6:	e7f2      	b.n	800ecae <tcp_input+0x44e>
        if (pcb->rcv_ann_wnd == 0) {
 800ecc8:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
 800ecca:	b1ab      	cbz	r3, 800ecf8 <tcp_input+0x498>
        TCP_STATS_INC(tcp.drop);
 800eccc:	4a0f      	ldr	r2, [pc, #60]	@ (800ed0c <tcp_input+0x4ac>)
 800ecce:	f8b2 30b2 	ldrh.w	r3, [r2, #178]	@ 0xb2
 800ecd2:	3301      	adds	r3, #1
 800ecd4:	f8a2 30b2 	strh.w	r3, [r2, #178]	@ 0xb2
    tcp_input_pcb = NULL;
 800ecd8:	2300      	movs	r3, #0
 800ecda:	4a15      	ldr	r2, [pc, #84]	@ (800ed30 <tcp_input+0x4d0>)
 800ecdc:	6013      	str	r3, [r2, #0]
    recv_data = NULL;
 800ecde:	4a0f      	ldr	r2, [pc, #60]	@ (800ed1c <tcp_input+0x4bc>)
 800ece0:	6013      	str	r3, [r2, #0]
    if (inseg.p != NULL) {
 800ece2:	4b0c      	ldr	r3, [pc, #48]	@ (800ed14 <tcp_input+0x4b4>)
 800ece4:	6858      	ldr	r0, [r3, #4]
 800ece6:	2800      	cmp	r0, #0
 800ece8:	f43f add9 	beq.w	800e89e <tcp_input+0x3e>
      pbuf_free(inseg.p);
 800ecec:	f7fc ff20 	bl	800bb30 <pbuf_free>
      inseg.p = NULL;
 800ecf0:	4b08      	ldr	r3, [pc, #32]	@ (800ed14 <tcp_input+0x4b4>)
 800ecf2:	2200      	movs	r2, #0
 800ecf4:	605a      	str	r2, [r3, #4]
 800ecf6:	e5d2      	b.n	800e89e <tcp_input+0x3e>
          tcp_send_empty_ack(pcb);
 800ecf8:	4620      	mov	r0, r4
 800ecfa:	f001 f987 	bl	801000c <tcp_send_empty_ack>
 800ecfe:	e7e5      	b.n	800eccc <tcp_input+0x46c>
 800ed00:	08017064 	.word	0x08017064
 800ed04:	08017418 	.word	0x08017418
 800ed08:	08015744 	.word	0x08015744
 800ed0c:	240141b4 	.word	0x240141b4
 800ed10:	08017444 	.word	0x08017444
 800ed14:	24014314 	.word	0x24014314
 800ed18:	24014310 	.word	0x24014310
 800ed1c:	240142f0 	.word	0x240142f0
 800ed20:	240142f4 	.word	0x240142f4
 800ed24:	240142f8 	.word	0x240142f8
 800ed28:	240142f5 	.word	0x240142f5
 800ed2c:	240142f6 	.word	0x240142f6
 800ed30:	240142ec 	.word	0x240142ec
 800ed34:	240142dc 	.word	0x240142dc
 800ed38:	240142d8 	.word	0x240142d8
 800ed3c:	08017470 	.word	0x08017470
 800ed40:	2400c4b0 	.word	0x2400c4b0
 800ed44:	240142e0 	.word	0x240142e0
        if (recv_acked > 0) {
 800ed48:	4b46      	ldr	r3, [pc, #280]	@ (800ee64 <tcp_input+0x604>)
 800ed4a:	881a      	ldrh	r2, [r3, #0]
 800ed4c:	b15a      	cbz	r2, 800ed66 <tcp_input+0x506>
            TCP_EVENT_SENT(pcb, (u16_t)acked16, err);
 800ed4e:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 800ed52:	b12b      	cbz	r3, 800ed60 <tcp_input+0x500>
 800ed54:	4621      	mov	r1, r4
 800ed56:	6920      	ldr	r0, [r4, #16]
 800ed58:	4798      	blx	r3
            if (err == ERR_ABRT) {
 800ed5a:	f110 0f0d 	cmn.w	r0, #13
 800ed5e:	d0bb      	beq.n	800ecd8 <tcp_input+0x478>
          recv_acked = 0;
 800ed60:	4b40      	ldr	r3, [pc, #256]	@ (800ee64 <tcp_input+0x604>)
 800ed62:	2200      	movs	r2, #0
 800ed64:	801a      	strh	r2, [r3, #0]
        if (tcp_input_delayed_close(pcb)) {
 800ed66:	4620      	mov	r0, r4
 800ed68:	f7fe fc28 	bl	800d5bc <tcp_input_delayed_close>
 800ed6c:	2800      	cmp	r0, #0
 800ed6e:	d1b3      	bne.n	800ecd8 <tcp_input+0x478>
        if (recv_data != NULL) {
 800ed70:	4b3d      	ldr	r3, [pc, #244]	@ (800ee68 <tcp_input+0x608>)
 800ed72:	681b      	ldr	r3, [r3, #0]
 800ed74:	b1e3      	cbz	r3, 800edb0 <tcp_input+0x550>
          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
 800ed76:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
 800ed78:	b133      	cbz	r3, 800ed88 <tcp_input+0x528>
 800ed7a:	4b3c      	ldr	r3, [pc, #240]	@ (800ee6c <tcp_input+0x60c>)
 800ed7c:	f44f 72f3 	mov.w	r2, #486	@ 0x1e6
 800ed80:	493b      	ldr	r1, [pc, #236]	@ (800ee70 <tcp_input+0x610>)
 800ed82:	483c      	ldr	r0, [pc, #240]	@ (800ee74 <tcp_input+0x614>)
 800ed84:	f005 f8fc 	bl	8013f80 <iprintf>
          if (pcb->flags & TF_RXCLOSED) {
 800ed88:	8b63      	ldrh	r3, [r4, #26]
 800ed8a:	f013 0f10 	tst.w	r3, #16
 800ed8e:	d126      	bne.n	800edde <tcp_input+0x57e>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 800ed90:	f8d4 5084 	ldr.w	r5, [r4, #132]	@ 0x84
 800ed94:	b35d      	cbz	r5, 800edee <tcp_input+0x58e>
 800ed96:	2300      	movs	r3, #0
 800ed98:	4a33      	ldr	r2, [pc, #204]	@ (800ee68 <tcp_input+0x608>)
 800ed9a:	6812      	ldr	r2, [r2, #0]
 800ed9c:	4621      	mov	r1, r4
 800ed9e:	6920      	ldr	r0, [r4, #16]
 800eda0:	47a8      	blx	r5
          if (err == ERR_ABRT) {
 800eda2:	f110 0f0d 	cmn.w	r0, #13
 800eda6:	d097      	beq.n	800ecd8 <tcp_input+0x478>
          if (err != ERR_OK) {
 800eda8:	b110      	cbz	r0, 800edb0 <tcp_input+0x550>
            pcb->refused_data = recv_data;
 800edaa:	4b2f      	ldr	r3, [pc, #188]	@ (800ee68 <tcp_input+0x608>)
 800edac:	681b      	ldr	r3, [r3, #0]
 800edae:	67a3      	str	r3, [r4, #120]	@ 0x78
        if (recv_flags & TF_GOT_FIN) {
 800edb0:	4b31      	ldr	r3, [pc, #196]	@ (800ee78 <tcp_input+0x618>)
 800edb2:	781b      	ldrb	r3, [r3, #0]
 800edb4:	f013 0f20 	tst.w	r3, #32
 800edb8:	d005      	beq.n	800edc6 <tcp_input+0x566>
          if (pcb->refused_data != NULL) {
 800edba:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
 800edbc:	b1fb      	cbz	r3, 800edfe <tcp_input+0x59e>
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
 800edbe:	7b5a      	ldrb	r2, [r3, #13]
 800edc0:	f042 0220 	orr.w	r2, r2, #32
 800edc4:	735a      	strb	r2, [r3, #13]
        tcp_input_pcb = NULL;
 800edc6:	4b2d      	ldr	r3, [pc, #180]	@ (800ee7c <tcp_input+0x61c>)
 800edc8:	2200      	movs	r2, #0
 800edca:	601a      	str	r2, [r3, #0]
        if (tcp_input_delayed_close(pcb)) {
 800edcc:	4620      	mov	r0, r4
 800edce:	f7fe fbf5 	bl	800d5bc <tcp_input_delayed_close>
 800edd2:	2800      	cmp	r0, #0
 800edd4:	d180      	bne.n	800ecd8 <tcp_input+0x478>
        tcp_output(pcb);
 800edd6:	4620      	mov	r0, r4
 800edd8:	f001 f952 	bl	8010080 <tcp_output>
 800eddc:	e77c      	b.n	800ecd8 <tcp_input+0x478>
            pbuf_free(recv_data);
 800edde:	4b22      	ldr	r3, [pc, #136]	@ (800ee68 <tcp_input+0x608>)
 800ede0:	6818      	ldr	r0, [r3, #0]
 800ede2:	f7fc fea5 	bl	800bb30 <pbuf_free>
            tcp_abort(pcb);
 800ede6:	4620      	mov	r0, r4
 800ede8:	f7fd fdf8 	bl	800c9dc <tcp_abort>
            goto aborted;
 800edec:	e774      	b.n	800ecd8 <tcp_input+0x478>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 800edee:	2300      	movs	r3, #0
 800edf0:	4a1d      	ldr	r2, [pc, #116]	@ (800ee68 <tcp_input+0x608>)
 800edf2:	6812      	ldr	r2, [r2, #0]
 800edf4:	4621      	mov	r1, r4
 800edf6:	4618      	mov	r0, r3
 800edf8:	f7fe f81e 	bl	800ce38 <tcp_recv_null>
 800edfc:	e7d1      	b.n	800eda2 <tcp_input+0x542>
            if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 800edfe:	8d23      	ldrh	r3, [r4, #40]	@ 0x28
 800ee00:	f241 62d0 	movw	r2, #5840	@ 0x16d0
 800ee04:	4293      	cmp	r3, r2
 800ee06:	d001      	beq.n	800ee0c <tcp_input+0x5ac>
              pcb->rcv_wnd++;
 800ee08:	3301      	adds	r3, #1
 800ee0a:	8523      	strh	r3, [r4, #40]	@ 0x28
            TCP_EVENT_CLOSED(pcb, err);
 800ee0c:	f8d4 5084 	ldr.w	r5, [r4, #132]	@ 0x84
 800ee10:	2d00      	cmp	r5, #0
 800ee12:	d0d8      	beq.n	800edc6 <tcp_input+0x566>
 800ee14:	2300      	movs	r3, #0
 800ee16:	461a      	mov	r2, r3
 800ee18:	4621      	mov	r1, r4
 800ee1a:	6920      	ldr	r0, [r4, #16]
 800ee1c:	47a8      	blx	r5
            if (err == ERR_ABRT) {
 800ee1e:	f110 0f0d 	cmn.w	r0, #13
 800ee22:	d1d0      	bne.n	800edc6 <tcp_input+0x566>
 800ee24:	e758      	b.n	800ecd8 <tcp_input+0x478>
      TCP_STATS_INC(tcp.proterr);
 800ee26:	4b16      	ldr	r3, [pc, #88]	@ (800ee80 <tcp_input+0x620>)
 800ee28:	f8b3 20bc 	ldrh.w	r2, [r3, #188]	@ 0xbc
 800ee2c:	3201      	adds	r2, #1
 800ee2e:	f8a3 20bc 	strh.w	r2, [r3, #188]	@ 0xbc
      TCP_STATS_INC(tcp.drop);
 800ee32:	f8b3 20b2 	ldrh.w	r2, [r3, #178]	@ 0xb2
 800ee36:	3201      	adds	r2, #1
 800ee38:	f8a3 20b2 	strh.w	r2, [r3, #178]	@ 0xb2
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800ee3c:	4b11      	ldr	r3, [pc, #68]	@ (800ee84 <tcp_input+0x624>)
 800ee3e:	6819      	ldr	r1, [r3, #0]
      tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
 800ee40:	4b11      	ldr	r3, [pc, #68]	@ (800ee88 <tcp_input+0x628>)
 800ee42:	4a12      	ldr	r2, [pc, #72]	@ (800ee8c <tcp_input+0x62c>)
 800ee44:	8810      	ldrh	r0, [r2, #0]
 800ee46:	4a12      	ldr	r2, [pc, #72]	@ (800ee90 <tcp_input+0x630>)
 800ee48:	6812      	ldr	r2, [r2, #0]
 800ee4a:	880c      	ldrh	r4, [r1, #0]
 800ee4c:	9402      	str	r4, [sp, #8]
 800ee4e:	8849      	ldrh	r1, [r1, #2]
 800ee50:	9101      	str	r1, [sp, #4]
 800ee52:	1f19      	subs	r1, r3, #4
 800ee54:	9100      	str	r1, [sp, #0]
 800ee56:	4402      	add	r2, r0
 800ee58:	490e      	ldr	r1, [pc, #56]	@ (800ee94 <tcp_input+0x634>)
 800ee5a:	6809      	ldr	r1, [r1, #0]
 800ee5c:	2000      	movs	r0, #0
 800ee5e:	f001 f88d 	bl	800ff7c <tcp_rst>
 800ee62:	e639      	b.n	800ead8 <tcp_input+0x278>
 800ee64:	240142f8 	.word	0x240142f8
 800ee68:	240142f0 	.word	0x240142f0
 800ee6c:	08017064 	.word	0x08017064
 800ee70:	080174a0 	.word	0x080174a0
 800ee74:	08015744 	.word	0x08015744
 800ee78:	240142f4 	.word	0x240142f4
 800ee7c:	240142ec 	.word	0x240142ec
 800ee80:	240141b4 	.word	0x240141b4
 800ee84:	24014310 	.word	0x24014310
 800ee88:	2400c4c4 	.word	0x2400c4c4
 800ee8c:	240142f6 	.word	0x240142f6
 800ee90:	24014300 	.word	0x24014300
 800ee94:	240142fc 	.word	0x240142fc

0800ee98 <tcp_trigger_input_pcb_close>:

void
tcp_trigger_input_pcb_close(void)
{
  recv_flags |= TF_CLOSED;
 800ee98:	4a02      	ldr	r2, [pc, #8]	@ (800eea4 <tcp_trigger_input_pcb_close+0xc>)
 800ee9a:	7813      	ldrb	r3, [r2, #0]
 800ee9c:	f043 0310 	orr.w	r3, r3, #16
 800eea0:	7013      	strb	r3, [r2, #0]
}
 800eea2:	4770      	bx	lr
 800eea4:	240142f4 	.word	0x240142f4

0800eea8 <tcp_write_checks>:
 * @param len length of data to send (checked agains snd_buf)
 * @return ERR_OK if tcp_write is allowed to proceed, another err_t otherwise
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
 800eea8:	b538      	push	{r3, r4, r5, lr}
 800eeaa:	460c      	mov	r4, r1
  LWIP_ASSERT("tcp_write_checks: invalid pcb", pcb != NULL);
 800eeac:	4605      	mov	r5, r0
 800eeae:	b1b8      	cbz	r0, 800eee0 <tcp_write_checks+0x38>

  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
 800eeb0:	7d2b      	ldrb	r3, [r5, #20]
 800eeb2:	2b04      	cmp	r3, #4
 800eeb4:	bf18      	it	ne
 800eeb6:	2b07      	cmpne	r3, #7
 800eeb8:	d003      	beq.n	800eec2 <tcp_write_checks+0x1a>
      (pcb->state != CLOSE_WAIT) &&
 800eeba:	2b02      	cmp	r3, #2
 800eebc:	d001      	beq.n	800eec2 <tcp_write_checks+0x1a>
      (pcb->state != SYN_SENT) &&
 800eebe:	2b03      	cmp	r3, #3
 800eec0:	d147      	bne.n	800ef52 <tcp_write_checks+0xaa>
      (pcb->state != SYN_RCVD)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  } else if (len == 0) {
 800eec2:	2c00      	cmp	r4, #0
 800eec4:	d048      	beq.n	800ef58 <tcp_write_checks+0xb0>
    return ERR_OK;
  }

  /* fail on too much data */
  if (len > pcb->snd_buf) {
 800eec6:	f8b5 3064 	ldrh.w	r3, [r5, #100]	@ 0x64
 800eeca:	42a3      	cmp	r3, r4
 800eecc:	d310      	bcc.n	800eef0 <tcp_write_checks+0x48>
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if (pcb->snd_queuelen >= LWIP_MIN(TCP_SND_QUEUELEN, (TCP_SNDQUEUELEN_OVERFLOW + 1))) {
 800eece:	f8b5 3066 	ldrh.w	r3, [r5, #102]	@ 0x66
 800eed2:	2b0f      	cmp	r3, #15
 800eed4:	d813      	bhi.n	800eefe <tcp_write_checks+0x56>
                pcb->snd_queuelen, (u16_t)TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
    return ERR_MEM;
  }
  if (pcb->snd_queuelen != 0) {
 800eed6:	b363      	cbz	r3, 800ef32 <tcp_write_checks+0x8a>
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
 800eed8:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
 800eeda:	b1eb      	cbz	r3, 800ef18 <tcp_write_checks+0x70>
                pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
                pcb->unacked == NULL && pcb->unsent == NULL);
  }
  return ERR_OK;
 800eedc:	2000      	movs	r0, #0
 800eede:	e03c      	b.n	800ef5a <tcp_write_checks+0xb2>
  LWIP_ASSERT("tcp_write_checks: invalid pcb", pcb != NULL);
 800eee0:	4b1e      	ldr	r3, [pc, #120]	@ (800ef5c <tcp_write_checks+0xb4>)
 800eee2:	f240 1233 	movw	r2, #307	@ 0x133
 800eee6:	491e      	ldr	r1, [pc, #120]	@ (800ef60 <tcp_write_checks+0xb8>)
 800eee8:	481e      	ldr	r0, [pc, #120]	@ (800ef64 <tcp_write_checks+0xbc>)
 800eeea:	f005 f849 	bl	8013f80 <iprintf>
 800eeee:	e7df      	b.n	800eeb0 <tcp_write_checks+0x8>
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 800eef0:	8b6b      	ldrh	r3, [r5, #26]
 800eef2:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800eef6:	836b      	strh	r3, [r5, #26]
    return ERR_MEM;
 800eef8:	f04f 30ff 	mov.w	r0, #4294967295
 800eefc:	e02d      	b.n	800ef5a <tcp_write_checks+0xb2>
    TCP_STATS_INC(tcp.memerr);
 800eefe:	4a1a      	ldr	r2, [pc, #104]	@ (800ef68 <tcp_write_checks+0xc0>)
 800ef00:	f8b2 30b8 	ldrh.w	r3, [r2, #184]	@ 0xb8
 800ef04:	3301      	adds	r3, #1
 800ef06:	f8a2 30b8 	strh.w	r3, [r2, #184]	@ 0xb8
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 800ef0a:	8b6b      	ldrh	r3, [r5, #26]
 800ef0c:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800ef10:	836b      	strh	r3, [r5, #26]
    return ERR_MEM;
 800ef12:	f04f 30ff 	mov.w	r0, #4294967295
 800ef16:	e020      	b.n	800ef5a <tcp_write_checks+0xb2>
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
 800ef18:	6eeb      	ldr	r3, [r5, #108]	@ 0x6c
 800ef1a:	b10b      	cbz	r3, 800ef20 <tcp_write_checks+0x78>
  return ERR_OK;
 800ef1c:	2000      	movs	r0, #0
 800ef1e:	e01c      	b.n	800ef5a <tcp_write_checks+0xb2>
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
 800ef20:	4b0e      	ldr	r3, [pc, #56]	@ (800ef5c <tcp_write_checks+0xb4>)
 800ef22:	f240 1255 	movw	r2, #341	@ 0x155
 800ef26:	4911      	ldr	r1, [pc, #68]	@ (800ef6c <tcp_write_checks+0xc4>)
 800ef28:	480e      	ldr	r0, [pc, #56]	@ (800ef64 <tcp_write_checks+0xbc>)
 800ef2a:	f005 f829 	bl	8013f80 <iprintf>
  return ERR_OK;
 800ef2e:	2000      	movs	r0, #0
 800ef30:	e013      	b.n	800ef5a <tcp_write_checks+0xb2>
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
 800ef32:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
 800ef34:	b143      	cbz	r3, 800ef48 <tcp_write_checks+0xa0>
 800ef36:	4b09      	ldr	r3, [pc, #36]	@ (800ef5c <tcp_write_checks+0xb4>)
 800ef38:	f44f 72ac 	mov.w	r2, #344	@ 0x158
 800ef3c:	490c      	ldr	r1, [pc, #48]	@ (800ef70 <tcp_write_checks+0xc8>)
 800ef3e:	4809      	ldr	r0, [pc, #36]	@ (800ef64 <tcp_write_checks+0xbc>)
 800ef40:	f005 f81e 	bl	8013f80 <iprintf>
  return ERR_OK;
 800ef44:	2000      	movs	r0, #0
 800ef46:	e008      	b.n	800ef5a <tcp_write_checks+0xb2>
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
 800ef48:	6eeb      	ldr	r3, [r5, #108]	@ 0x6c
 800ef4a:	2b00      	cmp	r3, #0
 800ef4c:	d1f3      	bne.n	800ef36 <tcp_write_checks+0x8e>
  return ERR_OK;
 800ef4e:	2000      	movs	r0, #0
 800ef50:	e003      	b.n	800ef5a <tcp_write_checks+0xb2>
    return ERR_CONN;
 800ef52:	f06f 000a 	mvn.w	r0, #10
 800ef56:	e000      	b.n	800ef5a <tcp_write_checks+0xb2>
    return ERR_OK;
 800ef58:	2000      	movs	r0, #0
}
 800ef5a:	bd38      	pop	{r3, r4, r5, pc}
 800ef5c:	080174bc 	.word	0x080174bc
 800ef60:	080174f0 	.word	0x080174f0
 800ef64:	08015744 	.word	0x08015744
 800ef68:	240141b4 	.word	0x240141b4
 800ef6c:	08017510 	.word	0x08017510
 800ef70:	0801754c 	.word	0x0801754c

0800ef74 <tcp_output_segment_busy>:
 * @arg seg the tcp segment to check
 * @return 1 if ref != 1, 0 if ref == 1
 */
static int
tcp_output_segment_busy(const struct tcp_seg *seg)
{
 800ef74:	b510      	push	{r4, lr}
  LWIP_ASSERT("tcp_output_segment_busy: invalid seg", seg != NULL);
 800ef76:	4604      	mov	r4, r0
 800ef78:	b128      	cbz	r0, 800ef86 <tcp_output_segment_busy+0x12>

  /* We only need to check the first pbuf here:
     If a pbuf is queued for transmission, a driver calls pbuf_ref(),
     which only changes the ref count of the first pbuf */
  if (seg->p->ref != 1) {
 800ef7a:	6863      	ldr	r3, [r4, #4]
 800ef7c:	7b9b      	ldrb	r3, [r3, #14]
 800ef7e:	2b01      	cmp	r3, #1
 800ef80:	d109      	bne.n	800ef96 <tcp_output_segment_busy+0x22>
    /* other reference found */
    return 1;
  }
  /* no other references found */
  return 0;
 800ef82:	2000      	movs	r0, #0
}
 800ef84:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("tcp_output_segment_busy: invalid seg", seg != NULL);
 800ef86:	4b05      	ldr	r3, [pc, #20]	@ (800ef9c <tcp_output_segment_busy+0x28>)
 800ef88:	f240 529a 	movw	r2, #1434	@ 0x59a
 800ef8c:	4904      	ldr	r1, [pc, #16]	@ (800efa0 <tcp_output_segment_busy+0x2c>)
 800ef8e:	4805      	ldr	r0, [pc, #20]	@ (800efa4 <tcp_output_segment_busy+0x30>)
 800ef90:	f004 fff6 	bl	8013f80 <iprintf>
 800ef94:	e7f1      	b.n	800ef7a <tcp_output_segment_busy+0x6>
    return 1;
 800ef96:	2001      	movs	r0, #1
 800ef98:	e7f4      	b.n	800ef84 <tcp_output_segment_busy+0x10>
 800ef9a:	bf00      	nop
 800ef9c:	080174bc 	.word	0x080174bc
 800efa0:	08017580 	.word	0x08017580
 800efa4:	08015744 	.word	0x08015744

0800efa8 <tcp_output_fill_options>:
}

/* Fill in options for control segments */
static void
tcp_output_fill_options(const struct tcp_pcb *pcb, struct pbuf *p, u8_t optflags, u8_t num_sacks)
{
 800efa8:	b538      	push	{r3, r4, r5, lr}
 800efaa:	4614      	mov	r4, r2
  struct tcp_hdr *tcphdr;
  u32_t *opts;
  u16_t sacks_len = 0;

  LWIP_ASSERT("tcp_output_fill_options: invalid pbuf", p != NULL);
 800efac:	460d      	mov	r5, r1
 800efae:	b189      	cbz	r1, 800efd4 <tcp_output_fill_options+0x2c>

  tcphdr = (struct tcp_hdr *)p->payload;
 800efb0:	686b      	ldr	r3, [r5, #4]
  opts = (u32_t *)(void *)(tcphdr + 1);
 800efb2:	f103 0214 	add.w	r2, r3, #20
  opts = LWIP_HOOK_TCP_OUT_ADD_TCPOPTS(p, tcphdr, pcb, opts);
#endif

  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(sacks_len);
  LWIP_ASSERT("options not filled", (u8_t *)opts == ((u8_t *)(tcphdr + 1)) + sacks_len * 4 + LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb));
 800efb6:	00a4      	lsls	r4, r4, #2
 800efb8:	f004 0404 	and.w	r4, r4, #4
 800efbc:	3414      	adds	r4, #20
 800efbe:	4423      	add	r3, r4
 800efc0:	4293      	cmp	r3, r2
 800efc2:	d006      	beq.n	800efd2 <tcp_output_fill_options+0x2a>
 800efc4:	4b07      	ldr	r3, [pc, #28]	@ (800efe4 <tcp_output_fill_options+0x3c>)
 800efc6:	f240 7275 	movw	r2, #1909	@ 0x775
 800efca:	4907      	ldr	r1, [pc, #28]	@ (800efe8 <tcp_output_fill_options+0x40>)
 800efcc:	4807      	ldr	r0, [pc, #28]	@ (800efec <tcp_output_fill_options+0x44>)
 800efce:	f004 ffd7 	bl	8013f80 <iprintf>
  LWIP_UNUSED_ARG(optflags); /* for LWIP_NOASSERT */
  LWIP_UNUSED_ARG(opts); /* for LWIP_NOASSERT */
}
 800efd2:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("tcp_output_fill_options: invalid pbuf", p != NULL);
 800efd4:	4b03      	ldr	r3, [pc, #12]	@ (800efe4 <tcp_output_fill_options+0x3c>)
 800efd6:	f240 7256 	movw	r2, #1878	@ 0x756
 800efda:	4905      	ldr	r1, [pc, #20]	@ (800eff0 <tcp_output_fill_options+0x48>)
 800efdc:	4803      	ldr	r0, [pc, #12]	@ (800efec <tcp_output_fill_options+0x44>)
 800efde:	f004 ffcf 	bl	8013f80 <iprintf>
 800efe2:	e7e5      	b.n	800efb0 <tcp_output_fill_options+0x8>
 800efe4:	080174bc 	.word	0x080174bc
 800efe8:	080175d0 	.word	0x080175d0
 800efec:	08015744 	.word	0x08015744
 800eff0:	080175a8 	.word	0x080175a8

0800eff4 <tcp_pbuf_prealloc>:
{
 800eff4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800eff8:	4606      	mov	r6, r0
 800effa:	460c      	mov	r4, r1
 800effc:	4615      	mov	r5, r2
 800effe:	9f08      	ldr	r7, [sp, #32]
 800f000:	f89d 9028 	ldrb.w	r9, [sp, #40]	@ 0x28
  LWIP_ASSERT("tcp_pbuf_prealloc: invalid oversize", oversize != NULL);
 800f004:	4698      	mov	r8, r3
 800f006:	b1cb      	cbz	r3, 800f03c <tcp_pbuf_prealloc+0x48>
  LWIP_ASSERT("tcp_pbuf_prealloc: invalid pcb", pcb != NULL);
 800f008:	b1ff      	cbz	r7, 800f04a <tcp_pbuf_prealloc+0x56>
  if (length < max_length) {
 800f00a:	42ac      	cmp	r4, r5
 800f00c:	d229      	bcs.n	800f062 <tcp_pbuf_prealloc+0x6e>
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 800f00e:	f89d 3024 	ldrb.w	r3, [sp, #36]	@ 0x24
 800f012:	f013 0f02 	tst.w	r3, #2
 800f016:	d108      	bne.n	800f02a <tcp_pbuf_prealloc+0x36>
        (!(pcb->flags & TF_NODELAY) &&
 800f018:	8b7b      	ldrh	r3, [r7, #26]
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 800f01a:	f013 0f40 	tst.w	r3, #64	@ 0x40
 800f01e:	d13a      	bne.n	800f096 <tcp_pbuf_prealloc+0xa2>
        (!(pcb->flags & TF_NODELAY) &&
 800f020:	f1b9 0f00 	cmp.w	r9, #0
 800f024:	d001      	beq.n	800f02a <tcp_pbuf_prealloc+0x36>
          pcb->unsent != NULL ||
 800f026:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
         (!first_seg ||
 800f028:	b1b3      	cbz	r3, 800f058 <tcp_pbuf_prealloc+0x64>
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(TCP_OVERSIZE_CALC_LENGTH(length)));
 800f02a:	f204 53b7 	addw	r3, r4, #1463	@ 0x5b7
 800f02e:	f023 0303 	bic.w	r3, r3, #3
 800f032:	429d      	cmp	r5, r3
 800f034:	bf28      	it	cs
 800f036:	461d      	movcs	r5, r3
 800f038:	b2a9      	uxth	r1, r5
 800f03a:	e013      	b.n	800f064 <tcp_pbuf_prealloc+0x70>
  LWIP_ASSERT("tcp_pbuf_prealloc: invalid oversize", oversize != NULL);
 800f03c:	4b17      	ldr	r3, [pc, #92]	@ (800f09c <tcp_pbuf_prealloc+0xa8>)
 800f03e:	22e8      	movs	r2, #232	@ 0xe8
 800f040:	4917      	ldr	r1, [pc, #92]	@ (800f0a0 <tcp_pbuf_prealloc+0xac>)
 800f042:	4818      	ldr	r0, [pc, #96]	@ (800f0a4 <tcp_pbuf_prealloc+0xb0>)
 800f044:	f004 ff9c 	bl	8013f80 <iprintf>
 800f048:	e7de      	b.n	800f008 <tcp_pbuf_prealloc+0x14>
  LWIP_ASSERT("tcp_pbuf_prealloc: invalid pcb", pcb != NULL);
 800f04a:	4b14      	ldr	r3, [pc, #80]	@ (800f09c <tcp_pbuf_prealloc+0xa8>)
 800f04c:	22e9      	movs	r2, #233	@ 0xe9
 800f04e:	4916      	ldr	r1, [pc, #88]	@ (800f0a8 <tcp_pbuf_prealloc+0xb4>)
 800f050:	4814      	ldr	r0, [pc, #80]	@ (800f0a4 <tcp_pbuf_prealloc+0xb0>)
 800f052:	f004 ff95 	bl	8013f80 <iprintf>
 800f056:	e7d8      	b.n	800f00a <tcp_pbuf_prealloc+0x16>
          pcb->unacked != NULL))) {
 800f058:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
          pcb->unsent != NULL ||
 800f05a:	2b00      	cmp	r3, #0
 800f05c:	d1e5      	bne.n	800f02a <tcp_pbuf_prealloc+0x36>
  u16_t alloc = length;
 800f05e:	4621      	mov	r1, r4
 800f060:	e000      	b.n	800f064 <tcp_pbuf_prealloc+0x70>
 800f062:	4621      	mov	r1, r4
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
 800f064:	f44f 7220 	mov.w	r2, #640	@ 0x280
 800f068:	4630      	mov	r0, r6
 800f06a:	f7fc fdc9 	bl	800bc00 <pbuf_alloc>
  if (p == NULL) {
 800f06e:	4605      	mov	r5, r0
 800f070:	b170      	cbz	r0, 800f090 <tcp_pbuf_prealloc+0x9c>
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
 800f072:	6803      	ldr	r3, [r0, #0]
 800f074:	b133      	cbz	r3, 800f084 <tcp_pbuf_prealloc+0x90>
 800f076:	4b09      	ldr	r3, [pc, #36]	@ (800f09c <tcp_pbuf_prealloc+0xa8>)
 800f078:	f240 120b 	movw	r2, #267	@ 0x10b
 800f07c:	490b      	ldr	r1, [pc, #44]	@ (800f0ac <tcp_pbuf_prealloc+0xb8>)
 800f07e:	4809      	ldr	r0, [pc, #36]	@ (800f0a4 <tcp_pbuf_prealloc+0xb0>)
 800f080:	f004 ff7e 	bl	8013f80 <iprintf>
  *oversize = p->len - length;
 800f084:	896b      	ldrh	r3, [r5, #10]
 800f086:	1b1b      	subs	r3, r3, r4
 800f088:	f8a8 3000 	strh.w	r3, [r8]
  p->len = p->tot_len = length;
 800f08c:	812c      	strh	r4, [r5, #8]
 800f08e:	816c      	strh	r4, [r5, #10]
}
 800f090:	4628      	mov	r0, r5
 800f092:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  u16_t alloc = length;
 800f096:	4621      	mov	r1, r4
 800f098:	e7e4      	b.n	800f064 <tcp_pbuf_prealloc+0x70>
 800f09a:	bf00      	nop
 800f09c:	080174bc 	.word	0x080174bc
 800f0a0:	080175e4 	.word	0x080175e4
 800f0a4:	08015744 	.word	0x08015744
 800f0a8:	08017608 	.word	0x08017608
 800f0ac:	08017628 	.word	0x08017628

0800f0b0 <tcp_create_segment>:
{
 800f0b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800f0b4:	460e      	mov	r6, r1
 800f0b6:	4617      	mov	r7, r2
 800f0b8:	4698      	mov	r8, r3
 800f0ba:	f89d a020 	ldrb.w	sl, [sp, #32]
  LWIP_ASSERT("tcp_create_segment: invalid pcb", pcb != NULL);
 800f0be:	4681      	mov	r9, r0
 800f0c0:	2800      	cmp	r0, #0
 800f0c2:	d040      	beq.n	800f146 <tcp_create_segment+0x96>
  LWIP_ASSERT("tcp_create_segment: invalid pbuf", p != NULL);
 800f0c4:	2e00      	cmp	r6, #0
 800f0c6:	d045      	beq.n	800f154 <tcp_create_segment+0xa4>
  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
 800f0c8:	ea4f 058a 	mov.w	r5, sl, lsl #2
 800f0cc:	f005 0504 	and.w	r5, r5, #4
  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 800f0d0:	2003      	movs	r0, #3
 800f0d2:	f7fc f9db 	bl	800b48c <memp_malloc>
 800f0d6:	4604      	mov	r4, r0
 800f0d8:	2800      	cmp	r0, #0
 800f0da:	d042      	beq.n	800f162 <tcp_create_segment+0xb2>
  seg->flags = optflags;
 800f0dc:	f880 a00c 	strb.w	sl, [r0, #12]
  seg->next = NULL;
 800f0e0:	2300      	movs	r3, #0
 800f0e2:	6003      	str	r3, [r0, #0]
  seg->p = p;
 800f0e4:	6046      	str	r6, [r0, #4]
  LWIP_ASSERT("p->tot_len >= optlen", p->tot_len >= optlen);
 800f0e6:	8933      	ldrh	r3, [r6, #8]
 800f0e8:	42ab      	cmp	r3, r5
 800f0ea:	d33e      	bcc.n	800f16a <tcp_create_segment+0xba>
  seg->len = p->tot_len - optlen;
 800f0ec:	8931      	ldrh	r1, [r6, #8]
 800f0ee:	1b49      	subs	r1, r1, r5
 800f0f0:	8121      	strh	r1, [r4, #8]
  seg->oversize_left = 0;
 800f0f2:	2300      	movs	r3, #0
 800f0f4:	8163      	strh	r3, [r4, #10]
  if (pbuf_add_header(p, TCP_HLEN)) {
 800f0f6:	2114      	movs	r1, #20
 800f0f8:	4630      	mov	r0, r6
 800f0fa:	f7fc fcce 	bl	800ba9a <pbuf_add_header>
 800f0fe:	2800      	cmp	r0, #0
 800f100:	d13a      	bne.n	800f178 <tcp_create_segment+0xc8>
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 800f102:	6863      	ldr	r3, [r4, #4]
 800f104:	685e      	ldr	r6, [r3, #4]
 800f106:	6126      	str	r6, [r4, #16]
  seg->tcphdr->src = lwip_htons(pcb->local_port);
 800f108:	f8b9 0016 	ldrh.w	r0, [r9, #22]
 800f10c:	f7fb fd28 	bl	800ab60 <lwip_htons>
 800f110:	8030      	strh	r0, [r6, #0]
  seg->tcphdr->dest = lwip_htons(pcb->remote_port);
 800f112:	6926      	ldr	r6, [r4, #16]
 800f114:	f8b9 0018 	ldrh.w	r0, [r9, #24]
 800f118:	f7fb fd22 	bl	800ab60 <lwip_htons>
 800f11c:	8070      	strh	r0, [r6, #2]
  seg->tcphdr->seqno = lwip_htonl(seqno);
 800f11e:	6926      	ldr	r6, [r4, #16]
 800f120:	4640      	mov	r0, r8
 800f122:	f7fb fd22 	bl	800ab6a <lwip_htonl>
 800f126:	6070      	str	r0, [r6, #4]
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), hdrflags);
 800f128:	08a8      	lsrs	r0, r5, #2
 800f12a:	3005      	adds	r0, #5
 800f12c:	6925      	ldr	r5, [r4, #16]
 800f12e:	ea47 3000 	orr.w	r0, r7, r0, lsl #12
 800f132:	f7fb fd15 	bl	800ab60 <lwip_htons>
 800f136:	81a8      	strh	r0, [r5, #12]
  seg->tcphdr->urgp = 0;
 800f138:	6923      	ldr	r3, [r4, #16]
 800f13a:	2200      	movs	r2, #0
 800f13c:	749a      	strb	r2, [r3, #18]
 800f13e:	74da      	strb	r2, [r3, #19]
}
 800f140:	4620      	mov	r0, r4
 800f142:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  LWIP_ASSERT("tcp_create_segment: invalid pcb", pcb != NULL);
 800f146:	4b12      	ldr	r3, [pc, #72]	@ (800f190 <tcp_create_segment+0xe0>)
 800f148:	22a3      	movs	r2, #163	@ 0xa3
 800f14a:	4912      	ldr	r1, [pc, #72]	@ (800f194 <tcp_create_segment+0xe4>)
 800f14c:	4812      	ldr	r0, [pc, #72]	@ (800f198 <tcp_create_segment+0xe8>)
 800f14e:	f004 ff17 	bl	8013f80 <iprintf>
 800f152:	e7b7      	b.n	800f0c4 <tcp_create_segment+0x14>
  LWIP_ASSERT("tcp_create_segment: invalid pbuf", p != NULL);
 800f154:	4b0e      	ldr	r3, [pc, #56]	@ (800f190 <tcp_create_segment+0xe0>)
 800f156:	22a4      	movs	r2, #164	@ 0xa4
 800f158:	4910      	ldr	r1, [pc, #64]	@ (800f19c <tcp_create_segment+0xec>)
 800f15a:	480f      	ldr	r0, [pc, #60]	@ (800f198 <tcp_create_segment+0xe8>)
 800f15c:	f004 ff10 	bl	8013f80 <iprintf>
 800f160:	e7b2      	b.n	800f0c8 <tcp_create_segment+0x18>
    pbuf_free(p);
 800f162:	4630      	mov	r0, r6
 800f164:	f7fc fce4 	bl	800bb30 <pbuf_free>
    return NULL;
 800f168:	e7ea      	b.n	800f140 <tcp_create_segment+0x90>
  LWIP_ASSERT("p->tot_len >= optlen", p->tot_len >= optlen);
 800f16a:	4b09      	ldr	r3, [pc, #36]	@ (800f190 <tcp_create_segment+0xe0>)
 800f16c:	22b0      	movs	r2, #176	@ 0xb0
 800f16e:	490c      	ldr	r1, [pc, #48]	@ (800f1a0 <tcp_create_segment+0xf0>)
 800f170:	4809      	ldr	r0, [pc, #36]	@ (800f198 <tcp_create_segment+0xe8>)
 800f172:	f004 ff05 	bl	8013f80 <iprintf>
 800f176:	e7b9      	b.n	800f0ec <tcp_create_segment+0x3c>
    TCP_STATS_INC(tcp.err);
 800f178:	4a0a      	ldr	r2, [pc, #40]	@ (800f1a4 <tcp_create_segment+0xf4>)
 800f17a:	f8b2 30c0 	ldrh.w	r3, [r2, #192]	@ 0xc0
 800f17e:	3301      	adds	r3, #1
 800f180:	f8a2 30c0 	strh.w	r3, [r2, #192]	@ 0xc0
    tcp_seg_free(seg);
 800f184:	4620      	mov	r0, r4
 800f186:	f7fd fa07 	bl	800c598 <tcp_seg_free>
    return NULL;
 800f18a:	2400      	movs	r4, #0
 800f18c:	e7d8      	b.n	800f140 <tcp_create_segment+0x90>
 800f18e:	bf00      	nop
 800f190:	080174bc 	.word	0x080174bc
 800f194:	0801763c 	.word	0x0801763c
 800f198:	08015744 	.word	0x08015744
 800f19c:	0801765c 	.word	0x0801765c
 800f1a0:	08017680 	.word	0x08017680
 800f1a4:	240141b4 	.word	0x240141b4

0800f1a8 <tcp_output_alloc_header_common>:
{
 800f1a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800f1ac:	4606      	mov	r6, r0
 800f1ae:	460c      	mov	r4, r1
 800f1b0:	4698      	mov	r8, r3
  p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 800f1b2:	4411      	add	r1, r2
 800f1b4:	b289      	uxth	r1, r1
 800f1b6:	3114      	adds	r1, #20
 800f1b8:	f44f 7220 	mov.w	r2, #640	@ 0x280
 800f1bc:	b289      	uxth	r1, r1
 800f1be:	2022      	movs	r0, #34	@ 0x22
 800f1c0:	f7fc fd1e 	bl	800bc00 <pbuf_alloc>
  if (p != NULL) {
 800f1c4:	4607      	mov	r7, r0
 800f1c6:	b348      	cbz	r0, 800f21c <tcp_output_alloc_header_common+0x74>
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 800f1c8:	f104 0313 	add.w	r3, r4, #19
 800f1cc:	8942      	ldrh	r2, [r0, #10]
 800f1ce:	4293      	cmp	r3, r2
 800f1d0:	da27      	bge.n	800f222 <tcp_output_alloc_header_common+0x7a>
    tcphdr = (struct tcp_hdr *)p->payload;
 800f1d2:	687d      	ldr	r5, [r7, #4]
    tcphdr->src = lwip_htons(src_port);
 800f1d4:	f8bd 0018 	ldrh.w	r0, [sp, #24]
 800f1d8:	f7fb fcc2 	bl	800ab60 <lwip_htons>
 800f1dc:	8028      	strh	r0, [r5, #0]
    tcphdr->dest = lwip_htons(dst_port);
 800f1de:	f8bd 001c 	ldrh.w	r0, [sp, #28]
 800f1e2:	f7fb fcbd 	bl	800ab60 <lwip_htons>
 800f1e6:	8068      	strh	r0, [r5, #2]
    tcphdr->seqno = seqno_be;
 800f1e8:	f8c5 8004 	str.w	r8, [r5, #4]
    tcphdr->ackno = lwip_htonl(ackno);
 800f1ec:	4630      	mov	r0, r6
 800f1ee:	f7fb fcbc 	bl	800ab6a <lwip_htonl>
 800f1f2:	60a8      	str	r0, [r5, #8]
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), flags);
 800f1f4:	08a4      	lsrs	r4, r4, #2
 800f1f6:	3405      	adds	r4, #5
 800f1f8:	0324      	lsls	r4, r4, #12
 800f1fa:	b2a4      	uxth	r4, r4
 800f1fc:	f89d 0020 	ldrb.w	r0, [sp, #32]
 800f200:	4320      	orrs	r0, r4
 800f202:	f7fb fcad 	bl	800ab60 <lwip_htons>
 800f206:	81a8      	strh	r0, [r5, #12]
    tcphdr->wnd = lwip_htons(wnd);
 800f208:	f8bd 0024 	ldrh.w	r0, [sp, #36]	@ 0x24
 800f20c:	f7fb fca8 	bl	800ab60 <lwip_htons>
 800f210:	81e8      	strh	r0, [r5, #14]
    tcphdr->chksum = 0;
 800f212:	2300      	movs	r3, #0
 800f214:	742b      	strb	r3, [r5, #16]
 800f216:	746b      	strb	r3, [r5, #17]
    tcphdr->urgp = 0;
 800f218:	74ab      	strb	r3, [r5, #18]
 800f21a:	74eb      	strb	r3, [r5, #19]
}
 800f21c:	4638      	mov	r0, r7
 800f21e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 800f222:	4b04      	ldr	r3, [pc, #16]	@ (800f234 <tcp_output_alloc_header_common+0x8c>)
 800f224:	f240 7223 	movw	r2, #1827	@ 0x723
 800f228:	4903      	ldr	r1, [pc, #12]	@ (800f238 <tcp_output_alloc_header_common+0x90>)
 800f22a:	4804      	ldr	r0, [pc, #16]	@ (800f23c <tcp_output_alloc_header_common+0x94>)
 800f22c:	f004 fea8 	bl	8013f80 <iprintf>
 800f230:	e7cf      	b.n	800f1d2 <tcp_output_alloc_header_common+0x2a>
 800f232:	bf00      	nop
 800f234:	080174bc 	.word	0x080174bc
 800f238:	08017698 	.word	0x08017698
 800f23c:	08015744 	.word	0x08015744

0800f240 <tcp_output_alloc_header>:
{
 800f240:	b5f0      	push	{r4, r5, r6, r7, lr}
 800f242:	b085      	sub	sp, #20
 800f244:	460d      	mov	r5, r1
 800f246:	4616      	mov	r6, r2
 800f248:	461f      	mov	r7, r3
  LWIP_ASSERT("tcp_output_alloc_header: invalid pcb", pcb != NULL);
 800f24a:	4604      	mov	r4, r0
 800f24c:	b1a0      	cbz	r0, 800f278 <tcp_output_alloc_header+0x38>
  p = tcp_output_alloc_header_common(pcb->rcv_nxt, optlen, datalen,
 800f24e:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
 800f250:	9303      	str	r3, [sp, #12]
 800f252:	2310      	movs	r3, #16
 800f254:	9302      	str	r3, [sp, #8]
 800f256:	8b23      	ldrh	r3, [r4, #24]
 800f258:	9301      	str	r3, [sp, #4]
 800f25a:	8ae3      	ldrh	r3, [r4, #22]
 800f25c:	9300      	str	r3, [sp, #0]
 800f25e:	463b      	mov	r3, r7
 800f260:	4632      	mov	r2, r6
 800f262:	4629      	mov	r1, r5
 800f264:	6a60      	ldr	r0, [r4, #36]	@ 0x24
 800f266:	f7ff ff9f 	bl	800f1a8 <tcp_output_alloc_header_common>
  if (p != NULL) {
 800f26a:	b118      	cbz	r0, 800f274 <tcp_output_alloc_header+0x34>
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 800f26c:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 800f26e:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
 800f270:	4413      	add	r3, r2
 800f272:	62e3      	str	r3, [r4, #44]	@ 0x2c
}
 800f274:	b005      	add	sp, #20
 800f276:	bdf0      	pop	{r4, r5, r6, r7, pc}
  LWIP_ASSERT("tcp_output_alloc_header: invalid pcb", pcb != NULL);
 800f278:	4b03      	ldr	r3, [pc, #12]	@ (800f288 <tcp_output_alloc_header+0x48>)
 800f27a:	f240 7242 	movw	r2, #1858	@ 0x742
 800f27e:	4903      	ldr	r1, [pc, #12]	@ (800f28c <tcp_output_alloc_header+0x4c>)
 800f280:	4803      	ldr	r0, [pc, #12]	@ (800f290 <tcp_output_alloc_header+0x50>)
 800f282:	f004 fe7d 	bl	8013f80 <iprintf>
 800f286:	e7e2      	b.n	800f24e <tcp_output_alloc_header+0xe>
 800f288:	080174bc 	.word	0x080174bc
 800f28c:	080176c8 	.word	0x080176c8
 800f290:	08015744 	.word	0x08015744

0800f294 <tcp_route>:
{
 800f294:	b508      	push	{r3, lr}
  if ((pcb != NULL) && (pcb->netif_idx != NETIF_NO_INDEX)) {
 800f296:	b108      	cbz	r0, 800f29c <tcp_route+0x8>
 800f298:	7a00      	ldrb	r0, [r0, #8]
 800f29a:	b918      	cbnz	r0, 800f2a4 <tcp_route+0x10>
    return ip_route(src, dst);
 800f29c:	4610      	mov	r0, r2
 800f29e:	f002 ffad 	bl	80121fc <ip4_route>
}
 800f2a2:	bd08      	pop	{r3, pc}
    return netif_get_by_index(pcb->netif_idx);
 800f2a4:	f7fc fb16 	bl	800b8d4 <netif_get_by_index>
 800f2a8:	e7fb      	b.n	800f2a2 <tcp_route+0xe>
	...

0800f2ac <tcp_output_segment>:
{
 800f2ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800f2b0:	b084      	sub	sp, #16
 800f2b2:	460c      	mov	r4, r1
 800f2b4:	4616      	mov	r6, r2
  LWIP_ASSERT("tcp_output_segment: invalid seg", seg != NULL);
 800f2b6:	4605      	mov	r5, r0
 800f2b8:	b148      	cbz	r0, 800f2ce <tcp_output_segment+0x22>
  LWIP_ASSERT("tcp_output_segment: invalid pcb", pcb != NULL);
 800f2ba:	b184      	cbz	r4, 800f2de <tcp_output_segment+0x32>
  LWIP_ASSERT("tcp_output_segment: invalid netif", netif != NULL);
 800f2bc:	b1be      	cbz	r6, 800f2ee <tcp_output_segment+0x42>
  if (tcp_output_segment_busy(seg)) {
 800f2be:	4628      	mov	r0, r5
 800f2c0:	f7ff fe58 	bl	800ef74 <tcp_output_segment_busy>
 800f2c4:	b1d8      	cbz	r0, 800f2fe <tcp_output_segment+0x52>
    return ERR_OK;
 800f2c6:	2000      	movs	r0, #0
}
 800f2c8:	b004      	add	sp, #16
 800f2ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ASSERT("tcp_output_segment: invalid seg", seg != NULL);
 800f2ce:	4b43      	ldr	r3, [pc, #268]	@ (800f3dc <tcp_output_segment+0x130>)
 800f2d0:	f44f 62b7 	mov.w	r2, #1464	@ 0x5b8
 800f2d4:	4942      	ldr	r1, [pc, #264]	@ (800f3e0 <tcp_output_segment+0x134>)
 800f2d6:	4843      	ldr	r0, [pc, #268]	@ (800f3e4 <tcp_output_segment+0x138>)
 800f2d8:	f004 fe52 	bl	8013f80 <iprintf>
 800f2dc:	e7ed      	b.n	800f2ba <tcp_output_segment+0xe>
  LWIP_ASSERT("tcp_output_segment: invalid pcb", pcb != NULL);
 800f2de:	4b3f      	ldr	r3, [pc, #252]	@ (800f3dc <tcp_output_segment+0x130>)
 800f2e0:	f240 52b9 	movw	r2, #1465	@ 0x5b9
 800f2e4:	4940      	ldr	r1, [pc, #256]	@ (800f3e8 <tcp_output_segment+0x13c>)
 800f2e6:	483f      	ldr	r0, [pc, #252]	@ (800f3e4 <tcp_output_segment+0x138>)
 800f2e8:	f004 fe4a 	bl	8013f80 <iprintf>
 800f2ec:	e7e6      	b.n	800f2bc <tcp_output_segment+0x10>
  LWIP_ASSERT("tcp_output_segment: invalid netif", netif != NULL);
 800f2ee:	4b3b      	ldr	r3, [pc, #236]	@ (800f3dc <tcp_output_segment+0x130>)
 800f2f0:	f240 52ba 	movw	r2, #1466	@ 0x5ba
 800f2f4:	493d      	ldr	r1, [pc, #244]	@ (800f3ec <tcp_output_segment+0x140>)
 800f2f6:	483b      	ldr	r0, [pc, #236]	@ (800f3e4 <tcp_output_segment+0x138>)
 800f2f8:	f004 fe42 	bl	8013f80 <iprintf>
 800f2fc:	e7df      	b.n	800f2be <tcp_output_segment+0x12>
  seg->tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);
 800f2fe:	692f      	ldr	r7, [r5, #16]
 800f300:	6a60      	ldr	r0, [r4, #36]	@ 0x24
 800f302:	f7fb fc32 	bl	800ab6a <lwip_htonl>
 800f306:	60b8      	str	r0, [r7, #8]
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
 800f308:	692f      	ldr	r7, [r5, #16]
 800f30a:	8d60      	ldrh	r0, [r4, #42]	@ 0x2a
 800f30c:	f7fb fc28 	bl	800ab60 <lwip_htons>
 800f310:	81f8      	strh	r0, [r7, #14]
  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 800f312:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 800f314:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
 800f316:	4413      	add	r3, r2
 800f318:	62e3      	str	r3, [r4, #44]	@ 0x2c
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
 800f31a:	f8d5 8010 	ldr.w	r8, [r5, #16]
 800f31e:	f108 0714 	add.w	r7, r8, #20
  if (seg->flags & TF_SEG_OPTS_MSS) {
 800f322:	7b2b      	ldrb	r3, [r5, #12]
 800f324:	f013 0f01 	tst.w	r3, #1
 800f328:	d13a      	bne.n	800f3a0 <tcp_output_segment+0xf4>
  if (pcb->rtime < 0) {
 800f32a:	f9b4 3030 	ldrsh.w	r3, [r4, #48]	@ 0x30
 800f32e:	2b00      	cmp	r3, #0
 800f330:	db45      	blt.n	800f3be <tcp_output_segment+0x112>
  if (pcb->rttest == 0) {
 800f332:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 800f334:	2b00      	cmp	r3, #0
 800f336:	d045      	beq.n	800f3c4 <tcp_output_segment+0x118>
  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 800f338:	692b      	ldr	r3, [r5, #16]
 800f33a:	686a      	ldr	r2, [r5, #4]
 800f33c:	6851      	ldr	r1, [r2, #4]
 800f33e:	1a5b      	subs	r3, r3, r1
 800f340:	b29b      	uxth	r3, r3
  seg->p->len -= len;
 800f342:	8951      	ldrh	r1, [r2, #10]
 800f344:	1ac9      	subs	r1, r1, r3
 800f346:	8151      	strh	r1, [r2, #10]
  seg->p->tot_len -= len;
 800f348:	6869      	ldr	r1, [r5, #4]
 800f34a:	890a      	ldrh	r2, [r1, #8]
 800f34c:	1ad3      	subs	r3, r2, r3
 800f34e:	810b      	strh	r3, [r1, #8]
  seg->p->payload = seg->tcphdr;
 800f350:	686a      	ldr	r2, [r5, #4]
 800f352:	692b      	ldr	r3, [r5, #16]
 800f354:	6053      	str	r3, [r2, #4]
  seg->tcphdr->chksum = 0;
 800f356:	2200      	movs	r2, #0
 800f358:	741a      	strb	r2, [r3, #16]
 800f35a:	745a      	strb	r2, [r3, #17]
  LWIP_ASSERT("options not filled", (u8_t *)opts == ((u8_t *)(seg->tcphdr + 1)) + LWIP_TCP_OPT_LENGTH_SEGMENT(seg->flags, pcb));
 800f35c:	692b      	ldr	r3, [r5, #16]
 800f35e:	7b2a      	ldrb	r2, [r5, #12]
 800f360:	f012 0f01 	tst.w	r2, #1
 800f364:	d037      	beq.n	800f3d6 <tcp_output_segment+0x12a>
 800f366:	2218      	movs	r2, #24
 800f368:	4413      	add	r3, r2
 800f36a:	429f      	cmp	r7, r3
 800f36c:	d006      	beq.n	800f37c <tcp_output_segment+0xd0>
 800f36e:	4b1b      	ldr	r3, [pc, #108]	@ (800f3dc <tcp_output_segment+0x130>)
 800f370:	f240 621c 	movw	r2, #1564	@ 0x61c
 800f374:	491e      	ldr	r1, [pc, #120]	@ (800f3f0 <tcp_output_segment+0x144>)
 800f376:	481b      	ldr	r0, [pc, #108]	@ (800f3e4 <tcp_output_segment+0x138>)
 800f378:	f004 fe02 	bl	8013f80 <iprintf>
  TCP_STATS_INC(tcp.xmit);
 800f37c:	4a1d      	ldr	r2, [pc, #116]	@ (800f3f4 <tcp_output_segment+0x148>)
 800f37e:	f8b2 30ac 	ldrh.w	r3, [r2, #172]	@ 0xac
 800f382:	3301      	adds	r3, #1
 800f384:	f8a2 30ac 	strh.w	r3, [r2, #172]	@ 0xac
  err = ip_output_if(seg->p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
 800f388:	9602      	str	r6, [sp, #8]
 800f38a:	2306      	movs	r3, #6
 800f38c:	9301      	str	r3, [sp, #4]
 800f38e:	7aa3      	ldrb	r3, [r4, #10]
 800f390:	9300      	str	r3, [sp, #0]
 800f392:	7ae3      	ldrb	r3, [r4, #11]
 800f394:	1d22      	adds	r2, r4, #4
 800f396:	4621      	mov	r1, r4
 800f398:	6868      	ldr	r0, [r5, #4]
 800f39a:	f003 f981 	bl	80126a0 <ip4_output_if>
  return err;
 800f39e:	e793      	b.n	800f2c8 <tcp_output_segment+0x1c>
    mss = tcp_eff_send_mss_netif(TCP_MSS, netif, &pcb->remote_ip);
 800f3a0:	1d22      	adds	r2, r4, #4
 800f3a2:	4631      	mov	r1, r6
 800f3a4:	f240 50b4 	movw	r0, #1460	@ 0x5b4
 800f3a8:	f7fd f9ce 	bl	800c748 <tcp_eff_send_mss_netif>
    *opts = TCP_BUILD_MSS_OPTION(mss);
 800f3ac:	f040 7001 	orr.w	r0, r0, #33816576	@ 0x2040000
 800f3b0:	f7fb fbdb 	bl	800ab6a <lwip_htonl>
 800f3b4:	f8c8 0014 	str.w	r0, [r8, #20]
    opts += 1;
 800f3b8:	f108 0718 	add.w	r7, r8, #24
 800f3bc:	e7b5      	b.n	800f32a <tcp_output_segment+0x7e>
    pcb->rtime = 0;
 800f3be:	2300      	movs	r3, #0
 800f3c0:	8623      	strh	r3, [r4, #48]	@ 0x30
 800f3c2:	e7b6      	b.n	800f332 <tcp_output_segment+0x86>
    pcb->rttest = tcp_ticks;
 800f3c4:	4b0c      	ldr	r3, [pc, #48]	@ (800f3f8 <tcp_output_segment+0x14c>)
 800f3c6:	681b      	ldr	r3, [r3, #0]
 800f3c8:	6363      	str	r3, [r4, #52]	@ 0x34
    pcb->rtseq = lwip_ntohl(seg->tcphdr->seqno);
 800f3ca:	692b      	ldr	r3, [r5, #16]
 800f3cc:	6858      	ldr	r0, [r3, #4]
 800f3ce:	f7fb fbcc 	bl	800ab6a <lwip_htonl>
 800f3d2:	63a0      	str	r0, [r4, #56]	@ 0x38
    LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_output_segment: rtseq %"U32_F"\n", pcb->rtseq));
 800f3d4:	e7b0      	b.n	800f338 <tcp_output_segment+0x8c>
  LWIP_ASSERT("options not filled", (u8_t *)opts == ((u8_t *)(seg->tcphdr + 1)) + LWIP_TCP_OPT_LENGTH_SEGMENT(seg->flags, pcb));
 800f3d6:	2214      	movs	r2, #20
 800f3d8:	e7c6      	b.n	800f368 <tcp_output_segment+0xbc>
 800f3da:	bf00      	nop
 800f3dc:	080174bc 	.word	0x080174bc
 800f3e0:	080176f0 	.word	0x080176f0
 800f3e4:	08015744 	.word	0x08015744
 800f3e8:	08017710 	.word	0x08017710
 800f3ec:	08017730 	.word	0x08017730
 800f3f0:	080175d0 	.word	0x080175d0
 800f3f4:	240141b4 	.word	0x240141b4
 800f3f8:	240142e8 	.word	0x240142e8

0800f3fc <tcp_output_control_segment>:
 * header checksum and calling ip_output_if while handling netif hints and stats.
 */
static err_t
tcp_output_control_segment(const struct tcp_pcb *pcb, struct pbuf *p,
                           const ip_addr_t *src, const ip_addr_t *dst)
{
 800f3fc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800f3fe:	b085      	sub	sp, #20
 800f400:	4604      	mov	r4, r0
 800f402:	4615      	mov	r5, r2
 800f404:	461e      	mov	r6, r3
  err_t err;
  struct netif *netif;

  LWIP_ASSERT("tcp_output_control_segment: invalid pbuf", p != NULL);
 800f406:	460f      	mov	r7, r1
 800f408:	b301      	cbz	r1, 800f44c <tcp_output_control_segment+0x50>

  netif = tcp_route(pcb, src, dst);
 800f40a:	4632      	mov	r2, r6
 800f40c:	4629      	mov	r1, r5
 800f40e:	4620      	mov	r0, r4
 800f410:	f7ff ff40 	bl	800f294 <tcp_route>
  if (netif == NULL) {
 800f414:	4684      	mov	ip, r0
 800f416:	b320      	cbz	r0, 800f462 <tcp_output_control_segment+0x66>
      struct tcp_hdr *tcphdr = (struct tcp_hdr *)p->payload;
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
                                        src, dst);
    }
#endif
    if (pcb != NULL) {
 800f418:	b304      	cbz	r4, 800f45c <tcp_output_control_segment+0x60>
      NETIF_SET_HINTS(netif, LWIP_CONST_CAST(struct netif_hint*, &(pcb->netif_hints)));
      ttl = pcb->ttl;
 800f41a:	7ae3      	ldrb	r3, [r4, #11]
      tos = pcb->tos;
 800f41c:	7aa0      	ldrb	r0, [r4, #10]
    } else {
      /* Send output with hardcoded TTL/HL since we have no access to the pcb */
      ttl = TCP_TTL;
      tos = 0;
    }
    TCP_STATS_INC(tcp.xmit);
 800f41e:	4912      	ldr	r1, [pc, #72]	@ (800f468 <tcp_output_control_segment+0x6c>)
 800f420:	f8b1 20ac 	ldrh.w	r2, [r1, #172]	@ 0xac
 800f424:	3201      	adds	r2, #1
 800f426:	f8a1 20ac 	strh.w	r2, [r1, #172]	@ 0xac
    err = ip_output_if(p, src, dst, ttl, tos, IP_PROTO_TCP, netif);
 800f42a:	f8cd c008 	str.w	ip, [sp, #8]
 800f42e:	2206      	movs	r2, #6
 800f430:	9201      	str	r2, [sp, #4]
 800f432:	9000      	str	r0, [sp, #0]
 800f434:	4632      	mov	r2, r6
 800f436:	4629      	mov	r1, r5
 800f438:	4638      	mov	r0, r7
 800f43a:	f003 f931 	bl	80126a0 <ip4_output_if>
 800f43e:	4604      	mov	r4, r0
    NETIF_RESET_HINTS(netif);
  }
  pbuf_free(p);
 800f440:	4638      	mov	r0, r7
 800f442:	f7fc fb75 	bl	800bb30 <pbuf_free>
  return err;
}
 800f446:	4620      	mov	r0, r4
 800f448:	b005      	add	sp, #20
 800f44a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  LWIP_ASSERT("tcp_output_control_segment: invalid pbuf", p != NULL);
 800f44c:	4b07      	ldr	r3, [pc, #28]	@ (800f46c <tcp_output_control_segment+0x70>)
 800f44e:	f240 7287 	movw	r2, #1927	@ 0x787
 800f452:	4907      	ldr	r1, [pc, #28]	@ (800f470 <tcp_output_control_segment+0x74>)
 800f454:	4807      	ldr	r0, [pc, #28]	@ (800f474 <tcp_output_control_segment+0x78>)
 800f456:	f004 fd93 	bl	8013f80 <iprintf>
 800f45a:	e7d6      	b.n	800f40a <tcp_output_control_segment+0xe>
      tos = 0;
 800f45c:	2000      	movs	r0, #0
      ttl = TCP_TTL;
 800f45e:	23ff      	movs	r3, #255	@ 0xff
 800f460:	e7dd      	b.n	800f41e <tcp_output_control_segment+0x22>
    err = ERR_RTE;
 800f462:	f06f 0403 	mvn.w	r4, #3
 800f466:	e7eb      	b.n	800f440 <tcp_output_control_segment+0x44>
 800f468:	240141b4 	.word	0x240141b4
 800f46c:	080174bc 	.word	0x080174bc
 800f470:	08017754 	.word	0x08017754
 800f474:	08015744 	.word	0x08015744

0800f478 <tcp_write>:
{
 800f478:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f47c:	b091      	sub	sp, #68	@ 0x44
 800f47e:	9107      	str	r1, [sp, #28]
 800f480:	9305      	str	r3, [sp, #20]
  u16_t oversize = 0;
 800f482:	2300      	movs	r3, #0
 800f484:	f8ad 303e 	strh.w	r3, [sp, #62]	@ 0x3e
  LWIP_ERROR("tcp_write: invalid pcb", pcb != NULL, return ERR_ARG);
 800f488:	2800      	cmp	r0, #0
 800f48a:	f000 809a 	beq.w	800f5c2 <tcp_write+0x14a>
 800f48e:	4692      	mov	sl, r2
 800f490:	4680      	mov	r8, r0
  mss_local = LWIP_MIN(pcb->mss, TCPWND_MIN16(pcb->snd_wnd_max / 2));
 800f492:	f8b0 3062 	ldrh.w	r3, [r0, #98]	@ 0x62
 800f496:	085b      	lsrs	r3, r3, #1
 800f498:	f8b0 b032 	ldrh.w	fp, [r0, #50]	@ 0x32
 800f49c:	455b      	cmp	r3, fp
 800f49e:	bf28      	it	cs
 800f4a0:	465b      	movcs	r3, fp
  mss_local = mss_local ? mss_local : pcb->mss;
 800f4a2:	b103      	cbz	r3, 800f4a6 <tcp_write+0x2e>
 800f4a4:	469b      	mov	fp, r3
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
 800f4a6:	9b07      	ldr	r3, [sp, #28]
 800f4a8:	2b00      	cmp	r3, #0
 800f4aa:	f000 8094 	beq.w	800f5d6 <tcp_write+0x15e>
  err = tcp_write_checks(pcb, len);
 800f4ae:	4651      	mov	r1, sl
 800f4b0:	4640      	mov	r0, r8
 800f4b2:	f7ff fcf9 	bl	800eea8 <tcp_write_checks>
  if (err != ERR_OK) {
 800f4b6:	4681      	mov	r9, r0
 800f4b8:	2800      	cmp	r0, #0
 800f4ba:	f040 81a7 	bne.w	800f80c <tcp_write+0x394>
  queuelen = pcb->snd_queuelen;
 800f4be:	f8b8 6066 	ldrh.w	r6, [r8, #102]	@ 0x66
  if (pcb->unsent != NULL) {
 800f4c2:	f8d8 306c 	ldr.w	r3, [r8, #108]	@ 0x6c
 800f4c6:	930a      	str	r3, [sp, #40]	@ 0x28
 800f4c8:	2b00      	cmp	r3, #0
 800f4ca:	f000 80e5 	beq.w	800f698 <tcp_write+0x220>
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 800f4ce:	9308      	str	r3, [sp, #32]
 800f4d0:	681b      	ldr	r3, [r3, #0]
 800f4d2:	2b00      	cmp	r3, #0
 800f4d4:	d1fb      	bne.n	800f4ce <tcp_write+0x56>
    unsent_optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(last_unsent->flags, pcb);
 800f4d6:	930a      	str	r3, [sp, #40]	@ 0x28
 800f4d8:	9b08      	ldr	r3, [sp, #32]
 800f4da:	7b1c      	ldrb	r4, [r3, #12]
 800f4dc:	00a4      	lsls	r4, r4, #2
 800f4de:	f004 0404 	and.w	r4, r4, #4
    LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
 800f4e2:	891b      	ldrh	r3, [r3, #8]
 800f4e4:	4423      	add	r3, r4
 800f4e6:	459b      	cmp	fp, r3
 800f4e8:	db7f      	blt.n	800f5ea <tcp_write+0x172>
    space = mss_local - (last_unsent->len + unsent_optlen);
 800f4ea:	9908      	ldr	r1, [sp, #32]
 800f4ec:	890b      	ldrh	r3, [r1, #8]
 800f4ee:	441c      	add	r4, r3
 800f4f0:	b2a4      	uxth	r4, r4
 800f4f2:	ebab 0404 	sub.w	r4, fp, r4
 800f4f6:	b2a4      	uxth	r4, r4
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
 800f4f8:	f8b8 2068 	ldrh.w	r2, [r8, #104]	@ 0x68
 800f4fc:	894b      	ldrh	r3, [r1, #10]
 800f4fe:	429a      	cmp	r2, r3
 800f500:	d17b      	bne.n	800f5fa <tcp_write+0x182>
    oversize = pcb->unsent_oversize;
 800f502:	f8b8 3068 	ldrh.w	r3, [r8, #104]	@ 0x68
 800f506:	9309      	str	r3, [sp, #36]	@ 0x24
 800f508:	f8ad 303e 	strh.w	r3, [sp, #62]	@ 0x3e
    if (oversize > 0) {
 800f50c:	2b00      	cmp	r3, #0
 800f50e:	f000 8084 	beq.w	800f61a <tcp_write+0x1a2>
      LWIP_ASSERT("inconsistent oversize vs. space", oversize <= space);
 800f512:	42a3      	cmp	r3, r4
 800f514:	d879      	bhi.n	800f60a <tcp_write+0x192>
      oversize_used = LWIP_MIN(space, LWIP_MIN(oversize, len));
 800f516:	f8bd 303e 	ldrh.w	r3, [sp, #62]	@ 0x3e
 800f51a:	461a      	mov	r2, r3
 800f51c:	4553      	cmp	r3, sl
 800f51e:	bf28      	it	cs
 800f520:	4652      	movcs	r2, sl
 800f522:	42a2      	cmp	r2, r4
 800f524:	bf28      	it	cs
 800f526:	4622      	movcs	r2, r4
 800f528:	9209      	str	r2, [sp, #36]	@ 0x24
      oversize -= oversize_used;
 800f52a:	1a9b      	subs	r3, r3, r2
 800f52c:	f8ad 303e 	strh.w	r3, [sp, #62]	@ 0x3e
      space -= oversize_used;
 800f530:	1aa4      	subs	r4, r4, r2
 800f532:	b2a4      	uxth	r4, r4
      seg = last_unsent;
 800f534:	9f08      	ldr	r7, [sp, #32]
    LWIP_ASSERT("inconsistent oversize vs. len", (oversize == 0) || (pos == len));
 800f536:	f8bd 303e 	ldrh.w	r3, [sp, #62]	@ 0x3e
 800f53a:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 800f53c:	2b00      	cmp	r3, #0
 800f53e:	bf18      	it	ne
 800f540:	4552      	cmpne	r2, sl
 800f542:	d16c      	bne.n	800f61e <tcp_write+0x1a6>
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 800f544:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800f546:	2c00      	cmp	r4, #0
 800f548:	bf18      	it	ne
 800f54a:	4553      	cmpne	r3, sl
 800f54c:	f080 816c 	bcs.w	800f828 <tcp_write+0x3b0>
 800f550:	9a08      	ldr	r2, [sp, #32]
 800f552:	8912      	ldrh	r2, [r2, #8]
 800f554:	920b      	str	r2, [sp, #44]	@ 0x2c
 800f556:	2a00      	cmp	r2, #0
 800f558:	f000 816f 	beq.w	800f83a <tcp_write+0x3c2>
      u16_t seglen = LWIP_MIN(space, len - pos);
 800f55c:	ebaa 0303 	sub.w	r3, sl, r3
 800f560:	42a3      	cmp	r3, r4
 800f562:	bfa8      	it	ge
 800f564:	4623      	movge	r3, r4
 800f566:	b29f      	uxth	r7, r3
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 800f568:	9b05      	ldr	r3, [sp, #20]
 800f56a:	f013 0f01 	tst.w	r3, #1
 800f56e:	d15e      	bne.n	800f62e <tcp_write+0x1b6>
        for (p = last_unsent->p; p->next != NULL; p = p->next);
 800f570:	9b08      	ldr	r3, [sp, #32]
 800f572:	685a      	ldr	r2, [r3, #4]
 800f574:	4613      	mov	r3, r2
 800f576:	6812      	ldr	r2, [r2, #0]
 800f578:	2a00      	cmp	r2, #0
 800f57a:	d1fb      	bne.n	800f574 <tcp_write+0xfc>
        if (((p->type_internal & (PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_FLAG_DATA_VOLATILE)) == 0) &&
 800f57c:	920a      	str	r2, [sp, #40]	@ 0x28
 800f57e:	7b1a      	ldrb	r2, [r3, #12]
 800f580:	2a3f      	cmp	r2, #63	@ 0x3f
 800f582:	d805      	bhi.n	800f590 <tcp_write+0x118>
            (const u8_t *)p->payload + p->len == (const u8_t *)arg) {
 800f584:	685a      	ldr	r2, [r3, #4]
 800f586:	895b      	ldrh	r3, [r3, #10]
 800f588:	4413      	add	r3, r2
        if (((p->type_internal & (PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_FLAG_DATA_VOLATILE)) == 0) &&
 800f58a:	9a07      	ldr	r2, [sp, #28]
 800f58c:	4293      	cmp	r3, r2
 800f58e:	d072      	beq.n	800f676 <tcp_write+0x1fe>
          if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
 800f590:	2201      	movs	r2, #1
 800f592:	4639      	mov	r1, r7
 800f594:	2000      	movs	r0, #0
 800f596:	f7fc fb33 	bl	800bc00 <pbuf_alloc>
 800f59a:	900a      	str	r0, [sp, #40]	@ 0x28
 800f59c:	2800      	cmp	r0, #0
 800f59e:	f000 8226 	beq.w	800f9ee <tcp_write+0x576>
          ((struct pbuf_rom *)concat_p)->payload = (const u8_t *)arg + pos;
 800f5a2:	9b07      	ldr	r3, [sp, #28]
 800f5a4:	9909      	ldr	r1, [sp, #36]	@ 0x24
 800f5a6:	440b      	add	r3, r1
 800f5a8:	6043      	str	r3, [r0, #4]
          queuelen += pbuf_clen(concat_p);
 800f5aa:	f7fc fc29 	bl	800be00 <pbuf_clen>
 800f5ae:	1833      	adds	r3, r6, r0
 800f5b0:	b29e      	uxth	r6, r3
  u16_t extendlen = 0;
 800f5b2:	2300      	movs	r3, #0
 800f5b4:	930d      	str	r3, [sp, #52]	@ 0x34
  u16_t oversize_add = 0;
 800f5b6:	930b      	str	r3, [sp, #44]	@ 0x2c
      pos += seglen;
 800f5b8:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800f5ba:	19dc      	adds	r4, r3, r7
 800f5bc:	b2a4      	uxth	r4, r4
      seg = last_unsent;
 800f5be:	9f08      	ldr	r7, [sp, #32]
 800f5c0:	e136      	b.n	800f830 <tcp_write+0x3b8>
  LWIP_ERROR("tcp_write: invalid pcb", pcb != NULL, return ERR_ARG);
 800f5c2:	4ba9      	ldr	r3, [pc, #676]	@ (800f868 <tcp_write+0x3f0>)
 800f5c4:	f44f 72cf 	mov.w	r2, #414	@ 0x19e
 800f5c8:	49a8      	ldr	r1, [pc, #672]	@ (800f86c <tcp_write+0x3f4>)
 800f5ca:	48a9      	ldr	r0, [pc, #676]	@ (800f870 <tcp_write+0x3f8>)
 800f5cc:	f004 fcd8 	bl	8013f80 <iprintf>
 800f5d0:	f06f 090f 	mvn.w	r9, #15
 800f5d4:	e11a      	b.n	800f80c <tcp_write+0x394>
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
 800f5d6:	4ba4      	ldr	r3, [pc, #656]	@ (800f868 <tcp_write+0x3f0>)
 800f5d8:	f240 12ad 	movw	r2, #429	@ 0x1ad
 800f5dc:	49a5      	ldr	r1, [pc, #660]	@ (800f874 <tcp_write+0x3fc>)
 800f5de:	48a4      	ldr	r0, [pc, #656]	@ (800f870 <tcp_write+0x3f8>)
 800f5e0:	f004 fcce 	bl	8013f80 <iprintf>
 800f5e4:	f06f 090f 	mvn.w	r9, #15
 800f5e8:	e110      	b.n	800f80c <tcp_write+0x394>
    LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
 800f5ea:	4b9f      	ldr	r3, [pc, #636]	@ (800f868 <tcp_write+0x3f0>)
 800f5ec:	f44f 72f3 	mov.w	r2, #486	@ 0x1e6
 800f5f0:	49a1      	ldr	r1, [pc, #644]	@ (800f878 <tcp_write+0x400>)
 800f5f2:	489f      	ldr	r0, [pc, #636]	@ (800f870 <tcp_write+0x3f8>)
 800f5f4:	f004 fcc4 	bl	8013f80 <iprintf>
 800f5f8:	e777      	b.n	800f4ea <tcp_write+0x72>
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
 800f5fa:	4b9b      	ldr	r3, [pc, #620]	@ (800f868 <tcp_write+0x3f0>)
 800f5fc:	f240 12f3 	movw	r2, #499	@ 0x1f3
 800f600:	499e      	ldr	r1, [pc, #632]	@ (800f87c <tcp_write+0x404>)
 800f602:	489b      	ldr	r0, [pc, #620]	@ (800f870 <tcp_write+0x3f8>)
 800f604:	f004 fcbc 	bl	8013f80 <iprintf>
 800f608:	e77b      	b.n	800f502 <tcp_write+0x8a>
      LWIP_ASSERT("inconsistent oversize vs. space", oversize <= space);
 800f60a:	4b97      	ldr	r3, [pc, #604]	@ (800f868 <tcp_write+0x3f0>)
 800f60c:	f44f 72fc 	mov.w	r2, #504	@ 0x1f8
 800f610:	499b      	ldr	r1, [pc, #620]	@ (800f880 <tcp_write+0x408>)
 800f612:	4897      	ldr	r0, [pc, #604]	@ (800f870 <tcp_write+0x3f8>)
 800f614:	f004 fcb4 	bl	8013f80 <iprintf>
 800f618:	e77d      	b.n	800f516 <tcp_write+0x9e>
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 800f61a:	9f0a      	ldr	r7, [sp, #40]	@ 0x28
 800f61c:	e78b      	b.n	800f536 <tcp_write+0xbe>
    LWIP_ASSERT("inconsistent oversize vs. len", (oversize == 0) || (pos == len));
 800f61e:	4b92      	ldr	r3, [pc, #584]	@ (800f868 <tcp_write+0x3f0>)
 800f620:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800f624:	4997      	ldr	r1, [pc, #604]	@ (800f884 <tcp_write+0x40c>)
 800f626:	4892      	ldr	r0, [pc, #584]	@ (800f870 <tcp_write+0x3f8>)
 800f628:	f004 fcaa 	bl	8013f80 <iprintf>
 800f62c:	e78a      	b.n	800f544 <tcp_write+0xcc>
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
 800f62e:	2301      	movs	r3, #1
 800f630:	9302      	str	r3, [sp, #8]
 800f632:	9b05      	ldr	r3, [sp, #20]
 800f634:	9301      	str	r3, [sp, #4]
 800f636:	f8cd 8000 	str.w	r8, [sp]
 800f63a:	f10d 033e 	add.w	r3, sp, #62	@ 0x3e
 800f63e:	4622      	mov	r2, r4
 800f640:	4639      	mov	r1, r7
 800f642:	2000      	movs	r0, #0
 800f644:	f7ff fcd6 	bl	800eff4 <tcp_pbuf_prealloc>
 800f648:	4604      	mov	r4, r0
 800f64a:	900a      	str	r0, [sp, #40]	@ 0x28
 800f64c:	2800      	cmp	r0, #0
 800f64e:	f000 81cc 	beq.w	800f9ea <tcp_write+0x572>
        oversize_add = oversize;
 800f652:	f8bd 303e 	ldrh.w	r3, [sp, #62]	@ 0x3e
 800f656:	930b      	str	r3, [sp, #44]	@ 0x2c
        TCP_DATA_COPY2(concat_p->payload, (const u8_t *)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
 800f658:	463a      	mov	r2, r7
 800f65a:	9b07      	ldr	r3, [sp, #28]
 800f65c:	9909      	ldr	r1, [sp, #36]	@ 0x24
 800f65e:	1859      	adds	r1, r3, r1
 800f660:	6840      	ldr	r0, [r0, #4]
 800f662:	f004 fece 	bl	8014402 <memcpy>
        queuelen += pbuf_clen(concat_p);
 800f666:	4620      	mov	r0, r4
 800f668:	f7fc fbca 	bl	800be00 <pbuf_clen>
 800f66c:	1833      	adds	r3, r6, r0
 800f66e:	b29e      	uxth	r6, r3
  u16_t extendlen = 0;
 800f670:	2300      	movs	r3, #0
 800f672:	930d      	str	r3, [sp, #52]	@ 0x34
 800f674:	e7a0      	b.n	800f5b8 <tcp_write+0x140>
          LWIP_ASSERT("tcp_write: ROM pbufs cannot be oversized", pos == 0);
 800f676:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800f678:	b91b      	cbnz	r3, 800f682 <tcp_write+0x20a>
          extendlen = seglen;
 800f67a:	970d      	str	r7, [sp, #52]	@ 0x34
  u16_t oversize_add = 0;
 800f67c:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800f67e:	930b      	str	r3, [sp, #44]	@ 0x2c
 800f680:	e79a      	b.n	800f5b8 <tcp_write+0x140>
          LWIP_ASSERT("tcp_write: ROM pbufs cannot be oversized", pos == 0);
 800f682:	4b79      	ldr	r3, [pc, #484]	@ (800f868 <tcp_write+0x3f0>)
 800f684:	f240 2231 	movw	r2, #561	@ 0x231
 800f688:	497f      	ldr	r1, [pc, #508]	@ (800f888 <tcp_write+0x410>)
 800f68a:	4879      	ldr	r0, [pc, #484]	@ (800f870 <tcp_write+0x3f8>)
 800f68c:	f004 fc78 	bl	8013f80 <iprintf>
          extendlen = seglen;
 800f690:	970d      	str	r7, [sp, #52]	@ 0x34
  u16_t oversize_add = 0;
 800f692:	2300      	movs	r3, #0
 800f694:	930b      	str	r3, [sp, #44]	@ 0x2c
 800f696:	e78f      	b.n	800f5b8 <tcp_write+0x140>
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
 800f698:	f8b8 4068 	ldrh.w	r4, [r8, #104]	@ 0x68
 800f69c:	b934      	cbnz	r4, 800f6ac <tcp_write+0x234>
  u16_t extendlen = 0;
 800f69e:	940d      	str	r4, [sp, #52]	@ 0x34
  u16_t oversize_add = 0;
 800f6a0:	940b      	str	r4, [sp, #44]	@ 0x2c
  u16_t oversize_used = 0;
 800f6a2:	9409      	str	r4, [sp, #36]	@ 0x24
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 800f6a4:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 800f6a6:	461f      	mov	r7, r3
 800f6a8:	9308      	str	r3, [sp, #32]
 800f6aa:	e0c1      	b.n	800f830 <tcp_write+0x3b8>
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
 800f6ac:	4b6e      	ldr	r3, [pc, #440]	@ (800f868 <tcp_write+0x3f0>)
 800f6ae:	f240 224a 	movw	r2, #586	@ 0x24a
 800f6b2:	4976      	ldr	r1, [pc, #472]	@ (800f88c <tcp_write+0x414>)
 800f6b4:	486e      	ldr	r0, [pc, #440]	@ (800f870 <tcp_write+0x3f8>)
 800f6b6:	f004 fc63 	bl	8013f80 <iprintf>
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 800f6ba:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 800f6bc:	461f      	mov	r7, r3
 800f6be:	9308      	str	r3, [sp, #32]
  u16_t extendlen = 0;
 800f6c0:	2400      	movs	r4, #0
 800f6c2:	940d      	str	r4, [sp, #52]	@ 0x34
  u16_t oversize_add = 0;
 800f6c4:	940b      	str	r4, [sp, #44]	@ 0x2c
  u16_t oversize_used = 0;
 800f6c6:	9409      	str	r4, [sp, #36]	@ 0x24
 800f6c8:	e0b2      	b.n	800f830 <tcp_write+0x3b8>
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
 800f6ca:	fab5 f385 	clz	r3, r5
 800f6ce:	095b      	lsrs	r3, r3, #5
 800f6d0:	9302      	str	r3, [sp, #8]
 800f6d2:	9b05      	ldr	r3, [sp, #20]
 800f6d4:	9301      	str	r3, [sp, #4]
 800f6d6:	f8cd 8000 	str.w	r8, [sp]
 800f6da:	f10d 033e 	add.w	r3, sp, #62	@ 0x3e
 800f6de:	465a      	mov	r2, fp
 800f6e0:	4649      	mov	r1, r9
 800f6e2:	2036      	movs	r0, #54	@ 0x36
 800f6e4:	f7ff fc86 	bl	800eff4 <tcp_pbuf_prealloc>
 800f6e8:	4607      	mov	r7, r0
 800f6ea:	2800      	cmp	r0, #0
 800f6ec:	d068      	beq.n	800f7c0 <tcp_write+0x348>
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
 800f6ee:	8943      	ldrh	r3, [r0, #10]
 800f6f0:	454b      	cmp	r3, r9
 800f6f2:	d306      	bcc.n	800f702 <tcp_write+0x28a>
      TCP_DATA_COPY2((char *)p->payload + optlen, (const u8_t *)arg + pos, seglen, &chksum, &chksum_swapped);
 800f6f4:	464a      	mov	r2, r9
 800f6f6:	9b07      	ldr	r3, [sp, #28]
 800f6f8:	1919      	adds	r1, r3, r4
 800f6fa:	6878      	ldr	r0, [r7, #4]
 800f6fc:	f004 fe81 	bl	8014402 <memcpy>
 800f700:	e01e      	b.n	800f740 <tcp_write+0x2c8>
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
 800f702:	4b59      	ldr	r3, [pc, #356]	@ (800f868 <tcp_write+0x3f0>)
 800f704:	f240 2266 	movw	r2, #614	@ 0x266
 800f708:	4961      	ldr	r1, [pc, #388]	@ (800f890 <tcp_write+0x418>)
 800f70a:	4859      	ldr	r0, [pc, #356]	@ (800f870 <tcp_write+0x3f8>)
 800f70c:	f004 fc38 	bl	8013f80 <iprintf>
 800f710:	e7f0      	b.n	800f6f4 <tcp_write+0x27c>
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
 800f712:	2201      	movs	r2, #1
 800f714:	4649      	mov	r1, r9
 800f716:	2036      	movs	r0, #54	@ 0x36
 800f718:	f7fc fa72 	bl	800bc00 <pbuf_alloc>
 800f71c:	9006      	str	r0, [sp, #24]
 800f71e:	2800      	cmp	r0, #0
 800f720:	d04e      	beq.n	800f7c0 <tcp_write+0x348>
      ((struct pbuf_rom *)p2)->payload = (const u8_t *)arg + pos;
 800f722:	9b07      	ldr	r3, [sp, #28]
 800f724:	4423      	add	r3, r4
 800f726:	6043      	str	r3, [r0, #4]
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 800f728:	f44f 7220 	mov.w	r2, #640	@ 0x280
 800f72c:	2100      	movs	r1, #0
 800f72e:	2036      	movs	r0, #54	@ 0x36
 800f730:	f7fc fa66 	bl	800bc00 <pbuf_alloc>
 800f734:	4607      	mov	r7, r0
 800f736:	2800      	cmp	r0, #0
 800f738:	d03b      	beq.n	800f7b2 <tcp_write+0x33a>
      pbuf_cat(p/*header*/, p2/*data*/);
 800f73a:	9906      	ldr	r1, [sp, #24]
 800f73c:	f7fc fb86 	bl	800be4c <pbuf_cat>
    queuelen += pbuf_clen(p);
 800f740:	4638      	mov	r0, r7
 800f742:	f7fc fb5d 	bl	800be00 <pbuf_clen>
 800f746:	4430      	add	r0, r6
 800f748:	b286      	uxth	r6, r0
    if (queuelen > LWIP_MIN(TCP_SND_QUEUELEN, TCP_SNDQUEUELEN_OVERFLOW)) {
 800f74a:	2e10      	cmp	r6, #16
 800f74c:	d835      	bhi.n	800f7ba <tcp_write+0x342>
    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
 800f74e:	f8d8 305c 	ldr.w	r3, [r8, #92]	@ 0x5c
 800f752:	2200      	movs	r2, #0
 800f754:	9200      	str	r2, [sp, #0]
 800f756:	4423      	add	r3, r4
 800f758:	4639      	mov	r1, r7
 800f75a:	4640      	mov	r0, r8
 800f75c:	f7ff fca8 	bl	800f0b0 <tcp_create_segment>
 800f760:	4607      	mov	r7, r0
 800f762:	b368      	cbz	r0, 800f7c0 <tcp_write+0x348>
    seg->oversize_left = oversize;
 800f764:	f8bd 303e 	ldrh.w	r3, [sp, #62]	@ 0x3e
 800f768:	8143      	strh	r3, [r0, #10]
    if (queue == NULL) {
 800f76a:	2d00      	cmp	r5, #0
 800f76c:	d05a      	beq.n	800f824 <tcp_write+0x3ac>
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
 800f76e:	9b04      	ldr	r3, [sp, #16]
 800f770:	2b00      	cmp	r3, #0
 800f772:	d04f      	beq.n	800f814 <tcp_write+0x39c>
      prev_seg->next = seg;
 800f774:	9b04      	ldr	r3, [sp, #16]
 800f776:	601f      	str	r7, [r3, #0]
    pos += seglen;
 800f778:	44a1      	add	r9, r4
 800f77a:	fa1f f489 	uxth.w	r4, r9
    prev_seg = seg;
 800f77e:	9704      	str	r7, [sp, #16]
  while (pos < len) {
 800f780:	4554      	cmp	r4, sl
 800f782:	d25e      	bcs.n	800f842 <tcp_write+0x3ca>
    u16_t left = len - pos;
 800f784:	ebaa 0904 	sub.w	r9, sl, r4
 800f788:	fa1f f989 	uxth.w	r9, r9
    u16_t seglen = LWIP_MIN(left, max_len);
 800f78c:	45d9      	cmp	r9, fp
 800f78e:	bf28      	it	cs
 800f790:	46d9      	movcs	r9, fp
    if (apiflags & TCP_WRITE_FLAG_COPY) {
 800f792:	9b05      	ldr	r3, [sp, #20]
 800f794:	f013 0f01 	tst.w	r3, #1
 800f798:	d197      	bne.n	800f6ca <tcp_write+0x252>
      LWIP_ASSERT("oversize == 0", oversize == 0);
 800f79a:	f8bd 303e 	ldrh.w	r3, [sp, #62]	@ 0x3e
 800f79e:	2b00      	cmp	r3, #0
 800f7a0:	d0b7      	beq.n	800f712 <tcp_write+0x29a>
 800f7a2:	4b31      	ldr	r3, [pc, #196]	@ (800f868 <tcp_write+0x3f0>)
 800f7a4:	f240 2271 	movw	r2, #625	@ 0x271
 800f7a8:	493a      	ldr	r1, [pc, #232]	@ (800f894 <tcp_write+0x41c>)
 800f7aa:	4831      	ldr	r0, [pc, #196]	@ (800f870 <tcp_write+0x3f8>)
 800f7ac:	f004 fbe8 	bl	8013f80 <iprintf>
 800f7b0:	e7af      	b.n	800f712 <tcp_write+0x29a>
        pbuf_free(p2);
 800f7b2:	9806      	ldr	r0, [sp, #24]
 800f7b4:	f7fc f9bc 	bl	800bb30 <pbuf_free>
        goto memerr;
 800f7b8:	e002      	b.n	800f7c0 <tcp_write+0x348>
      pbuf_free(p);
 800f7ba:	4638      	mov	r0, r7
 800f7bc:	f7fc f9b8 	bl	800bb30 <pbuf_free>
  tcp_set_flags(pcb, TF_NAGLEMEMERR);
 800f7c0:	f8b8 301a 	ldrh.w	r3, [r8, #26]
 800f7c4:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800f7c8:	f8a8 301a 	strh.w	r3, [r8, #26]
  TCP_STATS_INC(tcp.memerr);
 800f7cc:	4a32      	ldr	r2, [pc, #200]	@ (800f898 <tcp_write+0x420>)
 800f7ce:	f8b2 30b8 	ldrh.w	r3, [r2, #184]	@ 0xb8
 800f7d2:	3301      	adds	r3, #1
 800f7d4:	f8a2 30b8 	strh.w	r3, [r2, #184]	@ 0xb8
  if (concat_p != NULL) {
 800f7d8:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 800f7da:	b113      	cbz	r3, 800f7e2 <tcp_write+0x36a>
    pbuf_free(concat_p);
 800f7dc:	4618      	mov	r0, r3
 800f7de:	f7fc f9a7 	bl	800bb30 <pbuf_free>
  if (queue != NULL) {
 800f7e2:	b115      	cbz	r5, 800f7ea <tcp_write+0x372>
    tcp_segs_free(queue);
 800f7e4:	4628      	mov	r0, r5
 800f7e6:	f7fc fee4 	bl	800c5b2 <tcp_segs_free>
  if (pcb->snd_queuelen != 0) {
 800f7ea:	f8b8 3066 	ldrh.w	r3, [r8, #102]	@ 0x66
 800f7ee:	2b00      	cmp	r3, #0
 800f7f0:	f000 8109 	beq.w	800fa06 <tcp_write+0x58e>
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
 800f7f4:	f8d8 3070 	ldr.w	r3, [r8, #112]	@ 0x70
 800f7f8:	2b00      	cmp	r3, #0
 800f7fa:	f040 8107 	bne.w	800fa0c <tcp_write+0x594>
 800f7fe:	f8d8 306c 	ldr.w	r3, [r8, #108]	@ 0x6c
 800f802:	2b00      	cmp	r3, #0
 800f804:	f000 80f5 	beq.w	800f9f2 <tcp_write+0x57a>
  return ERR_MEM;
 800f808:	f04f 39ff 	mov.w	r9, #4294967295
}
 800f80c:	4648      	mov	r0, r9
 800f80e:	b011      	add	sp, #68	@ 0x44
 800f810:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
 800f814:	4b14      	ldr	r3, [pc, #80]	@ (800f868 <tcp_write+0x3f0>)
 800f816:	f240 22ab 	movw	r2, #683	@ 0x2ab
 800f81a:	4920      	ldr	r1, [pc, #128]	@ (800f89c <tcp_write+0x424>)
 800f81c:	4814      	ldr	r0, [pc, #80]	@ (800f870 <tcp_write+0x3f8>)
 800f81e:	f004 fbaf 	bl	8013f80 <iprintf>
 800f822:	e7a7      	b.n	800f774 <tcp_write+0x2fc>
      queue = seg;
 800f824:	4605      	mov	r5, r0
 800f826:	e7a7      	b.n	800f778 <tcp_write+0x300>
 800f828:	9c09      	ldr	r4, [sp, #36]	@ 0x24
  u16_t extendlen = 0;
 800f82a:	2300      	movs	r3, #0
 800f82c:	930d      	str	r3, [sp, #52]	@ 0x34
  u16_t oversize_add = 0;
 800f82e:	930b      	str	r3, [sp, #44]	@ 0x2c
 800f830:	2500      	movs	r5, #0
 800f832:	9504      	str	r5, [sp, #16]
 800f834:	f8cd 9030 	str.w	r9, [sp, #48]	@ 0x30
 800f838:	e7a2      	b.n	800f780 <tcp_write+0x308>
  u16_t extendlen = 0;
 800f83a:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 800f83c:	930d      	str	r3, [sp, #52]	@ 0x34
 800f83e:	9c09      	ldr	r4, [sp, #36]	@ 0x24
 800f840:	e7f6      	b.n	800f830 <tcp_write+0x3b8>
  if ((last_unsent != NULL) && (oversize_add != 0)) {
 800f842:	f8dd 9030 	ldr.w	r9, [sp, #48]	@ 0x30
 800f846:	9a08      	ldr	r2, [sp, #32]
 800f848:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 800f84a:	2a00      	cmp	r2, #0
 800f84c:	bf18      	it	ne
 800f84e:	2900      	cmpne	r1, #0
 800f850:	d002      	beq.n	800f858 <tcp_write+0x3e0>
    last_unsent->oversize_left += oversize_add;
 800f852:	8953      	ldrh	r3, [r2, #10]
 800f854:	440b      	add	r3, r1
 800f856:	8153      	strh	r3, [r2, #10]
  if (oversize_used > 0) {
 800f858:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800f85a:	2b00      	cmp	r3, #0
 800f85c:	d040      	beq.n	800f8e0 <tcp_write+0x468>
    for (p = last_unsent->p; p; p = p->next) {
 800f85e:	9a08      	ldr	r2, [sp, #32]
 800f860:	6854      	ldr	r4, [r2, #4]
 800f862:	469b      	mov	fp, r3
 800f864:	e01d      	b.n	800f8a2 <tcp_write+0x42a>
 800f866:	bf00      	nop
 800f868:	080174bc 	.word	0x080174bc
 800f86c:	08017780 	.word	0x08017780
 800f870:	08015744 	.word	0x08015744
 800f874:	08017798 	.word	0x08017798
 800f878:	080177cc 	.word	0x080177cc
 800f87c:	080177e4 	.word	0x080177e4
 800f880:	08017814 	.word	0x08017814
 800f884:	08017834 	.word	0x08017834
 800f888:	08017854 	.word	0x08017854
 800f88c:	08017880 	.word	0x08017880
 800f890:	080178b0 	.word	0x080178b0
 800f894:	080178f0 	.word	0x080178f0
 800f898:	240141b4 	.word	0x240141b4
 800f89c:	08017900 	.word	0x08017900
 800f8a0:	6824      	ldr	r4, [r4, #0]
 800f8a2:	b184      	cbz	r4, 800f8c6 <tcp_write+0x44e>
      p->tot_len += oversize_used;
 800f8a4:	8923      	ldrh	r3, [r4, #8]
 800f8a6:	445b      	add	r3, fp
 800f8a8:	8123      	strh	r3, [r4, #8]
      if (p->next == NULL) {
 800f8aa:	6823      	ldr	r3, [r4, #0]
 800f8ac:	2b00      	cmp	r3, #0
 800f8ae:	d1f7      	bne.n	800f8a0 <tcp_write+0x428>
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
 800f8b0:	6860      	ldr	r0, [r4, #4]
 800f8b2:	8963      	ldrh	r3, [r4, #10]
 800f8b4:	465a      	mov	r2, fp
 800f8b6:	9907      	ldr	r1, [sp, #28]
 800f8b8:	4418      	add	r0, r3
 800f8ba:	f004 fda2 	bl	8014402 <memcpy>
        p->len += oversize_used;
 800f8be:	8963      	ldrh	r3, [r4, #10]
 800f8c0:	445b      	add	r3, fp
 800f8c2:	8163      	strh	r3, [r4, #10]
 800f8c4:	e7ec      	b.n	800f8a0 <tcp_write+0x428>
    last_unsent->len += oversize_used;
 800f8c6:	9a08      	ldr	r2, [sp, #32]
 800f8c8:	8913      	ldrh	r3, [r2, #8]
 800f8ca:	9909      	ldr	r1, [sp, #36]	@ 0x24
 800f8cc:	440b      	add	r3, r1
 800f8ce:	8113      	strh	r3, [r2, #8]
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
 800f8d0:	8953      	ldrh	r3, [r2, #10]
 800f8d2:	428b      	cmp	r3, r1
 800f8d4:	d342      	bcc.n	800f95c <tcp_write+0x4e4>
    last_unsent->oversize_left -= oversize_used;
 800f8d6:	9a08      	ldr	r2, [sp, #32]
 800f8d8:	8953      	ldrh	r3, [r2, #10]
 800f8da:	9909      	ldr	r1, [sp, #36]	@ 0x24
 800f8dc:	1a5b      	subs	r3, r3, r1
 800f8de:	8153      	strh	r3, [r2, #10]
  pcb->unsent_oversize = oversize;
 800f8e0:	f8bd 303e 	ldrh.w	r3, [sp, #62]	@ 0x3e
 800f8e4:	f8a8 3068 	strh.w	r3, [r8, #104]	@ 0x68
  if (concat_p != NULL) {
 800f8e8:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 800f8ea:	2b00      	cmp	r3, #0
 800f8ec:	d046      	beq.n	800f97c <tcp_write+0x504>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
 800f8ee:	9b08      	ldr	r3, [sp, #32]
 800f8f0:	2b00      	cmp	r3, #0
 800f8f2:	d03b      	beq.n	800f96c <tcp_write+0x4f4>
    pbuf_cat(last_unsent->p, concat_p);
 800f8f4:	f8dd b028 	ldr.w	fp, [sp, #40]	@ 0x28
 800f8f8:	4659      	mov	r1, fp
 800f8fa:	9c08      	ldr	r4, [sp, #32]
 800f8fc:	6860      	ldr	r0, [r4, #4]
 800f8fe:	f7fc faa5 	bl	800be4c <pbuf_cat>
    last_unsent->len += concat_p->tot_len;
 800f902:	8923      	ldrh	r3, [r4, #8]
 800f904:	f8bb 2008 	ldrh.w	r2, [fp, #8]
 800f908:	4413      	add	r3, r2
 800f90a:	8123      	strh	r3, [r4, #8]
    last_unsent->next = queue;
 800f90c:	9b08      	ldr	r3, [sp, #32]
 800f90e:	601d      	str	r5, [r3, #0]
  pcb->snd_lbb += len;
 800f910:	f8d8 305c 	ldr.w	r3, [r8, #92]	@ 0x5c
 800f914:	4453      	add	r3, sl
 800f916:	f8c8 305c 	str.w	r3, [r8, #92]	@ 0x5c
  pcb->snd_buf -= len;
 800f91a:	f8b8 3064 	ldrh.w	r3, [r8, #100]	@ 0x64
 800f91e:	eba3 030a 	sub.w	r3, r3, sl
 800f922:	f8a8 3064 	strh.w	r3, [r8, #100]	@ 0x64
  pcb->snd_queuelen = queuelen;
 800f926:	f8a8 6066 	strh.w	r6, [r8, #102]	@ 0x66
  if (pcb->snd_queuelen != 0) {
 800f92a:	b11e      	cbz	r6, 800f934 <tcp_write+0x4bc>
    LWIP_ASSERT("tcp_write: valid queue length",
 800f92c:	f8d8 3070 	ldr.w	r3, [r8, #112]	@ 0x70
 800f930:	2b00      	cmp	r3, #0
 800f932:	d04e      	beq.n	800f9d2 <tcp_write+0x55a>
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE) == 0)) {
 800f934:	2f00      	cmp	r7, #0
 800f936:	f43f af69 	beq.w	800f80c <tcp_write+0x394>
 800f93a:	693b      	ldr	r3, [r7, #16]
 800f93c:	2b00      	cmp	r3, #0
 800f93e:	f43f af65 	beq.w	800f80c <tcp_write+0x394>
 800f942:	9a05      	ldr	r2, [sp, #20]
 800f944:	f012 0f02 	tst.w	r2, #2
 800f948:	f47f af60 	bne.w	800f80c <tcp_write+0x394>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
 800f94c:	899c      	ldrh	r4, [r3, #12]
 800f94e:	2008      	movs	r0, #8
 800f950:	f7fb f906 	bl	800ab60 <lwip_htons>
 800f954:	693b      	ldr	r3, [r7, #16]
 800f956:	4304      	orrs	r4, r0
 800f958:	819c      	strh	r4, [r3, #12]
 800f95a:	e757      	b.n	800f80c <tcp_write+0x394>
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
 800f95c:	4b2d      	ldr	r3, [pc, #180]	@ (800fa14 <tcp_write+0x59c>)
 800f95e:	f240 22d3 	movw	r2, #723	@ 0x2d3
 800f962:	492d      	ldr	r1, [pc, #180]	@ (800fa18 <tcp_write+0x5a0>)
 800f964:	482d      	ldr	r0, [pc, #180]	@ (800fa1c <tcp_write+0x5a4>)
 800f966:	f004 fb0b 	bl	8013f80 <iprintf>
 800f96a:	e7b4      	b.n	800f8d6 <tcp_write+0x45e>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
 800f96c:	4b29      	ldr	r3, [pc, #164]	@ (800fa14 <tcp_write+0x59c>)
 800f96e:	f44f 7238 	mov.w	r2, #736	@ 0x2e0
 800f972:	492b      	ldr	r1, [pc, #172]	@ (800fa20 <tcp_write+0x5a8>)
 800f974:	4829      	ldr	r0, [pc, #164]	@ (800fa1c <tcp_write+0x5a4>)
 800f976:	f004 fb03 	bl	8013f80 <iprintf>
 800f97a:	e7bb      	b.n	800f8f4 <tcp_write+0x47c>
  } else if (extendlen > 0) {
 800f97c:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 800f97e:	b313      	cbz	r3, 800f9c6 <tcp_write+0x54e>
    LWIP_ASSERT("tcp_write: extension of reference requires reference",
 800f980:	9b08      	ldr	r3, [sp, #32]
 800f982:	b12b      	cbz	r3, 800f990 <tcp_write+0x518>
 800f984:	685b      	ldr	r3, [r3, #4]
 800f986:	b11b      	cbz	r3, 800f990 <tcp_write+0x518>
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
 800f988:	9b08      	ldr	r3, [sp, #32]
 800f98a:	685b      	ldr	r3, [r3, #4]
 800f98c:	980d      	ldr	r0, [sp, #52]	@ 0x34
 800f98e:	e00b      	b.n	800f9a8 <tcp_write+0x530>
    LWIP_ASSERT("tcp_write: extension of reference requires reference",
 800f990:	4b20      	ldr	r3, [pc, #128]	@ (800fa14 <tcp_write+0x59c>)
 800f992:	f240 22e6 	movw	r2, #742	@ 0x2e6
 800f996:	4923      	ldr	r1, [pc, #140]	@ (800fa24 <tcp_write+0x5ac>)
 800f998:	4820      	ldr	r0, [pc, #128]	@ (800fa1c <tcp_write+0x5a4>)
 800f99a:	f004 faf1 	bl	8013f80 <iprintf>
 800f99e:	e7f3      	b.n	800f988 <tcp_write+0x510>
      p->tot_len += extendlen;
 800f9a0:	891a      	ldrh	r2, [r3, #8]
 800f9a2:	4402      	add	r2, r0
 800f9a4:	811a      	strh	r2, [r3, #8]
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
 800f9a6:	460b      	mov	r3, r1
 800f9a8:	6819      	ldr	r1, [r3, #0]
 800f9aa:	2900      	cmp	r1, #0
 800f9ac:	d1f8      	bne.n	800f9a0 <tcp_write+0x528>
    p->tot_len += extendlen;
 800f9ae:	891a      	ldrh	r2, [r3, #8]
 800f9b0:	990d      	ldr	r1, [sp, #52]	@ 0x34
 800f9b2:	440a      	add	r2, r1
 800f9b4:	811a      	strh	r2, [r3, #8]
    p->len += extendlen;
 800f9b6:	895a      	ldrh	r2, [r3, #10]
 800f9b8:	440a      	add	r2, r1
 800f9ba:	815a      	strh	r2, [r3, #10]
    last_unsent->len += extendlen;
 800f9bc:	9a08      	ldr	r2, [sp, #32]
 800f9be:	8913      	ldrh	r3, [r2, #8]
 800f9c0:	440b      	add	r3, r1
 800f9c2:	8113      	strh	r3, [r2, #8]
  if (last_unsent == NULL) {
 800f9c4:	e7a2      	b.n	800f90c <tcp_write+0x494>
 800f9c6:	9b08      	ldr	r3, [sp, #32]
 800f9c8:	2b00      	cmp	r3, #0
 800f9ca:	d19f      	bne.n	800f90c <tcp_write+0x494>
    pcb->unsent = queue;
 800f9cc:	f8c8 506c 	str.w	r5, [r8, #108]	@ 0x6c
 800f9d0:	e79e      	b.n	800f910 <tcp_write+0x498>
    LWIP_ASSERT("tcp_write: valid queue length",
 800f9d2:	f8d8 306c 	ldr.w	r3, [r8, #108]	@ 0x6c
 800f9d6:	2b00      	cmp	r3, #0
 800f9d8:	d1ac      	bne.n	800f934 <tcp_write+0x4bc>
 800f9da:	4b0e      	ldr	r3, [pc, #56]	@ (800fa14 <tcp_write+0x59c>)
 800f9dc:	f240 3212 	movw	r2, #786	@ 0x312
 800f9e0:	4911      	ldr	r1, [pc, #68]	@ (800fa28 <tcp_write+0x5b0>)
 800f9e2:	480e      	ldr	r0, [pc, #56]	@ (800fa1c <tcp_write+0x5a4>)
 800f9e4:	f004 facc 	bl	8013f80 <iprintf>
 800f9e8:	e7a4      	b.n	800f934 <tcp_write+0x4bc>
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 800f9ea:	9d0a      	ldr	r5, [sp, #40]	@ 0x28
 800f9ec:	e6e8      	b.n	800f7c0 <tcp_write+0x348>
 800f9ee:	9d0a      	ldr	r5, [sp, #40]	@ 0x28
 800f9f0:	e6e6      	b.n	800f7c0 <tcp_write+0x348>
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
 800f9f2:	4b08      	ldr	r3, [pc, #32]	@ (800fa14 <tcp_write+0x59c>)
 800f9f4:	f240 3227 	movw	r2, #807	@ 0x327
 800f9f8:	490b      	ldr	r1, [pc, #44]	@ (800fa28 <tcp_write+0x5b0>)
 800f9fa:	4808      	ldr	r0, [pc, #32]	@ (800fa1c <tcp_write+0x5a4>)
 800f9fc:	f004 fac0 	bl	8013f80 <iprintf>
  return ERR_MEM;
 800fa00:	f04f 39ff 	mov.w	r9, #4294967295
 800fa04:	e702      	b.n	800f80c <tcp_write+0x394>
 800fa06:	f04f 39ff 	mov.w	r9, #4294967295
 800fa0a:	e6ff      	b.n	800f80c <tcp_write+0x394>
 800fa0c:	f04f 39ff 	mov.w	r9, #4294967295
 800fa10:	e6fc      	b.n	800f80c <tcp_write+0x394>
 800fa12:	bf00      	nop
 800fa14:	080174bc 	.word	0x080174bc
 800fa18:	08017914 	.word	0x08017914
 800fa1c:	08015744 	.word	0x08015744
 800fa20:	08017940 	.word	0x08017940
 800fa24:	08017978 	.word	0x08017978
 800fa28:	080179b0 	.word	0x080179b0

0800fa2c <tcp_split_unsent_seg>:
{
 800fa2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800fa30:	b083      	sub	sp, #12
 800fa32:	460c      	mov	r4, r1
  LWIP_ASSERT("tcp_split_unsent_seg: invalid pcb", pcb != NULL);
 800fa34:	4607      	mov	r7, r0
 800fa36:	2800      	cmp	r0, #0
 800fa38:	d043      	beq.n	800fac2 <tcp_split_unsent_seg+0x96>
  useg = pcb->unsent;
 800fa3a:	6efd      	ldr	r5, [r7, #108]	@ 0x6c
  if (useg == NULL) {
 800fa3c:	2d00      	cmp	r5, #0
 800fa3e:	f000 80c3 	beq.w	800fbc8 <tcp_split_unsent_seg+0x19c>
  if (split == 0) {
 800fa42:	2c00      	cmp	r4, #0
 800fa44:	d045      	beq.n	800fad2 <tcp_split_unsent_seg+0xa6>
  if (useg->len <= split) {
 800fa46:	892b      	ldrh	r3, [r5, #8]
 800fa48:	42a3      	cmp	r3, r4
 800fa4a:	f240 80c0 	bls.w	800fbce <tcp_split_unsent_seg+0x1a2>
  LWIP_ASSERT("split <= mss", split <= pcb->mss);
 800fa4e:	8e7b      	ldrh	r3, [r7, #50]	@ 0x32
 800fa50:	42a3      	cmp	r3, r4
 800fa52:	d348      	bcc.n	800fae6 <tcp_split_unsent_seg+0xba>
  LWIP_ASSERT("useg->len > 0", useg->len > 0);
 800fa54:	892b      	ldrh	r3, [r5, #8]
 800fa56:	2b00      	cmp	r3, #0
 800fa58:	d04d      	beq.n	800faf6 <tcp_split_unsent_seg+0xca>
  optflags = useg->flags;
 800fa5a:	f895 900c 	ldrb.w	r9, [r5, #12]
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
 800fa5e:	ea4f 0b89 	mov.w	fp, r9, lsl #2
 800fa62:	f00b 0b04 	and.w	fp, fp, #4
  remainder = useg->len - split;
 800fa66:	f8b5 a008 	ldrh.w	sl, [r5, #8]
 800fa6a:	ebaa 0604 	sub.w	r6, sl, r4
 800fa6e:	b2b6      	uxth	r6, r6
  p = pbuf_alloc(PBUF_TRANSPORT, remainder + optlen, PBUF_RAM);
 800fa70:	eb0b 0106 	add.w	r1, fp, r6
 800fa74:	f44f 7220 	mov.w	r2, #640	@ 0x280
 800fa78:	b289      	uxth	r1, r1
 800fa7a:	2036      	movs	r0, #54	@ 0x36
 800fa7c:	f7fc f8c0 	bl	800bc00 <pbuf_alloc>
  if (p == NULL) {
 800fa80:	4680      	mov	r8, r0
 800fa82:	b170      	cbz	r0, 800faa2 <tcp_split_unsent_seg+0x76>
  offset = useg->p->tot_len - useg->len + split;
 800fa84:	6868      	ldr	r0, [r5, #4]
 800fa86:	8903      	ldrh	r3, [r0, #8]
 800fa88:	892a      	ldrh	r2, [r5, #8]
 800fa8a:	1a9b      	subs	r3, r3, r2
 800fa8c:	fa14 f383 	uxtah	r3, r4, r3
  if (pbuf_copy_partial(useg->p, (u8_t *)p->payload + optlen, remainder, offset ) != remainder) {
 800fa90:	f8d8 1004 	ldr.w	r1, [r8, #4]
 800fa94:	b29b      	uxth	r3, r3
 800fa96:	4632      	mov	r2, r6
 800fa98:	4459      	add	r1, fp
 800fa9a:	f7fc faaf 	bl	800bffc <pbuf_copy_partial>
 800fa9e:	42b0      	cmp	r0, r6
 800faa0:	d031      	beq.n	800fb06 <tcp_split_unsent_seg+0xda>
  TCP_STATS_INC(tcp.memerr);
 800faa2:	4a4e      	ldr	r2, [pc, #312]	@ (800fbdc <tcp_split_unsent_seg+0x1b0>)
 800faa4:	f8b2 30b8 	ldrh.w	r3, [r2, #184]	@ 0xb8
 800faa8:	3301      	adds	r3, #1
 800faaa:	f8a2 30b8 	strh.w	r3, [r2, #184]	@ 0xb8
  if (p != NULL) {
 800faae:	f1b8 0f00 	cmp.w	r8, #0
 800fab2:	f000 8090 	beq.w	800fbd6 <tcp_split_unsent_seg+0x1aa>
    pbuf_free(p);
 800fab6:	4640      	mov	r0, r8
 800fab8:	f7fc f83a 	bl	800bb30 <pbuf_free>
  return ERR_MEM;
 800fabc:	f04f 30ff 	mov.w	r0, #4294967295
 800fac0:	e086      	b.n	800fbd0 <tcp_split_unsent_seg+0x1a4>
  LWIP_ASSERT("tcp_split_unsent_seg: invalid pcb", pcb != NULL);
 800fac2:	4b47      	ldr	r3, [pc, #284]	@ (800fbe0 <tcp_split_unsent_seg+0x1b4>)
 800fac4:	f240 324b 	movw	r2, #843	@ 0x34b
 800fac8:	4946      	ldr	r1, [pc, #280]	@ (800fbe4 <tcp_split_unsent_seg+0x1b8>)
 800faca:	4847      	ldr	r0, [pc, #284]	@ (800fbe8 <tcp_split_unsent_seg+0x1bc>)
 800facc:	f004 fa58 	bl	8013f80 <iprintf>
 800fad0:	e7b3      	b.n	800fa3a <tcp_split_unsent_seg+0xe>
    LWIP_ASSERT("Can't split segment into length 0", 0);
 800fad2:	4b43      	ldr	r3, [pc, #268]	@ (800fbe0 <tcp_split_unsent_seg+0x1b4>)
 800fad4:	f240 3253 	movw	r2, #851	@ 0x353
 800fad8:	4944      	ldr	r1, [pc, #272]	@ (800fbec <tcp_split_unsent_seg+0x1c0>)
 800fada:	4843      	ldr	r0, [pc, #268]	@ (800fbe8 <tcp_split_unsent_seg+0x1bc>)
 800fadc:	f004 fa50 	bl	8013f80 <iprintf>
    return ERR_VAL;
 800fae0:	f06f 0005 	mvn.w	r0, #5
 800fae4:	e074      	b.n	800fbd0 <tcp_split_unsent_seg+0x1a4>
  LWIP_ASSERT("split <= mss", split <= pcb->mss);
 800fae6:	4b3e      	ldr	r3, [pc, #248]	@ (800fbe0 <tcp_split_unsent_seg+0x1b4>)
 800fae8:	f240 325b 	movw	r2, #859	@ 0x35b
 800faec:	4940      	ldr	r1, [pc, #256]	@ (800fbf0 <tcp_split_unsent_seg+0x1c4>)
 800faee:	483e      	ldr	r0, [pc, #248]	@ (800fbe8 <tcp_split_unsent_seg+0x1bc>)
 800faf0:	f004 fa46 	bl	8013f80 <iprintf>
 800faf4:	e7ae      	b.n	800fa54 <tcp_split_unsent_seg+0x28>
  LWIP_ASSERT("useg->len > 0", useg->len > 0);
 800faf6:	4b3a      	ldr	r3, [pc, #232]	@ (800fbe0 <tcp_split_unsent_seg+0x1b4>)
 800faf8:	f44f 7257 	mov.w	r2, #860	@ 0x35c
 800fafc:	493d      	ldr	r1, [pc, #244]	@ (800fbf4 <tcp_split_unsent_seg+0x1c8>)
 800fafe:	483a      	ldr	r0, [pc, #232]	@ (800fbe8 <tcp_split_unsent_seg+0x1bc>)
 800fb00:	f004 fa3e 	bl	8013f80 <iprintf>
 800fb04:	e7a9      	b.n	800fa5a <tcp_split_unsent_seg+0x2e>
  split_flags = TCPH_FLAGS(useg->tcphdr);
 800fb06:	692b      	ldr	r3, [r5, #16]
 800fb08:	8998      	ldrh	r0, [r3, #12]
 800fb0a:	f7fb f829 	bl	800ab60 <lwip_htons>
 800fb0e:	b2c3      	uxtb	r3, r0
 800fb10:	f000 063f 	and.w	r6, r0, #63	@ 0x3f
  if (split_flags & TCP_PSH) {
 800fb14:	f010 0b08 	ands.w	fp, r0, #8
 800fb18:	d003      	beq.n	800fb22 <tcp_split_unsent_seg+0xf6>
    split_flags &= ~TCP_PSH;
 800fb1a:	f003 0637 	and.w	r6, r3, #55	@ 0x37
    remainder_flags |= TCP_PSH;
 800fb1e:	f04f 0b08 	mov.w	fp, #8
  if (split_flags & TCP_FIN) {
 800fb22:	f016 0f01 	tst.w	r6, #1
 800fb26:	d003      	beq.n	800fb30 <tcp_split_unsent_seg+0x104>
    split_flags &= ~TCP_FIN;
 800fb28:	f006 06fe 	and.w	r6, r6, #254	@ 0xfe
    remainder_flags |= TCP_FIN;
 800fb2c:	f04b 0b01 	orr.w	fp, fp, #1
  seg = tcp_create_segment(pcb, p, remainder_flags, lwip_ntohl(useg->tcphdr->seqno) + split, optflags);
 800fb30:	692b      	ldr	r3, [r5, #16]
 800fb32:	6858      	ldr	r0, [r3, #4]
 800fb34:	f7fb f819 	bl	800ab6a <lwip_htonl>
 800fb38:	f8cd 9000 	str.w	r9, [sp]
 800fb3c:	1823      	adds	r3, r4, r0
 800fb3e:	465a      	mov	r2, fp
 800fb40:	4641      	mov	r1, r8
 800fb42:	4638      	mov	r0, r7
 800fb44:	f7ff fab4 	bl	800f0b0 <tcp_create_segment>
  if (seg == NULL) {
 800fb48:	4681      	mov	r9, r0
 800fb4a:	2800      	cmp	r0, #0
 800fb4c:	d0a9      	beq.n	800faa2 <tcp_split_unsent_seg+0x76>
  pcb->snd_queuelen -= pbuf_clen(useg->p);
 800fb4e:	6868      	ldr	r0, [r5, #4]
 800fb50:	f7fc f956 	bl	800be00 <pbuf_clen>
 800fb54:	f8b7 3066 	ldrh.w	r3, [r7, #102]	@ 0x66
 800fb58:	1a1b      	subs	r3, r3, r0
 800fb5a:	f8a7 3066 	strh.w	r3, [r7, #102]	@ 0x66
  pbuf_realloc(useg->p, useg->p->tot_len - remainder);
 800fb5e:	6868      	ldr	r0, [r5, #4]
 800fb60:	8901      	ldrh	r1, [r0, #8]
 800fb62:	eba4 040a 	sub.w	r4, r4, sl
 800fb66:	b2a4      	uxth	r4, r4
 800fb68:	4421      	add	r1, r4
 800fb6a:	b289      	uxth	r1, r1
 800fb6c:	f7fc f8f4 	bl	800bd58 <pbuf_realloc>
  useg->len -= remainder;
 800fb70:	892b      	ldrh	r3, [r5, #8]
 800fb72:	4423      	add	r3, r4
 800fb74:	812b      	strh	r3, [r5, #8]
  TCPH_SET_FLAG(useg->tcphdr, split_flags);
 800fb76:	692b      	ldr	r3, [r5, #16]
 800fb78:	899c      	ldrh	r4, [r3, #12]
 800fb7a:	4630      	mov	r0, r6
 800fb7c:	f7fa fff0 	bl	800ab60 <lwip_htons>
 800fb80:	692b      	ldr	r3, [r5, #16]
 800fb82:	4304      	orrs	r4, r0
 800fb84:	819c      	strh	r4, [r3, #12]
  useg->oversize_left = 0;
 800fb86:	2300      	movs	r3, #0
 800fb88:	816b      	strh	r3, [r5, #10]
  pcb->snd_queuelen += pbuf_clen(useg->p);
 800fb8a:	6868      	ldr	r0, [r5, #4]
 800fb8c:	f7fc f938 	bl	800be00 <pbuf_clen>
 800fb90:	f8b7 3066 	ldrh.w	r3, [r7, #102]	@ 0x66
 800fb94:	4403      	add	r3, r0
 800fb96:	f8a7 3066 	strh.w	r3, [r7, #102]	@ 0x66
  pcb->snd_queuelen += pbuf_clen(seg->p);
 800fb9a:	f8d9 0004 	ldr.w	r0, [r9, #4]
 800fb9e:	f7fc f92f 	bl	800be00 <pbuf_clen>
 800fba2:	f8b7 3066 	ldrh.w	r3, [r7, #102]	@ 0x66
 800fba6:	4403      	add	r3, r0
 800fba8:	f8a7 3066 	strh.w	r3, [r7, #102]	@ 0x66
  seg->next = useg->next;
 800fbac:	682b      	ldr	r3, [r5, #0]
 800fbae:	f8c9 3000 	str.w	r3, [r9]
  useg->next = seg;
 800fbb2:	f8c5 9000 	str.w	r9, [r5]
  if (seg->next == NULL) {
 800fbb6:	f8d9 3000 	ldr.w	r3, [r9]
 800fbba:	b10b      	cbz	r3, 800fbc0 <tcp_split_unsent_seg+0x194>
  return ERR_OK;
 800fbbc:	2000      	movs	r0, #0
 800fbbe:	e007      	b.n	800fbd0 <tcp_split_unsent_seg+0x1a4>
    pcb->unsent_oversize = 0;
 800fbc0:	2000      	movs	r0, #0
 800fbc2:	f8a7 0068 	strh.w	r0, [r7, #104]	@ 0x68
 800fbc6:	e003      	b.n	800fbd0 <tcp_split_unsent_seg+0x1a4>
    return ERR_MEM;
 800fbc8:	f04f 30ff 	mov.w	r0, #4294967295
 800fbcc:	e000      	b.n	800fbd0 <tcp_split_unsent_seg+0x1a4>
    return ERR_OK;
 800fbce:	2000      	movs	r0, #0
}
 800fbd0:	b003      	add	sp, #12
 800fbd2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  return ERR_MEM;
 800fbd6:	f04f 30ff 	mov.w	r0, #4294967295
 800fbda:	e7f9      	b.n	800fbd0 <tcp_split_unsent_seg+0x1a4>
 800fbdc:	240141b4 	.word	0x240141b4
 800fbe0:	080174bc 	.word	0x080174bc
 800fbe4:	080179d0 	.word	0x080179d0
 800fbe8:	08015744 	.word	0x08015744
 800fbec:	080179f4 	.word	0x080179f4
 800fbf0:	08017a18 	.word	0x08017a18
 800fbf4:	08017a28 	.word	0x08017a28

0800fbf8 <tcp_enqueue_flags>:
{
 800fbf8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800fbfc:	b083      	sub	sp, #12
 800fbfe:	4604      	mov	r4, r0
 800fc00:	460d      	mov	r5, r1
  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
 800fc02:	f011 0703 	ands.w	r7, r1, #3
 800fc06:	d04e      	beq.n	800fca6 <tcp_enqueue_flags+0xae>
  LWIP_ASSERT("tcp_enqueue_flags: invalid pcb", pcb != NULL);
 800fc08:	2c00      	cmp	r4, #0
 800fc0a:	d054      	beq.n	800fcb6 <tcp_enqueue_flags+0xbe>
  if (flags & TCP_SYN) {
 800fc0c:	f015 0802 	ands.w	r8, r5, #2
 800fc10:	d001      	beq.n	800fc16 <tcp_enqueue_flags+0x1e>
    optflags = TF_SEG_OPTS_MSS;
 800fc12:	f04f 0801 	mov.w	r8, #1
  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
 800fc16:	ea4f 0688 	mov.w	r6, r8, lsl #2
 800fc1a:	f006 0604 	and.w	r6, r6, #4
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 800fc1e:	f44f 7220 	mov.w	r2, #640	@ 0x280
 800fc22:	4631      	mov	r1, r6
 800fc24:	2036      	movs	r0, #54	@ 0x36
 800fc26:	f7fb ffeb 	bl	800bc00 <pbuf_alloc>
 800fc2a:	4681      	mov	r9, r0
 800fc2c:	2800      	cmp	r0, #0
 800fc2e:	d04a      	beq.n	800fcc6 <tcp_enqueue_flags+0xce>
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
 800fc30:	8943      	ldrh	r3, [r0, #10]
 800fc32:	429e      	cmp	r6, r3
 800fc34:	d854      	bhi.n	800fce0 <tcp_enqueue_flags+0xe8>
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
 800fc36:	f8cd 8000 	str.w	r8, [sp]
 800fc3a:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 800fc3c:	462a      	mov	r2, r5
 800fc3e:	4649      	mov	r1, r9
 800fc40:	4620      	mov	r0, r4
 800fc42:	f7ff fa35 	bl	800f0b0 <tcp_create_segment>
 800fc46:	4606      	mov	r6, r0
 800fc48:	2800      	cmp	r0, #0
 800fc4a:	d051      	beq.n	800fcf0 <tcp_enqueue_flags+0xf8>
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % LWIP_MIN(MEM_ALIGNMENT, 4)) == 0);
 800fc4c:	6903      	ldr	r3, [r0, #16]
 800fc4e:	f013 0f03 	tst.w	r3, #3
 800fc52:	d15a      	bne.n	800fd0a <tcp_enqueue_flags+0x112>
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
 800fc54:	8933      	ldrh	r3, [r6, #8]
 800fc56:	2b00      	cmp	r3, #0
 800fc58:	d15f      	bne.n	800fd1a <tcp_enqueue_flags+0x122>
  if (pcb->unsent == NULL) {
 800fc5a:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
 800fc5c:	2b00      	cmp	r3, #0
 800fc5e:	d064      	beq.n	800fd2a <tcp_enqueue_flags+0x132>
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 800fc60:	461a      	mov	r2, r3
 800fc62:	681b      	ldr	r3, [r3, #0]
 800fc64:	2b00      	cmp	r3, #0
 800fc66:	d1fb      	bne.n	800fc60 <tcp_enqueue_flags+0x68>
    useg->next = seg;
 800fc68:	6016      	str	r6, [r2, #0]
  pcb->unsent_oversize = 0;
 800fc6a:	2300      	movs	r3, #0
 800fc6c:	f8a4 3068 	strh.w	r3, [r4, #104]	@ 0x68
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
 800fc70:	b14f      	cbz	r7, 800fc86 <tcp_enqueue_flags+0x8e>
    pcb->snd_lbb++;
 800fc72:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 800fc74:	3301      	adds	r3, #1
 800fc76:	65e3      	str	r3, [r4, #92]	@ 0x5c
  if (flags & TCP_FIN) {
 800fc78:	f015 0f01 	tst.w	r5, #1
 800fc7c:	d003      	beq.n	800fc86 <tcp_enqueue_flags+0x8e>
    tcp_set_flags(pcb, TF_FIN);
 800fc7e:	8b63      	ldrh	r3, [r4, #26]
 800fc80:	f043 0320 	orr.w	r3, r3, #32
 800fc84:	8363      	strh	r3, [r4, #26]
  pcb->snd_queuelen += pbuf_clen(seg->p);
 800fc86:	6870      	ldr	r0, [r6, #4]
 800fc88:	f7fc f8ba 	bl	800be00 <pbuf_clen>
 800fc8c:	f8b4 3066 	ldrh.w	r3, [r4, #102]	@ 0x66
 800fc90:	4418      	add	r0, r3
 800fc92:	b280      	uxth	r0, r0
 800fc94:	f8a4 0066 	strh.w	r0, [r4, #102]	@ 0x66
  if (pcb->snd_queuelen != 0) {
 800fc98:	2800      	cmp	r0, #0
 800fc9a:	d055      	beq.n	800fd48 <tcp_enqueue_flags+0x150>
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
 800fc9c:	6f23      	ldr	r3, [r4, #112]	@ 0x70
 800fc9e:	2b00      	cmp	r3, #0
 800fca0:	d045      	beq.n	800fd2e <tcp_enqueue_flags+0x136>
  return ERR_OK;
 800fca2:	2000      	movs	r0, #0
 800fca4:	e051      	b.n	800fd4a <tcp_enqueue_flags+0x152>
  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
 800fca6:	4b2a      	ldr	r3, [pc, #168]	@ (800fd50 <tcp_enqueue_flags+0x158>)
 800fca8:	f240 4211 	movw	r2, #1041	@ 0x411
 800fcac:	4929      	ldr	r1, [pc, #164]	@ (800fd54 <tcp_enqueue_flags+0x15c>)
 800fcae:	482a      	ldr	r0, [pc, #168]	@ (800fd58 <tcp_enqueue_flags+0x160>)
 800fcb0:	f004 f966 	bl	8013f80 <iprintf>
 800fcb4:	e7a8      	b.n	800fc08 <tcp_enqueue_flags+0x10>
  LWIP_ASSERT("tcp_enqueue_flags: invalid pcb", pcb != NULL);
 800fcb6:	4b26      	ldr	r3, [pc, #152]	@ (800fd50 <tcp_enqueue_flags+0x158>)
 800fcb8:	f240 4213 	movw	r2, #1043	@ 0x413
 800fcbc:	4927      	ldr	r1, [pc, #156]	@ (800fd5c <tcp_enqueue_flags+0x164>)
 800fcbe:	4826      	ldr	r0, [pc, #152]	@ (800fd58 <tcp_enqueue_flags+0x160>)
 800fcc0:	f004 f95e 	bl	8013f80 <iprintf>
 800fcc4:	e7a2      	b.n	800fc0c <tcp_enqueue_flags+0x14>
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 800fcc6:	8b63      	ldrh	r3, [r4, #26]
 800fcc8:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800fccc:	8363      	strh	r3, [r4, #26]
    TCP_STATS_INC(tcp.memerr);
 800fcce:	4a24      	ldr	r2, [pc, #144]	@ (800fd60 <tcp_enqueue_flags+0x168>)
 800fcd0:	f8b2 30b8 	ldrh.w	r3, [r2, #184]	@ 0xb8
 800fcd4:	3301      	adds	r3, #1
 800fcd6:	f8a2 30b8 	strh.w	r3, [r2, #184]	@ 0xb8
    return ERR_MEM;
 800fcda:	f04f 30ff 	mov.w	r0, #4294967295
 800fcde:	e034      	b.n	800fd4a <tcp_enqueue_flags+0x152>
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
 800fce0:	4b1b      	ldr	r3, [pc, #108]	@ (800fd50 <tcp_enqueue_flags+0x158>)
 800fce2:	f240 4239 	movw	r2, #1081	@ 0x439
 800fce6:	491f      	ldr	r1, [pc, #124]	@ (800fd64 <tcp_enqueue_flags+0x16c>)
 800fce8:	481b      	ldr	r0, [pc, #108]	@ (800fd58 <tcp_enqueue_flags+0x160>)
 800fcea:	f004 f949 	bl	8013f80 <iprintf>
 800fcee:	e7a2      	b.n	800fc36 <tcp_enqueue_flags+0x3e>
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 800fcf0:	8b63      	ldrh	r3, [r4, #26]
 800fcf2:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800fcf6:	8363      	strh	r3, [r4, #26]
    TCP_STATS_INC(tcp.memerr);
 800fcf8:	4a19      	ldr	r2, [pc, #100]	@ (800fd60 <tcp_enqueue_flags+0x168>)
 800fcfa:	f8b2 30b8 	ldrh.w	r3, [r2, #184]	@ 0xb8
 800fcfe:	3301      	adds	r3, #1
 800fd00:	f8a2 30b8 	strh.w	r3, [r2, #184]	@ 0xb8
    return ERR_MEM;
 800fd04:	f04f 30ff 	mov.w	r0, #4294967295
 800fd08:	e01f      	b.n	800fd4a <tcp_enqueue_flags+0x152>
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % LWIP_MIN(MEM_ALIGNMENT, 4)) == 0);
 800fd0a:	4b11      	ldr	r3, [pc, #68]	@ (800fd50 <tcp_enqueue_flags+0x158>)
 800fd0c:	f240 4242 	movw	r2, #1090	@ 0x442
 800fd10:	4915      	ldr	r1, [pc, #84]	@ (800fd68 <tcp_enqueue_flags+0x170>)
 800fd12:	4811      	ldr	r0, [pc, #68]	@ (800fd58 <tcp_enqueue_flags+0x160>)
 800fd14:	f004 f934 	bl	8013f80 <iprintf>
 800fd18:	e79c      	b.n	800fc54 <tcp_enqueue_flags+0x5c>
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
 800fd1a:	4b0d      	ldr	r3, [pc, #52]	@ (800fd50 <tcp_enqueue_flags+0x158>)
 800fd1c:	f240 4243 	movw	r2, #1091	@ 0x443
 800fd20:	4912      	ldr	r1, [pc, #72]	@ (800fd6c <tcp_enqueue_flags+0x174>)
 800fd22:	480d      	ldr	r0, [pc, #52]	@ (800fd58 <tcp_enqueue_flags+0x160>)
 800fd24:	f004 f92c 	bl	8013f80 <iprintf>
 800fd28:	e797      	b.n	800fc5a <tcp_enqueue_flags+0x62>
    pcb->unsent = seg;
 800fd2a:	66e6      	str	r6, [r4, #108]	@ 0x6c
 800fd2c:	e79d      	b.n	800fc6a <tcp_enqueue_flags+0x72>
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
 800fd2e:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
 800fd30:	b10b      	cbz	r3, 800fd36 <tcp_enqueue_flags+0x13e>
  return ERR_OK;
 800fd32:	2000      	movs	r0, #0
 800fd34:	e009      	b.n	800fd4a <tcp_enqueue_flags+0x152>
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
 800fd36:	4b06      	ldr	r3, [pc, #24]	@ (800fd50 <tcp_enqueue_flags+0x158>)
 800fd38:	f240 4265 	movw	r2, #1125	@ 0x465
 800fd3c:	490c      	ldr	r1, [pc, #48]	@ (800fd70 <tcp_enqueue_flags+0x178>)
 800fd3e:	4806      	ldr	r0, [pc, #24]	@ (800fd58 <tcp_enqueue_flags+0x160>)
 800fd40:	f004 f91e 	bl	8013f80 <iprintf>
  return ERR_OK;
 800fd44:	2000      	movs	r0, #0
 800fd46:	e000      	b.n	800fd4a <tcp_enqueue_flags+0x152>
 800fd48:	2000      	movs	r0, #0
}
 800fd4a:	b003      	add	sp, #12
 800fd4c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800fd50:	080174bc 	.word	0x080174bc
 800fd54:	08017a38 	.word	0x08017a38
 800fd58:	08015744 	.word	0x08015744
 800fd5c:	08017a90 	.word	0x08017a90
 800fd60:	240141b4 	.word	0x240141b4
 800fd64:	08017ab0 	.word	0x08017ab0
 800fd68:	08017aec 	.word	0x08017aec
 800fd6c:	08017b04 	.word	0x08017b04
 800fd70:	08017b30 	.word	0x08017b30

0800fd74 <tcp_send_fin>:
{
 800fd74:	b570      	push	{r4, r5, r6, lr}
  LWIP_ASSERT("tcp_send_fin: invalid pcb", pcb != NULL);
 800fd76:	4605      	mov	r5, r0
 800fd78:	b188      	cbz	r0, 800fd9e <tcp_send_fin+0x2a>
  if (pcb->unsent != NULL) {
 800fd7a:	6eeb      	ldr	r3, [r5, #108]	@ 0x6c
 800fd7c:	b153      	cbz	r3, 800fd94 <tcp_send_fin+0x20>
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 800fd7e:	461c      	mov	r4, r3
 800fd80:	681b      	ldr	r3, [r3, #0]
 800fd82:	2b00      	cmp	r3, #0
 800fd84:	d1fb      	bne.n	800fd7e <tcp_send_fin+0xa>
    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
 800fd86:	6923      	ldr	r3, [r4, #16]
 800fd88:	8998      	ldrh	r0, [r3, #12]
 800fd8a:	f7fa fee9 	bl	800ab60 <lwip_htons>
 800fd8e:	f010 0f07 	tst.w	r0, #7
 800fd92:	d00c      	beq.n	800fdae <tcp_send_fin+0x3a>
  return tcp_enqueue_flags(pcb, TCP_FIN);
 800fd94:	2101      	movs	r1, #1
 800fd96:	4628      	mov	r0, r5
 800fd98:	f7ff ff2e 	bl	800fbf8 <tcp_enqueue_flags>
}
 800fd9c:	bd70      	pop	{r4, r5, r6, pc}
  LWIP_ASSERT("tcp_send_fin: invalid pcb", pcb != NULL);
 800fd9e:	4b0b      	ldr	r3, [pc, #44]	@ (800fdcc <tcp_send_fin+0x58>)
 800fda0:	f240 32eb 	movw	r2, #1003	@ 0x3eb
 800fda4:	490a      	ldr	r1, [pc, #40]	@ (800fdd0 <tcp_send_fin+0x5c>)
 800fda6:	480b      	ldr	r0, [pc, #44]	@ (800fdd4 <tcp_send_fin+0x60>)
 800fda8:	f004 f8ea 	bl	8013f80 <iprintf>
 800fdac:	e7e5      	b.n	800fd7a <tcp_send_fin+0x6>
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
 800fdae:	6923      	ldr	r3, [r4, #16]
 800fdb0:	899e      	ldrh	r6, [r3, #12]
 800fdb2:	2001      	movs	r0, #1
 800fdb4:	f7fa fed4 	bl	800ab60 <lwip_htons>
 800fdb8:	6923      	ldr	r3, [r4, #16]
 800fdba:	4306      	orrs	r6, r0
 800fdbc:	819e      	strh	r6, [r3, #12]
      tcp_set_flags(pcb, TF_FIN);
 800fdbe:	8b6b      	ldrh	r3, [r5, #26]
 800fdc0:	f043 0320 	orr.w	r3, r3, #32
 800fdc4:	836b      	strh	r3, [r5, #26]
      return ERR_OK;
 800fdc6:	2000      	movs	r0, #0
 800fdc8:	e7e8      	b.n	800fd9c <tcp_send_fin+0x28>
 800fdca:	bf00      	nop
 800fdcc:	080174bc 	.word	0x080174bc
 800fdd0:	08017b58 	.word	0x08017b58
 800fdd4:	08015744 	.word	0x08015744

0800fdd8 <tcp_rexmit_rto_prepare>:
{
 800fdd8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  LWIP_ASSERT("tcp_rexmit_rto_prepare: invalid pcb", pcb != NULL);
 800fdda:	4605      	mov	r5, r0
 800fddc:	b158      	cbz	r0, 800fdf6 <tcp_rexmit_rto_prepare+0x1e>
  if (pcb->unacked == NULL) {
 800fdde:	6f2c      	ldr	r4, [r5, #112]	@ 0x70
 800fde0:	2c00      	cmp	r4, #0
 800fde2:	d039      	beq.n	800fe58 <tcp_rexmit_rto_prepare+0x80>
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next) {
 800fde4:	6823      	ldr	r3, [r4, #0]
 800fde6:	b173      	cbz	r3, 800fe06 <tcp_rexmit_rto_prepare+0x2e>
    if (tcp_output_segment_busy(seg)) {
 800fde8:	4620      	mov	r0, r4
 800fdea:	f7ff f8c3 	bl	800ef74 <tcp_output_segment_busy>
 800fdee:	2800      	cmp	r0, #0
 800fdf0:	d135      	bne.n	800fe5e <tcp_rexmit_rto_prepare+0x86>
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next) {
 800fdf2:	6824      	ldr	r4, [r4, #0]
 800fdf4:	e7f6      	b.n	800fde4 <tcp_rexmit_rto_prepare+0xc>
  LWIP_ASSERT("tcp_rexmit_rto_prepare: invalid pcb", pcb != NULL);
 800fdf6:	4b1d      	ldr	r3, [pc, #116]	@ (800fe6c <tcp_rexmit_rto_prepare+0x94>)
 800fdf8:	f240 6263 	movw	r2, #1635	@ 0x663
 800fdfc:	491c      	ldr	r1, [pc, #112]	@ (800fe70 <tcp_rexmit_rto_prepare+0x98>)
 800fdfe:	481d      	ldr	r0, [pc, #116]	@ (800fe74 <tcp_rexmit_rto_prepare+0x9c>)
 800fe00:	f004 f8be 	bl	8013f80 <iprintf>
 800fe04:	e7eb      	b.n	800fdde <tcp_rexmit_rto_prepare+0x6>
  if (tcp_output_segment_busy(seg)) {
 800fe06:	4620      	mov	r0, r4
 800fe08:	f7ff f8b4 	bl	800ef74 <tcp_output_segment_busy>
 800fe0c:	bb50      	cbnz	r0, 800fe64 <tcp_rexmit_rto_prepare+0x8c>
  seg->next = pcb->unsent;
 800fe0e:	6eeb      	ldr	r3, [r5, #108]	@ 0x6c
 800fe10:	6023      	str	r3, [r4, #0]
  if (pcb->unsent == NULL) {
 800fe12:	b1db      	cbz	r3, 800fe4c <tcp_rexmit_rto_prepare+0x74>
  pcb->unsent = pcb->unacked;
 800fe14:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
 800fe16:	66eb      	str	r3, [r5, #108]	@ 0x6c
  pcb->unacked = NULL;
 800fe18:	2300      	movs	r3, #0
 800fe1a:	672b      	str	r3, [r5, #112]	@ 0x70
  tcp_set_flags(pcb, TF_RTO);
 800fe1c:	8b6b      	ldrh	r3, [r5, #26]
 800fe1e:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 800fe22:	836b      	strh	r3, [r5, #26]
  pcb->rto_end = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 800fe24:	6923      	ldr	r3, [r4, #16]
 800fe26:	6858      	ldr	r0, [r3, #4]
 800fe28:	f7fa fe9f 	bl	800ab6a <lwip_htonl>
 800fe2c:	4606      	mov	r6, r0
 800fe2e:	8927      	ldrh	r7, [r4, #8]
 800fe30:	6923      	ldr	r3, [r4, #16]
 800fe32:	8998      	ldrh	r0, [r3, #12]
 800fe34:	f7fa fe94 	bl	800ab60 <lwip_htons>
 800fe38:	f010 0f03 	tst.w	r0, #3
 800fe3c:	d00a      	beq.n	800fe54 <tcp_rexmit_rto_prepare+0x7c>
 800fe3e:	2301      	movs	r3, #1
 800fe40:	441f      	add	r7, r3
 800fe42:	443e      	add	r6, r7
 800fe44:	64ee      	str	r6, [r5, #76]	@ 0x4c
  pcb->rttest = 0;
 800fe46:	2000      	movs	r0, #0
 800fe48:	6368      	str	r0, [r5, #52]	@ 0x34
}
 800fe4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    pcb->unsent_oversize = seg->oversize_left;
 800fe4c:	8963      	ldrh	r3, [r4, #10]
 800fe4e:	f8a5 3068 	strh.w	r3, [r5, #104]	@ 0x68
 800fe52:	e7df      	b.n	800fe14 <tcp_rexmit_rto_prepare+0x3c>
  pcb->rto_end = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 800fe54:	2300      	movs	r3, #0
 800fe56:	e7f3      	b.n	800fe40 <tcp_rexmit_rto_prepare+0x68>
    return ERR_VAL;
 800fe58:	f06f 0005 	mvn.w	r0, #5
 800fe5c:	e7f5      	b.n	800fe4a <tcp_rexmit_rto_prepare+0x72>
      return ERR_VAL;
 800fe5e:	f06f 0005 	mvn.w	r0, #5
 800fe62:	e7f2      	b.n	800fe4a <tcp_rexmit_rto_prepare+0x72>
    return ERR_VAL;
 800fe64:	f06f 0005 	mvn.w	r0, #5
 800fe68:	e7ef      	b.n	800fe4a <tcp_rexmit_rto_prepare+0x72>
 800fe6a:	bf00      	nop
 800fe6c:	080174bc 	.word	0x080174bc
 800fe70:	08017b74 	.word	0x08017b74
 800fe74:	08015744 	.word	0x08015744

0800fe78 <tcp_rexmit>:
{
 800fe78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  LWIP_ASSERT("tcp_rexmit: invalid pcb", pcb != NULL);
 800fe7a:	4607      	mov	r7, r0
 800fe7c:	b150      	cbz	r0, 800fe94 <tcp_rexmit+0x1c>
  if (pcb->unacked == NULL) {
 800fe7e:	6f3e      	ldr	r6, [r7, #112]	@ 0x70
 800fe80:	b38e      	cbz	r6, 800fee6 <tcp_rexmit+0x6e>
  if (tcp_output_segment_busy(seg)) {
 800fe82:	4630      	mov	r0, r6
 800fe84:	f7ff f876 	bl	800ef74 <tcp_output_segment_busy>
 800fe88:	bb80      	cbnz	r0, 800feec <tcp_rexmit+0x74>
  pcb->unacked = seg->next;
 800fe8a:	6833      	ldr	r3, [r6, #0]
 800fe8c:	673b      	str	r3, [r7, #112]	@ 0x70
  cur_seg = &(pcb->unsent);
 800fe8e:	f107 056c 	add.w	r5, r7, #108	@ 0x6c
  while (*cur_seg &&
 800fe92:	e008      	b.n	800fea6 <tcp_rexmit+0x2e>
  LWIP_ASSERT("tcp_rexmit: invalid pcb", pcb != NULL);
 800fe94:	4b17      	ldr	r3, [pc, #92]	@ (800fef4 <tcp_rexmit+0x7c>)
 800fe96:	f240 62c1 	movw	r2, #1729	@ 0x6c1
 800fe9a:	4917      	ldr	r1, [pc, #92]	@ (800fef8 <tcp_rexmit+0x80>)
 800fe9c:	4817      	ldr	r0, [pc, #92]	@ (800fefc <tcp_rexmit+0x84>)
 800fe9e:	f004 f86f 	bl	8013f80 <iprintf>
 800fea2:	e7ec      	b.n	800fe7e <tcp_rexmit+0x6>
    cur_seg = &((*cur_seg)->next );
 800fea4:	682d      	ldr	r5, [r5, #0]
  while (*cur_seg &&
 800fea6:	682b      	ldr	r3, [r5, #0]
 800fea8:	b15b      	cbz	r3, 800fec2 <tcp_rexmit+0x4a>
         TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
 800feaa:	691b      	ldr	r3, [r3, #16]
 800feac:	6858      	ldr	r0, [r3, #4]
 800feae:	f7fa fe5c 	bl	800ab6a <lwip_htonl>
 800feb2:	4604      	mov	r4, r0
 800feb4:	6933      	ldr	r3, [r6, #16]
 800feb6:	6858      	ldr	r0, [r3, #4]
 800feb8:	f7fa fe57 	bl	800ab6a <lwip_htonl>
 800febc:	1a24      	subs	r4, r4, r0
  while (*cur_seg &&
 800febe:	2c00      	cmp	r4, #0
 800fec0:	dbf0      	blt.n	800fea4 <tcp_rexmit+0x2c>
  seg->next = *cur_seg;
 800fec2:	682b      	ldr	r3, [r5, #0]
 800fec4:	6033      	str	r3, [r6, #0]
  *cur_seg = seg;
 800fec6:	602e      	str	r6, [r5, #0]
  if (seg->next == NULL) {
 800fec8:	6833      	ldr	r3, [r6, #0]
 800feca:	b14b      	cbz	r3, 800fee0 <tcp_rexmit+0x68>
  if (pcb->nrtx < 0xFF) {
 800fecc:	f897 3042 	ldrb.w	r3, [r7, #66]	@ 0x42
 800fed0:	2bff      	cmp	r3, #255	@ 0xff
 800fed2:	d002      	beq.n	800feda <tcp_rexmit+0x62>
    ++pcb->nrtx;
 800fed4:	3301      	adds	r3, #1
 800fed6:	f887 3042 	strb.w	r3, [r7, #66]	@ 0x42
  pcb->rttest = 0;
 800feda:	2000      	movs	r0, #0
 800fedc:	6378      	str	r0, [r7, #52]	@ 0x34
}
 800fede:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    pcb->unsent_oversize = 0;
 800fee0:	f8a7 3068 	strh.w	r3, [r7, #104]	@ 0x68
 800fee4:	e7f2      	b.n	800fecc <tcp_rexmit+0x54>
    return ERR_VAL;
 800fee6:	f06f 0005 	mvn.w	r0, #5
 800feea:	e7f8      	b.n	800fede <tcp_rexmit+0x66>
    return ERR_VAL;
 800feec:	f06f 0005 	mvn.w	r0, #5
 800fef0:	e7f5      	b.n	800fede <tcp_rexmit+0x66>
 800fef2:	bf00      	nop
 800fef4:	080174bc 	.word	0x080174bc
 800fef8:	08017b98 	.word	0x08017b98
 800fefc:	08015744 	.word	0x08015744

0800ff00 <tcp_rexmit_fast>:
{
 800ff00:	b510      	push	{r4, lr}
  LWIP_ASSERT("tcp_rexmit_fast: invalid pcb", pcb != NULL);
 800ff02:	4604      	mov	r4, r0
 800ff04:	b130      	cbz	r0, 800ff14 <tcp_rexmit_fast+0x14>
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 800ff06:	6f23      	ldr	r3, [r4, #112]	@ 0x70
 800ff08:	b11b      	cbz	r3, 800ff12 <tcp_rexmit_fast+0x12>
 800ff0a:	8b63      	ldrh	r3, [r4, #26]
 800ff0c:	f013 0f04 	tst.w	r3, #4
 800ff10:	d008      	beq.n	800ff24 <tcp_rexmit_fast+0x24>
}
 800ff12:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("tcp_rexmit_fast: invalid pcb", pcb != NULL);
 800ff14:	4b16      	ldr	r3, [pc, #88]	@ (800ff70 <tcp_rexmit_fast+0x70>)
 800ff16:	f240 62f9 	movw	r2, #1785	@ 0x6f9
 800ff1a:	4916      	ldr	r1, [pc, #88]	@ (800ff74 <tcp_rexmit_fast+0x74>)
 800ff1c:	4816      	ldr	r0, [pc, #88]	@ (800ff78 <tcp_rexmit_fast+0x78>)
 800ff1e:	f004 f82f 	bl	8013f80 <iprintf>
 800ff22:	e7f0      	b.n	800ff06 <tcp_rexmit_fast+0x6>
    if (tcp_rexmit(pcb) == ERR_OK) {
 800ff24:	4620      	mov	r0, r4
 800ff26:	f7ff ffa7 	bl	800fe78 <tcp_rexmit>
 800ff2a:	2800      	cmp	r0, #0
 800ff2c:	d1f1      	bne.n	800ff12 <tcp_rexmit_fast+0x12>
      pcb->ssthresh = LWIP_MIN(pcb->cwnd, pcb->snd_wnd) / 2;
 800ff2e:	f8b4 3060 	ldrh.w	r3, [r4, #96]	@ 0x60
 800ff32:	f8b4 2048 	ldrh.w	r2, [r4, #72]	@ 0x48
 800ff36:	4293      	cmp	r3, r2
 800ff38:	bf28      	it	cs
 800ff3a:	4613      	movcs	r3, r2
 800ff3c:	105b      	asrs	r3, r3, #1
 800ff3e:	f8a4 304a 	strh.w	r3, [r4, #74]	@ 0x4a
      if (pcb->ssthresh < (2U * pcb->mss)) {
 800ff42:	b29b      	uxth	r3, r3
 800ff44:	8e62      	ldrh	r2, [r4, #50]	@ 0x32
 800ff46:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
 800ff4a:	d202      	bcs.n	800ff52 <tcp_rexmit_fast+0x52>
        pcb->ssthresh = 2 * pcb->mss;
 800ff4c:	0053      	lsls	r3, r2, #1
 800ff4e:	f8a4 304a 	strh.w	r3, [r4, #74]	@ 0x4a
      pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 800ff52:	f8b4 304a 	ldrh.w	r3, [r4, #74]	@ 0x4a
 800ff56:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 800ff5a:	4413      	add	r3, r2
 800ff5c:	f8a4 3048 	strh.w	r3, [r4, #72]	@ 0x48
      tcp_set_flags(pcb, TF_INFR);
 800ff60:	8b63      	ldrh	r3, [r4, #26]
 800ff62:	f043 0304 	orr.w	r3, r3, #4
 800ff66:	8363      	strh	r3, [r4, #26]
      pcb->rtime = 0;
 800ff68:	2300      	movs	r3, #0
 800ff6a:	8623      	strh	r3, [r4, #48]	@ 0x30
}
 800ff6c:	e7d1      	b.n	800ff12 <tcp_rexmit_fast+0x12>
 800ff6e:	bf00      	nop
 800ff70:	080174bc 	.word	0x080174bc
 800ff74:	08017bb0 	.word	0x08017bb0
 800ff78:	08015744 	.word	0x08015744

0800ff7c <tcp_rst>:
 */
void
tcp_rst(const struct tcp_pcb *pcb, u32_t seqno, u32_t ackno,
        const ip_addr_t *local_ip, const ip_addr_t *remote_ip,
        u16_t local_port, u16_t remote_port)
{
 800ff7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800ff80:	b084      	sub	sp, #16
 800ff82:	4604      	mov	r4, r0
 800ff84:	460e      	mov	r6, r1
 800ff86:	4615      	mov	r5, r2
 800ff88:	9f0a      	ldr	r7, [sp, #40]	@ 0x28
  struct pbuf *p;
  u16_t wnd;
  u8_t optlen;

  LWIP_ASSERT("tcp_rst: invalid local_ip", local_ip != NULL);
 800ff8a:	4698      	mov	r8, r3
 800ff8c:	b32b      	cbz	r3, 800ffda <tcp_rst+0x5e>
  LWIP_ASSERT("tcp_rst: invalid remote_ip", remote_ip != NULL);
 800ff8e:	b367      	cbz	r7, 800ffea <tcp_rst+0x6e>
  wnd = PP_HTONS(((TCP_WND >> TCP_RCV_SCALE) & 0xFFFF));
#else
  wnd = PP_HTONS(TCP_WND);
#endif

  p = tcp_output_alloc_header_common(ackno, optlen, 0, lwip_htonl(seqno), local_port,
 800ff90:	4630      	mov	r0, r6
 800ff92:	f7fa fdea 	bl	800ab6a <lwip_htonl>
 800ff96:	4603      	mov	r3, r0
 800ff98:	f24d 0216 	movw	r2, #53270	@ 0xd016
 800ff9c:	9203      	str	r2, [sp, #12]
 800ff9e:	2214      	movs	r2, #20
 800ffa0:	9202      	str	r2, [sp, #8]
 800ffa2:	f8bd 2030 	ldrh.w	r2, [sp, #48]	@ 0x30
 800ffa6:	9201      	str	r2, [sp, #4]
 800ffa8:	f8bd 202c 	ldrh.w	r2, [sp, #44]	@ 0x2c
 800ffac:	9200      	str	r2, [sp, #0]
 800ffae:	2200      	movs	r2, #0
 800ffb0:	4611      	mov	r1, r2
 800ffb2:	4628      	mov	r0, r5
 800ffb4:	f7ff f8f8 	bl	800f1a8 <tcp_output_alloc_header_common>
    remote_port, TCP_RST | TCP_ACK, wnd);
  if (p == NULL) {
 800ffb8:	4605      	mov	r5, r0
 800ffba:	b158      	cbz	r0, 800ffd4 <tcp_rst+0x58>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
    return;
  }
  tcp_output_fill_options(pcb, p, 0, optlen);
 800ffbc:	2300      	movs	r3, #0
 800ffbe:	461a      	mov	r2, r3
 800ffc0:	4601      	mov	r1, r0
 800ffc2:	4620      	mov	r0, r4
 800ffc4:	f7fe fff0 	bl	800efa8 <tcp_output_fill_options>

  MIB2_STATS_INC(mib2.tcpoutrsts);

  tcp_output_control_segment(pcb, p, local_ip, remote_ip);
 800ffc8:	463b      	mov	r3, r7
 800ffca:	4642      	mov	r2, r8
 800ffcc:	4629      	mov	r1, r5
 800ffce:	4620      	mov	r0, r4
 800ffd0:	f7ff fa14 	bl	800f3fc <tcp_output_control_segment>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 800ffd4:	b004      	add	sp, #16
 800ffd6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ASSERT("tcp_rst: invalid local_ip", local_ip != NULL);
 800ffda:	4b08      	ldr	r3, [pc, #32]	@ (800fffc <tcp_rst+0x80>)
 800ffdc:	f240 72c4 	movw	r2, #1988	@ 0x7c4
 800ffe0:	4907      	ldr	r1, [pc, #28]	@ (8010000 <tcp_rst+0x84>)
 800ffe2:	4808      	ldr	r0, [pc, #32]	@ (8010004 <tcp_rst+0x88>)
 800ffe4:	f003 ffcc 	bl	8013f80 <iprintf>
 800ffe8:	e7d1      	b.n	800ff8e <tcp_rst+0x12>
  LWIP_ASSERT("tcp_rst: invalid remote_ip", remote_ip != NULL);
 800ffea:	4b04      	ldr	r3, [pc, #16]	@ (800fffc <tcp_rst+0x80>)
 800ffec:	f240 72c5 	movw	r2, #1989	@ 0x7c5
 800fff0:	4905      	ldr	r1, [pc, #20]	@ (8010008 <tcp_rst+0x8c>)
 800fff2:	4804      	ldr	r0, [pc, #16]	@ (8010004 <tcp_rst+0x88>)
 800fff4:	f003 ffc4 	bl	8013f80 <iprintf>
 800fff8:	e7ca      	b.n	800ff90 <tcp_rst+0x14>
 800fffa:	bf00      	nop
 800fffc:	080174bc 	.word	0x080174bc
 8010000:	08017bd0 	.word	0x08017bd0
 8010004:	08015744 	.word	0x08015744
 8010008:	08017bec 	.word	0x08017bec

0801000c <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
 801000c:	b538      	push	{r3, r4, r5, lr}
  err_t err;
  struct pbuf *p;
  u8_t optlen, optflags = 0;
  u8_t num_sacks = 0;

  LWIP_ASSERT("tcp_send_empty_ack: invalid pcb", pcb != NULL);
 801000e:	4604      	mov	r4, r0
 8010010:	b1e0      	cbz	r0, 801004c <tcp_send_empty_ack+0x40>
  if ((num_sacks = tcp_get_num_sacks(pcb, optlen)) > 0) {
    optlen += 4 + num_sacks * 8; /* 4 bytes for header (including 2*NOP), plus 8B for each SACK */
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt));
 8010012:	6d20      	ldr	r0, [r4, #80]	@ 0x50
 8010014:	f7fa fda9 	bl	800ab6a <lwip_htonl>
 8010018:	4603      	mov	r3, r0
 801001a:	2200      	movs	r2, #0
 801001c:	4611      	mov	r1, r2
 801001e:	4620      	mov	r0, r4
 8010020:	f7ff f90e 	bl	800f240 <tcp_output_alloc_header>
  if (p == NULL) {
 8010024:	4605      	mov	r5, r0
 8010026:	b1c8      	cbz	r0, 801005c <tcp_send_empty_ack+0x50>
    /* let tcp_fasttmr retry sending this ACK */
    tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
  }
  tcp_output_fill_options(pcb, p, optflags, num_sacks);
 8010028:	2300      	movs	r3, #0
 801002a:	461a      	mov	r2, r3
 801002c:	4601      	mov	r1, r0
 801002e:	4620      	mov	r0, r4
 8010030:	f7fe ffba 	bl	800efa8 <tcp_output_fill_options>
  pcb->ts_lastacksent = pcb->rcv_nxt;
#endif

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG,
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 8010034:	1d23      	adds	r3, r4, #4
 8010036:	4622      	mov	r2, r4
 8010038:	4629      	mov	r1, r5
 801003a:	4620      	mov	r0, r4
 801003c:	f7ff f9de 	bl	800f3fc <tcp_output_control_segment>
  if (err != ERR_OK) {
 8010040:	b198      	cbz	r0, 801006a <tcp_send_empty_ack+0x5e>
    /* let tcp_fasttmr retry sending this ACK */
    tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 8010042:	8b63      	ldrh	r3, [r4, #26]
 8010044:	f043 0303 	orr.w	r3, r3, #3
 8010048:	8363      	strh	r3, [r4, #26]
    /* remove ACK flags from the PCB, as we sent an empty ACK now */
    tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
  }

  return err;
}
 801004a:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("tcp_send_empty_ack: invalid pcb", pcb != NULL);
 801004c:	4b09      	ldr	r3, [pc, #36]	@ (8010074 <tcp_send_empty_ack+0x68>)
 801004e:	f240 72ea 	movw	r2, #2026	@ 0x7ea
 8010052:	4909      	ldr	r1, [pc, #36]	@ (8010078 <tcp_send_empty_ack+0x6c>)
 8010054:	4809      	ldr	r0, [pc, #36]	@ (801007c <tcp_send_empty_ack+0x70>)
 8010056:	f003 ff93 	bl	8013f80 <iprintf>
 801005a:	e7da      	b.n	8010012 <tcp_send_empty_ack+0x6>
    tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 801005c:	8b63      	ldrh	r3, [r4, #26]
 801005e:	f043 0303 	orr.w	r3, r3, #3
 8010062:	8363      	strh	r3, [r4, #26]
    return ERR_BUF;
 8010064:	f06f 0001 	mvn.w	r0, #1
 8010068:	e7ef      	b.n	801004a <tcp_send_empty_ack+0x3e>
    tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 801006a:	8b63      	ldrh	r3, [r4, #26]
 801006c:	f023 0303 	bic.w	r3, r3, #3
 8010070:	8363      	strh	r3, [r4, #26]
 8010072:	e7ea      	b.n	801004a <tcp_send_empty_ack+0x3e>
 8010074:	080174bc 	.word	0x080174bc
 8010078:	08017c08 	.word	0x08017c08
 801007c:	08015744 	.word	0x08015744

08010080 <tcp_output>:
{
 8010080:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  LWIP_ASSERT("tcp_output: invalid pcb", pcb != NULL);
 8010084:	4605      	mov	r5, r0
 8010086:	2800      	cmp	r0, #0
 8010088:	d037      	beq.n	80100fa <tcp_output+0x7a>
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
 801008a:	7d2b      	ldrb	r3, [r5, #20]
 801008c:	2b01      	cmp	r3, #1
 801008e:	d03c      	beq.n	801010a <tcp_output+0x8a>
  if (tcp_input_pcb == pcb) {
 8010090:	4b9c      	ldr	r3, [pc, #624]	@ (8010304 <tcp_output+0x284>)
 8010092:	681b      	ldr	r3, [r3, #0]
 8010094:	42ab      	cmp	r3, r5
 8010096:	f000 8130 	beq.w	80102fa <tcp_output+0x27a>
  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 801009a:	f8b5 6048 	ldrh.w	r6, [r5, #72]	@ 0x48
 801009e:	f8b5 3060 	ldrh.w	r3, [r5, #96]	@ 0x60
 80100a2:	429e      	cmp	r6, r3
 80100a4:	bf28      	it	cs
 80100a6:	461e      	movcs	r6, r3
  seg = pcb->unsent;
 80100a8:	6eec      	ldr	r4, [r5, #108]	@ 0x6c
  if (seg == NULL) {
 80100aa:	2c00      	cmp	r4, #0
 80100ac:	d035      	beq.n	801011a <tcp_output+0x9a>
  netif = tcp_route(pcb, &pcb->local_ip, &pcb->remote_ip);
 80100ae:	1d2a      	adds	r2, r5, #4
 80100b0:	4629      	mov	r1, r5
 80100b2:	4628      	mov	r0, r5
 80100b4:	f7ff f8ee 	bl	800f294 <tcp_route>
  if (netif == NULL) {
 80100b8:	4680      	mov	r8, r0
 80100ba:	2800      	cmp	r0, #0
 80100bc:	f000 811f 	beq.w	80102fe <tcp_output+0x27e>
  if (ip_addr_isany(&pcb->local_ip)) {
 80100c0:	b10d      	cbz	r5, 80100c6 <tcp_output+0x46>
 80100c2:	682b      	ldr	r3, [r5, #0]
 80100c4:	b913      	cbnz	r3, 80100cc <tcp_output+0x4c>
    ip_addr_copy(pcb->local_ip, *local_ip);
 80100c6:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80100ca:	602b      	str	r3, [r5, #0]
  if (lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd) {
 80100cc:	6923      	ldr	r3, [r4, #16]
 80100ce:	6858      	ldr	r0, [r3, #4]
 80100d0:	f7fa fd4b 	bl	800ab6a <lwip_htonl>
 80100d4:	6c6b      	ldr	r3, [r5, #68]	@ 0x44
 80100d6:	1ac0      	subs	r0, r0, r3
 80100d8:	8923      	ldrh	r3, [r4, #8]
 80100da:	4418      	add	r0, r3
 80100dc:	42b0      	cmp	r0, r6
 80100de:	d93c      	bls.n	801015a <tcp_output+0xda>
    if (wnd == pcb->snd_wnd && pcb->unacked == NULL && pcb->persist_backoff == 0) {
 80100e0:	f8b5 3060 	ldrh.w	r3, [r5, #96]	@ 0x60
 80100e4:	429e      	cmp	r6, r3
 80100e6:	d029      	beq.n	801013c <tcp_output+0xbc>
    if (pcb->flags & TF_ACK_NOW) {
 80100e8:	8b6b      	ldrh	r3, [r5, #26]
 80100ea:	f013 0f02 	tst.w	r3, #2
 80100ee:	d018      	beq.n	8010122 <tcp_output+0xa2>
      return tcp_send_empty_ack(pcb);
 80100f0:	4628      	mov	r0, r5
 80100f2:	f7ff ff8b 	bl	801000c <tcp_send_empty_ack>
 80100f6:	4603      	mov	r3, r0
 80100f8:	e018      	b.n	801012c <tcp_output+0xac>
  LWIP_ASSERT("tcp_output: invalid pcb", pcb != NULL);
 80100fa:	4b83      	ldr	r3, [pc, #524]	@ (8010308 <tcp_output+0x288>)
 80100fc:	f240 42e1 	movw	r2, #1249	@ 0x4e1
 8010100:	4982      	ldr	r1, [pc, #520]	@ (801030c <tcp_output+0x28c>)
 8010102:	4883      	ldr	r0, [pc, #524]	@ (8010310 <tcp_output+0x290>)
 8010104:	f003 ff3c 	bl	8013f80 <iprintf>
 8010108:	e7bf      	b.n	801008a <tcp_output+0xa>
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
 801010a:	4b7f      	ldr	r3, [pc, #508]	@ (8010308 <tcp_output+0x288>)
 801010c:	f240 42e3 	movw	r2, #1251	@ 0x4e3
 8010110:	4980      	ldr	r1, [pc, #512]	@ (8010314 <tcp_output+0x294>)
 8010112:	487f      	ldr	r0, [pc, #508]	@ (8010310 <tcp_output+0x290>)
 8010114:	f003 ff34 	bl	8013f80 <iprintf>
 8010118:	e7ba      	b.n	8010090 <tcp_output+0x10>
    if (pcb->flags & TF_ACK_NOW) {
 801011a:	8b6b      	ldrh	r3, [r5, #26]
 801011c:	f013 0f02 	tst.w	r3, #2
 8010120:	d107      	bne.n	8010132 <tcp_output+0xb2>
  tcp_clear_flags(pcb, TF_NAGLEMEMERR);
 8010122:	8b6b      	ldrh	r3, [r5, #26]
 8010124:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8010128:	836b      	strh	r3, [r5, #26]
  return ERR_OK;
 801012a:	2300      	movs	r3, #0
}
 801012c:	4618      	mov	r0, r3
 801012e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      return tcp_send_empty_ack(pcb);
 8010132:	4628      	mov	r0, r5
 8010134:	f7ff ff6a 	bl	801000c <tcp_send_empty_ack>
 8010138:	4603      	mov	r3, r0
 801013a:	e7f7      	b.n	801012c <tcp_output+0xac>
    if (wnd == pcb->snd_wnd && pcb->unacked == NULL && pcb->persist_backoff == 0) {
 801013c:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
 801013e:	2b00      	cmp	r3, #0
 8010140:	d1d2      	bne.n	80100e8 <tcp_output+0x68>
 8010142:	f895 3099 	ldrb.w	r3, [r5, #153]	@ 0x99
 8010146:	2b00      	cmp	r3, #0
 8010148:	d1ce      	bne.n	80100e8 <tcp_output+0x68>
      pcb->persist_cnt = 0;
 801014a:	f885 3098 	strb.w	r3, [r5, #152]	@ 0x98
      pcb->persist_backoff = 1;
 801014e:	2201      	movs	r2, #1
 8010150:	f885 2099 	strb.w	r2, [r5, #153]	@ 0x99
      pcb->persist_probe = 0;
 8010154:	f885 309a 	strb.w	r3, [r5, #154]	@ 0x9a
 8010158:	e7c6      	b.n	80100e8 <tcp_output+0x68>
  pcb->persist_backoff = 0;
 801015a:	2300      	movs	r3, #0
 801015c:	f885 3099 	strb.w	r3, [r5, #153]	@ 0x99
  useg = pcb->unacked;
 8010160:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
  if (useg != NULL) {
 8010162:	2b00      	cmp	r3, #0
 8010164:	f000 80c7 	beq.w	80102f6 <tcp_output+0x276>
    for (; useg->next != NULL; useg = useg->next);
 8010168:	461f      	mov	r7, r3
 801016a:	681b      	ldr	r3, [r3, #0]
 801016c:	2b00      	cmp	r3, #0
 801016e:	d1fb      	bne.n	8010168 <tcp_output+0xe8>
 8010170:	e034      	b.n	80101dc <tcp_output+0x15c>
    LWIP_ASSERT("RST not expected here!",
 8010172:	4b65      	ldr	r3, [pc, #404]	@ (8010308 <tcp_output+0x288>)
 8010174:	f240 5236 	movw	r2, #1334	@ 0x536
 8010178:	4967      	ldr	r1, [pc, #412]	@ (8010318 <tcp_output+0x298>)
 801017a:	4865      	ldr	r0, [pc, #404]	@ (8010310 <tcp_output+0x290>)
 801017c:	f003 ff00 	bl	8013f80 <iprintf>
 8010180:	e03f      	b.n	8010202 <tcp_output+0x182>
    if ((tcp_do_output_nagle(pcb) == 0) &&
 8010182:	8911      	ldrh	r1, [r2, #8]
 8010184:	8e6a      	ldrh	r2, [r5, #50]	@ 0x32
 8010186:	4291      	cmp	r1, r2
 8010188:	d247      	bcs.n	801021a <tcp_output+0x19a>
 801018a:	f8b5 2064 	ldrh.w	r2, [r5, #100]	@ 0x64
 801018e:	2a00      	cmp	r2, #0
 8010190:	d043      	beq.n	801021a <tcp_output+0x19a>
 8010192:	f8b5 2066 	ldrh.w	r2, [r5, #102]	@ 0x66
 8010196:	2a0f      	cmp	r2, #15
 8010198:	d83f      	bhi.n	801021a <tcp_output+0x19a>
 801019a:	f013 0fa0 	tst.w	r3, #160	@ 0xa0
 801019e:	d13c      	bne.n	801021a <tcp_output+0x19a>
  if (pcb->unsent == NULL) {
 80101a0:	6eeb      	ldr	r3, [r5, #108]	@ 0x6c
 80101a2:	2b00      	cmp	r3, #0
 80101a4:	d1bd      	bne.n	8010122 <tcp_output+0xa2>
    pcb->unsent_oversize = 0;
 80101a6:	f8a5 3068 	strh.w	r3, [r5, #104]	@ 0x68
 80101aa:	e7ba      	b.n	8010122 <tcp_output+0xa2>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
 80101ac:	6923      	ldr	r3, [r4, #16]
 80101ae:	f8b3 900c 	ldrh.w	r9, [r3, #12]
 80101b2:	2010      	movs	r0, #16
 80101b4:	f7fa fcd4 	bl	800ab60 <lwip_htons>
 80101b8:	6923      	ldr	r3, [r4, #16]
 80101ba:	ea49 0900 	orr.w	r9, r9, r0
 80101be:	f8a3 900c 	strh.w	r9, [r3, #12]
 80101c2:	e02d      	b.n	8010220 <tcp_output+0x1a0>
      tcp_set_flags(pcb, TF_NAGLEMEMERR);
 80101c4:	8b6a      	ldrh	r2, [r5, #26]
 80101c6:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
 80101ca:	836a      	strh	r2, [r5, #26]
      return err;
 80101cc:	e7ae      	b.n	801012c <tcp_output+0xac>
    snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 80101ce:	2300      	movs	r3, #0
 80101d0:	e048      	b.n	8010264 <tcp_output+0x1e4>
      pcb->snd_nxt = snd_nxt;
 80101d2:	6528      	str	r0, [r5, #80]	@ 0x50
 80101d4:	e04d      	b.n	8010272 <tcp_output+0x1f2>
        pcb->unacked = seg;
 80101d6:	672c      	str	r4, [r5, #112]	@ 0x70
        useg = seg;
 80101d8:	4627      	mov	r7, r4
    seg = pcb->unsent;
 80101da:	6eec      	ldr	r4, [r5, #108]	@ 0x6c
  while (seg != NULL &&
 80101dc:	2c00      	cmp	r4, #0
 80101de:	d0df      	beq.n	80101a0 <tcp_output+0x120>
         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 80101e0:	6923      	ldr	r3, [r4, #16]
 80101e2:	6858      	ldr	r0, [r3, #4]
 80101e4:	f7fa fcc1 	bl	800ab6a <lwip_htonl>
 80101e8:	6c6b      	ldr	r3, [r5, #68]	@ 0x44
 80101ea:	1ac0      	subs	r0, r0, r3
 80101ec:	8923      	ldrh	r3, [r4, #8]
 80101ee:	4418      	add	r0, r3
  while (seg != NULL &&
 80101f0:	42b0      	cmp	r0, r6
 80101f2:	d8d5      	bhi.n	80101a0 <tcp_output+0x120>
    LWIP_ASSERT("RST not expected here!",
 80101f4:	6923      	ldr	r3, [r4, #16]
 80101f6:	8998      	ldrh	r0, [r3, #12]
 80101f8:	f7fa fcb2 	bl	800ab60 <lwip_htons>
 80101fc:	f010 0f04 	tst.w	r0, #4
 8010200:	d1b7      	bne.n	8010172 <tcp_output+0xf2>
    if ((tcp_do_output_nagle(pcb) == 0) &&
 8010202:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
 8010204:	b14b      	cbz	r3, 801021a <tcp_output+0x19a>
 8010206:	8b6b      	ldrh	r3, [r5, #26]
 8010208:	f013 0f44 	tst.w	r3, #68	@ 0x44
 801020c:	d105      	bne.n	801021a <tcp_output+0x19a>
 801020e:	6eea      	ldr	r2, [r5, #108]	@ 0x6c
 8010210:	2a00      	cmp	r2, #0
 8010212:	d0ba      	beq.n	801018a <tcp_output+0x10a>
 8010214:	6811      	ldr	r1, [r2, #0]
 8010216:	2900      	cmp	r1, #0
 8010218:	d0b3      	beq.n	8010182 <tcp_output+0x102>
    if (pcb->state != SYN_SENT) {
 801021a:	7d2b      	ldrb	r3, [r5, #20]
 801021c:	2b02      	cmp	r3, #2
 801021e:	d1c5      	bne.n	80101ac <tcp_output+0x12c>
    err = tcp_output_segment(seg, pcb, netif);
 8010220:	4642      	mov	r2, r8
 8010222:	4629      	mov	r1, r5
 8010224:	4620      	mov	r0, r4
 8010226:	f7ff f841 	bl	800f2ac <tcp_output_segment>
    if (err != ERR_OK) {
 801022a:	4603      	mov	r3, r0
 801022c:	2800      	cmp	r0, #0
 801022e:	d1c9      	bne.n	80101c4 <tcp_output+0x144>
    seg->oversize_left = 0;
 8010230:	2300      	movs	r3, #0
 8010232:	8163      	strh	r3, [r4, #10]
    pcb->unsent = seg->next;
 8010234:	6823      	ldr	r3, [r4, #0]
 8010236:	66eb      	str	r3, [r5, #108]	@ 0x6c
    if (pcb->state != SYN_SENT) {
 8010238:	7d2b      	ldrb	r3, [r5, #20]
 801023a:	2b02      	cmp	r3, #2
 801023c:	d003      	beq.n	8010246 <tcp_output+0x1c6>
      tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 801023e:	8b6b      	ldrh	r3, [r5, #26]
 8010240:	f023 0303 	bic.w	r3, r3, #3
 8010244:	836b      	strh	r3, [r5, #26]
    snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 8010246:	6923      	ldr	r3, [r4, #16]
 8010248:	6858      	ldr	r0, [r3, #4]
 801024a:	f7fa fc8e 	bl	800ab6a <lwip_htonl>
 801024e:	4681      	mov	r9, r0
 8010250:	f8b4 a008 	ldrh.w	sl, [r4, #8]
 8010254:	6923      	ldr	r3, [r4, #16]
 8010256:	8998      	ldrh	r0, [r3, #12]
 8010258:	f7fa fc82 	bl	800ab60 <lwip_htons>
 801025c:	f010 0f03 	tst.w	r0, #3
 8010260:	d0b5      	beq.n	80101ce <tcp_output+0x14e>
 8010262:	2301      	movs	r3, #1
 8010264:	4453      	add	r3, sl
 8010266:	eb09 0003 	add.w	r0, r9, r3
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 801026a:	6d2b      	ldr	r3, [r5, #80]	@ 0x50
 801026c:	1a1b      	subs	r3, r3, r0
 801026e:	2b00      	cmp	r3, #0
 8010270:	dbaf      	blt.n	80101d2 <tcp_output+0x152>
    if (TCP_TCPLEN(seg) > 0) {
 8010272:	f8b4 9008 	ldrh.w	r9, [r4, #8]
 8010276:	6923      	ldr	r3, [r4, #16]
 8010278:	8998      	ldrh	r0, [r3, #12]
 801027a:	f7fa fc71 	bl	800ab60 <lwip_htons>
 801027e:	f010 0f03 	tst.w	r0, #3
 8010282:	d102      	bne.n	801028a <tcp_output+0x20a>
 8010284:	f1b9 0f00 	cmp.w	r9, #0
 8010288:	d031      	beq.n	80102ee <tcp_output+0x26e>
      seg->next = NULL;
 801028a:	2300      	movs	r3, #0
 801028c:	6023      	str	r3, [r4, #0]
      if (pcb->unacked == NULL) {
 801028e:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
 8010290:	2b00      	cmp	r3, #0
 8010292:	d0a0      	beq.n	80101d6 <tcp_output+0x156>
        if (TCP_SEQ_LT(lwip_ntohl(seg->tcphdr->seqno), lwip_ntohl(useg->tcphdr->seqno))) {
 8010294:	6923      	ldr	r3, [r4, #16]
 8010296:	6858      	ldr	r0, [r3, #4]
 8010298:	f7fa fc67 	bl	800ab6a <lwip_htonl>
 801029c:	4681      	mov	r9, r0
 801029e:	693b      	ldr	r3, [r7, #16]
 80102a0:	6858      	ldr	r0, [r3, #4]
 80102a2:	f7fa fc62 	bl	800ab6a <lwip_htonl>
 80102a6:	eba9 0900 	sub.w	r9, r9, r0
 80102aa:	f1b9 0f00 	cmp.w	r9, #0
 80102ae:	db02      	blt.n	80102b6 <tcp_output+0x236>
          useg->next = seg;
 80102b0:	603c      	str	r4, [r7, #0]
          useg = useg->next;
 80102b2:	4627      	mov	r7, r4
 80102b4:	e791      	b.n	80101da <tcp_output+0x15a>
          struct tcp_seg **cur_seg = &(pcb->unacked);
 80102b6:	f105 0a70 	add.w	sl, r5, #112	@ 0x70
          while (*cur_seg &&
 80102ba:	f8da 3000 	ldr.w	r3, [sl]
 80102be:	b183      	cbz	r3, 80102e2 <tcp_output+0x262>
                 TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
 80102c0:	691b      	ldr	r3, [r3, #16]
 80102c2:	6858      	ldr	r0, [r3, #4]
 80102c4:	f7fa fc51 	bl	800ab6a <lwip_htonl>
 80102c8:	4681      	mov	r9, r0
 80102ca:	6923      	ldr	r3, [r4, #16]
 80102cc:	6858      	ldr	r0, [r3, #4]
 80102ce:	f7fa fc4c 	bl	800ab6a <lwip_htonl>
 80102d2:	eba9 0900 	sub.w	r9, r9, r0
          while (*cur_seg &&
 80102d6:	f1b9 0f00 	cmp.w	r9, #0
 80102da:	da02      	bge.n	80102e2 <tcp_output+0x262>
            cur_seg = &((*cur_seg)->next );
 80102dc:	f8da a000 	ldr.w	sl, [sl]
 80102e0:	e7eb      	b.n	80102ba <tcp_output+0x23a>
          seg->next = (*cur_seg);
 80102e2:	f8da 3000 	ldr.w	r3, [sl]
 80102e6:	6023      	str	r3, [r4, #0]
          (*cur_seg) = seg;
 80102e8:	f8ca 4000 	str.w	r4, [sl]
 80102ec:	e775      	b.n	80101da <tcp_output+0x15a>
      tcp_seg_free(seg);
 80102ee:	4620      	mov	r0, r4
 80102f0:	f7fc f952 	bl	800c598 <tcp_seg_free>
 80102f4:	e771      	b.n	80101da <tcp_output+0x15a>
  useg = pcb->unacked;
 80102f6:	461f      	mov	r7, r3
 80102f8:	e770      	b.n	80101dc <tcp_output+0x15c>
    return ERR_OK;
 80102fa:	2300      	movs	r3, #0
 80102fc:	e716      	b.n	801012c <tcp_output+0xac>
    return ERR_RTE;
 80102fe:	f06f 0303 	mvn.w	r3, #3
 8010302:	e713      	b.n	801012c <tcp_output+0xac>
 8010304:	240142ec 	.word	0x240142ec
 8010308:	080174bc 	.word	0x080174bc
 801030c:	08017c28 	.word	0x08017c28
 8010310:	08015744 	.word	0x08015744
 8010314:	08017c40 	.word	0x08017c40
 8010318:	08017c68 	.word	0x08017c68

0801031c <tcp_rexmit_rto_commit>:
{
 801031c:	b510      	push	{r4, lr}
  LWIP_ASSERT("tcp_rexmit_rto_commit: invalid pcb", pcb != NULL);
 801031e:	4604      	mov	r4, r0
 8010320:	b150      	cbz	r0, 8010338 <tcp_rexmit_rto_commit+0x1c>
  if (pcb->nrtx < 0xFF) {
 8010322:	f894 3042 	ldrb.w	r3, [r4, #66]	@ 0x42
 8010326:	2bff      	cmp	r3, #255	@ 0xff
 8010328:	d002      	beq.n	8010330 <tcp_rexmit_rto_commit+0x14>
    ++pcb->nrtx;
 801032a:	3301      	adds	r3, #1
 801032c:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
  tcp_output(pcb);
 8010330:	4620      	mov	r0, r4
 8010332:	f7ff fea5 	bl	8010080 <tcp_output>
}
 8010336:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("tcp_rexmit_rto_commit: invalid pcb", pcb != NULL);
 8010338:	4b03      	ldr	r3, [pc, #12]	@ (8010348 <tcp_rexmit_rto_commit+0x2c>)
 801033a:	f44f 62d3 	mov.w	r2, #1688	@ 0x698
 801033e:	4903      	ldr	r1, [pc, #12]	@ (801034c <tcp_rexmit_rto_commit+0x30>)
 8010340:	4803      	ldr	r0, [pc, #12]	@ (8010350 <tcp_rexmit_rto_commit+0x34>)
 8010342:	f003 fe1d 	bl	8013f80 <iprintf>
 8010346:	e7ec      	b.n	8010322 <tcp_rexmit_rto_commit+0x6>
 8010348:	080174bc 	.word	0x080174bc
 801034c:	08017c80 	.word	0x08017c80
 8010350:	08015744 	.word	0x08015744

08010354 <tcp_rexmit_rto>:
{
 8010354:	b510      	push	{r4, lr}
  LWIP_ASSERT("tcp_rexmit_rto: invalid pcb", pcb != NULL);
 8010356:	4604      	mov	r4, r0
 8010358:	b120      	cbz	r0, 8010364 <tcp_rexmit_rto+0x10>
  if (tcp_rexmit_rto_prepare(pcb) == ERR_OK) {
 801035a:	4620      	mov	r0, r4
 801035c:	f7ff fd3c 	bl	800fdd8 <tcp_rexmit_rto_prepare>
 8010360:	b140      	cbz	r0, 8010374 <tcp_rexmit_rto+0x20>
}
 8010362:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("tcp_rexmit_rto: invalid pcb", pcb != NULL);
 8010364:	4b05      	ldr	r3, [pc, #20]	@ (801037c <tcp_rexmit_rto+0x28>)
 8010366:	f240 62ad 	movw	r2, #1709	@ 0x6ad
 801036a:	4905      	ldr	r1, [pc, #20]	@ (8010380 <tcp_rexmit_rto+0x2c>)
 801036c:	4805      	ldr	r0, [pc, #20]	@ (8010384 <tcp_rexmit_rto+0x30>)
 801036e:	f003 fe07 	bl	8013f80 <iprintf>
 8010372:	e7f2      	b.n	801035a <tcp_rexmit_rto+0x6>
    tcp_rexmit_rto_commit(pcb);
 8010374:	4620      	mov	r0, r4
 8010376:	f7ff ffd1 	bl	801031c <tcp_rexmit_rto_commit>
}
 801037a:	e7f2      	b.n	8010362 <tcp_rexmit_rto+0xe>
 801037c:	080174bc 	.word	0x080174bc
 8010380:	08017ca4 	.word	0x08017ca4
 8010384:	08015744 	.word	0x08015744

08010388 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
err_t
tcp_keepalive(struct tcp_pcb *pcb)
{
 8010388:	b538      	push	{r3, r4, r5, lr}
  err_t err;
  struct pbuf *p;
  u8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);

  LWIP_ASSERT("tcp_keepalive: invalid pcb", pcb != NULL);
 801038a:	4604      	mov	r4, r0
 801038c:	b1c0      	cbz	r0, 80103c0 <tcp_keepalive+0x38>
  LWIP_DEBUGF(TCP_DEBUG, ("\n"));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
                          tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt - 1));
 801038e:	6d20      	ldr	r0, [r4, #80]	@ 0x50
 8010390:	3801      	subs	r0, #1
 8010392:	f7fa fbea 	bl	800ab6a <lwip_htonl>
 8010396:	4603      	mov	r3, r0
 8010398:	2200      	movs	r2, #0
 801039a:	4611      	mov	r1, r2
 801039c:	4620      	mov	r0, r4
 801039e:	f7fe ff4f 	bl	800f240 <tcp_output_alloc_header>
  if (p == NULL) {
 80103a2:	4605      	mov	r5, r0
 80103a4:	b1a0      	cbz	r0, 80103d0 <tcp_keepalive+0x48>
    LWIP_DEBUGF(TCP_DEBUG,
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return ERR_MEM;
  }
  tcp_output_fill_options(pcb, p, 0, optlen);
 80103a6:	2300      	movs	r3, #0
 80103a8:	461a      	mov	r2, r3
 80103aa:	4601      	mov	r1, r0
 80103ac:	4620      	mov	r0, r4
 80103ae:	f7fe fdfb 	bl	800efa8 <tcp_output_fill_options>
  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 80103b2:	1d23      	adds	r3, r4, #4
 80103b4:	4622      	mov	r2, r4
 80103b6:	4629      	mov	r1, r5
 80103b8:	4620      	mov	r0, r4
 80103ba:	f7ff f81f 	bl	800f3fc <tcp_output_control_segment>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
}
 80103be:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("tcp_keepalive: invalid pcb", pcb != NULL);
 80103c0:	4b05      	ldr	r3, [pc, #20]	@ (80103d8 <tcp_keepalive+0x50>)
 80103c2:	f640 0224 	movw	r2, #2084	@ 0x824
 80103c6:	4905      	ldr	r1, [pc, #20]	@ (80103dc <tcp_keepalive+0x54>)
 80103c8:	4805      	ldr	r0, [pc, #20]	@ (80103e0 <tcp_keepalive+0x58>)
 80103ca:	f003 fdd9 	bl	8013f80 <iprintf>
 80103ce:	e7de      	b.n	801038e <tcp_keepalive+0x6>
    return ERR_MEM;
 80103d0:	f04f 30ff 	mov.w	r0, #4294967295
 80103d4:	e7f3      	b.n	80103be <tcp_keepalive+0x36>
 80103d6:	bf00      	nop
 80103d8:	080174bc 	.word	0x080174bc
 80103dc:	08017cc0 	.word	0x08017cc0
 80103e0:	08015744 	.word	0x08015744

080103e4 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
err_t
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 80103e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  u16_t len;
  u8_t is_fin;
  u32_t snd_nxt;
  u8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);

  LWIP_ASSERT("tcp_zero_window_probe: invalid pcb", pcb != NULL);
 80103e8:	4604      	mov	r4, r0
 80103ea:	b1a8      	cbz	r0, 8010418 <tcp_zero_window_probe+0x34>
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
               tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  /* Only consider unsent, persist timer should be off when there is data in-flight */
  seg = pcb->unsent;
 80103ec:	6ee5      	ldr	r5, [r4, #108]	@ 0x6c
  if (seg == NULL) {
 80103ee:	2d00      	cmp	r5, #0
 80103f0:	d05b      	beq.n	80104aa <tcp_zero_window_probe+0xc6>

  /* increment probe count. NOTE: we record probe even if it fails
     to actually transmit due to an error. This ensures memory exhaustion/
     routing problem doesn't leave a zero-window pcb as an indefinite zombie.
     RTO mechanism has similar behavior, see pcb->nrtx */
  if (pcb->persist_probe < 0xFF) {
 80103f2:	f894 309a 	ldrb.w	r3, [r4, #154]	@ 0x9a
 80103f6:	2bff      	cmp	r3, #255	@ 0xff
 80103f8:	d002      	beq.n	8010400 <tcp_zero_window_probe+0x1c>
    ++pcb->persist_probe;
 80103fa:	3301      	adds	r3, #1
 80103fc:	f884 309a 	strb.w	r3, [r4, #154]	@ 0x9a
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 8010400:	692b      	ldr	r3, [r5, #16]
 8010402:	8998      	ldrh	r0, [r3, #12]
 8010404:	f7fa fbac 	bl	800ab60 <lwip_htons>
 8010408:	f010 0f01 	tst.w	r0, #1
 801040c:	d00c      	beq.n	8010428 <tcp_zero_window_probe+0x44>
 801040e:	892b      	ldrh	r3, [r5, #8]
 8010410:	2b00      	cmp	r3, #0
 8010412:	d03b      	beq.n	801048c <tcp_zero_window_probe+0xa8>
 8010414:	2200      	movs	r2, #0
 8010416:	e008      	b.n	801042a <tcp_zero_window_probe+0x46>
  LWIP_ASSERT("tcp_zero_window_probe: invalid pcb", pcb != NULL);
 8010418:	4b26      	ldr	r3, [pc, #152]	@ (80104b4 <tcp_zero_window_probe+0xd0>)
 801041a:	f640 024f 	movw	r2, #2127	@ 0x84f
 801041e:	4926      	ldr	r1, [pc, #152]	@ (80104b8 <tcp_zero_window_probe+0xd4>)
 8010420:	4826      	ldr	r0, [pc, #152]	@ (80104bc <tcp_zero_window_probe+0xd8>)
 8010422:	f003 fdad 	bl	8013f80 <iprintf>
 8010426:	e7e1      	b.n	80103ec <tcp_zero_window_probe+0x8>
  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 8010428:	2200      	movs	r2, #0
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;
 801042a:	f002 08ff 	and.w	r8, r2, #255	@ 0xff

  p = tcp_output_alloc_header(pcb, optlen, len, seg->tcphdr->seqno);
 801042e:	692b      	ldr	r3, [r5, #16]
 8010430:	685b      	ldr	r3, [r3, #4]
 8010432:	f082 0201 	eor.w	r2, r2, #1
 8010436:	2100      	movs	r1, #0
 8010438:	4620      	mov	r0, r4
 801043a:	f7fe ff01 	bl	800f240 <tcp_output_alloc_header>
  if (p == NULL) {
 801043e:	4606      	mov	r6, r0
 8010440:	b3a8      	cbz	r0, 80104ae <tcp_zero_window_probe+0xca>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return ERR_MEM;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 8010442:	6847      	ldr	r7, [r0, #4]

  if (is_fin) {
 8010444:	f1b8 0f00 	cmp.w	r8, #0
 8010448:	d022      	beq.n	8010490 <tcp_zero_window_probe+0xac>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
 801044a:	f8b7 800c 	ldrh.w	r8, [r7, #12]
 801044e:	2011      	movs	r0, #17
 8010450:	f7fa fb86 	bl	800ab60 <lwip_htons>
 8010454:	f428 587c 	bic.w	r8, r8, #16128	@ 0x3f00
 8010458:	ea40 0008 	orr.w	r0, r0, r8
 801045c:	81b8      	strh	r0, [r7, #12]
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
  }

  /* The byte may be acknowledged without the window being opened. */
  snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + 1;
 801045e:	692b      	ldr	r3, [r5, #16]
 8010460:	6858      	ldr	r0, [r3, #4]
 8010462:	f7fa fb82 	bl	800ab6a <lwip_htonl>
 8010466:	3001      	adds	r0, #1
  if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 8010468:	6d23      	ldr	r3, [r4, #80]	@ 0x50
 801046a:	1a1b      	subs	r3, r3, r0
 801046c:	2b00      	cmp	r3, #0
 801046e:	db1a      	blt.n	80104a6 <tcp_zero_window_probe+0xc2>
    pcb->snd_nxt = snd_nxt;
  }
  tcp_output_fill_options(pcb, p, 0, optlen);
 8010470:	2300      	movs	r3, #0
 8010472:	461a      	mov	r2, r3
 8010474:	4631      	mov	r1, r6
 8010476:	4620      	mov	r0, r4
 8010478:	f7fe fd96 	bl	800efa8 <tcp_output_fill_options>

  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 801047c:	1d23      	adds	r3, r4, #4
 801047e:	4622      	mov	r2, r4
 8010480:	4631      	mov	r1, r6
 8010482:	4620      	mov	r0, r4
 8010484:	f7fe ffba 	bl	800f3fc <tcp_output_control_segment>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
}
 8010488:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 801048c:	2201      	movs	r2, #1
 801048e:	e7cc      	b.n	801042a <tcp_zero_window_probe+0x46>
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
 8010490:	6868      	ldr	r0, [r5, #4]
 8010492:	8903      	ldrh	r3, [r0, #8]
 8010494:	892a      	ldrh	r2, [r5, #8]
 8010496:	1a9b      	subs	r3, r3, r2
 8010498:	b29b      	uxth	r3, r3
 801049a:	2201      	movs	r2, #1
 801049c:	f107 0114 	add.w	r1, r7, #20
 80104a0:	f7fb fdac 	bl	800bffc <pbuf_copy_partial>
 80104a4:	e7db      	b.n	801045e <tcp_zero_window_probe+0x7a>
    pcb->snd_nxt = snd_nxt;
 80104a6:	6520      	str	r0, [r4, #80]	@ 0x50
 80104a8:	e7e2      	b.n	8010470 <tcp_zero_window_probe+0x8c>
    return ERR_OK;
 80104aa:	2000      	movs	r0, #0
 80104ac:	e7ec      	b.n	8010488 <tcp_zero_window_probe+0xa4>
    return ERR_MEM;
 80104ae:	f04f 30ff 	mov.w	r0, #4294967295
 80104b2:	e7e9      	b.n	8010488 <tcp_zero_window_probe+0xa4>
 80104b4:	080174bc 	.word	0x080174bc
 80104b8:	08017cdc 	.word	0x08017cdc
 80104bc:	08015744 	.word	0x08015744

080104c0 <sys_timeout_abs>:
#if LWIP_DEBUG_TIMERNAMES
sys_timeout_abs(u32_t abs_time, sys_timeout_handler handler, void *arg, const char *handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
sys_timeout_abs(u32_t abs_time, sys_timeout_handler handler, void *arg)
#endif
{
 80104c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80104c2:	4604      	mov	r4, r0
 80104c4:	460f      	mov	r7, r1
 80104c6:	4616      	mov	r6, r2
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 80104c8:	200b      	movs	r0, #11
 80104ca:	f7fa ffdf 	bl	800b48c <memp_malloc>
  if (timeout == NULL) {
 80104ce:	b180      	cbz	r0, 80104f2 <sys_timeout_abs+0x32>
 80104d0:	4605      	mov	r5, r0
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
  }

  timeout->next = NULL;
 80104d2:	2300      	movs	r3, #0
 80104d4:	6003      	str	r3, [r0, #0]
  timeout->h = handler;
 80104d6:	6087      	str	r7, [r0, #8]
  timeout->arg = arg;
 80104d8:	60c6      	str	r6, [r0, #12]
  timeout->time = abs_time;
 80104da:	6044      	str	r4, [r0, #4]
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p abs_time=%"U32_F" handler=%s arg=%p\n",
                             (void *)timeout, abs_time, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
 80104dc:	4b10      	ldr	r3, [pc, #64]	@ (8010520 <sys_timeout_abs+0x60>)
 80104de:	681a      	ldr	r2, [r3, #0]
 80104e0:	b172      	cbz	r2, 8010500 <sys_timeout_abs+0x40>
    next_timeout = timeout;
    return;
  }
  if (TIME_LESS_THAN(timeout->time, next_timeout->time)) {
 80104e2:	6853      	ldr	r3, [r2, #4]
 80104e4:	1ae3      	subs	r3, r4, r3
 80104e6:	2b00      	cmp	r3, #0
 80104e8:	da0f      	bge.n	801050a <sys_timeout_abs+0x4a>
    timeout->next = next_timeout;
 80104ea:	6002      	str	r2, [r0, #0]
    next_timeout = timeout;
 80104ec:	4b0c      	ldr	r3, [pc, #48]	@ (8010520 <sys_timeout_abs+0x60>)
 80104ee:	6018      	str	r0, [r3, #0]
        t->next = timeout;
        break;
      }
    }
  }
}
 80104f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
 80104f2:	4b0c      	ldr	r3, [pc, #48]	@ (8010524 <sys_timeout_abs+0x64>)
 80104f4:	22be      	movs	r2, #190	@ 0xbe
 80104f6:	490c      	ldr	r1, [pc, #48]	@ (8010528 <sys_timeout_abs+0x68>)
 80104f8:	480c      	ldr	r0, [pc, #48]	@ (801052c <sys_timeout_abs+0x6c>)
 80104fa:	f003 fd41 	bl	8013f80 <iprintf>
    return;
 80104fe:	e7f7      	b.n	80104f0 <sys_timeout_abs+0x30>
    next_timeout = timeout;
 8010500:	6018      	str	r0, [r3, #0]
    return;
 8010502:	e7f5      	b.n	80104f0 <sys_timeout_abs+0x30>
        timeout->next = t->next;
 8010504:	602b      	str	r3, [r5, #0]
        t->next = timeout;
 8010506:	6015      	str	r5, [r2, #0]
        break;
 8010508:	e7f2      	b.n	80104f0 <sys_timeout_abs+0x30>
    for (t = next_timeout; t != NULL; t = t->next) {
 801050a:	2a00      	cmp	r2, #0
 801050c:	d0f0      	beq.n	80104f0 <sys_timeout_abs+0x30>
      if ((t->next == NULL) || TIME_LESS_THAN(timeout->time, t->next->time)) {
 801050e:	6813      	ldr	r3, [r2, #0]
 8010510:	2b00      	cmp	r3, #0
 8010512:	d0f7      	beq.n	8010504 <sys_timeout_abs+0x44>
 8010514:	6859      	ldr	r1, [r3, #4]
 8010516:	1a61      	subs	r1, r4, r1
 8010518:	2900      	cmp	r1, #0
 801051a:	dbf3      	blt.n	8010504 <sys_timeout_abs+0x44>
    for (t = next_timeout; t != NULL; t = t->next) {
 801051c:	461a      	mov	r2, r3
 801051e:	e7f4      	b.n	801050a <sys_timeout_abs+0x4a>
 8010520:	24014330 	.word	0x24014330
 8010524:	08017d00 	.word	0x08017d00
 8010528:	08017d34 	.word	0x08017d34
 801052c:	08015744 	.word	0x08015744

08010530 <lwip_cyclic_timer>:
#if !LWIP_TESTMODE
static
#endif
void
lwip_cyclic_timer(void *arg)
{
 8010530:	b538      	push	{r3, r4, r5, lr}
 8010532:	4604      	mov	r4, r0
  const struct lwip_cyclic_timer *cyclic = (const struct lwip_cyclic_timer *)arg;

#if LWIP_DEBUG_TIMERNAMES
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: %s()\n", cyclic->handler_name));
#endif
  cyclic->handler();
 8010534:	6843      	ldr	r3, [r0, #4]
 8010536:	4798      	blx	r3

  now = sys_now();
 8010538:	f003 f9da 	bl	80138f0 <sys_now>
 801053c:	4684      	mov	ip, r0
  next_timeout_time = (u32_t)(current_timeout_due_time + cyclic->interval_ms);  /* overflow handled by TIME_LESS_THAN macro */ 
 801053e:	6825      	ldr	r5, [r4, #0]
 8010540:	4b09      	ldr	r3, [pc, #36]	@ (8010568 <lwip_cyclic_timer+0x38>)
 8010542:	6818      	ldr	r0, [r3, #0]
 8010544:	4428      	add	r0, r5
  if (TIME_LESS_THAN(next_timeout_time, now)) {
 8010546:	eba0 030c 	sub.w	r3, r0, ip
 801054a:	2b00      	cmp	r3, #0
 801054c:	da06      	bge.n	801055c <lwip_cyclic_timer+0x2c>
    /* timer would immediately expire again -> "overload" -> restart without any correction */
#if LWIP_DEBUG_TIMERNAMES
    sys_timeout_abs((u32_t)(now + cyclic->interval_ms), lwip_cyclic_timer, arg, cyclic->handler_name);
#else
    sys_timeout_abs((u32_t)(now + cyclic->interval_ms), lwip_cyclic_timer, arg);
 801054e:	4622      	mov	r2, r4
 8010550:	4906      	ldr	r1, [pc, #24]	@ (801056c <lwip_cyclic_timer+0x3c>)
 8010552:	eb05 000c 	add.w	r0, r5, ip
 8010556:	f7ff ffb3 	bl	80104c0 <sys_timeout_abs>
    sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg, cyclic->handler_name);
#else
    sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg);
#endif
  }
}
 801055a:	bd38      	pop	{r3, r4, r5, pc}
    sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg);
 801055c:	4622      	mov	r2, r4
 801055e:	4903      	ldr	r1, [pc, #12]	@ (801056c <lwip_cyclic_timer+0x3c>)
 8010560:	f7ff ffae 	bl	80104c0 <sys_timeout_abs>
}
 8010564:	e7f9      	b.n	801055a <lwip_cyclic_timer+0x2a>
 8010566:	bf00      	nop
 8010568:	2401432c 	.word	0x2401432c
 801056c:	08010531 	.word	0x08010531

08010570 <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char *handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
 8010570:	b570      	push	{r4, r5, r6, lr}
 8010572:	4604      	mov	r4, r0
 8010574:	460d      	mov	r5, r1
 8010576:	4616      	mov	r6, r2
  u32_t next_timeout_time;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ASSERT("Timeout time too long, max is LWIP_UINT32_MAX/4 msecs", msecs <= (LWIP_UINT32_MAX / 4));
 8010578:	f1b0 4f80 	cmp.w	r0, #1073741824	@ 0x40000000
 801057c:	d207      	bcs.n	801058e <sys_timeout+0x1e>

  next_timeout_time = (u32_t)(sys_now() + msecs); /* overflow handled by TIME_LESS_THAN macro */ 
 801057e:	f003 f9b7 	bl	80138f0 <sys_now>

#if LWIP_DEBUG_TIMERNAMES
  sys_timeout_abs(next_timeout_time, handler, arg, handler_name);
#else
  sys_timeout_abs(next_timeout_time, handler, arg);
 8010582:	4632      	mov	r2, r6
 8010584:	4629      	mov	r1, r5
 8010586:	4420      	add	r0, r4
 8010588:	f7ff ff9a 	bl	80104c0 <sys_timeout_abs>
#endif
}
 801058c:	bd70      	pop	{r4, r5, r6, pc}
  LWIP_ASSERT("Timeout time too long, max is LWIP_UINT32_MAX/4 msecs", msecs <= (LWIP_UINT32_MAX / 4));
 801058e:	4b04      	ldr	r3, [pc, #16]	@ (80105a0 <sys_timeout+0x30>)
 8010590:	f240 1229 	movw	r2, #297	@ 0x129
 8010594:	4903      	ldr	r1, [pc, #12]	@ (80105a4 <sys_timeout+0x34>)
 8010596:	4804      	ldr	r0, [pc, #16]	@ (80105a8 <sys_timeout+0x38>)
 8010598:	f003 fcf2 	bl	8013f80 <iprintf>
 801059c:	e7ef      	b.n	801057e <sys_timeout+0xe>
 801059e:	bf00      	nop
 80105a0:	08017d00 	.word	0x08017d00
 80105a4:	08017d74 	.word	0x08017d74
 80105a8:	08015744 	.word	0x08015744

080105ac <tcp_timer_needed>:
{
 80105ac:	b508      	push	{r3, lr}
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 80105ae:	4b0a      	ldr	r3, [pc, #40]	@ (80105d8 <tcp_timer_needed+0x2c>)
 80105b0:	681b      	ldr	r3, [r3, #0]
 80105b2:	b953      	cbnz	r3, 80105ca <tcp_timer_needed+0x1e>
 80105b4:	4b09      	ldr	r3, [pc, #36]	@ (80105dc <tcp_timer_needed+0x30>)
 80105b6:	681b      	ldr	r3, [r3, #0]
 80105b8:	b143      	cbz	r3, 80105cc <tcp_timer_needed+0x20>
    tcpip_tcp_timer_active = 1;
 80105ba:	4b07      	ldr	r3, [pc, #28]	@ (80105d8 <tcp_timer_needed+0x2c>)
 80105bc:	2201      	movs	r2, #1
 80105be:	601a      	str	r2, [r3, #0]
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 80105c0:	2200      	movs	r2, #0
 80105c2:	4907      	ldr	r1, [pc, #28]	@ (80105e0 <tcp_timer_needed+0x34>)
 80105c4:	20fa      	movs	r0, #250	@ 0xfa
 80105c6:	f7ff ffd3 	bl	8010570 <sys_timeout>
}
 80105ca:	bd08      	pop	{r3, pc}
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 80105cc:	4b05      	ldr	r3, [pc, #20]	@ (80105e4 <tcp_timer_needed+0x38>)
 80105ce:	681b      	ldr	r3, [r3, #0]
 80105d0:	2b00      	cmp	r3, #0
 80105d2:	d1f2      	bne.n	80105ba <tcp_timer_needed+0xe>
 80105d4:	e7f9      	b.n	80105ca <tcp_timer_needed+0x1e>
 80105d6:	bf00      	nop
 80105d8:	24014328 	.word	0x24014328
 80105dc:	240142dc 	.word	0x240142dc
 80105e0:	080105e9 	.word	0x080105e9
 80105e4:	240142d8 	.word	0x240142d8

080105e8 <tcpip_tcp_timer>:
{
 80105e8:	b508      	push	{r3, lr}
  tcp_tmr();
 80105ea:	f7fc ff65 	bl	800d4b8 <tcp_tmr>
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 80105ee:	4b08      	ldr	r3, [pc, #32]	@ (8010610 <tcpip_tcp_timer+0x28>)
 80105f0:	681b      	ldr	r3, [r3, #0]
 80105f2:	b12b      	cbz	r3, 8010600 <tcpip_tcp_timer+0x18>
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 80105f4:	2200      	movs	r2, #0
 80105f6:	4907      	ldr	r1, [pc, #28]	@ (8010614 <tcpip_tcp_timer+0x2c>)
 80105f8:	20fa      	movs	r0, #250	@ 0xfa
 80105fa:	f7ff ffb9 	bl	8010570 <sys_timeout>
}
 80105fe:	bd08      	pop	{r3, pc}
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 8010600:	4b05      	ldr	r3, [pc, #20]	@ (8010618 <tcpip_tcp_timer+0x30>)
 8010602:	681b      	ldr	r3, [r3, #0]
 8010604:	2b00      	cmp	r3, #0
 8010606:	d1f5      	bne.n	80105f4 <tcpip_tcp_timer+0xc>
    tcpip_tcp_timer_active = 0;
 8010608:	4b04      	ldr	r3, [pc, #16]	@ (801061c <tcpip_tcp_timer+0x34>)
 801060a:	2200      	movs	r2, #0
 801060c:	601a      	str	r2, [r3, #0]
}
 801060e:	e7f6      	b.n	80105fe <tcpip_tcp_timer+0x16>
 8010610:	240142dc 	.word	0x240142dc
 8010614:	080105e9 	.word	0x080105e9
 8010618:	240142d8 	.word	0x240142d8
 801061c:	24014328 	.word	0x24014328

08010620 <sys_timeouts_init>:
{
 8010620:	b510      	push	{r4, lr}
  for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
 8010622:	2401      	movs	r4, #1
 8010624:	e008      	b.n	8010638 <sys_timeouts_init+0x18>
    sys_timeout(lwip_cyclic_timers[i].interval_ms, lwip_cyclic_timer, LWIP_CONST_CAST(void *, &lwip_cyclic_timers[i]));
 8010626:	4b06      	ldr	r3, [pc, #24]	@ (8010640 <sys_timeouts_init+0x20>)
 8010628:	eb03 02c4 	add.w	r2, r3, r4, lsl #3
 801062c:	4905      	ldr	r1, [pc, #20]	@ (8010644 <sys_timeouts_init+0x24>)
 801062e:	f853 0034 	ldr.w	r0, [r3, r4, lsl #3]
 8010632:	f7ff ff9d 	bl	8010570 <sys_timeout>
  for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
 8010636:	3401      	adds	r4, #1
 8010638:	2c03      	cmp	r4, #3
 801063a:	d9f4      	bls.n	8010626 <sys_timeouts_init+0x6>
}
 801063c:	bd10      	pop	{r4, pc}
 801063e:	bf00      	nop
 8010640:	08018f9c 	.word	0x08018f9c
 8010644:	08010531 	.word	0x08010531

08010648 <sys_check_timeouts>:
 *
 * Must be called periodically from your main loop.
 */
void
sys_check_timeouts(void)
{
 8010648:	b570      	push	{r4, r5, r6, lr}
  u32_t now;

  LWIP_ASSERT_CORE_LOCKED();

  /* Process only timers expired at the start of the function. */
  now = sys_now();
 801064a:	f003 f951 	bl	80138f0 <sys_now>
 801064e:	4605      	mov	r5, r0
    sys_timeout_handler handler;
    void *arg;

    PBUF_CHECK_FREE_OOSEQ();

    tmptimeout = next_timeout;
 8010650:	4b0b      	ldr	r3, [pc, #44]	@ (8010680 <sys_check_timeouts+0x38>)
 8010652:	6819      	ldr	r1, [r3, #0]
    if (tmptimeout == NULL) {
 8010654:	b191      	cbz	r1, 801067c <sys_check_timeouts+0x34>
      return;
    }

    if (TIME_LESS_THAN(now, tmptimeout->time)) {
 8010656:	684b      	ldr	r3, [r1, #4]
 8010658:	1aea      	subs	r2, r5, r3
 801065a:	2a00      	cmp	r2, #0
 801065c:	db0e      	blt.n	801067c <sys_check_timeouts+0x34>
      return;
    }

    /* Timeout has expired */
    next_timeout = tmptimeout->next;
 801065e:	6808      	ldr	r0, [r1, #0]
 8010660:	4a07      	ldr	r2, [pc, #28]	@ (8010680 <sys_check_timeouts+0x38>)
 8010662:	6010      	str	r0, [r2, #0]
    handler = tmptimeout->h;
 8010664:	688c      	ldr	r4, [r1, #8]
    arg = tmptimeout->arg;
 8010666:	68ce      	ldr	r6, [r1, #12]
    current_timeout_due_time = tmptimeout->time;
 8010668:	4a06      	ldr	r2, [pc, #24]	@ (8010684 <sys_check_timeouts+0x3c>)
 801066a:	6013      	str	r3, [r2, #0]
    if (handler != NULL) {
      LWIP_DEBUGF(TIMERS_DEBUG, ("sct calling h=%s t=%"U32_F" arg=%p\n",
                                 tmptimeout->handler_name, sys_now() - tmptimeout->time, arg));
    }
#endif /* LWIP_DEBUG_TIMERNAMES */
    memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
 801066c:	200b      	movs	r0, #11
 801066e:	f7fa ff43 	bl	800b4f8 <memp_free>
    if (handler != NULL) {
 8010672:	2c00      	cmp	r4, #0
 8010674:	d0ec      	beq.n	8010650 <sys_check_timeouts+0x8>
      handler(arg);
 8010676:	4630      	mov	r0, r6
 8010678:	47a0      	blx	r4
 801067a:	e7e9      	b.n	8010650 <sys_check_timeouts+0x8>
    }
    LWIP_TCPIP_THREAD_ALIVE();

    /* Repeat until all expired timers have been called */
  } while (1);
}
 801067c:	bd70      	pop	{r4, r5, r6, pc}
 801067e:	bf00      	nop
 8010680:	24014330 	.word	0x24014330
 8010684:	2401432c 	.word	0x2401432c

08010688 <sys_timeouts_sleeptime>:
/** Return the time left before the next timeout is due. If no timeouts are
 * enqueued, returns 0xffffffff
 */
u32_t
sys_timeouts_sleeptime(void)
{
 8010688:	b510      	push	{r4, lr}
  u32_t now;

  LWIP_ASSERT_CORE_LOCKED();

  if (next_timeout == NULL) {
 801068a:	4b0d      	ldr	r3, [pc, #52]	@ (80106c0 <sys_timeouts_sleeptime+0x38>)
 801068c:	681b      	ldr	r3, [r3, #0]
 801068e:	b183      	cbz	r3, 80106b2 <sys_timeouts_sleeptime+0x2a>
    return SYS_TIMEOUTS_SLEEPTIME_INFINITE;
  }
  now = sys_now();
 8010690:	f003 f92e 	bl	80138f0 <sys_now>
  if (TIME_LESS_THAN(next_timeout->time, now)) {
 8010694:	4b0a      	ldr	r3, [pc, #40]	@ (80106c0 <sys_timeouts_sleeptime+0x38>)
 8010696:	681b      	ldr	r3, [r3, #0]
 8010698:	685c      	ldr	r4, [r3, #4]
 801069a:	1a24      	subs	r4, r4, r0
 801069c:	d40c      	bmi.n	80106b8 <sys_timeouts_sleeptime+0x30>
    return 0;
  } else {
    u32_t ret = (u32_t)(next_timeout->time - now);
    LWIP_ASSERT("invalid sleeptime", ret <= LWIP_MAX_TIMEOUT);
 801069e:	2c00      	cmp	r4, #0
 80106a0:	da0b      	bge.n	80106ba <sys_timeouts_sleeptime+0x32>
 80106a2:	4b08      	ldr	r3, [pc, #32]	@ (80106c4 <sys_timeouts_sleeptime+0x3c>)
 80106a4:	f44f 72dc 	mov.w	r2, #440	@ 0x1b8
 80106a8:	4907      	ldr	r1, [pc, #28]	@ (80106c8 <sys_timeouts_sleeptime+0x40>)
 80106aa:	4808      	ldr	r0, [pc, #32]	@ (80106cc <sys_timeouts_sleeptime+0x44>)
 80106ac:	f003 fc68 	bl	8013f80 <iprintf>
    return ret;
 80106b0:	e003      	b.n	80106ba <sys_timeouts_sleeptime+0x32>
    return SYS_TIMEOUTS_SLEEPTIME_INFINITE;
 80106b2:	f04f 34ff 	mov.w	r4, #4294967295
 80106b6:	e000      	b.n	80106ba <sys_timeouts_sleeptime+0x32>
    return 0;
 80106b8:	2400      	movs	r4, #0
  }
}
 80106ba:	4620      	mov	r0, r4
 80106bc:	bd10      	pop	{r4, pc}
 80106be:	bf00      	nop
 80106c0:	24014330 	.word	0x24014330
 80106c4:	08017d00 	.word	0x08017d00
 80106c8:	08017dac 	.word	0x08017dac
 80106cc:	08015744 	.word	0x08015744

080106d0 <udp_new_port>:
 * @return a new (free) local UDP port number
 */
static u16_t
udp_new_port(void)
{
  u16_t n = 0;
 80106d0:	2000      	movs	r0, #0
  struct udp_pcb *pcb;

again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 80106d2:	4a10      	ldr	r2, [pc, #64]	@ (8010714 <udp_new_port+0x44>)
 80106d4:	8813      	ldrh	r3, [r2, #0]
 80106d6:	1c59      	adds	r1, r3, #1
 80106d8:	8011      	strh	r1, [r2, #0]
 80106da:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 80106de:	4293      	cmp	r3, r2
 80106e0:	d009      	beq.n	80106f6 <udp_new_port+0x26>
    udp_port = UDP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCBs. */
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 80106e2:	4b0d      	ldr	r3, [pc, #52]	@ (8010718 <udp_new_port+0x48>)
 80106e4:	681b      	ldr	r3, [r3, #0]
 80106e6:	b193      	cbz	r3, 801070e <udp_new_port+0x3e>
    if (pcb->local_port == udp_port) {
 80106e8:	8a59      	ldrh	r1, [r3, #18]
 80106ea:	4a0a      	ldr	r2, [pc, #40]	@ (8010714 <udp_new_port+0x44>)
 80106ec:	8812      	ldrh	r2, [r2, #0]
 80106ee:	4291      	cmp	r1, r2
 80106f0:	d006      	beq.n	8010700 <udp_new_port+0x30>
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 80106f2:	68db      	ldr	r3, [r3, #12]
 80106f4:	e7f7      	b.n	80106e6 <udp_new_port+0x16>
    udp_port = UDP_LOCAL_PORT_RANGE_START;
 80106f6:	4b07      	ldr	r3, [pc, #28]	@ (8010714 <udp_new_port+0x44>)
 80106f8:	f44f 4240 	mov.w	r2, #49152	@ 0xc000
 80106fc:	801a      	strh	r2, [r3, #0]
 80106fe:	e7f0      	b.n	80106e2 <udp_new_port+0x12>
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
 8010700:	3001      	adds	r0, #1
 8010702:	b280      	uxth	r0, r0
 8010704:	f5b0 4f80 	cmp.w	r0, #16384	@ 0x4000
 8010708:	d3e3      	bcc.n	80106d2 <udp_new_port+0x2>
        return 0;
 801070a:	2000      	movs	r0, #0
      }
      goto again;
    }
  }
  return udp_port;
}
 801070c:	4770      	bx	lr
  return udp_port;
 801070e:	4b01      	ldr	r3, [pc, #4]	@ (8010714 <udp_new_port+0x44>)
 8010710:	8818      	ldrh	r0, [r3, #0]
 8010712:	4770      	bx	lr
 8010714:	2400001a 	.word	0x2400001a
 8010718:	24014334 	.word	0x24014334

0801071c <udp_input_local_match>:
 * @param broadcast 1 if his is an IPv4 broadcast (global or subnet-only), 0 otherwise (only used for IPv4)
 * @return 1 on match, 0 otherwise
 */
static u8_t
udp_input_local_match(struct udp_pcb *pcb, struct netif *inp, u8_t broadcast)
{
 801071c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801071e:	460e      	mov	r6, r1
 8010720:	4615      	mov	r5, r2
  LWIP_UNUSED_ARG(inp);       /* in IPv6 only case */
  LWIP_UNUSED_ARG(broadcast); /* in IPv6 only case */

  LWIP_ASSERT("udp_input_local_match: invalid pcb", pcb != NULL);
 8010722:	4607      	mov	r7, r0
 8010724:	b1c8      	cbz	r0, 801075a <udp_input_local_match+0x3e>
  LWIP_ASSERT("udp_input_local_match: invalid netif", inp != NULL);
 8010726:	b1fe      	cbz	r6, 8010768 <udp_input_local_match+0x4c>

  /* check if PCB is bound to specific netif */
  if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 8010728:	7a3c      	ldrb	r4, [r7, #8]
 801072a:	b13c      	cbz	r4, 801073c <udp_input_local_match+0x20>
      (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 801072c:	4b1e      	ldr	r3, [pc, #120]	@ (80107a8 <udp_input_local_match+0x8c>)
 801072e:	685b      	ldr	r3, [r3, #4]
 8010730:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8010734:	3301      	adds	r3, #1
 8010736:	b2db      	uxtb	r3, r3
  if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 8010738:	429c      	cmp	r4, r3
 801073a:	d125      	bne.n	8010788 <udp_input_local_match+0x6c>
  /* Only need to check PCB if incoming IP version matches PCB IP version */
  if (IP_ADDR_PCB_VERSION_MATCH_EXACT(pcb, ip_current_dest_addr())) {
#if LWIP_IPV4
    /* Special case: IPv4 broadcast: all or broadcasts in my subnet
     * Note: broadcast variable can only be 1 if it is an IPv4 broadcast */
    if (broadcast != 0) {
 801073c:	b1dd      	cbz	r5, 8010776 <udp_input_local_match+0x5a>
#if IP_SOF_BROADCAST_RECV
      if (ip_get_option(pcb, SOF_BROADCAST))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 801073e:	b32f      	cbz	r7, 801078c <udp_input_local_match+0x70>
 8010740:	683b      	ldr	r3, [r7, #0]
 8010742:	b32b      	cbz	r3, 8010790 <udp_input_local_match+0x74>
            ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 8010744:	4a18      	ldr	r2, [pc, #96]	@ (80107a8 <udp_input_local_match+0x8c>)
 8010746:	6952      	ldr	r2, [r2, #20]
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 8010748:	f1b2 3fff 	cmp.w	r2, #4294967295
 801074c:	d022      	beq.n	8010794 <udp_input_local_match+0x78>
            ip4_addr_netcmp(ip_2_ip4(&pcb->local_ip), ip4_current_dest_addr(), netif_ip4_netmask(inp))) {
 801074e:	68b1      	ldr	r1, [r6, #8]
 8010750:	4053      	eors	r3, r2
            ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 8010752:	420b      	tst	r3, r1
 8010754:	d020      	beq.n	8010798 <udp_input_local_match+0x7c>
      if (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
        return 1;
      }
  }

  return 0;
 8010756:	2000      	movs	r0, #0
 8010758:	e017      	b.n	801078a <udp_input_local_match+0x6e>
  LWIP_ASSERT("udp_input_local_match: invalid pcb", pcb != NULL);
 801075a:	4b14      	ldr	r3, [pc, #80]	@ (80107ac <udp_input_local_match+0x90>)
 801075c:	2287      	movs	r2, #135	@ 0x87
 801075e:	4914      	ldr	r1, [pc, #80]	@ (80107b0 <udp_input_local_match+0x94>)
 8010760:	4814      	ldr	r0, [pc, #80]	@ (80107b4 <udp_input_local_match+0x98>)
 8010762:	f003 fc0d 	bl	8013f80 <iprintf>
 8010766:	e7de      	b.n	8010726 <udp_input_local_match+0xa>
  LWIP_ASSERT("udp_input_local_match: invalid netif", inp != NULL);
 8010768:	4b10      	ldr	r3, [pc, #64]	@ (80107ac <udp_input_local_match+0x90>)
 801076a:	2288      	movs	r2, #136	@ 0x88
 801076c:	4912      	ldr	r1, [pc, #72]	@ (80107b8 <udp_input_local_match+0x9c>)
 801076e:	4811      	ldr	r0, [pc, #68]	@ (80107b4 <udp_input_local_match+0x98>)
 8010770:	f003 fc06 	bl	8013f80 <iprintf>
 8010774:	e7d8      	b.n	8010728 <udp_input_local_match+0xc>
      if (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 8010776:	b18f      	cbz	r7, 801079c <udp_input_local_match+0x80>
 8010778:	683b      	ldr	r3, [r7, #0]
 801077a:	b18b      	cbz	r3, 80107a0 <udp_input_local_match+0x84>
 801077c:	4a0a      	ldr	r2, [pc, #40]	@ (80107a8 <udp_input_local_match+0x8c>)
 801077e:	6952      	ldr	r2, [r2, #20]
 8010780:	4293      	cmp	r3, r2
 8010782:	d00f      	beq.n	80107a4 <udp_input_local_match+0x88>
  return 0;
 8010784:	4628      	mov	r0, r5
 8010786:	e000      	b.n	801078a <udp_input_local_match+0x6e>
    return 0;
 8010788:	2000      	movs	r0, #0
}
 801078a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
          return 1;
 801078c:	2001      	movs	r0, #1
 801078e:	e7fc      	b.n	801078a <udp_input_local_match+0x6e>
 8010790:	2001      	movs	r0, #1
 8010792:	e7fa      	b.n	801078a <udp_input_local_match+0x6e>
 8010794:	2001      	movs	r0, #1
 8010796:	e7f8      	b.n	801078a <udp_input_local_match+0x6e>
 8010798:	2001      	movs	r0, #1
 801079a:	e7f6      	b.n	801078a <udp_input_local_match+0x6e>
        return 1;
 801079c:	2001      	movs	r0, #1
 801079e:	e7f4      	b.n	801078a <udp_input_local_match+0x6e>
 80107a0:	2001      	movs	r0, #1
 80107a2:	e7f2      	b.n	801078a <udp_input_local_match+0x6e>
 80107a4:	2001      	movs	r0, #1
 80107a6:	e7f0      	b.n	801078a <udp_input_local_match+0x6e>
 80107a8:	2400c4b0 	.word	0x2400c4b0
 80107ac:	08017dc0 	.word	0x08017dc0
 80107b0:	08017df0 	.word	0x08017df0
 80107b4:	08015744 	.word	0x08015744
 80107b8:	08017e14 	.word	0x08017e14

080107bc <udp_init>:
{
 80107bc:	b508      	push	{r3, lr}
  udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
 80107be:	f003 fadf 	bl	8013d80 <rand>
 80107c2:	4b02      	ldr	r3, [pc, #8]	@ (80107cc <udp_init+0x10>)
 80107c4:	4303      	orrs	r3, r0
 80107c6:	4a02      	ldr	r2, [pc, #8]	@ (80107d0 <udp_init+0x14>)
 80107c8:	8013      	strh	r3, [r2, #0]
}
 80107ca:	bd08      	pop	{r3, pc}
 80107cc:	ffffc000 	.word	0xffffc000
 80107d0:	2400001a 	.word	0x2400001a

080107d4 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
{
 80107d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80107d8:	b082      	sub	sp, #8
 80107da:	4604      	mov	r4, r0
 80107dc:	4615      	mov	r5, r2

  LWIP_ASSERT_CORE_LOCKED();

#if LWIP_IPV4
  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
 80107de:	460e      	mov	r6, r1
 80107e0:	b1c9      	cbz	r1, 8010816 <udp_bind+0x42>
  }
#else /* LWIP_IPV4 */
  LWIP_ERROR("udp_bind: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
#endif /* LWIP_IPV4 */

  LWIP_ERROR("udp_bind: invalid pcb", pcb != NULL, return ERR_ARG);
 80107e2:	b1d4      	cbz	r4, 801081a <udp_bind+0x46>

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
 80107e4:	483a      	ldr	r0, [pc, #232]	@ (80108d0 <udp_bind+0xfc>)
 80107e6:	f003 fbcb 	bl	8013f80 <iprintf>
  ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE, ipaddr);
 80107ea:	b306      	cbz	r6, 801082e <udp_bind+0x5a>
 80107ec:	7831      	ldrb	r1, [r6, #0]
 80107ee:	7872      	ldrb	r2, [r6, #1]
 80107f0:	78b3      	ldrb	r3, [r6, #2]
 80107f2:	78f0      	ldrb	r0, [r6, #3]
 80107f4:	9000      	str	r0, [sp, #0]
 80107f6:	4837      	ldr	r0, [pc, #220]	@ (80108d4 <udp_bind+0x100>)
 80107f8:	f003 fbc2 	bl	8013f80 <iprintf>
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));
 80107fc:	462f      	mov	r7, r5
 80107fe:	4629      	mov	r1, r5
 8010800:	4835      	ldr	r0, [pc, #212]	@ (80108d8 <udp_bind+0x104>)
 8010802:	f003 fbbd 	bl	8013f80 <iprintf>

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8010806:	4b35      	ldr	r3, [pc, #212]	@ (80108dc <udp_bind+0x108>)
 8010808:	681b      	ldr	r3, [r3, #0]
 801080a:	4619      	mov	r1, r3
 801080c:	b1a1      	cbz	r1, 8010838 <udp_bind+0x64>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
 801080e:	42a1      	cmp	r1, r4
 8010810:	d03c      	beq.n	801088c <udp_bind+0xb8>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8010812:	68c9      	ldr	r1, [r1, #12]
 8010814:	e7fa      	b.n	801080c <udp_bind+0x38>
    ipaddr = IP4_ADDR_ANY;
 8010816:	4e32      	ldr	r6, [pc, #200]	@ (80108e0 <udp_bind+0x10c>)
 8010818:	e7e3      	b.n	80107e2 <udp_bind+0xe>
  LWIP_ERROR("udp_bind: invalid pcb", pcb != NULL, return ERR_ARG);
 801081a:	4b32      	ldr	r3, [pc, #200]	@ (80108e4 <udp_bind+0x110>)
 801081c:	f240 32b7 	movw	r2, #951	@ 0x3b7
 8010820:	4931      	ldr	r1, [pc, #196]	@ (80108e8 <udp_bind+0x114>)
 8010822:	4832      	ldr	r0, [pc, #200]	@ (80108ec <udp_bind+0x118>)
 8010824:	f003 fbac 	bl	8013f80 <iprintf>
 8010828:	f06f 000f 	mvn.w	r0, #15
 801082c:	e02b      	b.n	8010886 <udp_bind+0xb2>
  ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE, ipaddr);
 801082e:	2300      	movs	r3, #0
 8010830:	461a      	mov	r2, r3
 8010832:	4619      	mov	r1, r3
 8010834:	4618      	mov	r0, r3
 8010836:	e7dd      	b.n	80107f4 <udp_bind+0x20>
  rebind = 0;
 8010838:	f04f 0800 	mov.w	r8, #0
    ipaddr = &zoned_ipaddr;
  }
#endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */

  /* no port specified? */
  if (port == 0) {
 801083c:	2d00      	cmp	r5, #0
 801083e:	d12f      	bne.n	80108a0 <udp_bind+0xcc>
    port = udp_new_port();
 8010840:	f7ff ff46 	bl	80106d0 <udp_new_port>
    if (port == 0) {
 8010844:	4605      	mov	r5, r0
 8010846:	b320      	cbz	r0, 8010892 <udp_bind+0xbe>
        }
      }
    }
  }

  ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
 8010848:	2e00      	cmp	r6, #0
 801084a:	d03f      	beq.n	80108cc <udp_bind+0xf8>
 801084c:	6833      	ldr	r3, [r6, #0]
 801084e:	6023      	str	r3, [r4, #0]

  pcb->local_port = port;
 8010850:	8265      	strh	r5, [r4, #18]
  mib2_udp_bind(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
 8010852:	f1b8 0f00 	cmp.w	r8, #0
 8010856:	d103      	bne.n	8010860 <udp_bind+0x8c>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
 8010858:	4b20      	ldr	r3, [pc, #128]	@ (80108dc <udp_bind+0x108>)
 801085a:	681a      	ldr	r2, [r3, #0]
 801085c:	60e2      	str	r2, [r4, #12]
    udp_pcbs = pcb;
 801085e:	601c      	str	r4, [r3, #0]
  }
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("udp_bind: bound to "));
 8010860:	4823      	ldr	r0, [pc, #140]	@ (80108f0 <udp_bind+0x11c>)
 8010862:	f003 fb8d 	bl	8013f80 <iprintf>
  ip_addr_debug_print_val(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, pcb->local_ip);
 8010866:	6821      	ldr	r1, [r4, #0]
 8010868:	0e0b      	lsrs	r3, r1, #24
 801086a:	9300      	str	r3, [sp, #0]
 801086c:	f3c1 4307 	ubfx	r3, r1, #16, #8
 8010870:	f3c1 2207 	ubfx	r2, r1, #8, #8
 8010874:	b2c9      	uxtb	r1, r1
 8010876:	4817      	ldr	r0, [pc, #92]	@ (80108d4 <udp_bind+0x100>)
 8010878:	f003 fb82 	bl	8013f80 <iprintf>
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->local_port));
 801087c:	8a61      	ldrh	r1, [r4, #18]
 801087e:	481d      	ldr	r0, [pc, #116]	@ (80108f4 <udp_bind+0x120>)
 8010880:	f003 fb7e 	bl	8013f80 <iprintf>
  return ERR_OK;
 8010884:	2000      	movs	r0, #0
}
 8010886:	b002      	add	sp, #8
 8010888:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      rebind = 1;
 801088c:	f04f 0801 	mov.w	r8, #1
 8010890:	e7d4      	b.n	801083c <udp_bind+0x68>
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
 8010892:	4819      	ldr	r0, [pc, #100]	@ (80108f8 <udp_bind+0x124>)
 8010894:	f003 fbe4 	bl	8014060 <puts>
      return ERR_USE;
 8010898:	f06f 0007 	mvn.w	r0, #7
 801089c:	e7f3      	b.n	8010886 <udp_bind+0xb2>
    for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 801089e:	68db      	ldr	r3, [r3, #12]
 80108a0:	2b00      	cmp	r3, #0
 80108a2:	d0d1      	beq.n	8010848 <udp_bind+0x74>
      if (pcb != ipcb) {
 80108a4:	42a3      	cmp	r3, r4
 80108a6:	d0fa      	beq.n	801089e <udp_bind+0xca>
          if ((ipcb->local_port == port) &&
 80108a8:	8a59      	ldrh	r1, [r3, #18]
 80108aa:	42a9      	cmp	r1, r5
 80108ac:	d1f7      	bne.n	801089e <udp_bind+0xca>
              (ip_addr_cmp(&ipcb->local_ip, ipaddr) || ip_addr_isany(ipaddr) ||
 80108ae:	6819      	ldr	r1, [r3, #0]
 80108b0:	6832      	ldr	r2, [r6, #0]
          if ((ipcb->local_port == port) &&
 80108b2:	4291      	cmp	r1, r2
 80108b4:	d003      	beq.n	80108be <udp_bind+0xea>
              (ip_addr_cmp(&ipcb->local_ip, ipaddr) || ip_addr_isany(ipaddr) ||
 80108b6:	b112      	cbz	r2, 80108be <udp_bind+0xea>
 80108b8:	b10b      	cbz	r3, 80108be <udp_bind+0xea>
              ip_addr_isany(&ipcb->local_ip))) {
 80108ba:	2900      	cmp	r1, #0
 80108bc:	d1ef      	bne.n	801089e <udp_bind+0xca>
            LWIP_DEBUGF(UDP_DEBUG,
 80108be:	4639      	mov	r1, r7
 80108c0:	480e      	ldr	r0, [pc, #56]	@ (80108fc <udp_bind+0x128>)
 80108c2:	f003 fb5d 	bl	8013f80 <iprintf>
            return ERR_USE;
 80108c6:	f06f 0007 	mvn.w	r0, #7
 80108ca:	e7dc      	b.n	8010886 <udp_bind+0xb2>
  ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
 80108cc:	2300      	movs	r3, #0
 80108ce:	e7be      	b.n	801084e <udp_bind+0x7a>
 80108d0:	08017e54 	.word	0x08017e54
 80108d4:	08017e68 	.word	0x08017e68
 80108d8:	08017e78 	.word	0x08017e78
 80108dc:	24014334 	.word	0x24014334
 80108e0:	08018fc0 	.word	0x08018fc0
 80108e4:	08017dc0 	.word	0x08017dc0
 80108e8:	08017e3c 	.word	0x08017e3c
 80108ec:	08015744 	.word	0x08015744
 80108f0:	08017ee0 	.word	0x08017ee0
 80108f4:	08017ef4 	.word	0x08017ef4
 80108f8:	08017e88 	.word	0x08017e88
 80108fc:	08017ea8 	.word	0x08017ea8

08010900 <udp_sendto_if_src>:
{
 8010900:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8010904:	b085      	sub	sp, #20
 8010906:	f8dd b038 	ldr.w	fp, [sp, #56]	@ 0x38
 801090a:	f8dd a03c 	ldr.w	sl, [sp, #60]	@ 0x3c
  LWIP_ERROR("udp_sendto_if_src: invalid pcb", pcb != NULL, return ERR_ARG);
 801090e:	2800      	cmp	r0, #0
 8010910:	d02e      	beq.n	8010970 <udp_sendto_if_src+0x70>
 8010912:	460c      	mov	r4, r1
 8010914:	4690      	mov	r8, r2
 8010916:	4699      	mov	r9, r3
 8010918:	4606      	mov	r6, r0
  LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 801091a:	2900      	cmp	r1, #0
 801091c:	d032      	beq.n	8010984 <udp_sendto_if_src+0x84>
  LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 801091e:	2a00      	cmp	r2, #0
 8010920:	d03a      	beq.n	8010998 <udp_sendto_if_src+0x98>
  LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 8010922:	f1ba 0f00 	cmp.w	sl, #0
 8010926:	d041      	beq.n	80109ac <udp_sendto_if_src+0xac>
  LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 8010928:	f1bb 0f00 	cmp.w	fp, #0
 801092c:	d048      	beq.n	80109c0 <udp_sendto_if_src+0xc0>
  if (pcb->local_port == 0) {
 801092e:	8a43      	ldrh	r3, [r0, #18]
 8010930:	2b00      	cmp	r3, #0
 8010932:	d04f      	beq.n	80109d4 <udp_sendto_if_src+0xd4>
  if ((u16_t)(p->tot_len + UDP_HLEN) < p->tot_len) {
 8010934:	8922      	ldrh	r2, [r4, #8]
 8010936:	f64f 73f7 	movw	r3, #65527	@ 0xfff7
 801093a:	429a      	cmp	r2, r3
 801093c:	f200 80c9 	bhi.w	8010ad2 <udp_sendto_if_src+0x1d2>
  if (pbuf_add_header(p, UDP_HLEN)) {
 8010940:	2108      	movs	r1, #8
 8010942:	4620      	mov	r0, r4
 8010944:	f7fb f8a9 	bl	800ba9a <pbuf_add_header>
 8010948:	2800      	cmp	r0, #0
 801094a:	d05c      	beq.n	8010a06 <udp_sendto_if_src+0x106>
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
 801094c:	f44f 7220 	mov.w	r2, #640	@ 0x280
 8010950:	2108      	movs	r1, #8
 8010952:	2022      	movs	r0, #34	@ 0x22
 8010954:	f7fb f954 	bl	800bc00 <pbuf_alloc>
    if (q == NULL) {
 8010958:	4605      	mov	r5, r0
 801095a:	2800      	cmp	r0, #0
 801095c:	d049      	beq.n	80109f2 <udp_sendto_if_src+0xf2>
    if (p->tot_len != 0) {
 801095e:	8923      	ldrh	r3, [r4, #8]
 8010960:	2b00      	cmp	r3, #0
 8010962:	d14c      	bne.n	80109fe <udp_sendto_if_src+0xfe>
    LWIP_DEBUGF(UDP_DEBUG,
 8010964:	4622      	mov	r2, r4
 8010966:	4629      	mov	r1, r5
 8010968:	485b      	ldr	r0, [pc, #364]	@ (8010ad8 <udp_sendto_if_src+0x1d8>)
 801096a:	f003 fb09 	bl	8013f80 <iprintf>
 801096e:	e04f      	b.n	8010a10 <udp_sendto_if_src+0x110>
  LWIP_ERROR("udp_sendto_if_src: invalid pcb", pcb != NULL, return ERR_ARG);
 8010970:	4b5a      	ldr	r3, [pc, #360]	@ (8010adc <udp_sendto_if_src+0x1dc>)
 8010972:	f240 22d1 	movw	r2, #721	@ 0x2d1
 8010976:	495a      	ldr	r1, [pc, #360]	@ (8010ae0 <udp_sendto_if_src+0x1e0>)
 8010978:	485a      	ldr	r0, [pc, #360]	@ (8010ae4 <udp_sendto_if_src+0x1e4>)
 801097a:	f003 fb01 	bl	8013f80 <iprintf>
 801097e:	f06f 070f 	mvn.w	r7, #15
 8010982:	e092      	b.n	8010aaa <udp_sendto_if_src+0x1aa>
  LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 8010984:	4b55      	ldr	r3, [pc, #340]	@ (8010adc <udp_sendto_if_src+0x1dc>)
 8010986:	f240 22d2 	movw	r2, #722	@ 0x2d2
 801098a:	4957      	ldr	r1, [pc, #348]	@ (8010ae8 <udp_sendto_if_src+0x1e8>)
 801098c:	4855      	ldr	r0, [pc, #340]	@ (8010ae4 <udp_sendto_if_src+0x1e4>)
 801098e:	f003 faf7 	bl	8013f80 <iprintf>
 8010992:	f06f 070f 	mvn.w	r7, #15
 8010996:	e088      	b.n	8010aaa <udp_sendto_if_src+0x1aa>
  LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 8010998:	4b50      	ldr	r3, [pc, #320]	@ (8010adc <udp_sendto_if_src+0x1dc>)
 801099a:	f240 22d3 	movw	r2, #723	@ 0x2d3
 801099e:	4953      	ldr	r1, [pc, #332]	@ (8010aec <udp_sendto_if_src+0x1ec>)
 80109a0:	4850      	ldr	r0, [pc, #320]	@ (8010ae4 <udp_sendto_if_src+0x1e4>)
 80109a2:	f003 faed 	bl	8013f80 <iprintf>
 80109a6:	f06f 070f 	mvn.w	r7, #15
 80109aa:	e07e      	b.n	8010aaa <udp_sendto_if_src+0x1aa>
  LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 80109ac:	4b4b      	ldr	r3, [pc, #300]	@ (8010adc <udp_sendto_if_src+0x1dc>)
 80109ae:	f44f 7235 	mov.w	r2, #724	@ 0x2d4
 80109b2:	494f      	ldr	r1, [pc, #316]	@ (8010af0 <udp_sendto_if_src+0x1f0>)
 80109b4:	484b      	ldr	r0, [pc, #300]	@ (8010ae4 <udp_sendto_if_src+0x1e4>)
 80109b6:	f003 fae3 	bl	8013f80 <iprintf>
 80109ba:	f06f 070f 	mvn.w	r7, #15
 80109be:	e074      	b.n	8010aaa <udp_sendto_if_src+0x1aa>
  LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 80109c0:	4b46      	ldr	r3, [pc, #280]	@ (8010adc <udp_sendto_if_src+0x1dc>)
 80109c2:	f240 22d5 	movw	r2, #725	@ 0x2d5
 80109c6:	494b      	ldr	r1, [pc, #300]	@ (8010af4 <udp_sendto_if_src+0x1f4>)
 80109c8:	4846      	ldr	r0, [pc, #280]	@ (8010ae4 <udp_sendto_if_src+0x1e4>)
 80109ca:	f003 fad9 	bl	8013f80 <iprintf>
 80109ce:	f06f 070f 	mvn.w	r7, #15
 80109d2:	e06a      	b.n	8010aaa <udp_sendto_if_src+0x1aa>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
 80109d4:	4848      	ldr	r0, [pc, #288]	@ (8010af8 <udp_sendto_if_src+0x1f8>)
 80109d6:	f003 fb43 	bl	8014060 <puts>
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 80109da:	8a72      	ldrh	r2, [r6, #18]
 80109dc:	4631      	mov	r1, r6
 80109de:	4630      	mov	r0, r6
 80109e0:	f7ff fef8 	bl	80107d4 <udp_bind>
    if (err != ERR_OK) {
 80109e4:	4607      	mov	r7, r0
 80109e6:	2800      	cmp	r0, #0
 80109e8:	d0a4      	beq.n	8010934 <udp_sendto_if_src+0x34>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
 80109ea:	4844      	ldr	r0, [pc, #272]	@ (8010afc <udp_sendto_if_src+0x1fc>)
 80109ec:	f003 fb38 	bl	8014060 <puts>
      return err;
 80109f0:	e05b      	b.n	8010aaa <udp_sendto_if_src+0x1aa>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
 80109f2:	4843      	ldr	r0, [pc, #268]	@ (8010b00 <udp_sendto_if_src+0x200>)
 80109f4:	f003 fb34 	bl	8014060 <puts>
      return ERR_MEM;
 80109f8:	f04f 37ff 	mov.w	r7, #4294967295
 80109fc:	e055      	b.n	8010aaa <udp_sendto_if_src+0x1aa>
      pbuf_chain(q, p);
 80109fe:	4621      	mov	r1, r4
 8010a00:	f7fb fa60 	bl	800bec4 <pbuf_chain>
 8010a04:	e7ae      	b.n	8010964 <udp_sendto_if_src+0x64>
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
 8010a06:	4621      	mov	r1, r4
 8010a08:	483e      	ldr	r0, [pc, #248]	@ (8010b04 <udp_sendto_if_src+0x204>)
 8010a0a:	f003 fab9 	bl	8013f80 <iprintf>
    q = p;
 8010a0e:	4625      	mov	r5, r4
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
 8010a10:	896b      	ldrh	r3, [r5, #10]
 8010a12:	2b07      	cmp	r3, #7
 8010a14:	d94d      	bls.n	8010ab2 <udp_sendto_if_src+0x1b2>
  udphdr = (struct udp_hdr *)q->payload;
 8010a16:	686f      	ldr	r7, [r5, #4]
  udphdr->src = lwip_htons(pcb->local_port);
 8010a18:	8a70      	ldrh	r0, [r6, #18]
 8010a1a:	f7fa f8a1 	bl	800ab60 <lwip_htons>
 8010a1e:	8038      	strh	r0, [r7, #0]
  udphdr->dest = lwip_htons(dst_port);
 8010a20:	4648      	mov	r0, r9
 8010a22:	f7fa f89d 	bl	800ab60 <lwip_htons>
 8010a26:	8078      	strh	r0, [r7, #2]
  udphdr->chksum = 0x0000;
 8010a28:	2300      	movs	r3, #0
 8010a2a:	71bb      	strb	r3, [r7, #6]
 8010a2c:	71fb      	strb	r3, [r7, #7]
  if (((pcb->flags & UDP_FLAGS_MULTICAST_LOOP) != 0) && ip_addr_ismulticast(dst_ip)) {
 8010a2e:	7c33      	ldrb	r3, [r6, #16]
 8010a30:	f013 0f08 	tst.w	r3, #8
 8010a34:	d005      	beq.n	8010a42 <udp_sendto_if_src+0x142>
 8010a36:	f8d8 3000 	ldr.w	r3, [r8]
 8010a3a:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 8010a3e:	2be0      	cmp	r3, #224	@ 0xe0
 8010a40:	d03f      	beq.n	8010ac2 <udp_sendto_if_src+0x1c2>
  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: sending datagram of length %"U16_F"\n", q->tot_len));
 8010a42:	8929      	ldrh	r1, [r5, #8]
 8010a44:	4830      	ldr	r0, [pc, #192]	@ (8010b08 <udp_sendto_if_src+0x208>)
 8010a46:	f003 fa9b 	bl	8013f80 <iprintf>
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
 8010a4a:	8929      	ldrh	r1, [r5, #8]
 8010a4c:	482f      	ldr	r0, [pc, #188]	@ (8010b0c <udp_sendto_if_src+0x20c>)
 8010a4e:	f003 fa97 	bl	8013f80 <iprintf>
    udphdr->len = lwip_htons(q->tot_len);
 8010a52:	8928      	ldrh	r0, [r5, #8]
 8010a54:	f7fa f884 	bl	800ab60 <lwip_htons>
 8010a58:	80b8      	strh	r0, [r7, #4]
  ttl = (ip_addr_ismulticast(dst_ip) ? udp_get_multicast_ttl(pcb) : pcb->ttl);
 8010a5a:	f8d8 3000 	ldr.w	r3, [r8]
 8010a5e:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 8010a62:	2be0      	cmp	r3, #224	@ 0xe0
 8010a64:	d032      	beq.n	8010acc <udp_sendto_if_src+0x1cc>
 8010a66:	f896 900b 	ldrb.w	r9, [r6, #11]
  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
 8010a6a:	88f9      	ldrh	r1, [r7, #6]
 8010a6c:	4828      	ldr	r0, [pc, #160]	@ (8010b10 <udp_sendto_if_src+0x210>)
 8010a6e:	f003 fa87 	bl	8013f80 <iprintf>
  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,0x%02"X16_F",)\n", (u16_t)ip_proto));
 8010a72:	2111      	movs	r1, #17
 8010a74:	4827      	ldr	r0, [pc, #156]	@ (8010b14 <udp_sendto_if_src+0x214>)
 8010a76:	f003 fa83 	bl	8013f80 <iprintf>
  err = ip_output_if_src(q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
 8010a7a:	f8cd b008 	str.w	fp, [sp, #8]
 8010a7e:	2311      	movs	r3, #17
 8010a80:	9301      	str	r3, [sp, #4]
 8010a82:	7ab3      	ldrb	r3, [r6, #10]
 8010a84:	9300      	str	r3, [sp, #0]
 8010a86:	464b      	mov	r3, r9
 8010a88:	4642      	mov	r2, r8
 8010a8a:	4651      	mov	r1, sl
 8010a8c:	4628      	mov	r0, r5
 8010a8e:	f001 fe18 	bl	80126c2 <ip4_output_if_src>
 8010a92:	4607      	mov	r7, r0
  if (q != p) {
 8010a94:	42a5      	cmp	r5, r4
 8010a96:	d002      	beq.n	8010a9e <udp_sendto_if_src+0x19e>
    pbuf_free(q);
 8010a98:	4628      	mov	r0, r5
 8010a9a:	f7fb f849 	bl	800bb30 <pbuf_free>
  UDP_STATS_INC(udp.xmit);
 8010a9e:	4a1e      	ldr	r2, [pc, #120]	@ (8010b18 <udp_sendto_if_src+0x218>)
 8010aa0:	f8b2 3094 	ldrh.w	r3, [r2, #148]	@ 0x94
 8010aa4:	3301      	adds	r3, #1
 8010aa6:	f8a2 3094 	strh.w	r3, [r2, #148]	@ 0x94
}
 8010aaa:	4638      	mov	r0, r7
 8010aac:	b005      	add	sp, #20
 8010aae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
 8010ab2:	4b0a      	ldr	r3, [pc, #40]	@ (8010adc <udp_sendto_if_src+0x1dc>)
 8010ab4:	f240 320d 	movw	r2, #781	@ 0x30d
 8010ab8:	4918      	ldr	r1, [pc, #96]	@ (8010b1c <udp_sendto_if_src+0x21c>)
 8010aba:	480a      	ldr	r0, [pc, #40]	@ (8010ae4 <udp_sendto_if_src+0x1e4>)
 8010abc:	f003 fa60 	bl	8013f80 <iprintf>
 8010ac0:	e7a9      	b.n	8010a16 <udp_sendto_if_src+0x116>
    q->flags |= PBUF_FLAG_MCASTLOOP;
 8010ac2:	7b6b      	ldrb	r3, [r5, #13]
 8010ac4:	f043 0304 	orr.w	r3, r3, #4
 8010ac8:	736b      	strb	r3, [r5, #13]
 8010aca:	e7ba      	b.n	8010a42 <udp_sendto_if_src+0x142>
  ttl = (ip_addr_ismulticast(dst_ip) ? udp_get_multicast_ttl(pcb) : pcb->ttl);
 8010acc:	f896 901d 	ldrb.w	r9, [r6, #29]
 8010ad0:	e7cb      	b.n	8010a6a <udp_sendto_if_src+0x16a>
    return ERR_MEM;
 8010ad2:	f04f 37ff 	mov.w	r7, #4294967295
 8010ad6:	e7e8      	b.n	8010aaa <udp_sendto_if_src+0x1aa>
 8010ad8:	08018028 	.word	0x08018028
 8010adc:	08017dc0 	.word	0x08017dc0
 8010ae0:	08017f04 	.word	0x08017f04
 8010ae4:	08015744 	.word	0x08015744
 8010ae8:	08017f24 	.word	0x08017f24
 8010aec:	08017f44 	.word	0x08017f44
 8010af0:	08017f68 	.word	0x08017f68
 8010af4:	08017f8c 	.word	0x08017f8c
 8010af8:	08017fb0 	.word	0x08017fb0
 8010afc:	08017fe0 	.word	0x08017fe0
 8010b00:	08018004 	.word	0x08018004
 8010b04:	08018060 	.word	0x08018060
 8010b08:	080180bc 	.word	0x080180bc
 8010b0c:	080180e8 	.word	0x080180e8
 8010b10:	0801810c 	.word	0x0801810c
 8010b14:	0801812c 	.word	0x0801812c
 8010b18:	240141b4 	.word	0x240141b4
 8010b1c:	0801808c 	.word	0x0801808c

08010b20 <udp_sendto_if>:
{
 8010b20:	b5f0      	push	{r4, r5, r6, r7, lr}
 8010b22:	b083      	sub	sp, #12
 8010b24:	9d08      	ldr	r5, [sp, #32]
  LWIP_ERROR("udp_sendto_if: invalid pcb", pcb != NULL, return ERR_ARG);
 8010b26:	b190      	cbz	r0, 8010b4e <udp_sendto_if+0x2e>
 8010b28:	4604      	mov	r4, r0
  LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 8010b2a:	b1d1      	cbz	r1, 8010b62 <udp_sendto_if+0x42>
  LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 8010b2c:	b31a      	cbz	r2, 8010b76 <udp_sendto_if+0x56>
  LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 8010b2e:	b365      	cbz	r5, 8010b8a <udp_sendto_if+0x6a>
    if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 8010b30:	2800      	cmp	r0, #0
 8010b32:	d034      	beq.n	8010b9e <udp_sendto_if+0x7e>
 8010b34:	6806      	ldr	r6, [r0, #0]
 8010b36:	b396      	cbz	r6, 8010b9e <udp_sendto_if+0x7e>
        ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 8010b38:	f006 0cf0 	and.w	ip, r6, #240	@ 0xf0
    if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 8010b3c:	f1bc 0fe0 	cmp.w	ip, #224	@ 0xe0
 8010b40:	d02d      	beq.n	8010b9e <udp_sendto_if+0x7e>
      if (!ip4_addr_cmp(ip_2_ip4(&(pcb->local_ip)), netif_ip4_addr(netif))) {
 8010b42:	686f      	ldr	r7, [r5, #4]
 8010b44:	42be      	cmp	r6, r7
 8010b46:	d02b      	beq.n	8010ba0 <udp_sendto_if+0x80>
        return ERR_RTE;
 8010b48:	f06f 0003 	mvn.w	r0, #3
 8010b4c:	e02d      	b.n	8010baa <udp_sendto_if+0x8a>
  LWIP_ERROR("udp_sendto_if: invalid pcb", pcb != NULL, return ERR_ARG);
 8010b4e:	4b18      	ldr	r3, [pc, #96]	@ (8010bb0 <udp_sendto_if+0x90>)
 8010b50:	f44f 7220 	mov.w	r2, #640	@ 0x280
 8010b54:	4917      	ldr	r1, [pc, #92]	@ (8010bb4 <udp_sendto_if+0x94>)
 8010b56:	4818      	ldr	r0, [pc, #96]	@ (8010bb8 <udp_sendto_if+0x98>)
 8010b58:	f003 fa12 	bl	8013f80 <iprintf>
 8010b5c:	f06f 000f 	mvn.w	r0, #15
 8010b60:	e023      	b.n	8010baa <udp_sendto_if+0x8a>
  LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 8010b62:	4b13      	ldr	r3, [pc, #76]	@ (8010bb0 <udp_sendto_if+0x90>)
 8010b64:	f240 2281 	movw	r2, #641	@ 0x281
 8010b68:	4914      	ldr	r1, [pc, #80]	@ (8010bbc <udp_sendto_if+0x9c>)
 8010b6a:	4813      	ldr	r0, [pc, #76]	@ (8010bb8 <udp_sendto_if+0x98>)
 8010b6c:	f003 fa08 	bl	8013f80 <iprintf>
 8010b70:	f06f 000f 	mvn.w	r0, #15
 8010b74:	e019      	b.n	8010baa <udp_sendto_if+0x8a>
  LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 8010b76:	4b0e      	ldr	r3, [pc, #56]	@ (8010bb0 <udp_sendto_if+0x90>)
 8010b78:	f240 2282 	movw	r2, #642	@ 0x282
 8010b7c:	4910      	ldr	r1, [pc, #64]	@ (8010bc0 <udp_sendto_if+0xa0>)
 8010b7e:	480e      	ldr	r0, [pc, #56]	@ (8010bb8 <udp_sendto_if+0x98>)
 8010b80:	f003 f9fe 	bl	8013f80 <iprintf>
 8010b84:	f06f 000f 	mvn.w	r0, #15
 8010b88:	e00f      	b.n	8010baa <udp_sendto_if+0x8a>
  LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 8010b8a:	4b09      	ldr	r3, [pc, #36]	@ (8010bb0 <udp_sendto_if+0x90>)
 8010b8c:	f240 2283 	movw	r2, #643	@ 0x283
 8010b90:	490c      	ldr	r1, [pc, #48]	@ (8010bc4 <udp_sendto_if+0xa4>)
 8010b92:	4809      	ldr	r0, [pc, #36]	@ (8010bb8 <udp_sendto_if+0x98>)
 8010b94:	f003 f9f4 	bl	8013f80 <iprintf>
 8010b98:	f06f 000f 	mvn.w	r0, #15
 8010b9c:	e005      	b.n	8010baa <udp_sendto_if+0x8a>
      src_ip = netif_ip_addr4(netif);
 8010b9e:	1d28      	adds	r0, r5, #4
  return udp_sendto_if_src(pcb, p, dst_ip, dst_port, netif, src_ip);
 8010ba0:	9001      	str	r0, [sp, #4]
 8010ba2:	9500      	str	r5, [sp, #0]
 8010ba4:	4620      	mov	r0, r4
 8010ba6:	f7ff feab 	bl	8010900 <udp_sendto_if_src>
}
 8010baa:	b003      	add	sp, #12
 8010bac:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8010bae:	bf00      	nop
 8010bb0:	08017dc0 	.word	0x08017dc0
 8010bb4:	08018154 	.word	0x08018154
 8010bb8:	08015744 	.word	0x08015744
 8010bbc:	08018170 	.word	0x08018170
 8010bc0:	0801818c 	.word	0x0801818c
 8010bc4:	080181ac 	.word	0x080181ac

08010bc8 <udp_sendto>:
{
 8010bc8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8010bca:	b083      	sub	sp, #12
  LWIP_ERROR("udp_sendto: invalid pcb", pcb != NULL, return ERR_ARG);
 8010bcc:	b348      	cbz	r0, 8010c22 <udp_sendto+0x5a>
 8010bce:	460d      	mov	r5, r1
 8010bd0:	4614      	mov	r4, r2
 8010bd2:	461e      	mov	r6, r3
 8010bd4:	4607      	mov	r7, r0
  LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 8010bd6:	2900      	cmp	r1, #0
 8010bd8:	d02d      	beq.n	8010c36 <udp_sendto+0x6e>
  LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 8010bda:	2a00      	cmp	r2, #0
 8010bdc:	d035      	beq.n	8010c4a <udp_sendto+0x82>
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send\n"));
 8010bde:	4832      	ldr	r0, [pc, #200]	@ (8010ca8 <udp_sendto+0xe0>)
 8010be0:	f003 fa3e 	bl	8014060 <puts>
  if (pcb->netif_idx != NETIF_NO_INDEX) {
 8010be4:	7a38      	ldrb	r0, [r7, #8]
 8010be6:	2800      	cmp	r0, #0
 8010be8:	d139      	bne.n	8010c5e <udp_sendto+0x96>
    if (ip_addr_ismulticast(dst_ip)) {
 8010bea:	6823      	ldr	r3, [r4, #0]
 8010bec:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 8010bf0:	2be0      	cmp	r3, #224	@ 0xe0
 8010bf2:	d108      	bne.n	8010c06 <udp_sendto+0x3e>
      if (pcb->mcast_ifindex != NETIF_NO_INDEX) {
 8010bf4:	7f38      	ldrb	r0, [r7, #28]
 8010bf6:	2800      	cmp	r0, #0
 8010bf8:	d134      	bne.n	8010c64 <udp_sendto+0x9c>
          if (!ip4_addr_isany_val(pcb->mcast_ip4) &&
 8010bfa:	69bb      	ldr	r3, [r7, #24]
 8010bfc:	b11b      	cbz	r3, 8010c06 <udp_sendto+0x3e>
              !ip4_addr_cmp(&pcb->mcast_ip4, IP4_ADDR_BROADCAST)) {
 8010bfe:	4a2b      	ldr	r2, [pc, #172]	@ (8010cac <udp_sendto+0xe4>)
 8010c00:	6812      	ldr	r2, [r2, #0]
          if (!ip4_addr_isany_val(pcb->mcast_ip4) &&
 8010c02:	4293      	cmp	r3, r2
 8010c04:	d133      	bne.n	8010c6e <udp_sendto+0xa6>
      netif = ip_route(&pcb->local_ip, dst_ip);
 8010c06:	4620      	mov	r0, r4
 8010c08:	f001 faf8 	bl	80121fc <ip4_route>
  if (netif == NULL) {
 8010c0c:	2800      	cmp	r0, #0
 8010c0e:	d033      	beq.n	8010c78 <udp_sendto+0xb0>
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
 8010c10:	9000      	str	r0, [sp, #0]
 8010c12:	4633      	mov	r3, r6
 8010c14:	4622      	mov	r2, r4
 8010c16:	4629      	mov	r1, r5
 8010c18:	4638      	mov	r0, r7
 8010c1a:	f7ff ff81 	bl	8010b20 <udp_sendto_if>
}
 8010c1e:	b003      	add	sp, #12
 8010c20:	bdf0      	pop	{r4, r5, r6, r7, pc}
  LWIP_ERROR("udp_sendto: invalid pcb", pcb != NULL, return ERR_ARG);
 8010c22:	4b23      	ldr	r3, [pc, #140]	@ (8010cb0 <udp_sendto+0xe8>)
 8010c24:	f44f 7206 	mov.w	r2, #536	@ 0x218
 8010c28:	4922      	ldr	r1, [pc, #136]	@ (8010cb4 <udp_sendto+0xec>)
 8010c2a:	4823      	ldr	r0, [pc, #140]	@ (8010cb8 <udp_sendto+0xf0>)
 8010c2c:	f003 f9a8 	bl	8013f80 <iprintf>
 8010c30:	f06f 000f 	mvn.w	r0, #15
 8010c34:	e7f3      	b.n	8010c1e <udp_sendto+0x56>
  LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 8010c36:	4b1e      	ldr	r3, [pc, #120]	@ (8010cb0 <udp_sendto+0xe8>)
 8010c38:	f240 2219 	movw	r2, #537	@ 0x219
 8010c3c:	491f      	ldr	r1, [pc, #124]	@ (8010cbc <udp_sendto+0xf4>)
 8010c3e:	481e      	ldr	r0, [pc, #120]	@ (8010cb8 <udp_sendto+0xf0>)
 8010c40:	f003 f99e 	bl	8013f80 <iprintf>
 8010c44:	f06f 000f 	mvn.w	r0, #15
 8010c48:	e7e9      	b.n	8010c1e <udp_sendto+0x56>
  LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 8010c4a:	4b19      	ldr	r3, [pc, #100]	@ (8010cb0 <udp_sendto+0xe8>)
 8010c4c:	f240 221a 	movw	r2, #538	@ 0x21a
 8010c50:	491b      	ldr	r1, [pc, #108]	@ (8010cc0 <udp_sendto+0xf8>)
 8010c52:	4819      	ldr	r0, [pc, #100]	@ (8010cb8 <udp_sendto+0xf0>)
 8010c54:	f003 f994 	bl	8013f80 <iprintf>
 8010c58:	f06f 000f 	mvn.w	r0, #15
 8010c5c:	e7df      	b.n	8010c1e <udp_sendto+0x56>
    netif = netif_get_by_index(pcb->netif_idx);
 8010c5e:	f7fa fe39 	bl	800b8d4 <netif_get_by_index>
 8010c62:	e7d3      	b.n	8010c0c <udp_sendto+0x44>
        netif = netif_get_by_index(pcb->mcast_ifindex);
 8010c64:	f7fa fe36 	bl	800b8d4 <netif_get_by_index>
    if (netif == NULL)
 8010c68:	2800      	cmp	r0, #0
 8010c6a:	d1d1      	bne.n	8010c10 <udp_sendto+0x48>
 8010c6c:	e7cb      	b.n	8010c06 <udp_sendto+0x3e>
            netif = ip4_route_src(ip_2_ip4(&pcb->local_ip), &pcb->mcast_ip4);
 8010c6e:	f107 0018 	add.w	r0, r7, #24
 8010c72:	f001 fac3 	bl	80121fc <ip4_route>
 8010c76:	e7f7      	b.n	8010c68 <udp_sendto+0xa0>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to "));
 8010c78:	4812      	ldr	r0, [pc, #72]	@ (8010cc4 <udp_sendto+0xfc>)
 8010c7a:	f003 f981 	bl	8013f80 <iprintf>
    ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, dst_ip);
 8010c7e:	78e3      	ldrb	r3, [r4, #3]
 8010c80:	9300      	str	r3, [sp, #0]
 8010c82:	78a3      	ldrb	r3, [r4, #2]
 8010c84:	7862      	ldrb	r2, [r4, #1]
 8010c86:	7821      	ldrb	r1, [r4, #0]
 8010c88:	480f      	ldr	r0, [pc, #60]	@ (8010cc8 <udp_sendto+0x100>)
 8010c8a:	f003 f979 	bl	8013f80 <iprintf>
    LWIP_DEBUGF(UDP_DEBUG, ("\n"));
 8010c8e:	200a      	movs	r0, #10
 8010c90:	f003 f988 	bl	8013fa4 <putchar>
    UDP_STATS_INC(udp.rterr);
 8010c94:	4a0d      	ldr	r2, [pc, #52]	@ (8010ccc <udp_sendto+0x104>)
 8010c96:	f8b2 30a2 	ldrh.w	r3, [r2, #162]	@ 0xa2
 8010c9a:	3301      	adds	r3, #1
 8010c9c:	f8a2 30a2 	strh.w	r3, [r2, #162]	@ 0xa2
    return ERR_RTE;
 8010ca0:	f06f 0003 	mvn.w	r0, #3
 8010ca4:	e7bb      	b.n	8010c1e <udp_sendto+0x56>
 8010ca6:	bf00      	nop
 8010ca8:	0801821c 	.word	0x0801821c
 8010cac:	08018fbc 	.word	0x08018fbc
 8010cb0:	08017dc0 	.word	0x08017dc0
 8010cb4:	080181cc 	.word	0x080181cc
 8010cb8:	08015744 	.word	0x08015744
 8010cbc:	080181e4 	.word	0x080181e4
 8010cc0:	08018200 	.word	0x08018200
 8010cc4:	08018228 	.word	0x08018228
 8010cc8:	08017e68 	.word	0x08017e68
 8010ccc:	240141b4 	.word	0x240141b4

08010cd0 <udp_recv>:
 * @param recv function pointer of the callback function
 * @param recv_arg additional argument to pass to the callback function
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
 8010cd0:	b508      	push	{r3, lr}
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_recv: invalid pcb", pcb != NULL, return);
 8010cd2:	b110      	cbz	r0, 8010cda <udp_recv+0xa>

  /* remember recv() callback and user data */
  pcb->recv = recv;
 8010cd4:	6201      	str	r1, [r0, #32]
  pcb->recv_arg = recv_arg;
 8010cd6:	6242      	str	r2, [r0, #36]	@ 0x24
}
 8010cd8:	bd08      	pop	{r3, pc}
  LWIP_ERROR("udp_recv: invalid pcb", pcb != NULL, return);
 8010cda:	4b04      	ldr	r3, [pc, #16]	@ (8010cec <udp_recv+0x1c>)
 8010cdc:	f240 428a 	movw	r2, #1162	@ 0x48a
 8010ce0:	4903      	ldr	r1, [pc, #12]	@ (8010cf0 <udp_recv+0x20>)
 8010ce2:	4804      	ldr	r0, [pc, #16]	@ (8010cf4 <udp_recv+0x24>)
 8010ce4:	f003 f94c 	bl	8013f80 <iprintf>
 8010ce8:	e7f6      	b.n	8010cd8 <udp_recv+0x8>
 8010cea:	bf00      	nop
 8010cec:	08017dc0 	.word	0x08017dc0
 8010cf0:	08018240 	.word	0x08018240
 8010cf4:	08015744 	.word	0x08015744

08010cf8 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 8010cf8:	b508      	push	{r3, lr}
  struct udp_pcb *pcb2;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_remove: invalid pcb", pcb != NULL, return);
 8010cfa:	b150      	cbz	r0, 8010d12 <udp_remove+0x1a>
 8010cfc:	4601      	mov	r1, r0

  mib2_udp_unbind(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
 8010cfe:	4b0f      	ldr	r3, [pc, #60]	@ (8010d3c <udp_remove+0x44>)
 8010d00:	681a      	ldr	r2, [r3, #0]
 8010d02:	4282      	cmp	r2, r0
 8010d04:	d111      	bne.n	8010d2a <udp_remove+0x32>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
 8010d06:	68d2      	ldr	r2, [r2, #12]
 8010d08:	601a      	str	r2, [r3, #0]
        pcb2->next = pcb->next;
        break;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
 8010d0a:	2000      	movs	r0, #0
 8010d0c:	f7fa fbf4 	bl	800b4f8 <memp_free>
}
 8010d10:	bd08      	pop	{r3, pc}
  LWIP_ERROR("udp_remove: invalid pcb", pcb != NULL, return);
 8010d12:	4b0b      	ldr	r3, [pc, #44]	@ (8010d40 <udp_remove+0x48>)
 8010d14:	f240 42a1 	movw	r2, #1185	@ 0x4a1
 8010d18:	490a      	ldr	r1, [pc, #40]	@ (8010d44 <udp_remove+0x4c>)
 8010d1a:	480b      	ldr	r0, [pc, #44]	@ (8010d48 <udp_remove+0x50>)
 8010d1c:	f003 f930 	bl	8013f80 <iprintf>
 8010d20:	e7f6      	b.n	8010d10 <udp_remove+0x18>
        pcb2->next = pcb->next;
 8010d22:	68cb      	ldr	r3, [r1, #12]
 8010d24:	60d3      	str	r3, [r2, #12]
        break;
 8010d26:	e7f0      	b.n	8010d0a <udp_remove+0x12>
 8010d28:	461a      	mov	r2, r3
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 8010d2a:	2a00      	cmp	r2, #0
 8010d2c:	d0ed      	beq.n	8010d0a <udp_remove+0x12>
      if (pcb2->next != NULL && pcb2->next == pcb) {
 8010d2e:	68d3      	ldr	r3, [r2, #12]
 8010d30:	2b00      	cmp	r3, #0
 8010d32:	d0f9      	beq.n	8010d28 <udp_remove+0x30>
 8010d34:	428b      	cmp	r3, r1
 8010d36:	d0f4      	beq.n	8010d22 <udp_remove+0x2a>
 8010d38:	461a      	mov	r2, r3
 8010d3a:	e7f6      	b.n	8010d2a <udp_remove+0x32>
 8010d3c:	24014334 	.word	0x24014334
 8010d40:	08017dc0 	.word	0x08017dc0
 8010d44:	08018258 	.word	0x08018258
 8010d48:	08015744 	.word	0x08015744

08010d4c <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
 8010d4c:	b510      	push	{r4, lr}
  struct udp_pcb *pcb;

  LWIP_ASSERT_CORE_LOCKED();

  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
 8010d4e:	2000      	movs	r0, #0
 8010d50:	f7fa fb9c 	bl	800b48c <memp_malloc>
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
 8010d54:	4604      	mov	r4, r0
 8010d56:	b130      	cbz	r0, 8010d66 <udp_new+0x1a>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
 8010d58:	2228      	movs	r2, #40	@ 0x28
 8010d5a:	2100      	movs	r1, #0
 8010d5c:	f003 faac 	bl	80142b8 <memset>
    pcb->ttl = UDP_TTL;
 8010d60:	23ff      	movs	r3, #255	@ 0xff
 8010d62:	72e3      	strb	r3, [r4, #11]
#if LWIP_MULTICAST_TX_OPTIONS
    udp_set_multicast_ttl(pcb, UDP_TTL);
 8010d64:	7763      	strb	r3, [r4, #29]
#endif /* LWIP_MULTICAST_TX_OPTIONS */
  }
  return pcb;
}
 8010d66:	4620      	mov	r0, r4
 8010d68:	bd10      	pop	{r4, pc}

08010d6a <udp_new_ip_type>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new_ip_type(u8_t type)
{
 8010d6a:	b508      	push	{r3, lr}
  struct udp_pcb *pcb;

  LWIP_ASSERT_CORE_LOCKED();

  pcb = udp_new();
 8010d6c:	f7ff ffee 	bl	8010d4c <udp_new>
  }
#else
  LWIP_UNUSED_ARG(type);
#endif /* LWIP_IPV4 && LWIP_IPV6 */
  return pcb;
}
 8010d70:	bd08      	pop	{r3, pc}
	...

08010d74 <udp_netif_ip_addr_changed>:
 */
void udp_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
  struct udp_pcb *upcb;

  if (!ip_addr_isany(old_addr) && !ip_addr_isany(new_addr)) {
 8010d74:	b1b8      	cbz	r0, 8010da6 <udp_netif_ip_addr_changed+0x32>
 8010d76:	4602      	mov	r2, r0
 8010d78:	6803      	ldr	r3, [r0, #0]
 8010d7a:	b1a3      	cbz	r3, 8010da6 <udp_netif_ip_addr_changed+0x32>
 8010d7c:	b199      	cbz	r1, 8010da6 <udp_netif_ip_addr_changed+0x32>
 8010d7e:	680b      	ldr	r3, [r1, #0]
 8010d80:	b18b      	cbz	r3, 8010da6 <udp_netif_ip_addr_changed+0x32>
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 8010d82:	4b09      	ldr	r3, [pc, #36]	@ (8010da8 <udp_netif_ip_addr_changed+0x34>)
 8010d84:	681b      	ldr	r3, [r3, #0]
 8010d86:	b16b      	cbz	r3, 8010da4 <udp_netif_ip_addr_changed+0x30>
{
 8010d88:	b410      	push	{r4}
 8010d8a:	e001      	b.n	8010d90 <udp_netif_ip_addr_changed+0x1c>
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 8010d8c:	68db      	ldr	r3, [r3, #12]
 8010d8e:	b133      	cbz	r3, 8010d9e <udp_netif_ip_addr_changed+0x2a>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&upcb->local_ip, old_addr)) {
 8010d90:	6810      	ldr	r0, [r2, #0]
 8010d92:	681c      	ldr	r4, [r3, #0]
 8010d94:	4284      	cmp	r4, r0
 8010d96:	d1f9      	bne.n	8010d8c <udp_netif_ip_addr_changed+0x18>
        /* The PCB is bound to the old ipaddr and
         * is set to bound to the new one instead */
        ip_addr_copy(upcb->local_ip, *new_addr);
 8010d98:	6808      	ldr	r0, [r1, #0]
 8010d9a:	6018      	str	r0, [r3, #0]
 8010d9c:	e7f6      	b.n	8010d8c <udp_netif_ip_addr_changed+0x18>
      }
    }
  }
}
 8010d9e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8010da2:	4770      	bx	lr
 8010da4:	4770      	bx	lr
 8010da6:	4770      	bx	lr
 8010da8:	24014334 	.word	0x24014334

08010dac <udp_debug_print>:
 *
 * @param udphdr pointer to the udp header in memory.
 */
void
udp_debug_print(struct udp_hdr *udphdr)
{
 8010dac:	b570      	push	{r4, r5, r6, lr}
 8010dae:	4604      	mov	r4, r0
  LWIP_DEBUGF(UDP_DEBUG, ("UDP header:\n"));
 8010db0:	4812      	ldr	r0, [pc, #72]	@ (8010dfc <udp_debug_print+0x50>)
 8010db2:	f003 f955 	bl	8014060 <puts>
  LWIP_DEBUGF(UDP_DEBUG, ("+-------------------------------+\n"));
 8010db6:	4d12      	ldr	r5, [pc, #72]	@ (8010e00 <udp_debug_print+0x54>)
 8010db8:	4628      	mov	r0, r5
 8010dba:	f003 f951 	bl	8014060 <puts>
  LWIP_DEBUGF(UDP_DEBUG, ("|     %5"U16_F"     |     %5"U16_F"     | (src port, dest port)\n",
 8010dbe:	8820      	ldrh	r0, [r4, #0]
 8010dc0:	f7f9 fece 	bl	800ab60 <lwip_htons>
 8010dc4:	4606      	mov	r6, r0
 8010dc6:	8860      	ldrh	r0, [r4, #2]
 8010dc8:	f7f9 feca 	bl	800ab60 <lwip_htons>
 8010dcc:	4602      	mov	r2, r0
 8010dce:	4631      	mov	r1, r6
 8010dd0:	480c      	ldr	r0, [pc, #48]	@ (8010e04 <udp_debug_print+0x58>)
 8010dd2:	f003 f8d5 	bl	8013f80 <iprintf>
                          lwip_ntohs(udphdr->src), lwip_ntohs(udphdr->dest)));
  LWIP_DEBUGF(UDP_DEBUG, ("+-------------------------------+\n"));
 8010dd6:	4628      	mov	r0, r5
 8010dd8:	f003 f942 	bl	8014060 <puts>
  LWIP_DEBUGF(UDP_DEBUG, ("|     %5"U16_F"     |     0x%04"X16_F"    | (len, chksum)\n",
 8010ddc:	88a0      	ldrh	r0, [r4, #4]
 8010dde:	f7f9 febf 	bl	800ab60 <lwip_htons>
 8010de2:	4606      	mov	r6, r0
 8010de4:	88e0      	ldrh	r0, [r4, #6]
 8010de6:	f7f9 febb 	bl	800ab60 <lwip_htons>
 8010dea:	4602      	mov	r2, r0
 8010dec:	4631      	mov	r1, r6
 8010dee:	4806      	ldr	r0, [pc, #24]	@ (8010e08 <udp_debug_print+0x5c>)
 8010df0:	f003 f8c6 	bl	8013f80 <iprintf>
                          lwip_ntohs(udphdr->len), lwip_ntohs(udphdr->chksum)));
  LWIP_DEBUGF(UDP_DEBUG, ("+-------------------------------+\n"));
 8010df4:	4628      	mov	r0, r5
 8010df6:	f003 f933 	bl	8014060 <puts>
}
 8010dfa:	bd70      	pop	{r4, r5, r6, pc}
 8010dfc:	08018270 	.word	0x08018270
 8010e00:	0801827c 	.word	0x0801827c
 8010e04:	080182a0 	.word	0x080182a0
 8010e08:	080182d8 	.word	0x080182d8

08010e0c <udp_input>:
{
 8010e0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8010e10:	b085      	sub	sp, #20
 8010e12:	4688      	mov	r8, r1
  LWIP_ASSERT("udp_input: invalid pbuf", p != NULL);
 8010e14:	4682      	mov	sl, r0
 8010e16:	2800      	cmp	r0, #0
 8010e18:	d052      	beq.n	8010ec0 <udp_input+0xb4>
  LWIP_ASSERT("udp_input: invalid netif", inp != NULL);
 8010e1a:	f1b8 0f00 	cmp.w	r8, #0
 8010e1e:	d056      	beq.n	8010ece <udp_input+0xc2>
  UDP_STATS_INC(udp.recv);
 8010e20:	4a99      	ldr	r2, [pc, #612]	@ (8011088 <udp_input+0x27c>)
 8010e22:	f8b2 3096 	ldrh.w	r3, [r2, #150]	@ 0x96
 8010e26:	3301      	adds	r3, #1
 8010e28:	f8a2 3096 	strh.w	r3, [r2, #150]	@ 0x96
  if (p->len < UDP_HLEN) {
 8010e2c:	f8ba 300a 	ldrh.w	r3, [sl, #10]
 8010e30:	2b07      	cmp	r3, #7
 8010e32:	d953      	bls.n	8010edc <udp_input+0xd0>
  udphdr = (struct udp_hdr *)p->payload;
 8010e34:	f8da 4004 	ldr.w	r4, [sl, #4]
  broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
 8010e38:	4f94      	ldr	r7, [pc, #592]	@ (801108c <udp_input+0x280>)
 8010e3a:	6839      	ldr	r1, [r7, #0]
 8010e3c:	6978      	ldr	r0, [r7, #20]
 8010e3e:	f001 fc51 	bl	80126e4 <ip4_addr_isbroadcast_u32>
 8010e42:	4681      	mov	r9, r0
  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));
 8010e44:	f8ba 1008 	ldrh.w	r1, [sl, #8]
 8010e48:	4891      	ldr	r0, [pc, #580]	@ (8011090 <udp_input+0x284>)
 8010e4a:	f003 f899 	bl	8013f80 <iprintf>
  src = lwip_ntohs(udphdr->src);
 8010e4e:	8820      	ldrh	r0, [r4, #0]
 8010e50:	f7f9 fe86 	bl	800ab60 <lwip_htons>
 8010e54:	4683      	mov	fp, r0
  dest = lwip_ntohs(udphdr->dest);
 8010e56:	8860      	ldrh	r0, [r4, #2]
 8010e58:	f7f9 fe82 	bl	800ab60 <lwip_htons>
 8010e5c:	4606      	mov	r6, r0
  udp_debug_print(udphdr);
 8010e5e:	4620      	mov	r0, r4
 8010e60:	f7ff ffa4 	bl	8010dac <udp_debug_print>
  LWIP_DEBUGF(UDP_DEBUG, ("udp ("));
 8010e64:	488b      	ldr	r0, [pc, #556]	@ (8011094 <udp_input+0x288>)
 8010e66:	f003 f88b 	bl	8013f80 <iprintf>
  ip_addr_debug_print_val(UDP_DEBUG, *ip_current_dest_addr());
 8010e6a:	6979      	ldr	r1, [r7, #20]
 8010e6c:	0e0b      	lsrs	r3, r1, #24
 8010e6e:	4d8a      	ldr	r5, [pc, #552]	@ (8011098 <udp_input+0x28c>)
 8010e70:	9300      	str	r3, [sp, #0]
 8010e72:	f3c1 4307 	ubfx	r3, r1, #16, #8
 8010e76:	f3c1 2207 	ubfx	r2, r1, #8, #8
 8010e7a:	b2c9      	uxtb	r1, r1
 8010e7c:	4628      	mov	r0, r5
 8010e7e:	f003 f87f 	bl	8013f80 <iprintf>
  LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", lwip_ntohs(udphdr->dest)));
 8010e82:	8860      	ldrh	r0, [r4, #2]
 8010e84:	f7f9 fe6c 	bl	800ab60 <lwip_htons>
 8010e88:	4601      	mov	r1, r0
 8010e8a:	4884      	ldr	r0, [pc, #528]	@ (801109c <udp_input+0x290>)
 8010e8c:	f003 f878 	bl	8013f80 <iprintf>
  ip_addr_debug_print_val(UDP_DEBUG, *ip_current_src_addr());
 8010e90:	6939      	ldr	r1, [r7, #16]
 8010e92:	0e0b      	lsrs	r3, r1, #24
 8010e94:	9300      	str	r3, [sp, #0]
 8010e96:	f3c1 4307 	ubfx	r3, r1, #16, #8
 8010e9a:	f3c1 2207 	ubfx	r2, r1, #8, #8
 8010e9e:	b2c9      	uxtb	r1, r1
 8010ea0:	4628      	mov	r0, r5
 8010ea2:	f003 f86d 	bl	8013f80 <iprintf>
  LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", lwip_ntohs(udphdr->src)));
 8010ea6:	8820      	ldrh	r0, [r4, #0]
 8010ea8:	f7f9 fe5a 	bl	800ab60 <lwip_htons>
 8010eac:	4601      	mov	r1, r0
 8010eae:	487c      	ldr	r0, [pc, #496]	@ (80110a0 <udp_input+0x294>)
 8010eb0:	f003 f866 	bl	8013f80 <iprintf>
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8010eb4:	4b7b      	ldr	r3, [pc, #492]	@ (80110a4 <udp_input+0x298>)
 8010eb6:	681c      	ldr	r4, [r3, #0]
  uncon_pcb = NULL;
 8010eb8:	2300      	movs	r3, #0
 8010eba:	9303      	str	r3, [sp, #12]
  prev = NULL;
 8010ebc:	461f      	mov	r7, r3
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8010ebe:	e027      	b.n	8010f10 <udp_input+0x104>
  LWIP_ASSERT("udp_input: invalid pbuf", p != NULL);
 8010ec0:	4b79      	ldr	r3, [pc, #484]	@ (80110a8 <udp_input+0x29c>)
 8010ec2:	22cf      	movs	r2, #207	@ 0xcf
 8010ec4:	4979      	ldr	r1, [pc, #484]	@ (80110ac <udp_input+0x2a0>)
 8010ec6:	487a      	ldr	r0, [pc, #488]	@ (80110b0 <udp_input+0x2a4>)
 8010ec8:	f003 f85a 	bl	8013f80 <iprintf>
 8010ecc:	e7a5      	b.n	8010e1a <udp_input+0xe>
  LWIP_ASSERT("udp_input: invalid netif", inp != NULL);
 8010ece:	4b76      	ldr	r3, [pc, #472]	@ (80110a8 <udp_input+0x29c>)
 8010ed0:	22d0      	movs	r2, #208	@ 0xd0
 8010ed2:	4978      	ldr	r1, [pc, #480]	@ (80110b4 <udp_input+0x2a8>)
 8010ed4:	4876      	ldr	r0, [pc, #472]	@ (80110b0 <udp_input+0x2a4>)
 8010ed6:	f003 f853 	bl	8013f80 <iprintf>
 8010eda:	e7a1      	b.n	8010e20 <udp_input+0x14>
    LWIP_DEBUGF(UDP_DEBUG,
 8010edc:	f8ba 1008 	ldrh.w	r1, [sl, #8]
 8010ee0:	4875      	ldr	r0, [pc, #468]	@ (80110b8 <udp_input+0x2ac>)
 8010ee2:	f003 f84d 	bl	8013f80 <iprintf>
    UDP_STATS_INC(udp.lenerr);
 8010ee6:	4b68      	ldr	r3, [pc, #416]	@ (8011088 <udp_input+0x27c>)
 8010ee8:	f8b3 209e 	ldrh.w	r2, [r3, #158]	@ 0x9e
 8010eec:	3201      	adds	r2, #1
 8010eee:	f8a3 209e 	strh.w	r2, [r3, #158]	@ 0x9e
    UDP_STATS_INC(udp.drop);
 8010ef2:	f8b3 209a 	ldrh.w	r2, [r3, #154]	@ 0x9a
 8010ef6:	3201      	adds	r2, #1
 8010ef8:	f8a3 209a 	strh.w	r2, [r3, #154]	@ 0x9a
    pbuf_free(p);
 8010efc:	4650      	mov	r0, sl
 8010efe:	f7fa fe17 	bl	800bb30 <pbuf_free>
    goto end;
 8010f02:	e074      	b.n	8010fee <udp_input+0x1e2>
          uncon_pcb = pcb;
 8010f04:	9403      	str	r4, [sp, #12]
      if ((pcb->remote_port == src) &&
 8010f06:	8aa3      	ldrh	r3, [r4, #20]
 8010f08:	455b      	cmp	r3, fp
 8010f0a:	d049      	beq.n	8010fa0 <udp_input+0x194>
    prev = pcb;
 8010f0c:	4627      	mov	r7, r4
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8010f0e:	68e4      	ldr	r4, [r4, #12]
 8010f10:	2c00      	cmp	r4, #0
 8010f12:	d059      	beq.n	8010fc8 <udp_input+0x1bc>
    LWIP_DEBUGF(UDP_DEBUG, ("pcb ("));
 8010f14:	4869      	ldr	r0, [pc, #420]	@ (80110bc <udp_input+0x2b0>)
 8010f16:	f003 f833 	bl	8013f80 <iprintf>
    ip_addr_debug_print_val(UDP_DEBUG, pcb->local_ip);
 8010f1a:	6821      	ldr	r1, [r4, #0]
 8010f1c:	0e0b      	lsrs	r3, r1, #24
 8010f1e:	4d5e      	ldr	r5, [pc, #376]	@ (8011098 <udp_input+0x28c>)
 8010f20:	9300      	str	r3, [sp, #0]
 8010f22:	f3c1 4307 	ubfx	r3, r1, #16, #8
 8010f26:	f3c1 2207 	ubfx	r2, r1, #8, #8
 8010f2a:	b2c9      	uxtb	r1, r1
 8010f2c:	4628      	mov	r0, r5
 8010f2e:	f003 f827 	bl	8013f80 <iprintf>
    LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", pcb->local_port));
 8010f32:	8a61      	ldrh	r1, [r4, #18]
 8010f34:	4859      	ldr	r0, [pc, #356]	@ (801109c <udp_input+0x290>)
 8010f36:	f003 f823 	bl	8013f80 <iprintf>
    ip_addr_debug_print_val(UDP_DEBUG, pcb->remote_ip);
 8010f3a:	6861      	ldr	r1, [r4, #4]
 8010f3c:	0e0b      	lsrs	r3, r1, #24
 8010f3e:	9300      	str	r3, [sp, #0]
 8010f40:	f3c1 4307 	ubfx	r3, r1, #16, #8
 8010f44:	f3c1 2207 	ubfx	r2, r1, #8, #8
 8010f48:	b2c9      	uxtb	r1, r1
 8010f4a:	4628      	mov	r0, r5
 8010f4c:	f003 f818 	bl	8013f80 <iprintf>
    LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", pcb->remote_port));
 8010f50:	8aa1      	ldrh	r1, [r4, #20]
 8010f52:	4853      	ldr	r0, [pc, #332]	@ (80110a0 <udp_input+0x294>)
 8010f54:	f003 f814 	bl	8013f80 <iprintf>
    if ((pcb->local_port == dest) &&
 8010f58:	8a63      	ldrh	r3, [r4, #18]
 8010f5a:	42b3      	cmp	r3, r6
 8010f5c:	d1d6      	bne.n	8010f0c <udp_input+0x100>
        (udp_input_local_match(pcb, inp, broadcast) != 0)) {
 8010f5e:	464a      	mov	r2, r9
 8010f60:	4641      	mov	r1, r8
 8010f62:	4620      	mov	r0, r4
 8010f64:	f7ff fbda 	bl	801071c <udp_input_local_match>
    if ((pcb->local_port == dest) &&
 8010f68:	2800      	cmp	r0, #0
 8010f6a:	d0cf      	beq.n	8010f0c <udp_input+0x100>
      if ((pcb->flags & UDP_FLAGS_CONNECTED) == 0) {
 8010f6c:	7c23      	ldrb	r3, [r4, #16]
 8010f6e:	f013 0f04 	tst.w	r3, #4
 8010f72:	d1c8      	bne.n	8010f06 <udp_input+0xfa>
        if (uncon_pcb == NULL) {
 8010f74:	9b03      	ldr	r3, [sp, #12]
 8010f76:	2b00      	cmp	r3, #0
 8010f78:	d0c4      	beq.n	8010f04 <udp_input+0xf8>
        } else if (broadcast && ip4_current_dest_addr()->addr == IPADDR_BROADCAST) {
 8010f7a:	f1b9 0f00 	cmp.w	r9, #0
 8010f7e:	d0c2      	beq.n	8010f06 <udp_input+0xfa>
 8010f80:	4b42      	ldr	r3, [pc, #264]	@ (801108c <udp_input+0x280>)
 8010f82:	695b      	ldr	r3, [r3, #20]
 8010f84:	f1b3 3fff 	cmp.w	r3, #4294967295
 8010f88:	d1bd      	bne.n	8010f06 <udp_input+0xfa>
          if (!IP_IS_V4_VAL(uncon_pcb->local_ip) || !ip4_addr_cmp(ip_2_ip4(&uncon_pcb->local_ip), netif_ip4_addr(inp))) {
 8010f8a:	9b03      	ldr	r3, [sp, #12]
 8010f8c:	681a      	ldr	r2, [r3, #0]
 8010f8e:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8010f92:	429a      	cmp	r2, r3
 8010f94:	d0b7      	beq.n	8010f06 <udp_input+0xfa>
            if (IP_IS_V4_VAL(pcb->local_ip) && ip4_addr_cmp(ip_2_ip4(&pcb->local_ip), netif_ip4_addr(inp))) {
 8010f96:	6822      	ldr	r2, [r4, #0]
 8010f98:	4293      	cmp	r3, r2
 8010f9a:	d1b4      	bne.n	8010f06 <udp_input+0xfa>
              uncon_pcb = pcb;
 8010f9c:	9403      	str	r4, [sp, #12]
 8010f9e:	e7b2      	b.n	8010f06 <udp_input+0xfa>
          (ip_addr_isany_val(pcb->remote_ip) ||
 8010fa0:	6863      	ldr	r3, [r4, #4]
      if ((pcb->remote_port == src) &&
 8010fa2:	b11b      	cbz	r3, 8010fac <udp_input+0x1a0>
           ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
 8010fa4:	4a39      	ldr	r2, [pc, #228]	@ (801108c <udp_input+0x280>)
 8010fa6:	6912      	ldr	r2, [r2, #16]
          (ip_addr_isany_val(pcb->remote_ip) ||
 8010fa8:	4293      	cmp	r3, r2
 8010faa:	d1af      	bne.n	8010f0c <udp_input+0x100>
        if (prev != NULL) {
 8010fac:	b137      	cbz	r7, 8010fbc <udp_input+0x1b0>
          prev->next = pcb->next;
 8010fae:	68e3      	ldr	r3, [r4, #12]
 8010fb0:	60fb      	str	r3, [r7, #12]
          pcb->next = udp_pcbs;
 8010fb2:	4b3c      	ldr	r3, [pc, #240]	@ (80110a4 <udp_input+0x298>)
 8010fb4:	681a      	ldr	r2, [r3, #0]
 8010fb6:	60e2      	str	r2, [r4, #12]
          udp_pcbs = pcb;
 8010fb8:	601c      	str	r4, [r3, #0]
  if (pcb == NULL) {
 8010fba:	e01c      	b.n	8010ff6 <udp_input+0x1ea>
          UDP_STATS_INC(udp.cachehit);
 8010fbc:	4a32      	ldr	r2, [pc, #200]	@ (8011088 <udp_input+0x27c>)
 8010fbe:	f8b2 30aa 	ldrh.w	r3, [r2, #170]	@ 0xaa
 8010fc2:	3301      	adds	r3, #1
 8010fc4:	f8a2 30aa 	strh.w	r3, [r2, #170]	@ 0xaa
  if (pcb == NULL) {
 8010fc8:	b1a4      	cbz	r4, 8010ff4 <udp_input+0x1e8>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: calculating checksum\n"));
 8010fca:	483d      	ldr	r0, [pc, #244]	@ (80110c0 <udp_input+0x2b4>)
 8010fcc:	f003 f848 	bl	8014060 <puts>
    if (pbuf_remove_header(p, UDP_HLEN)) {
 8010fd0:	2108      	movs	r1, #8
 8010fd2:	4650      	mov	r0, sl
 8010fd4:	f7fa fd66 	bl	800baa4 <pbuf_remove_header>
 8010fd8:	b9c8      	cbnz	r0, 801100e <udp_input+0x202>
    if (pcb != NULL) {
 8010fda:	b36c      	cbz	r4, 8011038 <udp_input+0x22c>
      if (pcb->recv != NULL) {
 8010fdc:	6a25      	ldr	r5, [r4, #32]
 8010fde:	b33d      	cbz	r5, 8011030 <udp_input+0x224>
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 8010fe0:	6a60      	ldr	r0, [r4, #36]	@ 0x24
 8010fe2:	f8cd b000 	str.w	fp, [sp]
 8010fe6:	4b37      	ldr	r3, [pc, #220]	@ (80110c4 <udp_input+0x2b8>)
 8010fe8:	4652      	mov	r2, sl
 8010fea:	4621      	mov	r1, r4
 8010fec:	47a8      	blx	r5
}
 8010fee:	b005      	add	sp, #20
 8010ff0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    pcb = uncon_pcb;
 8010ff4:	9c03      	ldr	r4, [sp, #12]
  if (pcb != NULL) {
 8010ff6:	2c00      	cmp	r4, #0
 8010ff8:	d1e7      	bne.n	8010fca <udp_input+0x1be>
      for_us = ip4_addr_cmp(netif_ip4_addr(inp), ip4_current_dest_addr());
 8010ffa:	f8d8 2004 	ldr.w	r2, [r8, #4]
 8010ffe:	4b23      	ldr	r3, [pc, #140]	@ (801108c <udp_input+0x280>)
 8011000:	695b      	ldr	r3, [r3, #20]
  if (for_us) {
 8011002:	429a      	cmp	r2, r3
 8011004:	d0e1      	beq.n	8010fca <udp_input+0x1be>
    pbuf_free(p);
 8011006:	4650      	mov	r0, sl
 8011008:	f7fa fd92 	bl	800bb30 <pbuf_free>
  return;
 801100c:	e7ef      	b.n	8010fee <udp_input+0x1e2>
      LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 801100e:	4b26      	ldr	r3, [pc, #152]	@ (80110a8 <udp_input+0x29c>)
 8011010:	f44f 72b8 	mov.w	r2, #368	@ 0x170
 8011014:	492c      	ldr	r1, [pc, #176]	@ (80110c8 <udp_input+0x2bc>)
 8011016:	4826      	ldr	r0, [pc, #152]	@ (80110b0 <udp_input+0x2a4>)
 8011018:	f002 ffb2 	bl	8013f80 <iprintf>
      UDP_STATS_INC(udp.drop);
 801101c:	4a1a      	ldr	r2, [pc, #104]	@ (8011088 <udp_input+0x27c>)
 801101e:	f8b2 309a 	ldrh.w	r3, [r2, #154]	@ 0x9a
 8011022:	3301      	adds	r3, #1
 8011024:	f8a2 309a 	strh.w	r3, [r2, #154]	@ 0x9a
      pbuf_free(p);
 8011028:	4650      	mov	r0, sl
 801102a:	f7fa fd81 	bl	800bb30 <pbuf_free>
      goto end;
 801102e:	e7de      	b.n	8010fee <udp_input+0x1e2>
        pbuf_free(p);
 8011030:	4650      	mov	r0, sl
 8011032:	f7fa fd7d 	bl	800bb30 <pbuf_free>
        goto end;
 8011036:	e7da      	b.n	8010fee <udp_input+0x1e2>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));
 8011038:	4824      	ldr	r0, [pc, #144]	@ (80110cc <udp_input+0x2c0>)
 801103a:	f003 f811 	bl	8014060 <puts>
      if (!broadcast && !ip_addr_ismulticast(ip_current_dest_addr())) {
 801103e:	f1b9 0f00 	cmp.w	r9, #0
 8011042:	d105      	bne.n	8011050 <udp_input+0x244>
 8011044:	4b11      	ldr	r3, [pc, #68]	@ (801108c <udp_input+0x280>)
 8011046:	695b      	ldr	r3, [r3, #20]
 8011048:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 801104c:	2be0      	cmp	r3, #224	@ 0xe0
 801104e:	d10e      	bne.n	801106e <udp_input+0x262>
      UDP_STATS_INC(udp.proterr);
 8011050:	4b0d      	ldr	r3, [pc, #52]	@ (8011088 <udp_input+0x27c>)
 8011052:	f8b3 20a4 	ldrh.w	r2, [r3, #164]	@ 0xa4
 8011056:	3201      	adds	r2, #1
 8011058:	f8a3 20a4 	strh.w	r2, [r3, #164]	@ 0xa4
      UDP_STATS_INC(udp.drop);
 801105c:	f8b3 209a 	ldrh.w	r2, [r3, #154]	@ 0x9a
 8011060:	3201      	adds	r2, #1
 8011062:	f8a3 209a 	strh.w	r2, [r3, #154]	@ 0x9a
      pbuf_free(p);
 8011066:	4650      	mov	r0, sl
 8011068:	f7fa fd62 	bl	800bb30 <pbuf_free>
 801106c:	e7bf      	b.n	8010fee <udp_input+0x1e2>
        pbuf_header_force(p, (s16_t)(ip_current_header_tot_len() + UDP_HLEN));
 801106e:	4b07      	ldr	r3, [pc, #28]	@ (801108c <udp_input+0x280>)
 8011070:	8999      	ldrh	r1, [r3, #12]
 8011072:	3108      	adds	r1, #8
 8011074:	b209      	sxth	r1, r1
 8011076:	4650      	mov	r0, sl
 8011078:	f7fa fd54 	bl	800bb24 <pbuf_header_force>
        icmp_port_unreach(ip_current_is_v6(), p);
 801107c:	2103      	movs	r1, #3
 801107e:	4650      	mov	r0, sl
 8011080:	f000 fe24 	bl	8011ccc <icmp_dest_unreach>
 8011084:	e7e4      	b.n	8011050 <udp_input+0x244>
 8011086:	bf00      	nop
 8011088:	240141b4 	.word	0x240141b4
 801108c:	2400c4b0 	.word	0x2400c4b0
 8011090:	08018378 	.word	0x08018378
 8011094:	080183a4 	.word	0x080183a4
 8011098:	08017e68 	.word	0x08017e68
 801109c:	080183ac 	.word	0x080183ac
 80110a0:	080183bc 	.word	0x080183bc
 80110a4:	24014334 	.word	0x24014334
 80110a8:	08017dc0 	.word	0x08017dc0
 80110ac:	0801830c 	.word	0x0801830c
 80110b0:	08015744 	.word	0x08015744
 80110b4:	08018324 	.word	0x08018324
 80110b8:	08018340 	.word	0x08018340
 80110bc:	080183c4 	.word	0x080183c4
 80110c0:	080183cc 	.word	0x080183cc
 80110c4:	2400c4c0 	.word	0x2400c4c0
 80110c8:	080183ec 	.word	0x080183ec
 80110cc:	08018408 	.word	0x08018408

080110d0 <etharp_free_entry>:
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
 80110d0:	b510      	push	{r4, lr}
 80110d2:	4604      	mov	r4, r0
  /* remove from SNMP ARP index tree */
  mib2_remove_arp_entry(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 80110d4:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 80110d8:	4b0d      	ldr	r3, [pc, #52]	@ (8011110 <etharp_free_entry+0x40>)
 80110da:	f853 0032 	ldr.w	r0, [r3, r2, lsl #3]
 80110de:	b138      	cbz	r0, 80110f0 <etharp_free_entry+0x20>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 80110e0:	f7fa fd26 	bl	800bb30 <pbuf_free>
    arp_table[i].q = NULL;
 80110e4:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 80110e8:	00db      	lsls	r3, r3, #3
 80110ea:	4a09      	ldr	r2, [pc, #36]	@ (8011110 <etharp_free_entry+0x40>)
 80110ec:	2100      	movs	r1, #0
 80110ee:	50d1      	str	r1, [r2, r3]
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 80110f0:	4a07      	ldr	r2, [pc, #28]	@ (8011110 <etharp_free_entry+0x40>)
 80110f2:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 80110f6:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 80110fa:	2100      	movs	r1, #0
 80110fc:	7519      	strb	r1, [r3, #20]
#ifdef LWIP_DEBUG
  /* for debugging, clean out the complete entry */
  arp_table[i].ctime = 0;
 80110fe:	8259      	strh	r1, [r3, #18]
  arp_table[i].netif = NULL;
 8011100:	6099      	str	r1, [r3, #8]
  ip4_addr_set_zero(&arp_table[i].ipaddr);
 8011102:	6059      	str	r1, [r3, #4]
  arp_table[i].ethaddr = ethzero;
 8011104:	4a03      	ldr	r2, [pc, #12]	@ (8011114 <etharp_free_entry+0x44>)
 8011106:	6810      	ldr	r0, [r2, #0]
 8011108:	60d8      	str	r0, [r3, #12]
 801110a:	8892      	ldrh	r2, [r2, #4]
 801110c:	821a      	strh	r2, [r3, #16]
#endif /* LWIP_DEBUG */
}
 801110e:	bd10      	pop	{r4, pc}
 8011110:	2401433c 	.word	0x2401433c
 8011114:	08018fc4 	.word	0x08018fc4

08011118 <etharp_find_entry>:
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s16_t
etharp_find_entry(const ip4_addr_t *ipaddr, u8_t flags, struct netif *netif)
{
 8011118:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801111c:	b085      	sub	sp, #20
 801111e:	4606      	mov	r6, r0
 8011120:	4617      	mov	r7, r2
  s16_t empty = ARP_TABLE_SIZE;
  s16_t i = 0;
  /* oldest entry with packets on queue */
  s16_t old_queue = ARP_TABLE_SIZE;
  /* its age */
  u16_t age_queue = 0, age_pending = 0, age_stable = 0;
 8011122:	f04f 0900 	mov.w	r9, #0
 8011126:	f8cd 900c 	str.w	r9, [sp, #12]
 801112a:	46cb      	mov	fp, r9
  s16_t old_queue = ARP_TABLE_SIZE;
 801112c:	f04f 0a0a 	mov.w	sl, #10
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8011130:	464b      	mov	r3, r9
  s16_t empty = ARP_TABLE_SIZE;
 8011132:	4655      	mov	r5, sl
  s16_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 8011134:	46d0      	mov	r8, sl
 8011136:	f8cd a008 	str.w	sl, [sp, #8]
 801113a:	9101      	str	r1, [sp, #4]
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 801113c:	e029      	b.n	8011192 <etharp_find_entry+0x7a>
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
                  state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip4_addr_cmp(ipaddr, &arp_table[i].ipaddr)
#if ETHARP_TABLE_MATCH_NETIF
          && ((netif == NULL) || (netif == arp_table[i].netif))
 801113e:	2f00      	cmp	r7, #0
 8011140:	f000 80ad 	beq.w	801129e <etharp_find_entry+0x186>
 8011144:	4a5a      	ldr	r2, [pc, #360]	@ (80112b0 <etharp_find_entry+0x198>)
 8011146:	eb02 02ce 	add.w	r2, r2, lr, lsl #3
 801114a:	6892      	ldr	r2, [r2, #8]
 801114c:	42ba      	cmp	r2, r7
 801114e:	d13a      	bne.n	80111c6 <etharp_find_entry+0xae>
#endif /* ETHARP_TABLE_MATCH_NETIF */
         ) {
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %d\n", (int)i));
        /* found exact IP address match, simply bail out */
        return i;
 8011150:	461d      	mov	r5, r3
 8011152:	e07e      	b.n	8011252 <etharp_find_entry+0x13a>
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 8011154:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 8011158:	4855      	ldr	r0, [pc, #340]	@ (80112b0 <etharp_find_entry+0x198>)
 801115a:	f850 2032 	ldr.w	r2, [r0, r2, lsl #3]
 801115e:	b14a      	cbz	r2, 8011174 <etharp_find_entry+0x5c>
          if (arp_table[i].ctime >= age_queue) {
 8011160:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8011164:	eb00 02c4 	add.w	r2, r0, r4, lsl #3
 8011168:	8a52      	ldrh	r2, [r2, #18]
 801116a:	455a      	cmp	r2, fp
 801116c:	d30f      	bcc.n	801118e <etharp_find_entry+0x76>
            old_queue = i;
            age_queue = arp_table[i].ctime;
 801116e:	4693      	mov	fp, r2
            old_queue = i;
 8011170:	469a      	mov	sl, r3
 8011172:	e00c      	b.n	801118e <etharp_find_entry+0x76>
          }
        } else
          /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 8011174:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8011178:	4a4d      	ldr	r2, [pc, #308]	@ (80112b0 <etharp_find_entry+0x198>)
 801117a:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
 801117e:	8a52      	ldrh	r2, [r2, #18]
 8011180:	9903      	ldr	r1, [sp, #12]
 8011182:	428a      	cmp	r2, r1
 8011184:	d303      	bcc.n	801118e <etharp_find_entry+0x76>
            old_pending = i;
            age_pending = arp_table[i].ctime;
 8011186:	9203      	str	r2, [sp, #12]
            old_pending = i;
 8011188:	9302      	str	r3, [sp, #8]
 801118a:	e000      	b.n	801118e <etharp_find_entry+0x76>
      empty = i;
 801118c:	461d      	mov	r5, r3
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 801118e:	3301      	adds	r3, #1
 8011190:	b21b      	sxth	r3, r3
 8011192:	2b09      	cmp	r3, #9
 8011194:	dc26      	bgt.n	80111e4 <etharp_find_entry+0xcc>
    u8_t state = arp_table[i].state;
 8011196:	461c      	mov	r4, r3
 8011198:	eb03 0043 	add.w	r0, r3, r3, lsl #1
 801119c:	4a44      	ldr	r2, [pc, #272]	@ (80112b0 <etharp_find_entry+0x198>)
 801119e:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
 80111a2:	7d10      	ldrb	r0, [r2, #20]
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 80111a4:	2d0a      	cmp	r5, #10
 80111a6:	bf08      	it	eq
 80111a8:	2800      	cmpeq	r0, #0
 80111aa:	d0ef      	beq.n	801118c <etharp_find_entry+0x74>
    } else if (state != ETHARP_STATE_EMPTY) {
 80111ac:	2800      	cmp	r0, #0
 80111ae:	d0ee      	beq.n	801118e <etharp_find_entry+0x76>
      if (ipaddr && ip4_addr_cmp(ipaddr, &arp_table[i].ipaddr)
 80111b0:	b14e      	cbz	r6, 80111c6 <etharp_find_entry+0xae>
 80111b2:	eb03 0e43 	add.w	lr, r3, r3, lsl #1
 80111b6:	4a3e      	ldr	r2, [pc, #248]	@ (80112b0 <etharp_find_entry+0x198>)
 80111b8:	eb02 0cce 	add.w	ip, r2, lr, lsl #3
 80111bc:	f8dc 2004 	ldr.w	r2, [ip, #4]
 80111c0:	6831      	ldr	r1, [r6, #0]
 80111c2:	4291      	cmp	r1, r2
 80111c4:	d0bb      	beq.n	801113e <etharp_find_entry+0x26>
      if (state == ETHARP_STATE_PENDING) {
 80111c6:	2801      	cmp	r0, #1
 80111c8:	d0c4      	beq.n	8011154 <etharp_find_entry+0x3c>
          }
        }
        /* stable entry? */
      } else if (state >= ETHARP_STATE_STABLE) {
 80111ca:	2801      	cmp	r0, #1
 80111cc:	d9df      	bls.n	801118e <etharp_find_entry+0x76>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 80111ce:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 80111d2:	4a37      	ldr	r2, [pc, #220]	@ (80112b0 <etharp_find_entry+0x198>)
 80111d4:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
 80111d8:	8a52      	ldrh	r2, [r2, #18]
 80111da:	454a      	cmp	r2, r9
 80111dc:	d3d7      	bcc.n	801118e <etharp_find_entry+0x76>
            old_stable = i;
            age_stable = arp_table[i].ctime;
 80111de:	4691      	mov	r9, r2
            old_stable = i;
 80111e0:	4698      	mov	r8, r3
 80111e2:	e7d4      	b.n	801118e <etharp_find_entry+0x76>
    }
  }
  /* { we have no match } => try to create a new entry */

  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
 80111e4:	9901      	ldr	r1, [sp, #4]
 80111e6:	f011 0f02 	tst.w	r1, #2
 80111ea:	d15a      	bne.n	80112a2 <etharp_find_entry+0x18a>
 80111ec:	2d0a      	cmp	r5, #10
 80111ee:	d034      	beq.n	801125a <etharp_find_entry+0x142>
   *
   * { ETHARP_FLAG_TRY_HARD is set at this point }
   */

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
 80111f0:	2d09      	cmp	r5, #9
 80111f2:	dd16      	ble.n	8011222 <etharp_find_entry+0x10a>
    i = empty;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %d\n", (int)i));
  } else {
    /* 2) found recyclable stable entry? */
    if (old_stable < ARP_TABLE_SIZE) {
 80111f4:	f1b8 0f09 	cmp.w	r8, #9
 80111f8:	dc35      	bgt.n	8011266 <etharp_find_entry+0x14e>
      /* recycle oldest stable*/
      i = old_stable;
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %d\n", (int)i));
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
 80111fa:	eb08 0348 	add.w	r3, r8, r8, lsl #1
 80111fe:	4a2c      	ldr	r2, [pc, #176]	@ (80112b0 <etharp_find_entry+0x198>)
 8011200:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8011204:	2b00      	cmp	r3, #0
 8011206:	d036      	beq.n	8011276 <etharp_find_entry+0x15e>
 8011208:	4b2a      	ldr	r3, [pc, #168]	@ (80112b4 <etharp_find_entry+0x19c>)
 801120a:	f240 126d 	movw	r2, #365	@ 0x16d
 801120e:	492a      	ldr	r1, [pc, #168]	@ (80112b8 <etharp_find_entry+0x1a0>)
 8011210:	482a      	ldr	r0, [pc, #168]	@ (80112bc <etharp_find_entry+0x1a4>)
 8011212:	f002 feb5 	bl	8013f80 <iprintf>
 8011216:	4645      	mov	r5, r8
      return (s16_t)ERR_MEM;
    }

    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
 8011218:	4628      	mov	r0, r5
 801121a:	f7ff ff59 	bl	80110d0 <etharp_free_entry>
  }

  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 801121e:	2d09      	cmp	r5, #9
 8011220:	dc2d      	bgt.n	801127e <etharp_find_entry+0x166>
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 8011222:	462c      	mov	r4, r5
 8011224:	eb05 0245 	add.w	r2, r5, r5, lsl #1
 8011228:	4b21      	ldr	r3, [pc, #132]	@ (80112b0 <etharp_find_entry+0x198>)
 801122a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801122e:	7d1b      	ldrb	r3, [r3, #20]
 8011230:	bb6b      	cbnz	r3, 801128e <etharp_find_entry+0x176>
              arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
 8011232:	b136      	cbz	r6, 8011242 <etharp_find_entry+0x12a>
    /* set IP address */
    ip4_addr_copy(arp_table[i].ipaddr, *ipaddr);
 8011234:	6831      	ldr	r1, [r6, #0]
 8011236:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 801123a:	4b1d      	ldr	r3, [pc, #116]	@ (80112b0 <etharp_find_entry+0x198>)
 801123c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8011240:	6059      	str	r1, [r3, #4]
  }
  arp_table[i].ctime = 0;
 8011242:	4b1b      	ldr	r3, [pc, #108]	@ (80112b0 <etharp_find_entry+0x198>)
 8011244:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 8011248:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 801124c:	2100      	movs	r1, #0
 801124e:	8251      	strh	r1, [r2, #18]
#if ETHARP_TABLE_MATCH_NETIF
  arp_table[i].netif = netif;
 8011250:	6097      	str	r7, [r2, #8]
#endif /* ETHARP_TABLE_MATCH_NETIF */
  return (s16_t)i;
}
 8011252:	4628      	mov	r0, r5
 8011254:	b005      	add	sp, #20
 8011256:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
 801125a:	f011 0f01 	tst.w	r1, #1
 801125e:	d1c7      	bne.n	80111f0 <etharp_find_entry+0xd8>
    return (s16_t)ERR_MEM;
 8011260:	f04f 35ff 	mov.w	r5, #4294967295
 8011264:	e7f5      	b.n	8011252 <etharp_find_entry+0x13a>
    } else if (old_pending < ARP_TABLE_SIZE) {
 8011266:	9b02      	ldr	r3, [sp, #8]
 8011268:	2b09      	cmp	r3, #9
 801126a:	dd06      	ble.n	801127a <etharp_find_entry+0x162>
    } else if (old_queue < ARP_TABLE_SIZE) {
 801126c:	f1ba 0f09 	cmp.w	sl, #9
 8011270:	dc1a      	bgt.n	80112a8 <etharp_find_entry+0x190>
      i = old_queue;
 8011272:	4655      	mov	r5, sl
 8011274:	e7d0      	b.n	8011218 <etharp_find_entry+0x100>
 8011276:	4645      	mov	r5, r8
 8011278:	e7ce      	b.n	8011218 <etharp_find_entry+0x100>
      i = old_pending;
 801127a:	9d02      	ldr	r5, [sp, #8]
 801127c:	e7cc      	b.n	8011218 <etharp_find_entry+0x100>
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 801127e:	4b0d      	ldr	r3, [pc, #52]	@ (80112b4 <etharp_find_entry+0x19c>)
 8011280:	f240 1283 	movw	r2, #387	@ 0x183
 8011284:	490e      	ldr	r1, [pc, #56]	@ (80112c0 <etharp_find_entry+0x1a8>)
 8011286:	480d      	ldr	r0, [pc, #52]	@ (80112bc <etharp_find_entry+0x1a4>)
 8011288:	f002 fe7a 	bl	8013f80 <iprintf>
 801128c:	e7c9      	b.n	8011222 <etharp_find_entry+0x10a>
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 801128e:	4b09      	ldr	r3, [pc, #36]	@ (80112b4 <etharp_find_entry+0x19c>)
 8011290:	f44f 72c2 	mov.w	r2, #388	@ 0x184
 8011294:	490b      	ldr	r1, [pc, #44]	@ (80112c4 <etharp_find_entry+0x1ac>)
 8011296:	4809      	ldr	r0, [pc, #36]	@ (80112bc <etharp_find_entry+0x1a4>)
 8011298:	f002 fe72 	bl	8013f80 <iprintf>
 801129c:	e7c9      	b.n	8011232 <etharp_find_entry+0x11a>
        return i;
 801129e:	461d      	mov	r5, r3
 80112a0:	e7d7      	b.n	8011252 <etharp_find_entry+0x13a>
    return (s16_t)ERR_MEM;
 80112a2:	f04f 35ff 	mov.w	r5, #4294967295
 80112a6:	e7d4      	b.n	8011252 <etharp_find_entry+0x13a>
      return (s16_t)ERR_MEM;
 80112a8:	f04f 35ff 	mov.w	r5, #4294967295
 80112ac:	e7d1      	b.n	8011252 <etharp_find_entry+0x13a>
 80112ae:	bf00      	nop
 80112b0:	2401433c 	.word	0x2401433c
 80112b4:	08018420 	.word	0x08018420
 80112b8:	08018458 	.word	0x08018458
 80112bc:	08015744 	.word	0x08015744
 80112c0:	08018470 	.word	0x08018470
 80112c4:	08018484 	.word	0x08018484

080112c8 <etharp_update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
etharp_update_arp_entry(struct netif *netif, const ip4_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
 80112c8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80112ca:	b083      	sub	sp, #12
 80112cc:	4605      	mov	r5, r0
 80112ce:	460c      	mov	r4, r1
 80112d0:	4616      	mov	r6, r2
 80112d2:	461f      	mov	r7, r3
  s16_t i;
  LWIP_ASSERT("netif->hwaddr_len == ETH_HWADDR_LEN", netif->hwaddr_len == ETH_HWADDR_LEN);
 80112d4:	f890 202c 	ldrb.w	r2, [r0, #44]	@ 0x2c
 80112d8:	2a06      	cmp	r2, #6
 80112da:	d13d      	bne.n	8011358 <etharp_update_arp_entry+0x90>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
              ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
              (u16_t)ethaddr->addr[0], (u16_t)ethaddr->addr[1], (u16_t)ethaddr->addr[2],
              (u16_t)ethaddr->addr[3], (u16_t)ethaddr->addr[4], (u16_t)ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip4_addr_isany(ipaddr) ||
 80112dc:	2c00      	cmp	r4, #0
 80112de:	d043      	beq.n	8011368 <etharp_update_arp_entry+0xa0>
 80112e0:	6820      	ldr	r0, [r4, #0]
 80112e2:	2800      	cmp	r0, #0
 80112e4:	d040      	beq.n	8011368 <etharp_update_arp_entry+0xa0>
      ip4_addr_isbroadcast(ipaddr, netif) ||
 80112e6:	4629      	mov	r1, r5
 80112e8:	f001 f9fc 	bl	80126e4 <ip4_addr_isbroadcast_u32>
  if (ip4_addr_isany(ipaddr) ||
 80112ec:	2800      	cmp	r0, #0
 80112ee:	d13b      	bne.n	8011368 <etharp_update_arp_entry+0xa0>
      ip4_addr_ismulticast(ipaddr)) {
 80112f0:	6822      	ldr	r2, [r4, #0]
 80112f2:	f002 02f0 	and.w	r2, r2, #240	@ 0xf0
      ip4_addr_isbroadcast(ipaddr, netif) ||
 80112f6:	2ae0      	cmp	r2, #224	@ 0xe0
 80112f8:	d036      	beq.n	8011368 <etharp_update_arp_entry+0xa0>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  }
  /* find or create ARP entry */
  i = etharp_find_entry(ipaddr, flags, netif);
 80112fa:	462a      	mov	r2, r5
 80112fc:	4639      	mov	r1, r7
 80112fe:	4620      	mov	r0, r4
 8011300:	f7ff ff0a 	bl	8011118 <etharp_find_entry>
  /* bail out if no entry could be found */
  if (i < 0) {
 8011304:	f1b0 0c00 	subs.w	ip, r0, #0
 8011308:	db31      	blt.n	801136e <etharp_update_arp_entry+0xa6>
    return ERR_VAL;
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
 801130a:	4b1c      	ldr	r3, [pc, #112]	@ (801137c <etharp_update_arp_entry+0xb4>)
 801130c:	eb0c 004c 	add.w	r0, ip, ip, lsl #1
 8011310:	eb03 02c0 	add.w	r2, r3, r0, lsl #3
 8011314:	2102      	movs	r1, #2
 8011316:	7511      	strb	r1, [r2, #20]
  }

  /* record network interface */
  arp_table[i].netif = netif;
 8011318:	6095      	str	r5, [r2, #8]
  /* insert in SNMP ARP index tree */
  mib2_add_arp_entry(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", i));
  /* update address */
  SMEMCPY(&arp_table[i].ethaddr, ethaddr, ETH_HWADDR_LEN);
 801131a:	00c1      	lsls	r1, r0, #3
 801131c:	3108      	adds	r1, #8
 801131e:	4419      	add	r1, r3
 8011320:	6834      	ldr	r4, [r6, #0]
 8011322:	604c      	str	r4, [r1, #4]
 8011324:	88b4      	ldrh	r4, [r6, #4]
 8011326:	810c      	strh	r4, [r1, #8]
  /* reset time stamp */
  arp_table[i].ctime = 0;
 8011328:	2100      	movs	r1, #0
 801132a:	8251      	strh	r1, [r2, #18]
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
#else /* ARP_QUEUEING */
  if (arp_table[i].q != NULL) {
 801132c:	f853 7030 	ldr.w	r7, [r3, r0, lsl #3]
 8011330:	b30f      	cbz	r7, 8011376 <etharp_update_arp_entry+0xae>
    struct pbuf *p = arp_table[i].q;
    arp_table[i].q = NULL;
 8011332:	00c3      	lsls	r3, r0, #3
 8011334:	460c      	mov	r4, r1
 8011336:	4a11      	ldr	r2, [pc, #68]	@ (801137c <etharp_update_arp_entry+0xb4>)
 8011338:	50d1      	str	r1, [r2, r3]
#endif /* ARP_QUEUEING */
    /* send the queued IP packet */
    ethernet_output(netif, p, (struct eth_addr *)(netif->hwaddr), ethaddr, ETHTYPE_IP);
 801133a:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 801133e:	9300      	str	r3, [sp, #0]
 8011340:	4633      	mov	r3, r6
 8011342:	f105 0226 	add.w	r2, r5, #38	@ 0x26
 8011346:	4639      	mov	r1, r7
 8011348:	4628      	mov	r0, r5
 801134a:	f001 ff61 	bl	8013210 <ethernet_output>
    /* free the queued IP packet */
    pbuf_free(p);
 801134e:	4638      	mov	r0, r7
 8011350:	f7fa fbee 	bl	800bb30 <pbuf_free>
  }
  return ERR_OK;
 8011354:	4620      	mov	r0, r4
 8011356:	e00c      	b.n	8011372 <etharp_update_arp_entry+0xaa>
  LWIP_ASSERT("netif->hwaddr_len == ETH_HWADDR_LEN", netif->hwaddr_len == ETH_HWADDR_LEN);
 8011358:	4b09      	ldr	r3, [pc, #36]	@ (8011380 <etharp_update_arp_entry+0xb8>)
 801135a:	f240 12a9 	movw	r2, #425	@ 0x1a9
 801135e:	4909      	ldr	r1, [pc, #36]	@ (8011384 <etharp_update_arp_entry+0xbc>)
 8011360:	4809      	ldr	r0, [pc, #36]	@ (8011388 <etharp_update_arp_entry+0xc0>)
 8011362:	f002 fe0d 	bl	8013f80 <iprintf>
 8011366:	e7b9      	b.n	80112dc <etharp_update_arp_entry+0x14>
    return ERR_ARG;
 8011368:	f06f 000f 	mvn.w	r0, #15
 801136c:	e001      	b.n	8011372 <etharp_update_arp_entry+0xaa>
    return (err_t)i;
 801136e:	fa4f f08c 	sxtb.w	r0, ip
}
 8011372:	b003      	add	sp, #12
 8011374:	bdf0      	pop	{r4, r5, r6, r7, pc}
  return ERR_OK;
 8011376:	2000      	movs	r0, #0
 8011378:	e7fb      	b.n	8011372 <etharp_update_arp_entry+0xaa>
 801137a:	bf00      	nop
 801137c:	2401433c 	.word	0x2401433c
 8011380:	08018420 	.word	0x08018420
 8011384:	080184b0 	.word	0x080184b0
 8011388:	08015744 	.word	0x08015744

0801138c <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const ip4_addr_t *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const ip4_addr_t *ipdst_addr,
           const u16_t opcode)
{
 801138c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8011390:	b082      	sub	sp, #8
 8011392:	460f      	mov	r7, r1
 8011394:	4690      	mov	r8, r2
 8011396:	461d      	mov	r5, r3
 8011398:	f8dd a02c 	ldr.w	sl, [sp, #44]	@ 0x2c
  struct pbuf *p;
  err_t result = ERR_OK;
  struct etharp_hdr *hdr;

  LWIP_ASSERT("netif != NULL", netif != NULL);
 801139c:	4681      	mov	r9, r0
 801139e:	2800      	cmp	r0, #0
 80113a0:	d046      	beq.n	8011430 <etharp_raw+0xa4>

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, SIZEOF_ETHARP_HDR, PBUF_RAM);
 80113a2:	f44f 7220 	mov.w	r2, #640	@ 0x280
 80113a6:	211c      	movs	r1, #28
 80113a8:	200e      	movs	r0, #14
 80113aa:	f7fa fc29 	bl	800bc00 <pbuf_alloc>
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
 80113ae:	4606      	mov	r6, r0
 80113b0:	2800      	cmp	r0, #0
 80113b2:	d045      	beq.n	8011440 <etharp_raw+0xb4>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
                ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
 80113b4:	8943      	ldrh	r3, [r0, #10]
 80113b6:	2b1b      	cmp	r3, #27
 80113b8:	d949      	bls.n	801144e <etharp_raw+0xc2>
              (p->len >= SIZEOF_ETHARP_HDR));

  hdr = (struct etharp_hdr *)p->payload;
 80113ba:	6874      	ldr	r4, [r6, #4]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = lwip_htons(opcode);
 80113bc:	f8bd 0034 	ldrh.w	r0, [sp, #52]	@ 0x34
 80113c0:	f7f9 fbce 	bl	800ab60 <lwip_htons>
 80113c4:	80e0      	strh	r0, [r4, #6]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETH_HWADDR_LEN for etharp!",
 80113c6:	f899 302c 	ldrb.w	r3, [r9, #44]	@ 0x2c
 80113ca:	2b06      	cmp	r3, #6
 80113cc:	d147      	bne.n	801145e <etharp_raw+0xd2>
              (netif->hwaddr_len == ETH_HWADDR_LEN));

  /* Write the ARP MAC-Addresses */
  SMEMCPY(&hdr->shwaddr, hwsrc_addr, ETH_HWADDR_LEN);
 80113ce:	682b      	ldr	r3, [r5, #0]
 80113d0:	60a3      	str	r3, [r4, #8]
 80113d2:	88ab      	ldrh	r3, [r5, #4]
 80113d4:	81a3      	strh	r3, [r4, #12]
  SMEMCPY(&hdr->dhwaddr, hwdst_addr, ETH_HWADDR_LEN);
 80113d6:	f8da 3000 	ldr.w	r3, [sl]
 80113da:	f8c4 3012 	str.w	r3, [r4, #18]
 80113de:	f8ba 3004 	ldrh.w	r3, [sl, #4]
 80113e2:	82e3      	strh	r3, [r4, #22]
  /* Copy struct ip4_addr_wordaligned to aligned ip4_addr, to support compilers without
   * structure packing. */
  IPADDR_WORDALIGNED_COPY_FROM_IP4_ADDR_T(&hdr->sipaddr, ipsrc_addr);
 80113e4:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 80113e6:	681b      	ldr	r3, [r3, #0]
 80113e8:	f8c4 300e 	str.w	r3, [r4, #14]
  IPADDR_WORDALIGNED_COPY_FROM_IP4_ADDR_T(&hdr->dipaddr, ipdst_addr);
 80113ec:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 80113ee:	681b      	ldr	r3, [r3, #0]
 80113f0:	61a3      	str	r3, [r4, #24]

  hdr->hwtype = PP_HTONS(LWIP_IANA_HWTYPE_ETHERNET);
 80113f2:	2500      	movs	r5, #0
 80113f4:	7025      	strb	r5, [r4, #0]
 80113f6:	2301      	movs	r3, #1
 80113f8:	7063      	strb	r3, [r4, #1]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 80113fa:	2308      	movs	r3, #8
 80113fc:	70a3      	strb	r3, [r4, #2]
 80113fe:	70e5      	strb	r5, [r4, #3]
  /* set hwlen and protolen */
  hdr->hwlen = ETH_HWADDR_LEN;
 8011400:	2306      	movs	r3, #6
 8011402:	7123      	strb	r3, [r4, #4]
  hdr->protolen = sizeof(ip4_addr_t);
 8011404:	2304      	movs	r3, #4
 8011406:	7163      	strb	r3, [r4, #5]
  if (ip4_addr_islinklocal(ipsrc_addr)) {
    ethernet_output(netif, p, ethsrc_addr, &ethbroadcast, ETHTYPE_ARP);
  } else
#endif /* LWIP_AUTOIP */
  {
    ethernet_output(netif, p, ethsrc_addr, ethdst_addr, ETHTYPE_ARP);
 8011408:	f640 0306 	movw	r3, #2054	@ 0x806
 801140c:	9300      	str	r3, [sp, #0]
 801140e:	4643      	mov	r3, r8
 8011410:	463a      	mov	r2, r7
 8011412:	4631      	mov	r1, r6
 8011414:	4648      	mov	r0, r9
 8011416:	f001 fefb 	bl	8013210 <ethernet_output>
  }

  ETHARP_STATS_INC(etharp.xmit);
 801141a:	4a15      	ldr	r2, [pc, #84]	@ (8011470 <etharp_raw+0xe4>)
 801141c:	8b13      	ldrh	r3, [r2, #24]
 801141e:	3301      	adds	r3, #1
 8011420:	8313      	strh	r3, [r2, #24]
  /* free ARP query packet */
  pbuf_free(p);
 8011422:	4630      	mov	r0, r6
 8011424:	f7fa fb84 	bl	800bb30 <pbuf_free>
  p = NULL;
  /* could not allocate pbuf for ARP request */

  return result;
 8011428:	4628      	mov	r0, r5
}
 801142a:	b002      	add	sp, #8
 801142c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  LWIP_ASSERT("netif != NULL", netif != NULL);
 8011430:	4b10      	ldr	r3, [pc, #64]	@ (8011474 <etharp_raw+0xe8>)
 8011432:	f240 4257 	movw	r2, #1111	@ 0x457
 8011436:	4910      	ldr	r1, [pc, #64]	@ (8011478 <etharp_raw+0xec>)
 8011438:	4810      	ldr	r0, [pc, #64]	@ (801147c <etharp_raw+0xf0>)
 801143a:	f002 fda1 	bl	8013f80 <iprintf>
 801143e:	e7b0      	b.n	80113a2 <etharp_raw+0x16>
    ETHARP_STATS_INC(etharp.memerr);
 8011440:	4a0b      	ldr	r2, [pc, #44]	@ (8011470 <etharp_raw+0xe4>)
 8011442:	8c93      	ldrh	r3, [r2, #36]	@ 0x24
 8011444:	3301      	adds	r3, #1
 8011446:	8493      	strh	r3, [r2, #36]	@ 0x24
    return ERR_MEM;
 8011448:	f04f 30ff 	mov.w	r0, #4294967295
 801144c:	e7ed      	b.n	801142a <etharp_raw+0x9e>
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
 801144e:	4b09      	ldr	r3, [pc, #36]	@ (8011474 <etharp_raw+0xe8>)
 8011450:	f240 4262 	movw	r2, #1122	@ 0x462
 8011454:	490a      	ldr	r1, [pc, #40]	@ (8011480 <etharp_raw+0xf4>)
 8011456:	4809      	ldr	r0, [pc, #36]	@ (801147c <etharp_raw+0xf0>)
 8011458:	f002 fd92 	bl	8013f80 <iprintf>
 801145c:	e7ad      	b.n	80113ba <etharp_raw+0x2e>
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETH_HWADDR_LEN for etharp!",
 801145e:	4b05      	ldr	r3, [pc, #20]	@ (8011474 <etharp_raw+0xe8>)
 8011460:	f240 4269 	movw	r2, #1129	@ 0x469
 8011464:	4907      	ldr	r1, [pc, #28]	@ (8011484 <etharp_raw+0xf8>)
 8011466:	4805      	ldr	r0, [pc, #20]	@ (801147c <etharp_raw+0xf0>)
 8011468:	f002 fd8a 	bl	8013f80 <iprintf>
 801146c:	e7af      	b.n	80113ce <etharp_raw+0x42>
 801146e:	bf00      	nop
 8011470:	240141b4 	.word	0x240141b4
 8011474:	08018420 	.word	0x08018420
 8011478:	080184d4 	.word	0x080184d4
 801147c:	08015744 	.word	0x08015744
 8011480:	080184e4 	.word	0x080184e4
 8011484:	08018518 	.word	0x08018518

08011488 <etharp_request_dst>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
static err_t
etharp_request_dst(struct netif *netif, const ip4_addr_t *ipaddr, const struct eth_addr *hw_dst_addr)
{
 8011488:	b530      	push	{r4, r5, lr}
 801148a:	b085      	sub	sp, #20
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
 801148c:	f100 0326 	add.w	r3, r0, #38	@ 0x26
                    (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 8011490:	1d04      	adds	r4, r0, #4
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
 8011492:	2501      	movs	r5, #1
 8011494:	9503      	str	r5, [sp, #12]
 8011496:	9102      	str	r1, [sp, #8]
 8011498:	4903      	ldr	r1, [pc, #12]	@ (80114a8 <etharp_request_dst+0x20>)
 801149a:	9101      	str	r1, [sp, #4]
 801149c:	9400      	str	r4, [sp, #0]
 801149e:	4619      	mov	r1, r3
 80114a0:	f7ff ff74 	bl	801138c <etharp_raw>
                    ipaddr, ARP_REQUEST);
}
 80114a4:	b005      	add	sp, #20
 80114a6:	bd30      	pop	{r4, r5, pc}
 80114a8:	08018fc4 	.word	0x08018fc4

080114ac <etharp_cleanup_netif>:
{
 80114ac:	b538      	push	{r3, r4, r5, lr}
 80114ae:	4605      	mov	r5, r0
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 80114b0:	2400      	movs	r4, #0
 80114b2:	e000      	b.n	80114b6 <etharp_cleanup_netif+0xa>
 80114b4:	3401      	adds	r4, #1
 80114b6:	2c09      	cmp	r4, #9
 80114b8:	dc11      	bgt.n	80114de <etharp_cleanup_netif+0x32>
    u8_t state = arp_table[i].state;
 80114ba:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 80114be:	4b08      	ldr	r3, [pc, #32]	@ (80114e0 <etharp_cleanup_netif+0x34>)
 80114c0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80114c4:	7d1b      	ldrb	r3, [r3, #20]
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 80114c6:	2b00      	cmp	r3, #0
 80114c8:	d0f4      	beq.n	80114b4 <etharp_cleanup_netif+0x8>
 80114ca:	4b05      	ldr	r3, [pc, #20]	@ (80114e0 <etharp_cleanup_netif+0x34>)
 80114cc:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80114d0:	689b      	ldr	r3, [r3, #8]
 80114d2:	42ab      	cmp	r3, r5
 80114d4:	d1ee      	bne.n	80114b4 <etharp_cleanup_netif+0x8>
      etharp_free_entry(i);
 80114d6:	4620      	mov	r0, r4
 80114d8:	f7ff fdfa 	bl	80110d0 <etharp_free_entry>
 80114dc:	e7ea      	b.n	80114b4 <etharp_cleanup_netif+0x8>
}
 80114de:	bd38      	pop	{r3, r4, r5, pc}
 80114e0:	2401433c 	.word	0x2401433c

080114e4 <etharp_input>:
{
 80114e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80114e8:	b086      	sub	sp, #24
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 80114ea:	b1e1      	cbz	r1, 8011526 <etharp_input+0x42>
 80114ec:	4604      	mov	r4, r0
 80114ee:	460e      	mov	r6, r1
  hdr = (struct etharp_hdr *)p->payload;
 80114f0:	6845      	ldr	r5, [r0, #4]
  if ((hdr->hwtype != PP_HTONS(LWIP_IANA_HWTYPE_ETHERNET)) ||
 80114f2:	882b      	ldrh	r3, [r5, #0]
 80114f4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80114f8:	d108      	bne.n	801150c <etharp_input+0x28>
      (hdr->hwlen != ETH_HWADDR_LEN) ||
 80114fa:	792b      	ldrb	r3, [r5, #4]
  if ((hdr->hwtype != PP_HTONS(LWIP_IANA_HWTYPE_ETHERNET)) ||
 80114fc:	2b06      	cmp	r3, #6
 80114fe:	d105      	bne.n	801150c <etharp_input+0x28>
      (hdr->protolen != sizeof(ip4_addr_t)) ||
 8011500:	796b      	ldrb	r3, [r5, #5]
      (hdr->hwlen != ETH_HWADDR_LEN) ||
 8011502:	2b04      	cmp	r3, #4
 8011504:	d102      	bne.n	801150c <etharp_input+0x28>
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
 8011506:	886b      	ldrh	r3, [r5, #2]
      (hdr->protolen != sizeof(ip4_addr_t)) ||
 8011508:	2b08      	cmp	r3, #8
 801150a:	d014      	beq.n	8011536 <etharp_input+0x52>
    ETHARP_STATS_INC(etharp.proterr);
 801150c:	4b29      	ldr	r3, [pc, #164]	@ (80115b4 <etharp_input+0xd0>)
 801150e:	8d1a      	ldrh	r2, [r3, #40]	@ 0x28
 8011510:	3201      	adds	r2, #1
 8011512:	851a      	strh	r2, [r3, #40]	@ 0x28
    ETHARP_STATS_INC(etharp.drop);
 8011514:	8bda      	ldrh	r2, [r3, #30]
 8011516:	3201      	adds	r2, #1
 8011518:	83da      	strh	r2, [r3, #30]
    pbuf_free(p);
 801151a:	4620      	mov	r0, r4
 801151c:	f7fa fb08 	bl	800bb30 <pbuf_free>
}
 8011520:	b006      	add	sp, #24
 8011522:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 8011526:	4b24      	ldr	r3, [pc, #144]	@ (80115b8 <etharp_input+0xd4>)
 8011528:	f240 228a 	movw	r2, #650	@ 0x28a
 801152c:	4923      	ldr	r1, [pc, #140]	@ (80115bc <etharp_input+0xd8>)
 801152e:	4824      	ldr	r0, [pc, #144]	@ (80115c0 <etharp_input+0xdc>)
 8011530:	f002 fd26 	bl	8013f80 <iprintf>
 8011534:	e7f4      	b.n	8011520 <etharp_input+0x3c>
  ETHARP_STATS_INC(etharp.recv);
 8011536:	4a1f      	ldr	r2, [pc, #124]	@ (80115b4 <etharp_input+0xd0>)
 8011538:	8b53      	ldrh	r3, [r2, #26]
 801153a:	3301      	adds	r3, #1
 801153c:	8353      	strh	r3, [r2, #26]
  IPADDR_WORDALIGNED_COPY_TO_IP4_ADDR_T(&sipaddr, &hdr->sipaddr);
 801153e:	f8d5 300e 	ldr.w	r3, [r5, #14]
 8011542:	9305      	str	r3, [sp, #20]
  IPADDR_WORDALIGNED_COPY_TO_IP4_ADDR_T(&dipaddr, &hdr->dipaddr);
 8011544:	69aa      	ldr	r2, [r5, #24]
  if (ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 8011546:	684f      	ldr	r7, [r1, #4]
 8011548:	b9b7      	cbnz	r7, 8011578 <etharp_input+0x94>
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 801154a:	f105 0808 	add.w	r8, r5, #8
 801154e:	2302      	movs	r3, #2
 8011550:	4642      	mov	r2, r8
 8011552:	a905      	add	r1, sp, #20
 8011554:	4630      	mov	r0, r6
 8011556:	f7ff feb7 	bl	80112c8 <etharp_update_arp_entry>
  switch (hdr->opcode) {
 801155a:	88eb      	ldrh	r3, [r5, #6]
 801155c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8011560:	d015      	beq.n	801158e <etharp_input+0xaa>
 8011562:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8011566:	d003      	beq.n	8011570 <etharp_input+0x8c>
      ETHARP_STATS_INC(etharp.err);
 8011568:	4a12      	ldr	r2, [pc, #72]	@ (80115b4 <etharp_input+0xd0>)
 801156a:	8d93      	ldrh	r3, [r2, #44]	@ 0x2c
 801156c:	3301      	adds	r3, #1
 801156e:	8593      	strh	r3, [r2, #44]	@ 0x2c
  pbuf_free(p);
 8011570:	4620      	mov	r0, r4
 8011572:	f7fa fadd 	bl	800bb30 <pbuf_free>
 8011576:	e7d3      	b.n	8011520 <etharp_input+0x3c>
    for_us = (u8_t)ip4_addr_cmp(&dipaddr, netif_ip4_addr(netif));
 8011578:	4297      	cmp	r7, r2
 801157a:	bf14      	ite	ne
 801157c:	2700      	movne	r7, #0
 801157e:	2701      	moveq	r7, #1
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 8011580:	f105 0808 	add.w	r8, r5, #8
 8011584:	b10f      	cbz	r7, 801158a <etharp_input+0xa6>
 8011586:	2301      	movs	r3, #1
 8011588:	e7e2      	b.n	8011550 <etharp_input+0x6c>
 801158a:	2302      	movs	r3, #2
 801158c:	e7e0      	b.n	8011550 <etharp_input+0x6c>
      if (for_us) {
 801158e:	2f00      	cmp	r7, #0
 8011590:	d0ee      	beq.n	8011570 <etharp_input+0x8c>
                   (struct eth_addr *)netif->hwaddr, &hdr->shwaddr,
 8011592:	f106 0126 	add.w	r1, r6, #38	@ 0x26
                   (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif),
 8011596:	1d33      	adds	r3, r6, #4
        etharp_raw(netif,
 8011598:	2202      	movs	r2, #2
 801159a:	9203      	str	r2, [sp, #12]
 801159c:	aa05      	add	r2, sp, #20
 801159e:	9202      	str	r2, [sp, #8]
 80115a0:	f8cd 8004 	str.w	r8, [sp, #4]
 80115a4:	9300      	str	r3, [sp, #0]
 80115a6:	460b      	mov	r3, r1
 80115a8:	4642      	mov	r2, r8
 80115aa:	4630      	mov	r0, r6
 80115ac:	f7ff feee 	bl	801138c <etharp_raw>
 80115b0:	e7de      	b.n	8011570 <etharp_input+0x8c>
 80115b2:	bf00      	nop
 80115b4:	240141b4 	.word	0x240141b4
 80115b8:	08018420 	.word	0x08018420
 80115bc:	080184d4 	.word	0x080184d4
 80115c0:	08015744 	.word	0x08015744

080115c4 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, const ip4_addr_t *ipaddr)
{
 80115c4:	b508      	push	{r3, lr}
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_request_dst(netif, ipaddr, &ethbroadcast);
 80115c6:	4a02      	ldr	r2, [pc, #8]	@ (80115d0 <etharp_request+0xc>)
 80115c8:	f7ff ff5e 	bl	8011488 <etharp_request_dst>
}
 80115cc:	bd08      	pop	{r3, pc}
 80115ce:	bf00      	nop
 80115d0:	08018fcc 	.word	0x08018fcc

080115d4 <etharp_tmr>:
{
 80115d4:	b510      	push	{r4, lr}
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 80115d6:	2400      	movs	r4, #0
 80115d8:	e005      	b.n	80115e6 <etharp_tmr+0x12>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 80115da:	2b04      	cmp	r3, #4
 80115dc:	d91b      	bls.n	8011616 <etharp_tmr+0x42>
        etharp_free_entry(i);
 80115de:	4620      	mov	r0, r4
 80115e0:	f7ff fd76 	bl	80110d0 <etharp_free_entry>
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 80115e4:	3401      	adds	r4, #1
 80115e6:	2c09      	cmp	r4, #9
 80115e8:	dc35      	bgt.n	8011656 <etharp_tmr+0x82>
    u8_t state = arp_table[i].state;
 80115ea:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 80115ee:	00da      	lsls	r2, r3, #3
 80115f0:	4b19      	ldr	r3, [pc, #100]	@ (8011658 <etharp_tmr+0x84>)
 80115f2:	4413      	add	r3, r2
 80115f4:	7d1a      	ldrb	r2, [r3, #20]
    if (state != ETHARP_STATE_EMPTY
 80115f6:	2a00      	cmp	r2, #0
 80115f8:	d0f4      	beq.n	80115e4 <etharp_tmr+0x10>
      arp_table[i].ctime++;
 80115fa:	eb04 0144 	add.w	r1, r4, r4, lsl #1
 80115fe:	00cb      	lsls	r3, r1, #3
 8011600:	4915      	ldr	r1, [pc, #84]	@ (8011658 <etharp_tmr+0x84>)
 8011602:	4419      	add	r1, r3
 8011604:	8a4b      	ldrh	r3, [r1, #18]
 8011606:	3301      	adds	r3, #1
 8011608:	b29b      	uxth	r3, r3
 801160a:	824b      	strh	r3, [r1, #18]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 801160c:	f5b3 7f96 	cmp.w	r3, #300	@ 0x12c
 8011610:	d2e5      	bcs.n	80115de <etharp_tmr+0xa>
 8011612:	2a01      	cmp	r2, #1
 8011614:	d0e1      	beq.n	80115da <etharp_tmr+0x6>
      } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_1) {
 8011616:	2a03      	cmp	r2, #3
 8011618:	d00d      	beq.n	8011636 <etharp_tmr+0x62>
      } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_2) {
 801161a:	2a04      	cmp	r2, #4
 801161c:	d013      	beq.n	8011646 <etharp_tmr+0x72>
      } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 801161e:	2a01      	cmp	r2, #1
 8011620:	d1e0      	bne.n	80115e4 <etharp_tmr+0x10>
        etharp_request(arp_table[i].netif, &arp_table[i].ipaddr);
 8011622:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 8011626:	00d3      	lsls	r3, r2, #3
 8011628:	4a0b      	ldr	r2, [pc, #44]	@ (8011658 <etharp_tmr+0x84>)
 801162a:	4413      	add	r3, r2
 801162c:	1d19      	adds	r1, r3, #4
 801162e:	6898      	ldr	r0, [r3, #8]
 8011630:	f7ff ffc8 	bl	80115c4 <etharp_request>
 8011634:	e7d6      	b.n	80115e4 <etharp_tmr+0x10>
        arp_table[i].state = ETHARP_STATE_STABLE_REREQUESTING_2;
 8011636:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 801163a:	00da      	lsls	r2, r3, #3
 801163c:	4b06      	ldr	r3, [pc, #24]	@ (8011658 <etharp_tmr+0x84>)
 801163e:	4413      	add	r3, r2
 8011640:	2204      	movs	r2, #4
 8011642:	751a      	strb	r2, [r3, #20]
 8011644:	e7ce      	b.n	80115e4 <etharp_tmr+0x10>
        arp_table[i].state = ETHARP_STATE_STABLE;
 8011646:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 801164a:	00da      	lsls	r2, r3, #3
 801164c:	4b02      	ldr	r3, [pc, #8]	@ (8011658 <etharp_tmr+0x84>)
 801164e:	4413      	add	r3, r2
 8011650:	2202      	movs	r2, #2
 8011652:	751a      	strb	r2, [r3, #20]
 8011654:	e7c6      	b.n	80115e4 <etharp_tmr+0x10>
}
 8011656:	bd10      	pop	{r4, pc}
 8011658:	2401433c 	.word	0x2401433c

0801165c <etharp_output_to_arp_index>:
{
 801165c:	b570      	push	{r4, r5, r6, lr}
 801165e:	b082      	sub	sp, #8
 8011660:	4605      	mov	r5, r0
 8011662:	460e      	mov	r6, r1
 8011664:	4614      	mov	r4, r2
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 8011666:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 801166a:	4b2e      	ldr	r3, [pc, #184]	@ (8011724 <etharp_output_to_arp_index+0xc8>)
 801166c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8011670:	7d1b      	ldrb	r3, [r3, #20]
 8011672:	2b01      	cmp	r3, #1
 8011674:	d919      	bls.n	80116aa <etharp_output_to_arp_index+0x4e>
  if (arp_table[arp_idx].state == ETHARP_STATE_STABLE) {
 8011676:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 801167a:	4b2a      	ldr	r3, [pc, #168]	@ (8011724 <etharp_output_to_arp_index+0xc8>)
 801167c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8011680:	7d1b      	ldrb	r3, [r3, #20]
 8011682:	2b02      	cmp	r3, #2
 8011684:	d019      	beq.n	80116ba <etharp_output_to_arp_index+0x5e>
  return ethernet_output(netif, q, (struct eth_addr *)(netif->hwaddr), &arp_table[arp_idx].ethaddr, ETHTYPE_IP);
 8011686:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 801168a:	00db      	lsls	r3, r3, #3
 801168c:	3308      	adds	r3, #8
 801168e:	4a25      	ldr	r2, [pc, #148]	@ (8011724 <etharp_output_to_arp_index+0xc8>)
 8011690:	4413      	add	r3, r2
 8011692:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8011696:	9200      	str	r2, [sp, #0]
 8011698:	3304      	adds	r3, #4
 801169a:	f105 0226 	add.w	r2, r5, #38	@ 0x26
 801169e:	4631      	mov	r1, r6
 80116a0:	4628      	mov	r0, r5
 80116a2:	f001 fdb5 	bl	8013210 <ethernet_output>
}
 80116a6:	b002      	add	sp, #8
 80116a8:	bd70      	pop	{r4, r5, r6, pc}
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 80116aa:	4b1f      	ldr	r3, [pc, #124]	@ (8011728 <etharp_output_to_arp_index+0xcc>)
 80116ac:	f240 22ee 	movw	r2, #750	@ 0x2ee
 80116b0:	491e      	ldr	r1, [pc, #120]	@ (801172c <etharp_output_to_arp_index+0xd0>)
 80116b2:	481f      	ldr	r0, [pc, #124]	@ (8011730 <etharp_output_to_arp_index+0xd4>)
 80116b4:	f002 fc64 	bl	8013f80 <iprintf>
 80116b8:	e7dd      	b.n	8011676 <etharp_output_to_arp_index+0x1a>
    if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_BROADCAST) {
 80116ba:	4b1a      	ldr	r3, [pc, #104]	@ (8011724 <etharp_output_to_arp_index+0xc8>)
 80116bc:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80116c0:	8a5b      	ldrh	r3, [r3, #18]
 80116c2:	f5b3 7f8e 	cmp.w	r3, #284	@ 0x11c
 80116c6:	d81b      	bhi.n	8011700 <etharp_output_to_arp_index+0xa4>
    } else if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_UNICAST) {
 80116c8:	f5b3 7f87 	cmp.w	r3, #270	@ 0x10e
 80116cc:	d3db      	bcc.n	8011686 <etharp_output_to_arp_index+0x2a>
      if (etharp_request_dst(netif, &arp_table[arp_idx].ipaddr, &arp_table[arp_idx].ethaddr) == ERR_OK) {
 80116ce:	eb04 0144 	add.w	r1, r4, r4, lsl #1
 80116d2:	4b14      	ldr	r3, [pc, #80]	@ (8011724 <etharp_output_to_arp_index+0xc8>)
 80116d4:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 80116d8:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 80116dc:	00d2      	lsls	r2, r2, #3
 80116de:	3208      	adds	r2, #8
 80116e0:	441a      	add	r2, r3
 80116e2:	3204      	adds	r2, #4
 80116e4:	3104      	adds	r1, #4
 80116e6:	4628      	mov	r0, r5
 80116e8:	f7ff fece 	bl	8011488 <etharp_request_dst>
 80116ec:	2800      	cmp	r0, #0
 80116ee:	d1ca      	bne.n	8011686 <etharp_output_to_arp_index+0x2a>
        arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 80116f0:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 80116f4:	4b0b      	ldr	r3, [pc, #44]	@ (8011724 <etharp_output_to_arp_index+0xc8>)
 80116f6:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80116fa:	2203      	movs	r2, #3
 80116fc:	751a      	strb	r2, [r3, #20]
 80116fe:	e7c2      	b.n	8011686 <etharp_output_to_arp_index+0x2a>
      if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
 8011700:	4908      	ldr	r1, [pc, #32]	@ (8011724 <etharp_output_to_arp_index+0xc8>)
 8011702:	eb01 01c2 	add.w	r1, r1, r2, lsl #3
 8011706:	3104      	adds	r1, #4
 8011708:	4628      	mov	r0, r5
 801170a:	f7ff ff5b 	bl	80115c4 <etharp_request>
 801170e:	2800      	cmp	r0, #0
 8011710:	d1b9      	bne.n	8011686 <etharp_output_to_arp_index+0x2a>
        arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 8011712:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 8011716:	4b03      	ldr	r3, [pc, #12]	@ (8011724 <etharp_output_to_arp_index+0xc8>)
 8011718:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801171c:	2203      	movs	r2, #3
 801171e:	751a      	strb	r2, [r3, #20]
 8011720:	e7b1      	b.n	8011686 <etharp_output_to_arp_index+0x2a>
 8011722:	bf00      	nop
 8011724:	2401433c 	.word	0x2401433c
 8011728:	08018420 	.word	0x08018420
 801172c:	0801857c 	.word	0x0801857c
 8011730:	08015744 	.word	0x08015744

08011734 <etharp_query>:
{
 8011734:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8011738:	b083      	sub	sp, #12
 801173a:	4605      	mov	r5, r0
 801173c:	4688      	mov	r8, r1
 801173e:	4616      	mov	r6, r2
  struct eth_addr *srcaddr = (struct eth_addr *)netif->hwaddr;
 8011740:	f100 0726 	add.w	r7, r0, #38	@ 0x26
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
 8011744:	4601      	mov	r1, r0
 8011746:	f8d8 0000 	ldr.w	r0, [r8]
 801174a:	f000 ffcb 	bl	80126e4 <ip4_addr_isbroadcast_u32>
 801174e:	2800      	cmp	r0, #0
 8011750:	f040 80ad 	bne.w	80118ae <etharp_query+0x17a>
      ip4_addr_ismulticast(ipaddr) ||
 8011754:	f8d8 3000 	ldr.w	r3, [r8]
 8011758:	f003 02f0 	and.w	r2, r3, #240	@ 0xf0
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
 801175c:	2ae0      	cmp	r2, #224	@ 0xe0
 801175e:	f000 80a9 	beq.w	80118b4 <etharp_query+0x180>
      ip4_addr_isany(ipaddr)) {
 8011762:	2b00      	cmp	r3, #0
 8011764:	f000 80a9 	beq.w	80118ba <etharp_query+0x186>
  i_err = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD, netif);
 8011768:	462a      	mov	r2, r5
 801176a:	2101      	movs	r1, #1
 801176c:	4640      	mov	r0, r8
 801176e:	f7ff fcd3 	bl	8011118 <etharp_find_entry>
  if (i_err < 0) {
 8011772:	1e04      	subs	r4, r0, #0
 8011774:	db13      	blt.n	801179e <etharp_query+0x6a>
  LWIP_ASSERT("type overflow", (size_t)i_err < NETIF_ADDR_IDX_MAX);
 8011776:	b2a3      	uxth	r3, r4
 8011778:	2b7e      	cmp	r3, #126	@ 0x7e
 801177a:	d817      	bhi.n	80117ac <etharp_query+0x78>
  i = (netif_addr_idx_t)i_err;
 801177c:	b2e4      	uxtb	r4, r4
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
 801177e:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 8011782:	4b4f      	ldr	r3, [pc, #316]	@ (80118c0 <etharp_query+0x18c>)
 8011784:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8011788:	7d1b      	ldrb	r3, [r3, #20]
 801178a:	b9bb      	cbnz	r3, 80117bc <etharp_query+0x88>
    arp_table[i].state = ETHARP_STATE_PENDING;
 801178c:	4b4c      	ldr	r3, [pc, #304]	@ (80118c0 <etharp_query+0x18c>)
 801178e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8011792:	f04f 0901 	mov.w	r9, #1
 8011796:	f883 9014 	strb.w	r9, [r3, #20]
    arp_table[i].netif = netif;
 801179a:	609d      	str	r5, [r3, #8]
 801179c:	e010      	b.n	80117c0 <etharp_query+0x8c>
    if (q) {
 801179e:	b11e      	cbz	r6, 80117a8 <etharp_query+0x74>
      ETHARP_STATS_INC(etharp.memerr);
 80117a0:	4a48      	ldr	r2, [pc, #288]	@ (80118c4 <etharp_query+0x190>)
 80117a2:	8c93      	ldrh	r3, [r2, #36]	@ 0x24
 80117a4:	3301      	adds	r3, #1
 80117a6:	8493      	strh	r3, [r2, #36]	@ 0x24
    return (err_t)i_err;
 80117a8:	b260      	sxtb	r0, r4
 80117aa:	e042      	b.n	8011832 <etharp_query+0xfe>
  LWIP_ASSERT("type overflow", (size_t)i_err < NETIF_ADDR_IDX_MAX);
 80117ac:	4b46      	ldr	r3, [pc, #280]	@ (80118c8 <etharp_query+0x194>)
 80117ae:	f240 32c1 	movw	r2, #961	@ 0x3c1
 80117b2:	4946      	ldr	r1, [pc, #280]	@ (80118cc <etharp_query+0x198>)
 80117b4:	4846      	ldr	r0, [pc, #280]	@ (80118d0 <etharp_query+0x19c>)
 80117b6:	f002 fbe3 	bl	8013f80 <iprintf>
 80117ba:	e7df      	b.n	801177c <etharp_query+0x48>
  int is_new_entry = 0;
 80117bc:	f04f 0900 	mov.w	r9, #0
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
 80117c0:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 80117c4:	4b3e      	ldr	r3, [pc, #248]	@ (80118c0 <etharp_query+0x18c>)
 80117c6:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80117ca:	7d1b      	ldrb	r3, [r3, #20]
 80117cc:	b19b      	cbz	r3, 80117f6 <etharp_query+0xc2>
  if (is_new_entry || (q == NULL)) {
 80117ce:	2e00      	cmp	r6, #0
 80117d0:	bf14      	ite	ne
 80117d2:	464b      	movne	r3, r9
 80117d4:	f049 0301 	orreq.w	r3, r9, #1
 80117d8:	b9ab      	cbnz	r3, 8011806 <etharp_query+0xd2>
  err_t result = ERR_MEM;
 80117da:	f04f 30ff 	mov.w	r0, #4294967295
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
 80117de:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 80117e2:	4b37      	ldr	r3, [pc, #220]	@ (80118c0 <etharp_query+0x18c>)
 80117e4:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80117e8:	7d1b      	ldrb	r3, [r3, #20]
 80117ea:	2b01      	cmp	r3, #1
 80117ec:	d812      	bhi.n	8011814 <etharp_query+0xe0>
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 80117ee:	2b01      	cmp	r3, #1
 80117f0:	d11f      	bne.n	8011832 <etharp_query+0xfe>
    p = q;
 80117f2:	4635      	mov	r5, r6
 80117f4:	e025      	b.n	8011842 <etharp_query+0x10e>
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
 80117f6:	4b34      	ldr	r3, [pc, #208]	@ (80118c8 <etharp_query+0x194>)
 80117f8:	f240 32cd 	movw	r2, #973	@ 0x3cd
 80117fc:	4935      	ldr	r1, [pc, #212]	@ (80118d4 <etharp_query+0x1a0>)
 80117fe:	4834      	ldr	r0, [pc, #208]	@ (80118d0 <etharp_query+0x19c>)
 8011800:	f002 fbbe 	bl	8013f80 <iprintf>
 8011804:	e7e3      	b.n	80117ce <etharp_query+0x9a>
    result = etharp_request(netif, ipaddr);
 8011806:	4641      	mov	r1, r8
 8011808:	4628      	mov	r0, r5
 801180a:	f7ff fedb 	bl	80115c4 <etharp_request>
    if (q == NULL) {
 801180e:	2e00      	cmp	r6, #0
 8011810:	d1e5      	bne.n	80117de <etharp_query+0xaa>
 8011812:	e00e      	b.n	8011832 <etharp_query+0xfe>
    ETHARP_SET_ADDRHINT(netif, i);
 8011814:	4b30      	ldr	r3, [pc, #192]	@ (80118d8 <etharp_query+0x1a4>)
 8011816:	701c      	strb	r4, [r3, #0]
    result = ethernet_output(netif, q, srcaddr, &(arp_table[i].ethaddr), ETHTYPE_IP);
 8011818:	00d3      	lsls	r3, r2, #3
 801181a:	3308      	adds	r3, #8
 801181c:	4a28      	ldr	r2, [pc, #160]	@ (80118c0 <etharp_query+0x18c>)
 801181e:	4413      	add	r3, r2
 8011820:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8011824:	9200      	str	r2, [sp, #0]
 8011826:	3304      	adds	r3, #4
 8011828:	463a      	mov	r2, r7
 801182a:	4631      	mov	r1, r6
 801182c:	4628      	mov	r0, r5
 801182e:	f001 fcef 	bl	8013210 <ethernet_output>
}
 8011832:	b003      	add	sp, #12
 8011834:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      if (PBUF_NEEDS_COPY(p)) {
 8011838:	7b2b      	ldrb	r3, [r5, #12]
 801183a:	f013 0f40 	tst.w	r3, #64	@ 0x40
 801183e:	d129      	bne.n	8011894 <etharp_query+0x160>
      p = p->next;
 8011840:	682d      	ldr	r5, [r5, #0]
    while (p) {
 8011842:	b175      	cbz	r5, 8011862 <etharp_query+0x12e>
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
 8011844:	896a      	ldrh	r2, [r5, #10]
 8011846:	892b      	ldrh	r3, [r5, #8]
 8011848:	429a      	cmp	r2, r3
 801184a:	d1f5      	bne.n	8011838 <etharp_query+0x104>
 801184c:	682b      	ldr	r3, [r5, #0]
 801184e:	2b00      	cmp	r3, #0
 8011850:	d0f2      	beq.n	8011838 <etharp_query+0x104>
 8011852:	4b1d      	ldr	r3, [pc, #116]	@ (80118c8 <etharp_query+0x194>)
 8011854:	f240 32f1 	movw	r2, #1009	@ 0x3f1
 8011858:	4920      	ldr	r1, [pc, #128]	@ (80118dc <etharp_query+0x1a8>)
 801185a:	481d      	ldr	r0, [pc, #116]	@ (80118d0 <etharp_query+0x19c>)
 801185c:	f002 fb90 	bl	8013f80 <iprintf>
 8011860:	e7ea      	b.n	8011838 <etharp_query+0x104>
    int copy_needed = 0;
 8011862:	2300      	movs	r3, #0
    if (copy_needed) {
 8011864:	b1c3      	cbz	r3, 8011898 <etharp_query+0x164>
      p = pbuf_clone(PBUF_LINK, PBUF_RAM, q);
 8011866:	4632      	mov	r2, r6
 8011868:	f44f 7120 	mov.w	r1, #640	@ 0x280
 801186c:	200e      	movs	r0, #14
 801186e:	f7fa fc13 	bl	800c098 <pbuf_clone>
 8011872:	4606      	mov	r6, r0
    if (p != NULL) {
 8011874:	b1a6      	cbz	r6, 80118a0 <etharp_query+0x16c>
      if (arp_table[i].q != NULL) {
 8011876:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 801187a:	4a11      	ldr	r2, [pc, #68]	@ (80118c0 <etharp_query+0x18c>)
 801187c:	f852 0033 	ldr.w	r0, [r2, r3, lsl #3]
 8011880:	b108      	cbz	r0, 8011886 <etharp_query+0x152>
        pbuf_free(arp_table[i].q);
 8011882:	f7fa f955 	bl	800bb30 <pbuf_free>
      arp_table[i].q = p;
 8011886:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 801188a:	4b0d      	ldr	r3, [pc, #52]	@ (80118c0 <etharp_query+0x18c>)
 801188c:	f843 6034 	str.w	r6, [r3, r4, lsl #3]
      result = ERR_OK;
 8011890:	2000      	movs	r0, #0
 8011892:	e7ce      	b.n	8011832 <etharp_query+0xfe>
        copy_needed = 1;
 8011894:	2301      	movs	r3, #1
 8011896:	e7e5      	b.n	8011864 <etharp_query+0x130>
      pbuf_ref(p);
 8011898:	4630      	mov	r0, r6
 801189a:	f7fa fabb 	bl	800be14 <pbuf_ref>
 801189e:	e7e9      	b.n	8011874 <etharp_query+0x140>
      ETHARP_STATS_INC(etharp.memerr);
 80118a0:	4a08      	ldr	r2, [pc, #32]	@ (80118c4 <etharp_query+0x190>)
 80118a2:	8c93      	ldrh	r3, [r2, #36]	@ 0x24
 80118a4:	3301      	adds	r3, #1
 80118a6:	8493      	strh	r3, [r2, #36]	@ 0x24
      result = ERR_MEM;
 80118a8:	f04f 30ff 	mov.w	r0, #4294967295
 80118ac:	e7c1      	b.n	8011832 <etharp_query+0xfe>
    return ERR_ARG;
 80118ae:	f06f 000f 	mvn.w	r0, #15
 80118b2:	e7be      	b.n	8011832 <etharp_query+0xfe>
 80118b4:	f06f 000f 	mvn.w	r0, #15
 80118b8:	e7bb      	b.n	8011832 <etharp_query+0xfe>
 80118ba:	f06f 000f 	mvn.w	r0, #15
 80118be:	e7b8      	b.n	8011832 <etharp_query+0xfe>
 80118c0:	2401433c 	.word	0x2401433c
 80118c4:	240141b4 	.word	0x240141b4
 80118c8:	08018420 	.word	0x08018420
 80118cc:	080185ac 	.word	0x080185ac
 80118d0:	08015744 	.word	0x08015744
 80118d4:	080185bc 	.word	0x080185bc
 80118d8:	24014338 	.word	0x24014338
 80118dc:	080185e4 	.word	0x080185e4

080118e0 <etharp_output>:
{
 80118e0:	b570      	push	{r4, r5, r6, lr}
 80118e2:	b084      	sub	sp, #16
 80118e4:	460e      	mov	r6, r1
 80118e6:	4614      	mov	r4, r2
  LWIP_ASSERT("netif != NULL", netif != NULL);
 80118e8:	4605      	mov	r5, r0
 80118ea:	2800      	cmp	r0, #0
 80118ec:	d041      	beq.n	8011972 <etharp_output+0x92>
  LWIP_ASSERT("q != NULL", q != NULL);
 80118ee:	2e00      	cmp	r6, #0
 80118f0:	d047      	beq.n	8011982 <etharp_output+0xa2>
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 80118f2:	2c00      	cmp	r4, #0
 80118f4:	d04d      	beq.n	8011992 <etharp_output+0xb2>
  if (ip4_addr_isbroadcast(ipaddr, netif)) {
 80118f6:	4629      	mov	r1, r5
 80118f8:	6820      	ldr	r0, [r4, #0]
 80118fa:	f000 fef3 	bl	80126e4 <ip4_addr_isbroadcast_u32>
 80118fe:	4603      	mov	r3, r0
 8011900:	2800      	cmp	r0, #0
 8011902:	f040 8085 	bne.w	8011a10 <etharp_output+0x130>
  } else if (ip4_addr_ismulticast(ipaddr)) {
 8011906:	6822      	ldr	r2, [r4, #0]
 8011908:	f002 01f0 	and.w	r1, r2, #240	@ 0xf0
 801190c:	29e0      	cmp	r1, #224	@ 0xe0
 801190e:	d048      	beq.n	80119a2 <etharp_output+0xc2>
    if (!ip4_addr_netcmp(ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif)) &&
 8011910:	6869      	ldr	r1, [r5, #4]
 8011912:	68a8      	ldr	r0, [r5, #8]
 8011914:	4051      	eors	r1, r2
 8011916:	4201      	tst	r1, r0
 8011918:	d009      	beq.n	801192e <etharp_output+0x4e>
        !ip4_addr_islinklocal(ipaddr)) {
 801191a:	b292      	uxth	r2, r2
    if (!ip4_addr_netcmp(ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif)) &&
 801191c:	f64f 61a9 	movw	r1, #65193	@ 0xfea9
 8011920:	428a      	cmp	r2, r1
 8011922:	d004      	beq.n	801192e <etharp_output+0x4e>
          if (!ip4_addr_isany_val(*netif_ip4_gw(netif))) {
 8011924:	68ea      	ldr	r2, [r5, #12]
 8011926:	2a00      	cmp	r2, #0
 8011928:	d07e      	beq.n	8011a28 <etharp_output+0x148>
            dst_addr = netif_ip4_gw(netif);
 801192a:	f105 040c 	add.w	r4, r5, #12
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 801192e:	4a40      	ldr	r2, [pc, #256]	@ (8011a30 <etharp_output+0x150>)
 8011930:	7812      	ldrb	r2, [r2, #0]
 8011932:	eb02 0042 	add.w	r0, r2, r2, lsl #1
 8011936:	493f      	ldr	r1, [pc, #252]	@ (8011a34 <etharp_output+0x154>)
 8011938:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
 801193c:	7d09      	ldrb	r1, [r1, #20]
 801193e:	2901      	cmp	r1, #1
 8011940:	d947      	bls.n	80119d2 <etharp_output+0xf2>
            (arp_table[etharp_cached_entry].netif == netif) &&
 8011942:	493c      	ldr	r1, [pc, #240]	@ (8011a34 <etharp_output+0x154>)
 8011944:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
 8011948:	6889      	ldr	r1, [r1, #8]
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 801194a:	42a9      	cmp	r1, r5
 801194c:	d141      	bne.n	80119d2 <etharp_output+0xf2>
            (ip4_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
 801194e:	6820      	ldr	r0, [r4, #0]
 8011950:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
 8011954:	4937      	ldr	r1, [pc, #220]	@ (8011a34 <etharp_output+0x154>)
 8011956:	eb01 01cc 	add.w	r1, r1, ip, lsl #3
 801195a:	6849      	ldr	r1, [r1, #4]
            (arp_table[etharp_cached_entry].netif == netif) &&
 801195c:	4288      	cmp	r0, r1
 801195e:	d138      	bne.n	80119d2 <etharp_output+0xf2>
          ETHARP_STATS_INC(etharp.cachehit);
 8011960:	4935      	ldr	r1, [pc, #212]	@ (8011a38 <etharp_output+0x158>)
 8011962:	8dcb      	ldrh	r3, [r1, #46]	@ 0x2e
 8011964:	3301      	adds	r3, #1
 8011966:	85cb      	strh	r3, [r1, #46]	@ 0x2e
          return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
 8011968:	4631      	mov	r1, r6
 801196a:	4628      	mov	r0, r5
 801196c:	f7ff fe76 	bl	801165c <etharp_output_to_arp_index>
 8011970:	e058      	b.n	8011a24 <etharp_output+0x144>
  LWIP_ASSERT("netif != NULL", netif != NULL);
 8011972:	4b32      	ldr	r3, [pc, #200]	@ (8011a3c <etharp_output+0x15c>)
 8011974:	f240 321e 	movw	r2, #798	@ 0x31e
 8011978:	4931      	ldr	r1, [pc, #196]	@ (8011a40 <etharp_output+0x160>)
 801197a:	4832      	ldr	r0, [pc, #200]	@ (8011a44 <etharp_output+0x164>)
 801197c:	f002 fb00 	bl	8013f80 <iprintf>
 8011980:	e7b5      	b.n	80118ee <etharp_output+0xe>
  LWIP_ASSERT("q != NULL", q != NULL);
 8011982:	4b2e      	ldr	r3, [pc, #184]	@ (8011a3c <etharp_output+0x15c>)
 8011984:	f240 321f 	movw	r2, #799	@ 0x31f
 8011988:	492f      	ldr	r1, [pc, #188]	@ (8011a48 <etharp_output+0x168>)
 801198a:	482e      	ldr	r0, [pc, #184]	@ (8011a44 <etharp_output+0x164>)
 801198c:	f002 faf8 	bl	8013f80 <iprintf>
 8011990:	e7af      	b.n	80118f2 <etharp_output+0x12>
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 8011992:	4b2a      	ldr	r3, [pc, #168]	@ (8011a3c <etharp_output+0x15c>)
 8011994:	f44f 7248 	mov.w	r2, #800	@ 0x320
 8011998:	492c      	ldr	r1, [pc, #176]	@ (8011a4c <etharp_output+0x16c>)
 801199a:	482a      	ldr	r0, [pc, #168]	@ (8011a44 <etharp_output+0x164>)
 801199c:	f002 faf0 	bl	8013f80 <iprintf>
 80119a0:	e7a9      	b.n	80118f6 <etharp_output+0x16>
    mcastaddr.addr[0] = LL_IP4_MULTICAST_ADDR_0;
 80119a2:	2301      	movs	r3, #1
 80119a4:	f88d 3008 	strb.w	r3, [sp, #8]
    mcastaddr.addr[1] = LL_IP4_MULTICAST_ADDR_1;
 80119a8:	2300      	movs	r3, #0
 80119aa:	f88d 3009 	strb.w	r3, [sp, #9]
    mcastaddr.addr[2] = LL_IP4_MULTICAST_ADDR_2;
 80119ae:	235e      	movs	r3, #94	@ 0x5e
 80119b0:	f88d 300a 	strb.w	r3, [sp, #10]
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 80119b4:	7863      	ldrb	r3, [r4, #1]
 80119b6:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 80119ba:	f88d 300b 	strb.w	r3, [sp, #11]
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
 80119be:	78a3      	ldrb	r3, [r4, #2]
 80119c0:	f88d 300c 	strb.w	r3, [sp, #12]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
 80119c4:	78e3      	ldrb	r3, [r4, #3]
 80119c6:	f88d 300d 	strb.w	r3, [sp, #13]
    dest = &mcastaddr;
 80119ca:	ab02      	add	r3, sp, #8
 80119cc:	e021      	b.n	8011a12 <etharp_output+0x132>
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 80119ce:	3301      	adds	r3, #1
 80119d0:	b2db      	uxtb	r3, r3
 80119d2:	2b09      	cmp	r3, #9
 80119d4:	d816      	bhi.n	8011a04 <etharp_output+0x124>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 80119d6:	eb03 0c43 	add.w	ip, r3, r3, lsl #1
 80119da:	4816      	ldr	r0, [pc, #88]	@ (8011a34 <etharp_output+0x154>)
 80119dc:	eb00 00cc 	add.w	r0, r0, ip, lsl #3
 80119e0:	7d02      	ldrb	r2, [r0, #20]
 80119e2:	2a01      	cmp	r2, #1
 80119e4:	d9f3      	bls.n	80119ce <etharp_output+0xee>
          (arp_table[i].netif == netif) &&
 80119e6:	6882      	ldr	r2, [r0, #8]
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 80119e8:	42aa      	cmp	r2, r5
 80119ea:	d1f0      	bne.n	80119ce <etharp_output+0xee>
          (ip4_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
 80119ec:	6821      	ldr	r1, [r4, #0]
 80119ee:	6842      	ldr	r2, [r0, #4]
          (arp_table[i].netif == netif) &&
 80119f0:	4291      	cmp	r1, r2
 80119f2:	d1ec      	bne.n	80119ce <etharp_output+0xee>
        ETHARP_SET_ADDRHINT(netif, i);
 80119f4:	4a0e      	ldr	r2, [pc, #56]	@ (8011a30 <etharp_output+0x150>)
 80119f6:	7013      	strb	r3, [r2, #0]
        return etharp_output_to_arp_index(netif, q, i);
 80119f8:	461a      	mov	r2, r3
 80119fa:	4631      	mov	r1, r6
 80119fc:	4628      	mov	r0, r5
 80119fe:	f7ff fe2d 	bl	801165c <etharp_output_to_arp_index>
 8011a02:	e00f      	b.n	8011a24 <etharp_output+0x144>
    return etharp_query(netif, dst_addr, q);
 8011a04:	4632      	mov	r2, r6
 8011a06:	4621      	mov	r1, r4
 8011a08:	4628      	mov	r0, r5
 8011a0a:	f7ff fe93 	bl	8011734 <etharp_query>
 8011a0e:	e009      	b.n	8011a24 <etharp_output+0x144>
    dest = (const struct eth_addr *)&ethbroadcast;
 8011a10:	4b0f      	ldr	r3, [pc, #60]	@ (8011a50 <etharp_output+0x170>)
  return ethernet_output(netif, q, (struct eth_addr *)(netif->hwaddr), dest, ETHTYPE_IP);
 8011a12:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8011a16:	9200      	str	r2, [sp, #0]
 8011a18:	f105 0226 	add.w	r2, r5, #38	@ 0x26
 8011a1c:	4631      	mov	r1, r6
 8011a1e:	4628      	mov	r0, r5
 8011a20:	f001 fbf6 	bl	8013210 <ethernet_output>
}
 8011a24:	b004      	add	sp, #16
 8011a26:	bd70      	pop	{r4, r5, r6, pc}
            return ERR_RTE;
 8011a28:	f06f 0003 	mvn.w	r0, #3
 8011a2c:	e7fa      	b.n	8011a24 <etharp_output+0x144>
 8011a2e:	bf00      	nop
 8011a30:	24014338 	.word	0x24014338
 8011a34:	2401433c 	.word	0x2401433c
 8011a38:	240141b4 	.word	0x240141b4
 8011a3c:	08018420 	.word	0x08018420
 8011a40:	080184d4 	.word	0x080184d4
 8011a44:	08015744 	.word	0x08015744
 8011a48:	08018600 	.word	0x08018600
 8011a4c:	0801855c 	.word	0x0801855c
 8011a50:	08018fcc 	.word	0x08018fcc

08011a54 <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
 8011a54:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8011a58:	b086      	sub	sp, #24
 8011a5a:	4606      	mov	r6, r0
 8011a5c:	4688      	mov	r8, r1
 8011a5e:	4617      	mov	r7, r2

  /* increase number of messages attempted to send */
  MIB2_STATS_INC(mib2.icmpoutmsgs);

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
 8011a60:	f44f 7220 	mov.w	r2, #640	@ 0x280
 8011a64:	2124      	movs	r1, #36	@ 0x24
 8011a66:	2022      	movs	r0, #34	@ 0x22
 8011a68:	f7fa f8ca 	bl	800bc00 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
 8011a6c:	2800      	cmp	r0, #0
 8011a6e:	d041      	beq.n	8011af4 <icmp_send_response+0xa0>
 8011a70:	4605      	mov	r5, r0
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    MIB2_STATS_INC(mib2.icmpouterrors);
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
 8011a72:	8943      	ldrh	r3, [r0, #10]
 8011a74:	2b23      	cmp	r3, #35	@ 0x23
 8011a76:	d940      	bls.n	8011afa <icmp_send_response+0xa6>
              (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
 8011a78:	f8d6 c004 	ldr.w	ip, [r6, #4]
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->src);
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->dest);
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
 8011a7c:	686c      	ldr	r4, [r5, #4]
  icmphdr->type = type;
 8011a7e:	f884 8000 	strb.w	r8, [r4]
  icmphdr->code = code;
 8011a82:	7067      	strb	r7, [r4, #1]
  icmphdr->id = 0;
 8011a84:	2300      	movs	r3, #0
 8011a86:	7123      	strb	r3, [r4, #4]
 8011a88:	7163      	strb	r3, [r4, #5]
  icmphdr->seqno = 0;
 8011a8a:	71a3      	strb	r3, [r4, #6]
 8011a8c:	71e3      	strb	r3, [r4, #7]

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 8011a8e:	686b      	ldr	r3, [r5, #4]
 8011a90:	6872      	ldr	r2, [r6, #4]
 8011a92:	6816      	ldr	r6, [r2, #0]
 8011a94:	6850      	ldr	r0, [r2, #4]
 8011a96:	6891      	ldr	r1, [r2, #8]
 8011a98:	68d7      	ldr	r7, [r2, #12]
 8011a9a:	609e      	str	r6, [r3, #8]
 8011a9c:	60d8      	str	r0, [r3, #12]
 8011a9e:	6119      	str	r1, [r3, #16]
 8011aa0:	615f      	str	r7, [r3, #20]
 8011aa2:	6916      	ldr	r6, [r2, #16]
 8011aa4:	6950      	ldr	r0, [r2, #20]
 8011aa6:	6991      	ldr	r1, [r2, #24]
 8011aa8:	619e      	str	r6, [r3, #24]
 8011aaa:	61d8      	str	r0, [r3, #28]
 8011aac:	6219      	str	r1, [r3, #32]
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  ip4_addr_copy(iphdr_src, iphdr->src);
 8011aae:	f8dc 300c 	ldr.w	r3, [ip, #12]
 8011ab2:	9305      	str	r3, [sp, #20]
    ip4_addr_t iphdr_dst;
    ip4_addr_copy(iphdr_dst, iphdr->dest);
    netif = ip4_route_src(&iphdr_dst, &iphdr_src);
  }
#else
  netif = ip4_route(&iphdr_src);
 8011ab4:	a805      	add	r0, sp, #20
 8011ab6:	f000 fba1 	bl	80121fc <ip4_route>
#endif
  if (netif != NULL) {
 8011aba:	4607      	mov	r7, r0
 8011abc:	b1b8      	cbz	r0, 8011aee <icmp_send_response+0x9a>
    /* calculate checksum */
    icmphdr->chksum = 0;
 8011abe:	2600      	movs	r6, #0
 8011ac0:	70a6      	strb	r6, [r4, #2]
 8011ac2:	70e6      	strb	r6, [r4, #3]
#if CHECKSUM_GEN_ICMP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_ICMP) {
      icmphdr->chksum = inet_chksum(icmphdr, q->len);
 8011ac4:	8969      	ldrh	r1, [r5, #10]
 8011ac6:	4620      	mov	r0, r4
 8011ac8:	f7f9 f88d 	bl	800abe6 <inet_chksum>
 8011acc:	8060      	strh	r0, [r4, #2]
    }
#endif
    ICMP_STATS_INC(icmp.xmit);
 8011ace:	4a0f      	ldr	r2, [pc, #60]	@ (8011b0c <icmp_send_response+0xb8>)
 8011ad0:	f8b2 3060 	ldrh.w	r3, [r2, #96]	@ 0x60
 8011ad4:	3301      	adds	r3, #1
 8011ad6:	f8a2 3060 	strh.w	r3, [r2, #96]	@ 0x60
    ip4_output_if(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP, netif);
 8011ada:	9702      	str	r7, [sp, #8]
 8011adc:	2301      	movs	r3, #1
 8011ade:	9301      	str	r3, [sp, #4]
 8011ae0:	9600      	str	r6, [sp, #0]
 8011ae2:	23ff      	movs	r3, #255	@ 0xff
 8011ae4:	aa05      	add	r2, sp, #20
 8011ae6:	4631      	mov	r1, r6
 8011ae8:	4628      	mov	r0, r5
 8011aea:	f000 fdd9 	bl	80126a0 <ip4_output_if>
  }
  pbuf_free(q);
 8011aee:	4628      	mov	r0, r5
 8011af0:	f7fa f81e 	bl	800bb30 <pbuf_free>
}
 8011af4:	b006      	add	sp, #24
 8011af6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ASSERT("check that first pbuf can hold icmp message",
 8011afa:	4b05      	ldr	r3, [pc, #20]	@ (8011b10 <icmp_send_response+0xbc>)
 8011afc:	f44f 72b4 	mov.w	r2, #360	@ 0x168
 8011b00:	4904      	ldr	r1, [pc, #16]	@ (8011b14 <icmp_send_response+0xc0>)
 8011b02:	4805      	ldr	r0, [pc, #20]	@ (8011b18 <icmp_send_response+0xc4>)
 8011b04:	f002 fa3c 	bl	8013f80 <iprintf>
 8011b08:	e7b6      	b.n	8011a78 <icmp_send_response+0x24>
 8011b0a:	bf00      	nop
 8011b0c:	240141b4 	.word	0x240141b4
 8011b10:	0801860c 	.word	0x0801860c
 8011b14:	08018644 	.word	0x08018644
 8011b18:	08015744 	.word	0x08015744

08011b1c <icmp_input>:
{
 8011b1c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8011b20:	b084      	sub	sp, #16
 8011b22:	4605      	mov	r5, r0
  ICMP_STATS_INC(icmp.recv);
 8011b24:	4a62      	ldr	r2, [pc, #392]	@ (8011cb0 <icmp_input+0x194>)
 8011b26:	f8b2 3062 	ldrh.w	r3, [r2, #98]	@ 0x62
 8011b2a:	3301      	adds	r3, #1
 8011b2c:	f8a2 3062 	strh.w	r3, [r2, #98]	@ 0x62
  iphdr_in = ip4_current_header();
 8011b30:	4b60      	ldr	r3, [pc, #384]	@ (8011cb4 <icmp_input+0x198>)
 8011b32:	689f      	ldr	r7, [r3, #8]
  hlen = IPH_HL_BYTES(iphdr_in);
 8011b34:	783c      	ldrb	r4, [r7, #0]
 8011b36:	f004 040f 	and.w	r4, r4, #15
 8011b3a:	00a4      	lsls	r4, r4, #2
  if (hlen < IP_HLEN) {
 8011b3c:	2c13      	cmp	r4, #19
 8011b3e:	d919      	bls.n	8011b74 <icmp_input+0x58>
 8011b40:	460e      	mov	r6, r1
  if (p->len < sizeof(u16_t) * 2) {
 8011b42:	8943      	ldrh	r3, [r0, #10]
 8011b44:	2b03      	cmp	r3, #3
 8011b46:	d915      	bls.n	8011b74 <icmp_input+0x58>
  type = *((u8_t *)p->payload);
 8011b48:	6843      	ldr	r3, [r0, #4]
 8011b4a:	781b      	ldrb	r3, [r3, #0]
  switch (type) {
 8011b4c:	2b00      	cmp	r3, #0
 8011b4e:	f000 80aa 	beq.w	8011ca6 <icmp_input+0x18a>
 8011b52:	2b08      	cmp	r3, #8
 8011b54:	f040 809c 	bne.w	8011c90 <icmp_input+0x174>
      if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
 8011b58:	4b56      	ldr	r3, [pc, #344]	@ (8011cb4 <icmp_input+0x198>)
 8011b5a:	6958      	ldr	r0, [r3, #20]
 8011b5c:	f000 03f0 	and.w	r3, r0, #240	@ 0xf0
 8011b60:	2be0      	cmp	r3, #224	@ 0xe0
 8011b62:	d020      	beq.n	8011ba6 <icmp_input+0x8a>
      if (ip4_addr_isbroadcast(ip4_current_dest_addr(), ip_current_netif())) {
 8011b64:	4b53      	ldr	r3, [pc, #332]	@ (8011cb4 <icmp_input+0x198>)
 8011b66:	6819      	ldr	r1, [r3, #0]
 8011b68:	f000 fdbc 	bl	80126e4 <ip4_addr_isbroadcast_u32>
 8011b6c:	b9d8      	cbnz	r0, 8011ba6 <icmp_input+0x8a>
      if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
 8011b6e:	892b      	ldrh	r3, [r5, #8]
 8011b70:	2b07      	cmp	r3, #7
 8011b72:	d80b      	bhi.n	8011b8c <icmp_input+0x70>
  pbuf_free(p);
 8011b74:	4628      	mov	r0, r5
 8011b76:	f7f9 ffdb 	bl	800bb30 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
 8011b7a:	4a4d      	ldr	r2, [pc, #308]	@ (8011cb0 <icmp_input+0x194>)
 8011b7c:	f8b2 306a 	ldrh.w	r3, [r2, #106]	@ 0x6a
 8011b80:	3301      	adds	r3, #1
 8011b82:	f8a2 306a 	strh.w	r3, [r2, #106]	@ 0x6a
}
 8011b86:	b004      	add	sp, #16
 8011b88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (pbuf_add_header(p, hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN)) {
 8011b8c:	f104 080e 	add.w	r8, r4, #14
 8011b90:	4641      	mov	r1, r8
 8011b92:	4628      	mov	r0, r5
 8011b94:	f7f9 ff81 	bl	800ba9a <pbuf_add_header>
 8011b98:	2800      	cmp	r0, #0
 8011b9a:	d040      	beq.n	8011c1e <icmp_input+0x102>
        u16_t alloc_len = (u16_t)(p->tot_len + hlen);
 8011b9c:	892b      	ldrh	r3, [r5, #8]
 8011b9e:	1919      	adds	r1, r3, r4
 8011ba0:	b289      	uxth	r1, r1
        if (alloc_len < p->tot_len) {
 8011ba2:	428b      	cmp	r3, r1
 8011ba4:	d909      	bls.n	8011bba <icmp_input+0x9e>
  pbuf_free(p);
 8011ba6:	4628      	mov	r0, r5
 8011ba8:	f7f9 ffc2 	bl	800bb30 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
 8011bac:	4a40      	ldr	r2, [pc, #256]	@ (8011cb0 <icmp_input+0x194>)
 8011bae:	f8b2 3074 	ldrh.w	r3, [r2, #116]	@ 0x74
 8011bb2:	3301      	adds	r3, #1
 8011bb4:	f8a2 3074 	strh.w	r3, [r2, #116]	@ 0x74
  return;
 8011bb8:	e7e5      	b.n	8011b86 <icmp_input+0x6a>
        r = pbuf_alloc(PBUF_LINK, alloc_len, PBUF_RAM);
 8011bba:	f44f 7220 	mov.w	r2, #640	@ 0x280
 8011bbe:	200e      	movs	r0, #14
 8011bc0:	f7fa f81e 	bl	800bc00 <pbuf_alloc>
        if (r == NULL) {
 8011bc4:	4680      	mov	r8, r0
 8011bc6:	2800      	cmp	r0, #0
 8011bc8:	d0ed      	beq.n	8011ba6 <icmp_input+0x8a>
        if (r->len < hlen + sizeof(struct icmp_echo_hdr)) {
 8011bca:	8942      	ldrh	r2, [r0, #10]
 8011bcc:	f104 0308 	add.w	r3, r4, #8
 8011bd0:	429a      	cmp	r2, r3
 8011bd2:	d313      	bcc.n	8011bfc <icmp_input+0xe0>
        MEMCPY(r->payload, iphdr_in, hlen);
 8011bd4:	4622      	mov	r2, r4
 8011bd6:	4639      	mov	r1, r7
 8011bd8:	6840      	ldr	r0, [r0, #4]
 8011bda:	f002 fc12 	bl	8014402 <memcpy>
        if (pbuf_remove_header(r, hlen)) {
 8011bde:	4621      	mov	r1, r4
 8011be0:	4640      	mov	r0, r8
 8011be2:	f7f9 ff5f 	bl	800baa4 <pbuf_remove_header>
 8011be6:	b960      	cbnz	r0, 8011c02 <icmp_input+0xe6>
        if (pbuf_copy(r, p) != ERR_OK) {
 8011be8:	4629      	mov	r1, r5
 8011bea:	4640      	mov	r0, r8
 8011bec:	f7fa f972 	bl	800bed4 <pbuf_copy>
 8011bf0:	b988      	cbnz	r0, 8011c16 <icmp_input+0xfa>
        pbuf_free(p);
 8011bf2:	4628      	mov	r0, r5
 8011bf4:	f7f9 ff9c 	bl	800bb30 <pbuf_free>
        p = r;
 8011bf8:	4645      	mov	r5, r8
 8011bfa:	e015      	b.n	8011c28 <icmp_input+0x10c>
          pbuf_free(r);
 8011bfc:	f7f9 ff98 	bl	800bb30 <pbuf_free>
          goto icmperr;
 8011c00:	e7d1      	b.n	8011ba6 <icmp_input+0x8a>
          LWIP_ASSERT("icmp_input: moving r->payload to icmp header failed\n", 0);
 8011c02:	4b2d      	ldr	r3, [pc, #180]	@ (8011cb8 <icmp_input+0x19c>)
 8011c04:	22b6      	movs	r2, #182	@ 0xb6
 8011c06:	492d      	ldr	r1, [pc, #180]	@ (8011cbc <icmp_input+0x1a0>)
 8011c08:	482d      	ldr	r0, [pc, #180]	@ (8011cc0 <icmp_input+0x1a4>)
 8011c0a:	f002 f9b9 	bl	8013f80 <iprintf>
          pbuf_free(r);
 8011c0e:	4640      	mov	r0, r8
 8011c10:	f7f9 ff8e 	bl	800bb30 <pbuf_free>
          goto icmperr;
 8011c14:	e7c7      	b.n	8011ba6 <icmp_input+0x8a>
          pbuf_free(r);
 8011c16:	4640      	mov	r0, r8
 8011c18:	f7f9 ff8a 	bl	800bb30 <pbuf_free>
          goto icmperr;
 8011c1c:	e7c3      	b.n	8011ba6 <icmp_input+0x8a>
        if (pbuf_remove_header(p, hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN)) {
 8011c1e:	4641      	mov	r1, r8
 8011c20:	4628      	mov	r0, r5
 8011c22:	f7f9 ff3f 	bl	800baa4 <pbuf_remove_header>
 8011c26:	bb48      	cbnz	r0, 8011c7c <icmp_input+0x160>
      iecho = (struct icmp_echo_hdr *)p->payload;
 8011c28:	686f      	ldr	r7, [r5, #4]
      if (pbuf_add_header(p, hlen)) {
 8011c2a:	4621      	mov	r1, r4
 8011c2c:	4628      	mov	r0, r5
 8011c2e:	f7f9 ff34 	bl	800ba9a <pbuf_add_header>
 8011c32:	2800      	cmp	r0, #0
 8011c34:	d137      	bne.n	8011ca6 <icmp_input+0x18a>
        struct ip_hdr *iphdr = (struct ip_hdr *)p->payload;
 8011c36:	6869      	ldr	r1, [r5, #4]
        ip4_addr_copy(iphdr->src, *src);
 8011c38:	4b1e      	ldr	r3, [pc, #120]	@ (8011cb4 <icmp_input+0x198>)
 8011c3a:	695a      	ldr	r2, [r3, #20]
 8011c3c:	60ca      	str	r2, [r1, #12]
        ip4_addr_copy(iphdr->dest, *ip4_current_src_addr());
 8011c3e:	691b      	ldr	r3, [r3, #16]
 8011c40:	610b      	str	r3, [r1, #16]
        ICMPH_TYPE_SET(iecho, ICMP_ER);
 8011c42:	2300      	movs	r3, #0
 8011c44:	703b      	strb	r3, [r7, #0]
          if (iecho->chksum > PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
 8011c46:	887b      	ldrh	r3, [r7, #2]
 8011c48:	f64f 72f7 	movw	r2, #65527	@ 0xfff7
 8011c4c:	4293      	cmp	r3, r2
 8011c4e:	d91c      	bls.n	8011c8a <icmp_input+0x16e>
            iecho->chksum = (u16_t)(iecho->chksum + PP_HTONS((u16_t)(ICMP_ECHO << 8)) + 1);
 8011c50:	3309      	adds	r3, #9
 8011c52:	807b      	strh	r3, [r7, #2]
        IPH_TTL_SET(iphdr, ICMP_TTL);
 8011c54:	23ff      	movs	r3, #255	@ 0xff
 8011c56:	720b      	strb	r3, [r1, #8]
        IPH_CHKSUM_SET(iphdr, 0);
 8011c58:	2200      	movs	r2, #0
 8011c5a:	728a      	strb	r2, [r1, #10]
 8011c5c:	72ca      	strb	r2, [r1, #11]
        ICMP_STATS_INC(icmp.xmit);
 8011c5e:	4814      	ldr	r0, [pc, #80]	@ (8011cb0 <icmp_input+0x194>)
 8011c60:	f8b0 1060 	ldrh.w	r1, [r0, #96]	@ 0x60
 8011c64:	3101      	adds	r1, #1
 8011c66:	f8a0 1060 	strh.w	r1, [r0, #96]	@ 0x60
        ret = ip4_output_if(p, src, LWIP_IP_HDRINCL,
 8011c6a:	9602      	str	r6, [sp, #8]
 8011c6c:	2101      	movs	r1, #1
 8011c6e:	9101      	str	r1, [sp, #4]
 8011c70:	9200      	str	r2, [sp, #0]
 8011c72:	4914      	ldr	r1, [pc, #80]	@ (8011cc4 <icmp_input+0x1a8>)
 8011c74:	4628      	mov	r0, r5
 8011c76:	f000 fd13 	bl	80126a0 <ip4_output_if>
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %s\n", lwip_strerr(ret)));
 8011c7a:	e014      	b.n	8011ca6 <icmp_input+0x18a>
          LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
 8011c7c:	4b0e      	ldr	r3, [pc, #56]	@ (8011cb8 <icmp_input+0x19c>)
 8011c7e:	22c7      	movs	r2, #199	@ 0xc7
 8011c80:	4911      	ldr	r1, [pc, #68]	@ (8011cc8 <icmp_input+0x1ac>)
 8011c82:	480f      	ldr	r0, [pc, #60]	@ (8011cc0 <icmp_input+0x1a4>)
 8011c84:	f002 f97c 	bl	8013f80 <iprintf>
          goto icmperr;
 8011c88:	e78d      	b.n	8011ba6 <icmp_input+0x8a>
            iecho->chksum = (u16_t)(iecho->chksum + PP_HTONS(ICMP_ECHO << 8));
 8011c8a:	3308      	adds	r3, #8
 8011c8c:	807b      	strh	r3, [r7, #2]
 8011c8e:	e7e1      	b.n	8011c54 <icmp_input+0x138>
      ICMP_STATS_INC(icmp.proterr);
 8011c90:	4b07      	ldr	r3, [pc, #28]	@ (8011cb0 <icmp_input+0x194>)
 8011c92:	f8b3 2070 	ldrh.w	r2, [r3, #112]	@ 0x70
 8011c96:	3201      	adds	r2, #1
 8011c98:	f8a3 2070 	strh.w	r2, [r3, #112]	@ 0x70
      ICMP_STATS_INC(icmp.drop);
 8011c9c:	f8b3 2066 	ldrh.w	r2, [r3, #102]	@ 0x66
 8011ca0:	3201      	adds	r2, #1
 8011ca2:	f8a3 2066 	strh.w	r2, [r3, #102]	@ 0x66
  pbuf_free(p);
 8011ca6:	4628      	mov	r0, r5
 8011ca8:	f7f9 ff42 	bl	800bb30 <pbuf_free>
  return;
 8011cac:	e76b      	b.n	8011b86 <icmp_input+0x6a>
 8011cae:	bf00      	nop
 8011cb0:	240141b4 	.word	0x240141b4
 8011cb4:	2400c4b0 	.word	0x2400c4b0
 8011cb8:	0801860c 	.word	0x0801860c
 8011cbc:	08018670 	.word	0x08018670
 8011cc0:	08015744 	.word	0x08015744
 8011cc4:	2400c4c4 	.word	0x2400c4c4
 8011cc8:	080186a8 	.word	0x080186a8

08011ccc <icmp_dest_unreach>:
{
 8011ccc:	b508      	push	{r3, lr}
 8011cce:	460a      	mov	r2, r1
  icmp_send_response(p, ICMP_DUR, t);
 8011cd0:	2103      	movs	r1, #3
 8011cd2:	f7ff febf 	bl	8011a54 <icmp_send_response>
}
 8011cd6:	bd08      	pop	{r3, pc}

08011cd8 <icmp_time_exceeded>:
{
 8011cd8:	b508      	push	{r3, lr}
 8011cda:	460a      	mov	r2, r1
  icmp_send_response(p, ICMP_TE, t);
 8011cdc:	210b      	movs	r1, #11
 8011cde:	f7ff feb9 	bl	8011a54 <icmp_send_response>
}
 8011ce2:	bd08      	pop	{r3, pc}

08011ce4 <igmp_start_timer>:
 * @param max_time the time in multiples of IGMP_TMR_INTERVAL (decrease with
 *        every call to igmp_tmr())
 */
static void
igmp_start_timer(struct igmp_group *group, u8_t max_time)
{
 8011ce4:	b538      	push	{r3, r4, r5, lr}
 8011ce6:	4605      	mov	r5, r0
#ifdef LWIP_RAND
  group->timer = (u16_t)(max_time > 2 ? (LWIP_RAND() % max_time) : 1);
 8011ce8:	2902      	cmp	r1, #2
 8011cea:	d805      	bhi.n	8011cf8 <igmp_start_timer+0x14>
 8011cec:	2301      	movs	r3, #1
 8011cee:	816b      	strh	r3, [r5, #10]
#else /* LWIP_RAND */
  /* ATTENTION: use this only if absolutely necessary! */
  group->timer = max_time / 2;
#endif /* LWIP_RAND */

  if (group->timer == 0) {
 8011cf0:	b90b      	cbnz	r3, 8011cf6 <igmp_start_timer+0x12>
    group->timer = 1;
 8011cf2:	2301      	movs	r3, #1
 8011cf4:	816b      	strh	r3, [r5, #10]
  }
}
 8011cf6:	bd38      	pop	{r3, r4, r5, pc}
 8011cf8:	460c      	mov	r4, r1
  group->timer = (u16_t)(max_time > 2 ? (LWIP_RAND() % max_time) : 1);
 8011cfa:	f002 f841 	bl	8013d80 <rand>
 8011cfe:	fbb0 f2f4 	udiv	r2, r0, r4
 8011d02:	fb04 0312 	mls	r3, r4, r2, r0
 8011d06:	b29b      	uxth	r3, r3
 8011d08:	e7f1      	b.n	8011cee <igmp_start_timer+0xa>

08011d0a <igmp_delaying_member>:
 * @param group the igmp_group for which "delaying" membership report
 * @param maxresp query delay
 */
static void
igmp_delaying_member(struct igmp_group *group, u8_t maxresp)
{
 8011d0a:	b510      	push	{r4, lr}
 8011d0c:	4604      	mov	r4, r0
  if ((group->group_state == IGMP_GROUP_IDLE_MEMBER) ||
 8011d0e:	7a43      	ldrb	r3, [r0, #9]
 8011d10:	2b02      	cmp	r3, #2
 8011d12:	d006      	beq.n	8011d22 <igmp_delaying_member+0x18>
 8011d14:	2b01      	cmp	r3, #1
 8011d16:	d000      	beq.n	8011d1a <igmp_delaying_member+0x10>
      ((group->group_state == IGMP_GROUP_DELAYING_MEMBER) &&
       ((group->timer == 0) || (maxresp < group->timer)))) {
    igmp_start_timer(group, maxresp);
    group->group_state = IGMP_GROUP_DELAYING_MEMBER;
  }
}
 8011d18:	bd10      	pop	{r4, pc}
       ((group->timer == 0) || (maxresp < group->timer)))) {
 8011d1a:	8943      	ldrh	r3, [r0, #10]
      ((group->group_state == IGMP_GROUP_DELAYING_MEMBER) &&
 8011d1c:	b10b      	cbz	r3, 8011d22 <igmp_delaying_member+0x18>
       ((group->timer == 0) || (maxresp < group->timer)))) {
 8011d1e:	428b      	cmp	r3, r1
 8011d20:	d9fa      	bls.n	8011d18 <igmp_delaying_member+0xe>
    igmp_start_timer(group, maxresp);
 8011d22:	4620      	mov	r0, r4
 8011d24:	f7ff ffde 	bl	8011ce4 <igmp_start_timer>
    group->group_state = IGMP_GROUP_DELAYING_MEMBER;
 8011d28:	2301      	movs	r3, #1
 8011d2a:	7263      	strb	r3, [r4, #9]
}
 8011d2c:	e7f4      	b.n	8011d18 <igmp_delaying_member+0xe>
	...

08011d30 <igmp_ip_output_if>:
 *         ERR_BUF if p doesn't have enough space for IP/LINK headers
 *         returns errors returned by netif->output
 */
static err_t
igmp_ip_output_if(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest, struct netif *netif)
{
 8011d30:	b530      	push	{r4, r5, lr}
 8011d32:	b089      	sub	sp, #36	@ 0x24
  /* This is the "router alert" option */
  u16_t ra[2];
  ra[0] = PP_HTONS(ROUTER_ALERT);
 8011d34:	f240 4494 	movw	r4, #1172	@ 0x494
 8011d38:	f8ad 401c 	strh.w	r4, [sp, #28]
  ra[1] = 0x0000; /* Router shall examine packet */
 8011d3c:	2400      	movs	r4, #0
 8011d3e:	f8ad 401e 	strh.w	r4, [sp, #30]
  IGMP_STATS_INC(igmp.xmit);
 8011d42:	4d0a      	ldr	r5, [pc, #40]	@ (8011d6c <igmp_ip_output_if+0x3c>)
 8011d44:	f8b5 c078 	ldrh.w	ip, [r5, #120]	@ 0x78
 8011d48:	f10c 0c01 	add.w	ip, ip, #1
 8011d4c:	f8a5 c078 	strh.w	ip, [r5, #120]	@ 0x78
  return ip4_output_if_opt(p, src, dest, IGMP_TTL, 0, IP_PROTO_IGMP, netif, ra, ROUTER_ALERTLEN);
 8011d50:	2504      	movs	r5, #4
 8011d52:	9504      	str	r5, [sp, #16]
 8011d54:	ad07      	add	r5, sp, #28
 8011d56:	9503      	str	r5, [sp, #12]
 8011d58:	9302      	str	r3, [sp, #8]
 8011d5a:	2302      	movs	r3, #2
 8011d5c:	9301      	str	r3, [sp, #4]
 8011d5e:	9400      	str	r4, [sp, #0]
 8011d60:	2301      	movs	r3, #1
 8011d62:	f000 fc83 	bl	801266c <ip4_output_if_opt>
}
 8011d66:	b009      	add	sp, #36	@ 0x24
 8011d68:	bd30      	pop	{r4, r5, pc}
 8011d6a:	bf00      	nop
 8011d6c:	240141b4 	.word	0x240141b4

08011d70 <igmp_send>:
 * @param group the group to which to send the packet
 * @param type the type of igmp packet to send
 */
static void
igmp_send(struct netif *netif, struct igmp_group *group, u8_t type)
{
 8011d70:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8011d74:	b083      	sub	sp, #12
 8011d76:	4605      	mov	r5, r0
 8011d78:	460e      	mov	r6, r1
 8011d7a:	4614      	mov	r4, r2
  struct pbuf     *p    = NULL;
  struct igmp_msg *igmp = NULL;
  ip4_addr_t   src  = *IP4_ADDR_ANY4;
 8011d7c:	4b2b      	ldr	r3, [pc, #172]	@ (8011e2c <igmp_send+0xbc>)
 8011d7e:	681b      	ldr	r3, [r3, #0]
 8011d80:	9301      	str	r3, [sp, #4]
  ip4_addr_t  *dest = NULL;

  /* IP header + "router alert" option + IGMP header */
  p = pbuf_alloc(PBUF_TRANSPORT, IGMP_MINLEN, PBUF_RAM);
 8011d82:	f44f 7220 	mov.w	r2, #640	@ 0x280
 8011d86:	2108      	movs	r1, #8
 8011d88:	2036      	movs	r0, #54	@ 0x36
 8011d8a:	f7f9 ff39 	bl	800bc00 <pbuf_alloc>

  if (p) {
 8011d8e:	2800      	cmp	r0, #0
 8011d90:	d044      	beq.n	8011e1c <igmp_send+0xac>
 8011d92:	4607      	mov	r7, r0
    igmp = (struct igmp_msg *)p->payload;
 8011d94:	f8d0 8004 	ldr.w	r8, [r0, #4]
    LWIP_ASSERT("igmp_send: check that first pbuf can hold struct igmp_msg",
 8011d98:	8943      	ldrh	r3, [r0, #10]
 8011d9a:	2b07      	cmp	r3, #7
 8011d9c:	d912      	bls.n	8011dc4 <igmp_send+0x54>
                (p->len >= sizeof(struct igmp_msg)));
    ip4_addr_copy(src, *netif_ip4_addr(netif));
 8011d9e:	686b      	ldr	r3, [r5, #4]
 8011da0:	9301      	str	r3, [sp, #4]

    if (type == IGMP_V2_MEMB_REPORT) {
 8011da2:	2c16      	cmp	r4, #22
 8011da4:	d016      	beq.n	8011dd4 <igmp_send+0x64>
      dest = &(group->group_address);
      ip4_addr_copy(igmp->igmp_group_address, group->group_address);
      group->last_reporter_flag = 1; /* Remember we were the last to report */
    } else {
      if (type == IGMP_LEAVE_GROUP) {
 8011da6:	2c17      	cmp	r4, #23
 8011da8:	d01c      	beq.n	8011de4 <igmp_send+0x74>
  ip4_addr_t  *dest = NULL;
 8011daa:	f04f 0900 	mov.w	r9, #0
        dest = &allrouters;
        ip4_addr_copy(igmp->igmp_group_address, group->group_address);
      }
    }

    if ((type == IGMP_V2_MEMB_REPORT) || (type == IGMP_LEAVE_GROUP)) {
 8011dae:	f1a4 0316 	sub.w	r3, r4, #22
 8011db2:	b2db      	uxtb	r3, r3
 8011db4:	2b01      	cmp	r3, #1
 8011db6:	d91b      	bls.n	8011df0 <igmp_send+0x80>
      igmp->igmp_checksum = inet_chksum(igmp, IGMP_MINLEN);

      igmp_ip_output_if(p, &src, dest, netif);
    }

    pbuf_free(p);
 8011db8:	4638      	mov	r0, r7
 8011dba:	f7f9 feb9 	bl	800bb30 <pbuf_free>
  } else {
    LWIP_DEBUGF(IGMP_DEBUG, ("igmp_send: not enough memory for igmp_send\n"));
    IGMP_STATS_INC(igmp.memerr);
  }
}
 8011dbe:	b003      	add	sp, #12
 8011dc0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    LWIP_ASSERT("igmp_send: check that first pbuf can hold struct igmp_msg",
 8011dc4:	4b1a      	ldr	r3, [pc, #104]	@ (8011e30 <igmp_send+0xc0>)
 8011dc6:	f240 3202 	movw	r2, #770	@ 0x302
 8011dca:	491a      	ldr	r1, [pc, #104]	@ (8011e34 <igmp_send+0xc4>)
 8011dcc:	481a      	ldr	r0, [pc, #104]	@ (8011e38 <igmp_send+0xc8>)
 8011dce:	f002 f8d7 	bl	8013f80 <iprintf>
 8011dd2:	e7e4      	b.n	8011d9e <igmp_send+0x2e>
      dest = &(group->group_address);
 8011dd4:	f106 0904 	add.w	r9, r6, #4
      ip4_addr_copy(igmp->igmp_group_address, group->group_address);
 8011dd8:	6873      	ldr	r3, [r6, #4]
 8011dda:	f8c8 3004 	str.w	r3, [r8, #4]
      group->last_reporter_flag = 1; /* Remember we were the last to report */
 8011dde:	2301      	movs	r3, #1
 8011de0:	7233      	strb	r3, [r6, #8]
 8011de2:	e7e4      	b.n	8011dae <igmp_send+0x3e>
        ip4_addr_copy(igmp->igmp_group_address, group->group_address);
 8011de4:	6873      	ldr	r3, [r6, #4]
 8011de6:	f8c8 3004 	str.w	r3, [r8, #4]
        dest = &allrouters;
 8011dea:	f8df 9054 	ldr.w	r9, [pc, #84]	@ 8011e40 <igmp_send+0xd0>
 8011dee:	e7de      	b.n	8011dae <igmp_send+0x3e>
      igmp->igmp_msgtype  = type;
 8011df0:	f888 4000 	strb.w	r4, [r8]
      igmp->igmp_maxresp  = 0;
 8011df4:	2300      	movs	r3, #0
 8011df6:	f888 3001 	strb.w	r3, [r8, #1]
      igmp->igmp_checksum = 0;
 8011dfa:	f888 3002 	strb.w	r3, [r8, #2]
 8011dfe:	f888 3003 	strb.w	r3, [r8, #3]
      igmp->igmp_checksum = inet_chksum(igmp, IGMP_MINLEN);
 8011e02:	2108      	movs	r1, #8
 8011e04:	4640      	mov	r0, r8
 8011e06:	f7f8 feee 	bl	800abe6 <inet_chksum>
 8011e0a:	f8a8 0002 	strh.w	r0, [r8, #2]
      igmp_ip_output_if(p, &src, dest, netif);
 8011e0e:	462b      	mov	r3, r5
 8011e10:	464a      	mov	r2, r9
 8011e12:	a901      	add	r1, sp, #4
 8011e14:	4638      	mov	r0, r7
 8011e16:	f7ff ff8b 	bl	8011d30 <igmp_ip_output_if>
 8011e1a:	e7cd      	b.n	8011db8 <igmp_send+0x48>
    IGMP_STATS_INC(igmp.memerr);
 8011e1c:	4a07      	ldr	r2, [pc, #28]	@ (8011e3c <igmp_send+0xcc>)
 8011e1e:	f8b2 3082 	ldrh.w	r3, [r2, #130]	@ 0x82
 8011e22:	3301      	adds	r3, #1
 8011e24:	f8a2 3082 	strh.w	r3, [r2, #130]	@ 0x82
}
 8011e28:	e7c9      	b.n	8011dbe <igmp_send+0x4e>
 8011e2a:	bf00      	nop
 8011e2c:	08018fc0 	.word	0x08018fc0
 8011e30:	080186dc 	.word	0x080186dc
 8011e34:	08018714 	.word	0x08018714
 8011e38:	08015744 	.word	0x08015744
 8011e3c:	240141b4 	.word	0x240141b4
 8011e40:	2401442c 	.word	0x2401442c

08011e44 <igmp_timeout>:
{
 8011e44:	b508      	push	{r3, lr}
  if ((group->group_state == IGMP_GROUP_DELAYING_MEMBER) &&
 8011e46:	7a4b      	ldrb	r3, [r1, #9]
 8011e48:	2b01      	cmp	r3, #1
 8011e4a:	d000      	beq.n	8011e4e <igmp_timeout+0xa>
}
 8011e4c:	bd08      	pop	{r3, pc}
      (!(ip4_addr_cmp(&(group->group_address), &allsystems)))) {
 8011e4e:	684a      	ldr	r2, [r1, #4]
 8011e50:	4b07      	ldr	r3, [pc, #28]	@ (8011e70 <igmp_timeout+0x2c>)
 8011e52:	681b      	ldr	r3, [r3, #0]
  if ((group->group_state == IGMP_GROUP_DELAYING_MEMBER) &&
 8011e54:	429a      	cmp	r2, r3
 8011e56:	d0f9      	beq.n	8011e4c <igmp_timeout+0x8>
    group->group_state = IGMP_GROUP_IDLE_MEMBER;
 8011e58:	2302      	movs	r3, #2
 8011e5a:	724b      	strb	r3, [r1, #9]
    IGMP_STATS_INC(igmp.tx_report);
 8011e5c:	4a05      	ldr	r2, [pc, #20]	@ (8011e74 <igmp_timeout+0x30>)
 8011e5e:	f8b2 3092 	ldrh.w	r3, [r2, #146]	@ 0x92
 8011e62:	3301      	adds	r3, #1
 8011e64:	f8a2 3092 	strh.w	r3, [r2, #146]	@ 0x92
    igmp_send(netif, group, IGMP_V2_MEMB_REPORT);
 8011e68:	2216      	movs	r2, #22
 8011e6a:	f7ff ff81 	bl	8011d70 <igmp_send>
}
 8011e6e:	e7ed      	b.n	8011e4c <igmp_timeout+0x8>
 8011e70:	24014430 	.word	0x24014430
 8011e74:	240141b4 	.word	0x240141b4

08011e78 <igmp_init>:
  IP4_ADDR(&allsystems, 224, 0, 0, 1);
 8011e78:	4b03      	ldr	r3, [pc, #12]	@ (8011e88 <igmp_init+0x10>)
 8011e7a:	4a04      	ldr	r2, [pc, #16]	@ (8011e8c <igmp_init+0x14>)
 8011e7c:	601a      	str	r2, [r3, #0]
  IP4_ADDR(&allrouters, 224, 0, 0, 2);
 8011e7e:	4b04      	ldr	r3, [pc, #16]	@ (8011e90 <igmp_init+0x18>)
 8011e80:	f102 7280 	add.w	r2, r2, #16777216	@ 0x1000000
 8011e84:	601a      	str	r2, [r3, #0]
}
 8011e86:	4770      	bx	lr
 8011e88:	24014430 	.word	0x24014430
 8011e8c:	010000e0 	.word	0x010000e0
 8011e90:	2401442c 	.word	0x2401442c

08011e94 <igmp_report_groups>:
{
 8011e94:	b510      	push	{r4, lr}
  struct igmp_group *group = netif_igmp_data(netif);
 8011e96:	6a04      	ldr	r4, [r0, #32]
  if (group != NULL) {
 8011e98:	b134      	cbz	r4, 8011ea8 <igmp_report_groups+0x14>
    group = group->next;
 8011e9a:	6824      	ldr	r4, [r4, #0]
 8011e9c:	e004      	b.n	8011ea8 <igmp_report_groups+0x14>
    igmp_delaying_member(group, IGMP_JOIN_DELAYING_MEMBER_TMR);
 8011e9e:	2105      	movs	r1, #5
 8011ea0:	4620      	mov	r0, r4
 8011ea2:	f7ff ff32 	bl	8011d0a <igmp_delaying_member>
    group = group->next;
 8011ea6:	6824      	ldr	r4, [r4, #0]
  while (group != NULL) {
 8011ea8:	2c00      	cmp	r4, #0
 8011eaa:	d1f8      	bne.n	8011e9e <igmp_report_groups+0xa>
}
 8011eac:	bd10      	pop	{r4, pc}

08011eae <igmp_lookfor_group>:
  struct igmp_group *group = netif_igmp_data(ifp);
 8011eae:	6a00      	ldr	r0, [r0, #32]
  while (group != NULL) {
 8011eb0:	e000      	b.n	8011eb4 <igmp_lookfor_group+0x6>
    group = group->next;
 8011eb2:	6800      	ldr	r0, [r0, #0]
  while (group != NULL) {
 8011eb4:	b118      	cbz	r0, 8011ebe <igmp_lookfor_group+0x10>
    if (ip4_addr_cmp(&(group->group_address), addr)) {
 8011eb6:	6842      	ldr	r2, [r0, #4]
 8011eb8:	680b      	ldr	r3, [r1, #0]
 8011eba:	429a      	cmp	r2, r3
 8011ebc:	d1f9      	bne.n	8011eb2 <igmp_lookfor_group+0x4>
}
 8011ebe:	4770      	bx	lr

08011ec0 <igmp_lookup_group>:
{
 8011ec0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8011ec2:	4604      	mov	r4, r0
 8011ec4:	460e      	mov	r6, r1
  struct igmp_group *list_head = netif_igmp_data(ifp);
 8011ec6:	6a07      	ldr	r7, [r0, #32]
  group = igmp_lookfor_group(ifp, addr);
 8011ec8:	f7ff fff1 	bl	8011eae <igmp_lookfor_group>
  if (group != NULL) {
 8011ecc:	4605      	mov	r5, r0
 8011ece:	b108      	cbz	r0, 8011ed4 <igmp_lookup_group+0x14>
}
 8011ed0:	4628      	mov	r0, r5
 8011ed2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  group = (struct igmp_group *)memp_malloc(MEMP_IGMP_GROUP);
 8011ed4:	200a      	movs	r0, #10
 8011ed6:	f7f9 fad9 	bl	800b48c <memp_malloc>
  if (group != NULL) {
 8011eda:	4605      	mov	r5, r0
 8011edc:	2800      	cmp	r0, #0
 8011ede:	d0f7      	beq.n	8011ed0 <igmp_lookup_group+0x10>
    ip4_addr_set(&(group->group_address), addr);
 8011ee0:	b186      	cbz	r6, 8011f04 <igmp_lookup_group+0x44>
 8011ee2:	6833      	ldr	r3, [r6, #0]
 8011ee4:	606b      	str	r3, [r5, #4]
    group->timer              = 0; /* Not running */
 8011ee6:	2300      	movs	r3, #0
 8011ee8:	816b      	strh	r3, [r5, #10]
    group->group_state        = IGMP_GROUP_NON_MEMBER;
 8011eea:	726b      	strb	r3, [r5, #9]
    group->last_reporter_flag = 0;
 8011eec:	722b      	strb	r3, [r5, #8]
    group->use                = 0;
 8011eee:	732b      	strb	r3, [r5, #12]
    if (list_head == NULL) {
 8011ef0:	b157      	cbz	r7, 8011f08 <igmp_lookup_group+0x48>
      LWIP_ASSERT("igmp_lookup_group: all except first group must not be allsystems",
 8011ef2:	6832      	ldr	r2, [r6, #0]
 8011ef4:	4b11      	ldr	r3, [pc, #68]	@ (8011f3c <igmp_lookup_group+0x7c>)
 8011ef6:	681b      	ldr	r3, [r3, #0]
 8011ef8:	429a      	cmp	r2, r3
 8011efa:	d016      	beq.n	8011f2a <igmp_lookup_group+0x6a>
      group->next = list_head->next;
 8011efc:	683b      	ldr	r3, [r7, #0]
 8011efe:	602b      	str	r3, [r5, #0]
      list_head->next = group;
 8011f00:	603d      	str	r5, [r7, #0]
 8011f02:	e7e5      	b.n	8011ed0 <igmp_lookup_group+0x10>
    ip4_addr_set(&(group->group_address), addr);
 8011f04:	2300      	movs	r3, #0
 8011f06:	e7ed      	b.n	8011ee4 <igmp_lookup_group+0x24>
      LWIP_ASSERT("igmp_lookup_group: first group must be allsystems",
 8011f08:	6832      	ldr	r2, [r6, #0]
 8011f0a:	4b0c      	ldr	r3, [pc, #48]	@ (8011f3c <igmp_lookup_group+0x7c>)
 8011f0c:	681b      	ldr	r3, [r3, #0]
 8011f0e:	429a      	cmp	r2, r3
 8011f10:	d103      	bne.n	8011f1a <igmp_lookup_group+0x5a>
      group->next = NULL;
 8011f12:	2300      	movs	r3, #0
 8011f14:	602b      	str	r3, [r5, #0]
      netif_set_client_data(ifp, LWIP_NETIF_CLIENT_DATA_INDEX_IGMP, group);
 8011f16:	6225      	str	r5, [r4, #32]
 8011f18:	e7da      	b.n	8011ed0 <igmp_lookup_group+0x10>
      LWIP_ASSERT("igmp_lookup_group: first group must be allsystems",
 8011f1a:	4b09      	ldr	r3, [pc, #36]	@ (8011f40 <igmp_lookup_group+0x80>)
 8011f1c:	f44f 7286 	mov.w	r2, #268	@ 0x10c
 8011f20:	4908      	ldr	r1, [pc, #32]	@ (8011f44 <igmp_lookup_group+0x84>)
 8011f22:	4809      	ldr	r0, [pc, #36]	@ (8011f48 <igmp_lookup_group+0x88>)
 8011f24:	f002 f82c 	bl	8013f80 <iprintf>
 8011f28:	e7f3      	b.n	8011f12 <igmp_lookup_group+0x52>
      LWIP_ASSERT("igmp_lookup_group: all except first group must not be allsystems",
 8011f2a:	4b05      	ldr	r3, [pc, #20]	@ (8011f40 <igmp_lookup_group+0x80>)
 8011f2c:	f44f 7289 	mov.w	r2, #274	@ 0x112
 8011f30:	4906      	ldr	r1, [pc, #24]	@ (8011f4c <igmp_lookup_group+0x8c>)
 8011f32:	4805      	ldr	r0, [pc, #20]	@ (8011f48 <igmp_lookup_group+0x88>)
 8011f34:	f002 f824 	bl	8013f80 <iprintf>
 8011f38:	e7e0      	b.n	8011efc <igmp_lookup_group+0x3c>
 8011f3a:	bf00      	nop
 8011f3c:	24014430 	.word	0x24014430
 8011f40:	080186dc 	.word	0x080186dc
 8011f44:	08018750 	.word	0x08018750
 8011f48:	08015744 	.word	0x08015744
 8011f4c:	08018784 	.word	0x08018784

08011f50 <igmp_start>:
{
 8011f50:	b510      	push	{r4, lr}
 8011f52:	4604      	mov	r4, r0
  group = igmp_lookup_group(netif, &allsystems);
 8011f54:	4909      	ldr	r1, [pc, #36]	@ (8011f7c <igmp_start+0x2c>)
 8011f56:	f7ff ffb3 	bl	8011ec0 <igmp_lookup_group>
  if (group != NULL) {
 8011f5a:	b160      	cbz	r0, 8011f76 <igmp_start+0x26>
    group->group_state = IGMP_GROUP_IDLE_MEMBER;
 8011f5c:	2202      	movs	r2, #2
 8011f5e:	7242      	strb	r2, [r0, #9]
    group->use++;
 8011f60:	7b02      	ldrb	r2, [r0, #12]
 8011f62:	3201      	adds	r2, #1
 8011f64:	7302      	strb	r2, [r0, #12]
    if (netif->igmp_mac_filter != NULL) {
 8011f66:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 8011f68:	b11b      	cbz	r3, 8011f72 <igmp_start+0x22>
      netif->igmp_mac_filter(netif, &allsystems, NETIF_ADD_MAC_FILTER);
 8011f6a:	2201      	movs	r2, #1
 8011f6c:	4903      	ldr	r1, [pc, #12]	@ (8011f7c <igmp_start+0x2c>)
 8011f6e:	4620      	mov	r0, r4
 8011f70:	4798      	blx	r3
    return ERR_OK;
 8011f72:	2000      	movs	r0, #0
}
 8011f74:	bd10      	pop	{r4, pc}
  return ERR_MEM;
 8011f76:	f04f 30ff 	mov.w	r0, #4294967295
 8011f7a:	e7fb      	b.n	8011f74 <igmp_start+0x24>
 8011f7c:	24014430 	.word	0x24014430

08011f80 <igmp_input>:
{
 8011f80:	b5f0      	push	{r4, r5, r6, r7, lr}
 8011f82:	b083      	sub	sp, #12
 8011f84:	4604      	mov	r4, r0
 8011f86:	460e      	mov	r6, r1
  IGMP_STATS_INC(igmp.recv);
 8011f88:	4d4d      	ldr	r5, [pc, #308]	@ (80120c0 <igmp_input+0x140>)
 8011f8a:	f8b5 307a 	ldrh.w	r3, [r5, #122]	@ 0x7a
 8011f8e:	3301      	adds	r3, #1
 8011f90:	f8a5 307a 	strh.w	r3, [r5, #122]	@ 0x7a
  if (p->len < IGMP_MINLEN) {
 8011f94:	8941      	ldrh	r1, [r0, #10]
 8011f96:	2907      	cmp	r1, #7
 8011f98:	d91b      	bls.n	8011fd2 <igmp_input+0x52>
 8011f9a:	4617      	mov	r7, r2
  igmp = (struct igmp_msg *)p->payload;
 8011f9c:	6845      	ldr	r5, [r0, #4]
  if (inet_chksum(igmp, p->len)) {
 8011f9e:	4628      	mov	r0, r5
 8011fa0:	f7f8 fe21 	bl	800abe6 <inet_chksum>
 8011fa4:	b9e8      	cbnz	r0, 8011fe2 <igmp_input+0x62>
  group = igmp_lookfor_group(inp, dest); /* use the destination IP address of incoming packet */
 8011fa6:	4639      	mov	r1, r7
 8011fa8:	4630      	mov	r0, r6
 8011faa:	f7ff ff80 	bl	8011eae <igmp_lookfor_group>
  if (!group) {
 8011fae:	4602      	mov	r2, r0
 8011fb0:	b308      	cbz	r0, 8011ff6 <igmp_input+0x76>
  switch (igmp->igmp_msgtype) {
 8011fb2:	782b      	ldrb	r3, [r5, #0]
 8011fb4:	2b11      	cmp	r3, #17
 8011fb6:	d028      	beq.n	801200a <igmp_input+0x8a>
 8011fb8:	2b16      	cmp	r3, #22
 8011fba:	d072      	beq.n	80120a2 <igmp_input+0x122>
      IGMP_STATS_INC(igmp.proterr);
 8011fbc:	4a40      	ldr	r2, [pc, #256]	@ (80120c0 <igmp_input+0x140>)
 8011fbe:	f8b2 3084 	ldrh.w	r3, [r2, #132]	@ 0x84
 8011fc2:	3301      	adds	r3, #1
 8011fc4:	f8a2 3084 	strh.w	r3, [r2, #132]	@ 0x84
  pbuf_free(p);
 8011fc8:	4620      	mov	r0, r4
 8011fca:	f7f9 fdb1 	bl	800bb30 <pbuf_free>
}
 8011fce:	b003      	add	sp, #12
 8011fd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    pbuf_free(p);
 8011fd2:	f7f9 fdad 	bl	800bb30 <pbuf_free>
    IGMP_STATS_INC(igmp.lenerr);
 8011fd6:	f8b5 3080 	ldrh.w	r3, [r5, #128]	@ 0x80
 8011fda:	3301      	adds	r3, #1
 8011fdc:	f8a5 3080 	strh.w	r3, [r5, #128]	@ 0x80
    return;
 8011fe0:	e7f5      	b.n	8011fce <igmp_input+0x4e>
    pbuf_free(p);
 8011fe2:	4620      	mov	r0, r4
 8011fe4:	f7f9 fda4 	bl	800bb30 <pbuf_free>
    IGMP_STATS_INC(igmp.chkerr);
 8011fe8:	4a35      	ldr	r2, [pc, #212]	@ (80120c0 <igmp_input+0x140>)
 8011fea:	f8b2 307e 	ldrh.w	r3, [r2, #126]	@ 0x7e
 8011fee:	3301      	adds	r3, #1
 8011ff0:	f8a2 307e 	strh.w	r3, [r2, #126]	@ 0x7e
    return;
 8011ff4:	e7eb      	b.n	8011fce <igmp_input+0x4e>
    pbuf_free(p);
 8011ff6:	4620      	mov	r0, r4
 8011ff8:	f7f9 fd9a 	bl	800bb30 <pbuf_free>
    IGMP_STATS_INC(igmp.drop);
 8011ffc:	4a30      	ldr	r2, [pc, #192]	@ (80120c0 <igmp_input+0x140>)
 8011ffe:	f8b2 307c 	ldrh.w	r3, [r2, #124]	@ 0x7c
 8012002:	3301      	adds	r3, #1
 8012004:	f8a2 307c 	strh.w	r3, [r2, #124]	@ 0x7c
    return;
 8012008:	e7e1      	b.n	8011fce <igmp_input+0x4e>
      if ((ip4_addr_cmp(dest, &allsystems)) && ip4_addr_isany(&igmp->igmp_group_address)) {
 801200a:	6839      	ldr	r1, [r7, #0]
 801200c:	4b2d      	ldr	r3, [pc, #180]	@ (80120c4 <igmp_input+0x144>)
 801200e:	681b      	ldr	r3, [r3, #0]
 8012010:	4299      	cmp	r1, r3
 8012012:	d011      	beq.n	8012038 <igmp_input+0xb8>
        if (!ip4_addr_isany(&igmp->igmp_group_address)) {
 8012014:	6868      	ldr	r0, [r5, #4]
 8012016:	2800      	cmp	r0, #0
 8012018:	d03c      	beq.n	8012094 <igmp_input+0x114>
          if (ip4_addr_cmp(dest, &allsystems)) {
 801201a:	4299      	cmp	r1, r3
 801201c:	d02c      	beq.n	8012078 <igmp_input+0xf8>
          if (group != NULL) {
 801201e:	2a00      	cmp	r2, #0
 8012020:	d031      	beq.n	8012086 <igmp_input+0x106>
            IGMP_STATS_INC(igmp.rx_group);
 8012022:	4927      	ldr	r1, [pc, #156]	@ (80120c0 <igmp_input+0x140>)
 8012024:	f8b1 3088 	ldrh.w	r3, [r1, #136]	@ 0x88
 8012028:	3301      	adds	r3, #1
 801202a:	f8a1 3088 	strh.w	r3, [r1, #136]	@ 0x88
            igmp_delaying_member(group, igmp->igmp_maxresp);
 801202e:	7869      	ldrb	r1, [r5, #1]
 8012030:	4610      	mov	r0, r2
 8012032:	f7ff fe6a 	bl	8011d0a <igmp_delaying_member>
 8012036:	e7c7      	b.n	8011fc8 <igmp_input+0x48>
      if ((ip4_addr_cmp(dest, &allsystems)) && ip4_addr_isany(&igmp->igmp_group_address)) {
 8012038:	6868      	ldr	r0, [r5, #4]
 801203a:	2800      	cmp	r0, #0
 801203c:	d1ea      	bne.n	8012014 <igmp_input+0x94>
        if (igmp->igmp_maxresp == 0) {
 801203e:	786b      	ldrb	r3, [r5, #1]
 8012040:	b95b      	cbnz	r3, 801205a <igmp_input+0xda>
          IGMP_STATS_INC(igmp.rx_v1);
 8012042:	4a1f      	ldr	r2, [pc, #124]	@ (80120c0 <igmp_input+0x140>)
 8012044:	f8b2 3086 	ldrh.w	r3, [r2, #134]	@ 0x86
 8012048:	3301      	adds	r3, #1
 801204a:	f8a2 3086 	strh.w	r3, [r2, #134]	@ 0x86
          igmp->igmp_maxresp = IGMP_V1_DELAYING_MEMBER_TMR;
 801204e:	230a      	movs	r3, #10
 8012050:	706b      	strb	r3, [r5, #1]
        groupref = netif_igmp_data(inp);
 8012052:	6a36      	ldr	r6, [r6, #32]
        if (groupref != NULL) {
 8012054:	b16e      	cbz	r6, 8012072 <igmp_input+0xf2>
          groupref = groupref->next;
 8012056:	6836      	ldr	r6, [r6, #0]
 8012058:	e00b      	b.n	8012072 <igmp_input+0xf2>
          IGMP_STATS_INC(igmp.rx_general);
 801205a:	4a19      	ldr	r2, [pc, #100]	@ (80120c0 <igmp_input+0x140>)
 801205c:	f8b2 308a 	ldrh.w	r3, [r2, #138]	@ 0x8a
 8012060:	3301      	adds	r3, #1
 8012062:	f8a2 308a 	strh.w	r3, [r2, #138]	@ 0x8a
 8012066:	e7f4      	b.n	8012052 <igmp_input+0xd2>
          igmp_delaying_member(groupref, igmp->igmp_maxresp);
 8012068:	7869      	ldrb	r1, [r5, #1]
 801206a:	4630      	mov	r0, r6
 801206c:	f7ff fe4d 	bl	8011d0a <igmp_delaying_member>
          groupref = groupref->next;
 8012070:	6836      	ldr	r6, [r6, #0]
        while (groupref) {
 8012072:	2e00      	cmp	r6, #0
 8012074:	d1f8      	bne.n	8012068 <igmp_input+0xe8>
 8012076:	e7a7      	b.n	8011fc8 <igmp_input+0x48>
            ip4_addr_copy(groupaddr, igmp->igmp_group_address);
 8012078:	9001      	str	r0, [sp, #4]
            group = igmp_lookfor_group(inp, &groupaddr);
 801207a:	a901      	add	r1, sp, #4
 801207c:	4630      	mov	r0, r6
 801207e:	f7ff ff16 	bl	8011eae <igmp_lookfor_group>
 8012082:	4602      	mov	r2, r0
 8012084:	e7cb      	b.n	801201e <igmp_input+0x9e>
            IGMP_STATS_INC(igmp.drop);
 8012086:	4a0e      	ldr	r2, [pc, #56]	@ (80120c0 <igmp_input+0x140>)
 8012088:	f8b2 307c 	ldrh.w	r3, [r2, #124]	@ 0x7c
 801208c:	3301      	adds	r3, #1
 801208e:	f8a2 307c 	strh.w	r3, [r2, #124]	@ 0x7c
 8012092:	e799      	b.n	8011fc8 <igmp_input+0x48>
          IGMP_STATS_INC(igmp.proterr);
 8012094:	4a0a      	ldr	r2, [pc, #40]	@ (80120c0 <igmp_input+0x140>)
 8012096:	f8b2 3084 	ldrh.w	r3, [r2, #132]	@ 0x84
 801209a:	3301      	adds	r3, #1
 801209c:	f8a2 3084 	strh.w	r3, [r2, #132]	@ 0x84
 80120a0:	e792      	b.n	8011fc8 <igmp_input+0x48>
      IGMP_STATS_INC(igmp.rx_report);
 80120a2:	4907      	ldr	r1, [pc, #28]	@ (80120c0 <igmp_input+0x140>)
 80120a4:	f8b1 308c 	ldrh.w	r3, [r1, #140]	@ 0x8c
 80120a8:	3301      	adds	r3, #1
 80120aa:	f8a1 308c 	strh.w	r3, [r1, #140]	@ 0x8c
      if (group->group_state == IGMP_GROUP_DELAYING_MEMBER) {
 80120ae:	7a43      	ldrb	r3, [r0, #9]
 80120b0:	2b01      	cmp	r3, #1
 80120b2:	d189      	bne.n	8011fc8 <igmp_input+0x48>
        group->timer = 0; /* stopped */
 80120b4:	2300      	movs	r3, #0
 80120b6:	8143      	strh	r3, [r0, #10]
        group->group_state = IGMP_GROUP_IDLE_MEMBER;
 80120b8:	2102      	movs	r1, #2
 80120ba:	7241      	strb	r1, [r0, #9]
        group->last_reporter_flag = 0;
 80120bc:	7203      	strb	r3, [r0, #8]
 80120be:	e783      	b.n	8011fc8 <igmp_input+0x48>
 80120c0:	240141b4 	.word	0x240141b4
 80120c4:	24014430 	.word	0x24014430

080120c8 <igmp_joingroup_netif>:
{
 80120c8:	b570      	push	{r4, r5, r6, lr}
  LWIP_ERROR("igmp_joingroup_netif: attempt to join non-multicast address", ip4_addr_ismulticast(groupaddr), return ERR_VAL;);
 80120ca:	680b      	ldr	r3, [r1, #0]
 80120cc:	f003 02f0 	and.w	r2, r3, #240	@ 0xf0
 80120d0:	2ae0      	cmp	r2, #224	@ 0xe0
 80120d2:	d12f      	bne.n	8012134 <igmp_joingroup_netif+0x6c>
 80120d4:	4604      	mov	r4, r0
 80120d6:	460e      	mov	r6, r1
  LWIP_ERROR("igmp_joingroup_netif: attempt to join allsystems address", (!ip4_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);
 80120d8:	4a27      	ldr	r2, [pc, #156]	@ (8012178 <igmp_joingroup_netif+0xb0>)
 80120da:	6812      	ldr	r2, [r2, #0]
 80120dc:	4293      	cmp	r3, r2
 80120de:	d033      	beq.n	8012148 <igmp_joingroup_netif+0x80>
  LWIP_ERROR("igmp_joingroup_netif: attempt to join on non-IGMP netif", netif->flags & NETIF_FLAG_IGMP, return ERR_VAL;);
 80120e0:	f890 302d 	ldrb.w	r3, [r0, #45]	@ 0x2d
 80120e4:	f013 0f20 	tst.w	r3, #32
 80120e8:	d038      	beq.n	801215c <igmp_joingroup_netif+0x94>
  group = igmp_lookup_group(netif, groupaddr);
 80120ea:	f7ff fee9 	bl	8011ec0 <igmp_lookup_group>
  if (group != NULL) {
 80120ee:	4605      	mov	r5, r0
 80120f0:	2800      	cmp	r0, #0
 80120f2:	d03d      	beq.n	8012170 <igmp_joingroup_netif+0xa8>
    if (group->group_state != IGMP_GROUP_NON_MEMBER) {
 80120f4:	7a43      	ldrb	r3, [r0, #9]
 80120f6:	b9c3      	cbnz	r3, 801212a <igmp_joingroup_netif+0x62>
      if ((group->use == 0) && (netif->igmp_mac_filter != NULL)) {
 80120f8:	7b03      	ldrb	r3, [r0, #12]
 80120fa:	b92b      	cbnz	r3, 8012108 <igmp_joingroup_netif+0x40>
 80120fc:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 80120fe:	b11b      	cbz	r3, 8012108 <igmp_joingroup_netif+0x40>
        netif->igmp_mac_filter(netif, groupaddr, NETIF_ADD_MAC_FILTER);
 8012100:	2201      	movs	r2, #1
 8012102:	4631      	mov	r1, r6
 8012104:	4620      	mov	r0, r4
 8012106:	4798      	blx	r3
      IGMP_STATS_INC(igmp.tx_join);
 8012108:	4a1c      	ldr	r2, [pc, #112]	@ (801217c <igmp_joingroup_netif+0xb4>)
 801210a:	f8b2 308e 	ldrh.w	r3, [r2, #142]	@ 0x8e
 801210e:	3301      	adds	r3, #1
 8012110:	f8a2 308e 	strh.w	r3, [r2, #142]	@ 0x8e
      igmp_send(netif, group, IGMP_V2_MEMB_REPORT);
 8012114:	2216      	movs	r2, #22
 8012116:	4629      	mov	r1, r5
 8012118:	4620      	mov	r0, r4
 801211a:	f7ff fe29 	bl	8011d70 <igmp_send>
      igmp_start_timer(group, IGMP_JOIN_DELAYING_MEMBER_TMR);
 801211e:	2105      	movs	r1, #5
 8012120:	4628      	mov	r0, r5
 8012122:	f7ff fddf 	bl	8011ce4 <igmp_start_timer>
      group->group_state = IGMP_GROUP_DELAYING_MEMBER;
 8012126:	2301      	movs	r3, #1
 8012128:	726b      	strb	r3, [r5, #9]
    group->use++;
 801212a:	7b2b      	ldrb	r3, [r5, #12]
 801212c:	3301      	adds	r3, #1
 801212e:	732b      	strb	r3, [r5, #12]
    return ERR_OK;
 8012130:	2000      	movs	r0, #0
}
 8012132:	bd70      	pop	{r4, r5, r6, pc}
  LWIP_ERROR("igmp_joingroup_netif: attempt to join non-multicast address", ip4_addr_ismulticast(groupaddr), return ERR_VAL;);
 8012134:	4b12      	ldr	r3, [pc, #72]	@ (8012180 <igmp_joingroup_netif+0xb8>)
 8012136:	f44f 72f6 	mov.w	r2, #492	@ 0x1ec
 801213a:	4912      	ldr	r1, [pc, #72]	@ (8012184 <igmp_joingroup_netif+0xbc>)
 801213c:	4812      	ldr	r0, [pc, #72]	@ (8012188 <igmp_joingroup_netif+0xc0>)
 801213e:	f001 ff1f 	bl	8013f80 <iprintf>
 8012142:	f06f 0005 	mvn.w	r0, #5
 8012146:	e7f4      	b.n	8012132 <igmp_joingroup_netif+0x6a>
  LWIP_ERROR("igmp_joingroup_netif: attempt to join allsystems address", (!ip4_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);
 8012148:	4b0d      	ldr	r3, [pc, #52]	@ (8012180 <igmp_joingroup_netif+0xb8>)
 801214a:	f240 12ed 	movw	r2, #493	@ 0x1ed
 801214e:	490f      	ldr	r1, [pc, #60]	@ (801218c <igmp_joingroup_netif+0xc4>)
 8012150:	480d      	ldr	r0, [pc, #52]	@ (8012188 <igmp_joingroup_netif+0xc0>)
 8012152:	f001 ff15 	bl	8013f80 <iprintf>
 8012156:	f06f 0005 	mvn.w	r0, #5
 801215a:	e7ea      	b.n	8012132 <igmp_joingroup_netif+0x6a>
  LWIP_ERROR("igmp_joingroup_netif: attempt to join on non-IGMP netif", netif->flags & NETIF_FLAG_IGMP, return ERR_VAL;);
 801215c:	4b08      	ldr	r3, [pc, #32]	@ (8012180 <igmp_joingroup_netif+0xb8>)
 801215e:	f44f 72f8 	mov.w	r2, #496	@ 0x1f0
 8012162:	490b      	ldr	r1, [pc, #44]	@ (8012190 <igmp_joingroup_netif+0xc8>)
 8012164:	4808      	ldr	r0, [pc, #32]	@ (8012188 <igmp_joingroup_netif+0xc0>)
 8012166:	f001 ff0b 	bl	8013f80 <iprintf>
 801216a:	f06f 0005 	mvn.w	r0, #5
 801216e:	e7e0      	b.n	8012132 <igmp_joingroup_netif+0x6a>
    return ERR_MEM;
 8012170:	f04f 30ff 	mov.w	r0, #4294967295
 8012174:	e7dd      	b.n	8012132 <igmp_joingroup_netif+0x6a>
 8012176:	bf00      	nop
 8012178:	24014430 	.word	0x24014430
 801217c:	240141b4 	.word	0x240141b4
 8012180:	080186dc 	.word	0x080186dc
 8012184:	080187c8 	.word	0x080187c8
 8012188:	08015744 	.word	0x08015744
 801218c:	08018804 	.word	0x08018804
 8012190:	08018840 	.word	0x08018840

08012194 <igmp_tmr>:
{
 8012194:	b538      	push	{r3, r4, r5, lr}
  NETIF_FOREACH(netif) {
 8012196:	4b0b      	ldr	r3, [pc, #44]	@ (80121c4 <igmp_tmr+0x30>)
 8012198:	681d      	ldr	r5, [r3, #0]
 801219a:	e00f      	b.n	80121bc <igmp_tmr+0x28>
      group = group->next;
 801219c:	6824      	ldr	r4, [r4, #0]
    while (group != NULL) {
 801219e:	b164      	cbz	r4, 80121ba <igmp_tmr+0x26>
      if (group->timer > 0) {
 80121a0:	8963      	ldrh	r3, [r4, #10]
 80121a2:	2b00      	cmp	r3, #0
 80121a4:	d0fa      	beq.n	801219c <igmp_tmr+0x8>
        group->timer--;
 80121a6:	3b01      	subs	r3, #1
 80121a8:	b29b      	uxth	r3, r3
 80121aa:	8163      	strh	r3, [r4, #10]
        if (group->timer == 0) {
 80121ac:	2b00      	cmp	r3, #0
 80121ae:	d1f5      	bne.n	801219c <igmp_tmr+0x8>
          igmp_timeout(netif, group);
 80121b0:	4621      	mov	r1, r4
 80121b2:	4628      	mov	r0, r5
 80121b4:	f7ff fe46 	bl	8011e44 <igmp_timeout>
 80121b8:	e7f0      	b.n	801219c <igmp_tmr+0x8>
  NETIF_FOREACH(netif) {
 80121ba:	682d      	ldr	r5, [r5, #0]
 80121bc:	b10d      	cbz	r5, 80121c2 <igmp_tmr+0x2e>
    struct igmp_group *group = netif_igmp_data(netif);
 80121be:	6a2c      	ldr	r4, [r5, #32]
    while (group != NULL) {
 80121c0:	e7ed      	b.n	801219e <igmp_tmr+0xa>
}
 80121c2:	bd38      	pop	{r3, r4, r5, pc}
 80121c4:	240141ac 	.word	0x240141ac

080121c8 <ip4_input_accept>:
#endif /* IP_FORWARD */

/** Return true if the current input packet should be accepted on this netif */
static int
ip4_input_accept(struct netif *netif)
{
 80121c8:	b508      	push	{r3, lr}
                         ip4_addr_get_u32(ip4_current_dest_addr()) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
                         ip4_addr_get_u32(netif_ip4_addr(netif)) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
                         ip4_addr_get_u32(ip4_current_dest_addr()) & ~ip4_addr_get_u32(netif_ip4_netmask(netif))));

  /* interface is up and configured? */
  if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif)))) {
 80121ca:	f890 302d 	ldrb.w	r3, [r0, #45]	@ 0x2d
 80121ce:	f013 0f01 	tst.w	r3, #1
 80121d2:	d00d      	beq.n	80121f0 <ip4_input_accept+0x28>
 80121d4:	4601      	mov	r1, r0
 80121d6:	6843      	ldr	r3, [r0, #4]
 80121d8:	b163      	cbz	r3, 80121f4 <ip4_input_accept+0x2c>
    /* unicast to this interface address? */
    if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 80121da:	4a07      	ldr	r2, [pc, #28]	@ (80121f8 <ip4_input_accept+0x30>)
 80121dc:	6950      	ldr	r0, [r2, #20]
 80121de:	4283      	cmp	r3, r0
 80121e0:	d004      	beq.n	80121ec <ip4_input_accept+0x24>
        /* or broadcast on this interface network address? */
        ip4_addr_isbroadcast(ip4_current_dest_addr(), netif)
 80121e2:	f000 fa7f 	bl	80126e4 <ip4_addr_isbroadcast_u32>
    if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 80121e6:	b908      	cbnz	r0, 80121ec <ip4_input_accept+0x24>
      /* accept on this netif */
      return 1;
    }
#endif /* LWIP_AUTOIP */
  }
  return 0;
 80121e8:	2000      	movs	r0, #0
 80121ea:	e002      	b.n	80121f2 <ip4_input_accept+0x2a>
      return 1;
 80121ec:	2001      	movs	r0, #1
 80121ee:	e000      	b.n	80121f2 <ip4_input_accept+0x2a>
  return 0;
 80121f0:	2000      	movs	r0, #0
}
 80121f2:	bd08      	pop	{r3, pc}
  return 0;
 80121f4:	2000      	movs	r0, #0
 80121f6:	e7fc      	b.n	80121f2 <ip4_input_accept+0x2a>
 80121f8:	2400c4b0 	.word	0x2400c4b0

080121fc <ip4_route>:
{
 80121fc:	b410      	push	{r4}
  if (ip4_addr_ismulticast(dest) && ip4_default_multicast_netif) {
 80121fe:	6804      	ldr	r4, [r0, #0]
 8012200:	f004 03f0 	and.w	r3, r4, #240	@ 0xf0
 8012204:	2be0      	cmp	r3, #224	@ 0xe0
 8012206:	d002      	beq.n	801220e <ip4_route+0x12>
  NETIF_FOREACH(netif) {
 8012208:	4b1c      	ldr	r3, [pc, #112]	@ (801227c <ip4_route+0x80>)
 801220a:	681b      	ldr	r3, [r3, #0]
 801220c:	e004      	b.n	8012218 <ip4_route+0x1c>
  if (ip4_addr_ismulticast(dest) && ip4_default_multicast_netif) {
 801220e:	4b1c      	ldr	r3, [pc, #112]	@ (8012280 <ip4_route+0x84>)
 8012210:	6818      	ldr	r0, [r3, #0]
 8012212:	bb70      	cbnz	r0, 8012272 <ip4_route+0x76>
 8012214:	e7f8      	b.n	8012208 <ip4_route+0xc>
  NETIF_FOREACH(netif) {
 8012216:	681b      	ldr	r3, [r3, #0]
 8012218:	b1b3      	cbz	r3, 8012248 <ip4_route+0x4c>
    if (netif_is_up(netif) && netif_is_link_up(netif) && !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 801221a:	f893 202d 	ldrb.w	r2, [r3, #45]	@ 0x2d
 801221e:	f012 0f01 	tst.w	r2, #1
 8012222:	d0f8      	beq.n	8012216 <ip4_route+0x1a>
 8012224:	f012 0f04 	tst.w	r2, #4
 8012228:	d0f5      	beq.n	8012216 <ip4_route+0x1a>
 801222a:	6859      	ldr	r1, [r3, #4]
 801222c:	2900      	cmp	r1, #0
 801222e:	d0f2      	beq.n	8012216 <ip4_route+0x1a>
      if (ip4_addr_netcmp(dest, netif_ip4_addr(netif), netif_ip4_netmask(netif))) {
 8012230:	6898      	ldr	r0, [r3, #8]
 8012232:	4061      	eors	r1, r4
 8012234:	4201      	tst	r1, r0
 8012236:	d01f      	beq.n	8012278 <ip4_route+0x7c>
      if (((netif->flags & NETIF_FLAG_BROADCAST) == 0) && ip4_addr_cmp(dest, netif_ip4_gw(netif))) {
 8012238:	f012 0f02 	tst.w	r2, #2
 801223c:	d1eb      	bne.n	8012216 <ip4_route+0x1a>
 801223e:	68da      	ldr	r2, [r3, #12]
 8012240:	4294      	cmp	r4, r2
 8012242:	d1e8      	bne.n	8012216 <ip4_route+0x1a>
        return netif;
 8012244:	4618      	mov	r0, r3
 8012246:	e014      	b.n	8012272 <ip4_route+0x76>
  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
 8012248:	4a0e      	ldr	r2, [pc, #56]	@ (8012284 <ip4_route+0x88>)
 801224a:	6810      	ldr	r0, [r2, #0]
 801224c:	b150      	cbz	r0, 8012264 <ip4_route+0x68>
 801224e:	f890 202d 	ldrb.w	r2, [r0, #45]	@ 0x2d
 8012252:	f002 0205 	and.w	r2, r2, #5
 8012256:	2a05      	cmp	r2, #5
 8012258:	d104      	bne.n	8012264 <ip4_route+0x68>
      ip4_addr_isany_val(*netif_ip4_addr(netif_default)) || ip4_addr_isloopback(dest)) {
 801225a:	6842      	ldr	r2, [r0, #4]
  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
 801225c:	b112      	cbz	r2, 8012264 <ip4_route+0x68>
      ip4_addr_isany_val(*netif_ip4_addr(netif_default)) || ip4_addr_isloopback(dest)) {
 801225e:	b2e4      	uxtb	r4, r4
 8012260:	2c7f      	cmp	r4, #127	@ 0x7f
 8012262:	d106      	bne.n	8012272 <ip4_route+0x76>
    IP_STATS_INC(ip.rterr);
 8012264:	4908      	ldr	r1, [pc, #32]	@ (8012288 <ip4_route+0x8c>)
 8012266:	f8b1 2056 	ldrh.w	r2, [r1, #86]	@ 0x56
 801226a:	3201      	adds	r2, #1
 801226c:	f8a1 2056 	strh.w	r2, [r1, #86]	@ 0x56
    return NULL;
 8012270:	4618      	mov	r0, r3
}
 8012272:	f85d 4b04 	ldr.w	r4, [sp], #4
 8012276:	4770      	bx	lr
        return netif;
 8012278:	4618      	mov	r0, r3
 801227a:	e7fa      	b.n	8012272 <ip4_route+0x76>
 801227c:	240141ac 	.word	0x240141ac
 8012280:	24014434 	.word	0x24014434
 8012284:	240141a8 	.word	0x240141a8
 8012288:	240141b4 	.word	0x240141b4

0801228c <ip4_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip4_input(struct pbuf *p, struct netif *inp)
{
 801228c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8012290:	4604      	mov	r4, r0
  raw_input_state_t raw_status;
#endif /* LWIP_RAW */

  LWIP_ASSERT_CORE_LOCKED();

  IP_STATS_INC(ip.recv);
 8012292:	4a8a      	ldr	r2, [pc, #552]	@ (80124bc <ip4_input+0x230>)
 8012294:	f8b2 304a 	ldrh.w	r3, [r2, #74]	@ 0x4a
 8012298:	3301      	adds	r3, #1
 801229a:	f8a2 304a 	strh.w	r3, [r2, #74]	@ 0x4a
  MIB2_STATS_INC(mib2.ipinreceives);

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
 801229e:	6847      	ldr	r7, [r0, #4]
  if (IPH_V(iphdr) != 4) {
 80122a0:	783b      	ldrb	r3, [r7, #0]
 80122a2:	091a      	lsrs	r2, r3, #4
 80122a4:	2a04      	cmp	r2, #4
 80122a6:	d00f      	beq.n	80122c8 <ip4_input+0x3c>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", (u16_t)IPH_V(iphdr)));
    ip4_debug_print(p);
    pbuf_free(p);
 80122a8:	f7f9 fc42 	bl	800bb30 <pbuf_free>
    IP_STATS_INC(ip.err);
 80122ac:	4b83      	ldr	r3, [pc, #524]	@ (80124bc <ip4_input+0x230>)
 80122ae:	f8b3 205c 	ldrh.w	r2, [r3, #92]	@ 0x5c
 80122b2:	3201      	adds	r2, #1
 80122b4:	f8a3 205c 	strh.w	r2, [r3, #92]	@ 0x5c
    IP_STATS_INC(ip.drop);
 80122b8:	f8b3 204e 	ldrh.w	r2, [r3, #78]	@ 0x4e
 80122bc:	3201      	adds	r2, #1
 80122be:	f8a3 204e 	strh.w	r2, [r3, #78]	@ 0x4e
  ip_data.current_ip_header_tot_len = 0;
  ip4_addr_set_any(ip4_current_src_addr());
  ip4_addr_set_any(ip4_current_dest_addr());

  return ERR_OK;
}
 80122c2:	2000      	movs	r0, #0
 80122c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80122c8:	460e      	mov	r6, r1
  iphdr_hlen = IPH_HL_BYTES(iphdr);
 80122ca:	f003 030f 	and.w	r3, r3, #15
 80122ce:	009d      	lsls	r5, r3, #2
  iphdr_len = lwip_ntohs(IPH_LEN(iphdr));
 80122d0:	8878      	ldrh	r0, [r7, #2]
 80122d2:	f7f8 fc45 	bl	800ab60 <lwip_htons>
 80122d6:	4680      	mov	r8, r0
  if (iphdr_len < p->tot_len) {
 80122d8:	8923      	ldrh	r3, [r4, #8]
 80122da:	4283      	cmp	r3, r0
 80122dc:	d851      	bhi.n	8012382 <ip4_input+0xf6>
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len) || (iphdr_hlen < IP_HLEN)) {
 80122de:	8963      	ldrh	r3, [r4, #10]
 80122e0:	42ab      	cmp	r3, r5
 80122e2:	d353      	bcc.n	801238c <ip4_input+0x100>
 80122e4:	8923      	ldrh	r3, [r4, #8]
 80122e6:	4543      	cmp	r3, r8
 80122e8:	d350      	bcc.n	801238c <ip4_input+0x100>
 80122ea:	2d13      	cmp	r5, #19
 80122ec:	d94e      	bls.n	801238c <ip4_input+0x100>
  ip_addr_copy_from_ip4(ip_data.current_iphdr_dest, iphdr->dest);
 80122ee:	693b      	ldr	r3, [r7, #16]
 80122f0:	4a73      	ldr	r2, [pc, #460]	@ (80124c0 <ip4_input+0x234>)
 80122f2:	6153      	str	r3, [r2, #20]
  ip_addr_copy_from_ip4(ip_data.current_iphdr_src, iphdr->src);
 80122f4:	68f9      	ldr	r1, [r7, #12]
 80122f6:	6111      	str	r1, [r2, #16]
  if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
 80122f8:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 80122fc:	2be0      	cmp	r3, #224	@ 0xe0
 80122fe:	d16a      	bne.n	80123d6 <ip4_input+0x14a>
    if ((inp->flags & NETIF_FLAG_IGMP) && (igmp_lookfor_group(inp, ip4_current_dest_addr()))) {
 8012300:	f896 302d 	ldrb.w	r3, [r6, #45]	@ 0x2d
 8012304:	f013 0f20 	tst.w	r3, #32
 8012308:	d14f      	bne.n	80123aa <ip4_input+0x11e>
      netif = NULL;
 801230a:	f04f 0800 	mov.w	r8, #0
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
 801230e:	4631      	mov	r1, r6
 8012310:	4b6b      	ldr	r3, [pc, #428]	@ (80124c0 <ip4_input+0x234>)
 8012312:	6918      	ldr	r0, [r3, #16]
 8012314:	f000 f9e6 	bl	80126e4 <ip4_addr_isbroadcast_u32>
 8012318:	2800      	cmp	r0, #0
 801231a:	d17a      	bne.n	8012412 <ip4_input+0x186>
        (ip4_addr_ismulticast(ip4_current_src_addr()))) {
 801231c:	4b68      	ldr	r3, [pc, #416]	@ (80124c0 <ip4_input+0x234>)
 801231e:	691b      	ldr	r3, [r3, #16]
 8012320:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
 8012324:	2be0      	cmp	r3, #224	@ 0xe0
 8012326:	d074      	beq.n	8012412 <ip4_input+0x186>
  if (netif == NULL) {
 8012328:	f1b8 0f00 	cmp.w	r8, #0
 801232c:	d07b      	beq.n	8012426 <ip4_input+0x19a>
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
 801232e:	88fb      	ldrh	r3, [r7, #6]
 8012330:	f023 03c0 	bic.w	r3, r3, #192	@ 0xc0
 8012334:	b29b      	uxth	r3, r3
 8012336:	b133      	cbz	r3, 8012346 <ip4_input+0xba>
    p = ip4_reass(p);
 8012338:	4620      	mov	r0, r4
 801233a:	f000 fcd7 	bl	8012cec <ip4_reass>
    if (p == NULL) {
 801233e:	4604      	mov	r4, r0
 8012340:	2800      	cmp	r0, #0
 8012342:	d0be      	beq.n	80122c2 <ip4_input+0x36>
    iphdr = (const struct ip_hdr *)p->payload;
 8012344:	6847      	ldr	r7, [r0, #4]
  ip_data.current_netif = netif;
 8012346:	4a5e      	ldr	r2, [pc, #376]	@ (80124c0 <ip4_input+0x234>)
 8012348:	f8c2 8000 	str.w	r8, [r2]
  ip_data.current_input_netif = inp;
 801234c:	6056      	str	r6, [r2, #4]
  ip_data.current_ip4_header = iphdr;
 801234e:	6097      	str	r7, [r2, #8]
  ip_data.current_ip_header_tot_len = IPH_HL_BYTES(iphdr);
 8012350:	783b      	ldrb	r3, [r7, #0]
 8012352:	f003 030f 	and.w	r3, r3, #15
 8012356:	009b      	lsls	r3, r3, #2
 8012358:	8193      	strh	r3, [r2, #12]
    pbuf_remove_header(p, iphdr_hlen); /* Move to payload, no check necessary. */
 801235a:	4629      	mov	r1, r5
 801235c:	4620      	mov	r0, r4
 801235e:	f7f9 fba1 	bl	800baa4 <pbuf_remove_header>
    switch (IPH_PROTO(iphdr)) {
 8012362:	7a7b      	ldrb	r3, [r7, #9]
 8012364:	3b01      	subs	r3, #1
 8012366:	2b10      	cmp	r3, #16
 8012368:	f200 8084 	bhi.w	8012474 <ip4_input+0x1e8>
 801236c:	e8df f003 	tbb	[pc, r3]
 8012370:	82827c77 	.word	0x82827c77
 8012374:	82827282 	.word	0x82827282
 8012378:	82828282 	.word	0x82828282
 801237c:	82828282 	.word	0x82828282
 8012380:	65          	.byte	0x65
 8012381:	00          	.byte	0x00
    pbuf_realloc(p, iphdr_len);
 8012382:	4601      	mov	r1, r0
 8012384:	4620      	mov	r0, r4
 8012386:	f7f9 fce7 	bl	800bd58 <pbuf_realloc>
 801238a:	e7a8      	b.n	80122de <ip4_input+0x52>
    pbuf_free(p);
 801238c:	4620      	mov	r0, r4
 801238e:	f7f9 fbcf 	bl	800bb30 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
 8012392:	4b4a      	ldr	r3, [pc, #296]	@ (80124bc <ip4_input+0x230>)
 8012394:	f8b3 2052 	ldrh.w	r2, [r3, #82]	@ 0x52
 8012398:	3201      	adds	r2, #1
 801239a:	f8a3 2052 	strh.w	r2, [r3, #82]	@ 0x52
    IP_STATS_INC(ip.drop);
 801239e:	f8b3 204e 	ldrh.w	r2, [r3, #78]	@ 0x4e
 80123a2:	3201      	adds	r2, #1
 80123a4:	f8a3 204e 	strh.w	r2, [r3, #78]	@ 0x4e
    return ERR_OK;
 80123a8:	e78b      	b.n	80122c2 <ip4_input+0x36>
    if ((inp->flags & NETIF_FLAG_IGMP) && (igmp_lookfor_group(inp, ip4_current_dest_addr()))) {
 80123aa:	f102 0114 	add.w	r1, r2, #20
 80123ae:	4630      	mov	r0, r6
 80123b0:	f7ff fd7d 	bl	8011eae <igmp_lookfor_group>
 80123b4:	4680      	mov	r8, r0
 80123b6:	2800      	cmp	r0, #0
 80123b8:	d0a9      	beq.n	801230e <ip4_input+0x82>
      if (ip4_addr_cmp(ip4_current_dest_addr(), &allsystems) &&
 80123ba:	4b41      	ldr	r3, [pc, #260]	@ (80124c0 <ip4_input+0x234>)
 80123bc:	695a      	ldr	r2, [r3, #20]
 80123be:	4b41      	ldr	r3, [pc, #260]	@ (80124c4 <ip4_input+0x238>)
 80123c0:	429a      	cmp	r2, r3
 80123c2:	d001      	beq.n	80123c8 <ip4_input+0x13c>
      netif = inp;
 80123c4:	46b0      	mov	r8, r6
 80123c6:	e7a2      	b.n	801230e <ip4_input+0x82>
          ip4_addr_isany(ip4_current_src_addr())) {
 80123c8:	4b3d      	ldr	r3, [pc, #244]	@ (80124c0 <ip4_input+0x234>)
 80123ca:	691b      	ldr	r3, [r3, #16]
 80123cc:	b90b      	cbnz	r3, 80123d2 <ip4_input+0x146>
      netif = inp;
 80123ce:	46b0      	mov	r8, r6
 80123d0:	e7aa      	b.n	8012328 <ip4_input+0x9c>
 80123d2:	46b0      	mov	r8, r6
 80123d4:	e79b      	b.n	801230e <ip4_input+0x82>
    if (ip4_input_accept(inp)) {
 80123d6:	4630      	mov	r0, r6
 80123d8:	f7ff fef6 	bl	80121c8 <ip4_input_accept>
 80123dc:	b9a0      	cbnz	r0, 8012408 <ip4_input+0x17c>
      if (!ip4_addr_isloopback(ip4_current_dest_addr()))
 80123de:	4b38      	ldr	r3, [pc, #224]	@ (80124c0 <ip4_input+0x234>)
 80123e0:	7d1b      	ldrb	r3, [r3, #20]
 80123e2:	2b7f      	cmp	r3, #127	@ 0x7f
 80123e4:	d012      	beq.n	801240c <ip4_input+0x180>
        NETIF_FOREACH(netif) {
 80123e6:	4b38      	ldr	r3, [pc, #224]	@ (80124c8 <ip4_input+0x23c>)
 80123e8:	f8d3 8000 	ldr.w	r8, [r3]
 80123ec:	e001      	b.n	80123f2 <ip4_input+0x166>
 80123ee:	f8d8 8000 	ldr.w	r8, [r8]
 80123f2:	f1b8 0f00 	cmp.w	r8, #0
 80123f6:	d08a      	beq.n	801230e <ip4_input+0x82>
          if (netif == inp) {
 80123f8:	4546      	cmp	r6, r8
 80123fa:	d0f8      	beq.n	80123ee <ip4_input+0x162>
          if (ip4_input_accept(netif)) {
 80123fc:	4640      	mov	r0, r8
 80123fe:	f7ff fee3 	bl	80121c8 <ip4_input_accept>
 8012402:	2800      	cmp	r0, #0
 8012404:	d0f3      	beq.n	80123ee <ip4_input+0x162>
 8012406:	e782      	b.n	801230e <ip4_input+0x82>
      netif = inp;
 8012408:	46b0      	mov	r8, r6
 801240a:	e780      	b.n	801230e <ip4_input+0x82>
      netif = NULL;
 801240c:	f04f 0800 	mov.w	r8, #0
 8012410:	e77d      	b.n	801230e <ip4_input+0x82>
      pbuf_free(p);
 8012412:	4620      	mov	r0, r4
 8012414:	f7f9 fb8c 	bl	800bb30 <pbuf_free>
      IP_STATS_INC(ip.drop);
 8012418:	4a28      	ldr	r2, [pc, #160]	@ (80124bc <ip4_input+0x230>)
 801241a:	f8b2 304e 	ldrh.w	r3, [r2, #78]	@ 0x4e
 801241e:	3301      	adds	r3, #1
 8012420:	f8a2 304e 	strh.w	r3, [r2, #78]	@ 0x4e
      return ERR_OK;
 8012424:	e74d      	b.n	80122c2 <ip4_input+0x36>
      IP_STATS_INC(ip.drop);
 8012426:	4a25      	ldr	r2, [pc, #148]	@ (80124bc <ip4_input+0x230>)
 8012428:	f8b2 304e 	ldrh.w	r3, [r2, #78]	@ 0x4e
 801242c:	3301      	adds	r3, #1
 801242e:	f8a2 304e 	strh.w	r3, [r2, #78]	@ 0x4e
    pbuf_free(p);
 8012432:	4620      	mov	r0, r4
 8012434:	f7f9 fb7c 	bl	800bb30 <pbuf_free>
    return ERR_OK;
 8012438:	e743      	b.n	80122c2 <ip4_input+0x36>
        udp_input(p, inp);
 801243a:	4631      	mov	r1, r6
 801243c:	4620      	mov	r0, r4
 801243e:	f7fe fce5 	bl	8010e0c <udp_input>
  ip_data.current_netif = NULL;
 8012442:	4b1f      	ldr	r3, [pc, #124]	@ (80124c0 <ip4_input+0x234>)
 8012444:	2200      	movs	r2, #0
 8012446:	601a      	str	r2, [r3, #0]
  ip_data.current_input_netif = NULL;
 8012448:	605a      	str	r2, [r3, #4]
  ip_data.current_ip4_header = NULL;
 801244a:	609a      	str	r2, [r3, #8]
  ip_data.current_ip_header_tot_len = 0;
 801244c:	819a      	strh	r2, [r3, #12]
  ip4_addr_set_any(ip4_current_src_addr());
 801244e:	611a      	str	r2, [r3, #16]
  ip4_addr_set_any(ip4_current_dest_addr());
 8012450:	615a      	str	r2, [r3, #20]
  return ERR_OK;
 8012452:	e736      	b.n	80122c2 <ip4_input+0x36>
        tcp_input(p, inp);
 8012454:	4631      	mov	r1, r6
 8012456:	4620      	mov	r0, r4
 8012458:	f7fc fa02 	bl	800e860 <tcp_input>
        break;
 801245c:	e7f1      	b.n	8012442 <ip4_input+0x1b6>
        icmp_input(p, inp);
 801245e:	4631      	mov	r1, r6
 8012460:	4620      	mov	r0, r4
 8012462:	f7ff fb5b 	bl	8011b1c <icmp_input>
        break;
 8012466:	e7ec      	b.n	8012442 <ip4_input+0x1b6>
        igmp_input(p, inp, ip4_current_dest_addr());
 8012468:	4a18      	ldr	r2, [pc, #96]	@ (80124cc <ip4_input+0x240>)
 801246a:	4631      	mov	r1, r6
 801246c:	4620      	mov	r0, r4
 801246e:	f7ff fd87 	bl	8011f80 <igmp_input>
        break;
 8012472:	e7e6      	b.n	8012442 <ip4_input+0x1b6>
          if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
 8012474:	4641      	mov	r1, r8
 8012476:	4b12      	ldr	r3, [pc, #72]	@ (80124c0 <ip4_input+0x234>)
 8012478:	6958      	ldr	r0, [r3, #20]
 801247a:	f000 f933 	bl	80126e4 <ip4_addr_isbroadcast_u32>
 801247e:	b928      	cbnz	r0, 801248c <ip4_input+0x200>
              !ip4_addr_ismulticast(ip4_current_dest_addr())) {
 8012480:	4b0f      	ldr	r3, [pc, #60]	@ (80124c0 <ip4_input+0x234>)
 8012482:	695b      	ldr	r3, [r3, #20]
 8012484:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
          if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
 8012488:	2be0      	cmp	r3, #224	@ 0xe0
 801248a:	d10e      	bne.n	80124aa <ip4_input+0x21e>
          IP_STATS_INC(ip.proterr);
 801248c:	4b0b      	ldr	r3, [pc, #44]	@ (80124bc <ip4_input+0x230>)
 801248e:	f8b3 2058 	ldrh.w	r2, [r3, #88]	@ 0x58
 8012492:	3201      	adds	r2, #1
 8012494:	f8a3 2058 	strh.w	r2, [r3, #88]	@ 0x58
          IP_STATS_INC(ip.drop);
 8012498:	f8b3 204e 	ldrh.w	r2, [r3, #78]	@ 0x4e
 801249c:	3201      	adds	r2, #1
 801249e:	f8a3 204e 	strh.w	r2, [r3, #78]	@ 0x4e
        pbuf_free(p);
 80124a2:	4620      	mov	r0, r4
 80124a4:	f7f9 fb44 	bl	800bb30 <pbuf_free>
        break;
 80124a8:	e7cb      	b.n	8012442 <ip4_input+0x1b6>
            pbuf_header_force(p, (s16_t)iphdr_hlen); /* Move to ip header, no check necessary. */
 80124aa:	4629      	mov	r1, r5
 80124ac:	4620      	mov	r0, r4
 80124ae:	f7f9 fb39 	bl	800bb24 <pbuf_header_force>
            icmp_dest_unreach(p, ICMP_DUR_PROTO);
 80124b2:	2102      	movs	r1, #2
 80124b4:	4620      	mov	r0, r4
 80124b6:	f7ff fc09 	bl	8011ccc <icmp_dest_unreach>
 80124ba:	e7e7      	b.n	801248c <ip4_input+0x200>
 80124bc:	240141b4 	.word	0x240141b4
 80124c0:	2400c4b0 	.word	0x2400c4b0
 80124c4:	010000e0 	.word	0x010000e0
 80124c8:	240141ac 	.word	0x240141ac
 80124cc:	2400c4c4 	.word	0x2400c4c4

080124d0 <ip4_output_if_opt_src>:
 */
err_t
ip4_output_if_opt_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
                      u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
                      u16_t optlen)
{
 80124d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80124d4:	b083      	sub	sp, #12
 80124d6:	4604      	mov	r4, r0
 80124d8:	4688      	mov	r8, r1
 80124da:	4617      	mov	r7, r2
 80124dc:	469a      	mov	sl, r3
 80124de:	f8dd 9038 	ldr.w	r9, [sp, #56]	@ 0x38
 80124e2:	f8bd 5040 	ldrh.w	r5, [sp, #64]	@ 0x40
#if CHECKSUM_GEN_IP_INLINE
  u32_t chk_sum = 0;
#endif /* CHECKSUM_GEN_IP_INLINE */

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
 80124e6:	7b83      	ldrb	r3, [r0, #14]
 80124e8:	2b01      	cmp	r3, #1
 80124ea:	d160      	bne.n	80125ae <ip4_output_if_opt_src+0xde>

  MIB2_STATS_INC(mib2.ipoutrequests);

  /* Should the IP header be generated or is it already included in p? */
  if (dest != LWIP_IP_HDRINCL) {
 80124ec:	2f00      	cmp	r7, #0
 80124ee:	f000 8097 	beq.w	8012620 <ip4_output_if_opt_src+0x150>
    u16_t ip_hlen = IP_HLEN;
#if IP_OPTIONS_SEND
    u16_t optlen_aligned = 0;
    if (optlen != 0) {
 80124f2:	2d00      	cmp	r5, #0
 80124f4:	d07d      	beq.n	80125f2 <ip4_output_if_opt_src+0x122>
#if CHECKSUM_GEN_IP_INLINE
      int i;
#endif /* CHECKSUM_GEN_IP_INLINE */
      if (optlen > (IP_HLEN_MAX - IP_HLEN)) {
 80124f6:	2d28      	cmp	r5, #40	@ 0x28
 80124f8:	d861      	bhi.n	80125be <ip4_output_if_opt_src+0xee>
        IP_STATS_INC(ip.err);
        MIB2_STATS_INC(mib2.ipoutdiscards);
        return ERR_VAL;
      }
      /* round up to a multiple of 4 */
      optlen_aligned = (u16_t)((optlen + 3) & ~3);
 80124fa:	1cee      	adds	r6, r5, #3
 80124fc:	b2b6      	uxth	r6, r6
 80124fe:	f026 0603 	bic.w	r6, r6, #3
 8012502:	fa1f fb86 	uxth.w	fp, r6
      ip_hlen = (u16_t)(ip_hlen + optlen_aligned);
 8012506:	3614      	adds	r6, #20
 8012508:	b2b6      	uxth	r6, r6
      /* First write in the IP options */
      if (pbuf_add_header(p, optlen_aligned)) {
 801250a:	4659      	mov	r1, fp
 801250c:	4620      	mov	r0, r4
 801250e:	f7f9 fac4 	bl	800ba9a <pbuf_add_header>
 8012512:	2800      	cmp	r0, #0
 8012514:	d15c      	bne.n	80125d0 <ip4_output_if_opt_src+0x100>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output_if_opt: not enough room for IP options in pbuf\n"));
        IP_STATS_INC(ip.err);
        MIB2_STATS_INC(mib2.ipoutdiscards);
        return ERR_BUF;
      }
      MEMCPY(p->payload, ip_options, optlen);
 8012516:	462a      	mov	r2, r5
 8012518:	990f      	ldr	r1, [sp, #60]	@ 0x3c
 801251a:	6860      	ldr	r0, [r4, #4]
 801251c:	f001 ff71 	bl	8014402 <memcpy>
      if (optlen < optlen_aligned) {
 8012520:	455d      	cmp	r5, fp
 8012522:	d35e      	bcc.n	80125e2 <ip4_output_if_opt_src+0x112>
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_add_header(p, IP_HLEN)) {
 8012524:	2114      	movs	r1, #20
 8012526:	4620      	mov	r0, r4
 8012528:	f7f9 fab7 	bl	800ba9a <pbuf_add_header>
 801252c:	2800      	cmp	r0, #0
 801252e:	d162      	bne.n	80125f6 <ip4_output_if_opt_src+0x126>
      IP_STATS_INC(ip.err);
      MIB2_STATS_INC(mib2.ipoutdiscards);
      return ERR_BUF;
    }

    iphdr = (struct ip_hdr *)p->payload;
 8012530:	6865      	ldr	r5, [r4, #4]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
 8012532:	8963      	ldrh	r3, [r4, #10]
 8012534:	2b13      	cmp	r3, #19
 8012536:	d967      	bls.n	8012608 <ip4_output_if_opt_src+0x138>
                (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
 8012538:	f885 a008 	strb.w	sl, [r5, #8]
    IPH_PROTO_SET(iphdr, proto);
 801253c:	f89d 3034 	ldrb.w	r3, [sp, #52]	@ 0x34
 8012540:	726b      	strb	r3, [r5, #9]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(proto | (ttl << 8));
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip4_addr_copy(iphdr->dest, *dest);
 8012542:	683b      	ldr	r3, [r7, #0]
 8012544:	612b      	str	r3, [r5, #16]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 8012546:	08b6      	lsrs	r6, r6, #2
 8012548:	f046 0640 	orr.w	r6, r6, #64	@ 0x40
 801254c:	702e      	strb	r6, [r5, #0]
    IPH_TOS_SET(iphdr, tos);
 801254e:	f89d 3030 	ldrb.w	r3, [sp, #48]	@ 0x30
 8012552:	706b      	strb	r3, [r5, #1]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(tos | (iphdr->_v_hl << 8));
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, lwip_htons(p->tot_len));
 8012554:	8920      	ldrh	r0, [r4, #8]
 8012556:	f7f8 fb03 	bl	800ab60 <lwip_htons>
 801255a:	8068      	strh	r0, [r5, #2]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
 801255c:	2300      	movs	r3, #0
 801255e:	71ab      	strb	r3, [r5, #6]
 8012560:	71eb      	strb	r3, [r5, #7]
    IPH_ID_SET(iphdr, lwip_htons(ip_id));
 8012562:	4e3b      	ldr	r6, [pc, #236]	@ (8012650 <ip4_output_if_opt_src+0x180>)
 8012564:	8830      	ldrh	r0, [r6, #0]
 8012566:	f7f8 fafb 	bl	800ab60 <lwip_htons>
 801256a:	80a8      	strh	r0, [r5, #4]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 801256c:	8833      	ldrh	r3, [r6, #0]
 801256e:	3301      	adds	r3, #1
 8012570:	8033      	strh	r3, [r6, #0]

    if (src == NULL) {
 8012572:	f1b8 0f00 	cmp.w	r8, #0
 8012576:	d04f      	beq.n	8012618 <ip4_output_if_opt_src+0x148>
      ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY4);
    } else {
      /* src cannot be NULL here */
      ip4_addr_copy(iphdr->src, *src);
 8012578:	f8d8 3000 	ldr.w	r3, [r8]
 801257c:	60eb      	str	r3, [r5, #12]
    else {
      IPH_CHKSUM_SET(iphdr, 0);
    }
#endif /* LWIP_CHECKSUM_CTRL_PER_NETIF*/
#else /* CHECKSUM_GEN_IP_INLINE */
    IPH_CHKSUM_SET(iphdr, 0);
 801257e:	2300      	movs	r3, #0
 8012580:	72ab      	strb	r3, [r5, #10]
 8012582:	72eb      	strb	r3, [r5, #11]
    iphdr = (struct ip_hdr *)p->payload;
    ip4_addr_copy(dest_addr, iphdr->dest);
    dest = &dest_addr;
  }

  IP_STATS_INC(ip.xmit);
 8012584:	4a33      	ldr	r2, [pc, #204]	@ (8012654 <ip4_output_if_opt_src+0x184>)
 8012586:	f8b2 3048 	ldrh.w	r3, [r2, #72]	@ 0x48
 801258a:	3301      	adds	r3, #1
 801258c:	f8a2 3048 	strh.w	r3, [r2, #72]	@ 0x48
  }
#endif /* LWIP_MULTICAST_TX_OPTIONS */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
 8012590:	f8b9 3024 	ldrh.w	r3, [r9, #36]	@ 0x24
 8012594:	b113      	cbz	r3, 801259c <ip4_output_if_opt_src+0xcc>
 8012596:	8922      	ldrh	r2, [r4, #8]
 8012598:	4293      	cmp	r3, r2
 801259a:	d352      	bcc.n	8012642 <ip4_output_if_opt_src+0x172>
    return ip4_frag(p, netif, dest);
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: call netif->output()\n"));
  return netif->output(netif, p, dest);
 801259c:	f8d9 3014 	ldr.w	r3, [r9, #20]
 80125a0:	463a      	mov	r2, r7
 80125a2:	4621      	mov	r1, r4
 80125a4:	4648      	mov	r0, r9
 80125a6:	4798      	blx	r3
}
 80125a8:	b003      	add	sp, #12
 80125aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
 80125ae:	4b2a      	ldr	r3, [pc, #168]	@ (8012658 <ip4_output_if_opt_src+0x188>)
 80125b0:	f44f 7255 	mov.w	r2, #852	@ 0x354
 80125b4:	4929      	ldr	r1, [pc, #164]	@ (801265c <ip4_output_if_opt_src+0x18c>)
 80125b6:	482a      	ldr	r0, [pc, #168]	@ (8012660 <ip4_output_if_opt_src+0x190>)
 80125b8:	f001 fce2 	bl	8013f80 <iprintf>
 80125bc:	e796      	b.n	80124ec <ip4_output_if_opt_src+0x1c>
        IP_STATS_INC(ip.err);
 80125be:	4a25      	ldr	r2, [pc, #148]	@ (8012654 <ip4_output_if_opt_src+0x184>)
 80125c0:	f8b2 305c 	ldrh.w	r3, [r2, #92]	@ 0x5c
 80125c4:	3301      	adds	r3, #1
 80125c6:	f8a2 305c 	strh.w	r3, [r2, #92]	@ 0x5c
        return ERR_VAL;
 80125ca:	f06f 0005 	mvn.w	r0, #5
 80125ce:	e7eb      	b.n	80125a8 <ip4_output_if_opt_src+0xd8>
        IP_STATS_INC(ip.err);
 80125d0:	4a20      	ldr	r2, [pc, #128]	@ (8012654 <ip4_output_if_opt_src+0x184>)
 80125d2:	f8b2 305c 	ldrh.w	r3, [r2, #92]	@ 0x5c
 80125d6:	3301      	adds	r3, #1
 80125d8:	f8a2 305c 	strh.w	r3, [r2, #92]	@ 0x5c
        return ERR_BUF;
 80125dc:	f06f 0001 	mvn.w	r0, #1
 80125e0:	e7e2      	b.n	80125a8 <ip4_output_if_opt_src+0xd8>
        memset(((char *)p->payload) + optlen, 0, (size_t)(optlen_aligned - optlen));
 80125e2:	6860      	ldr	r0, [r4, #4]
 80125e4:	ebab 0205 	sub.w	r2, fp, r5
 80125e8:	2100      	movs	r1, #0
 80125ea:	4428      	add	r0, r5
 80125ec:	f001 fe64 	bl	80142b8 <memset>
 80125f0:	e798      	b.n	8012524 <ip4_output_if_opt_src+0x54>
    u16_t ip_hlen = IP_HLEN;
 80125f2:	2614      	movs	r6, #20
 80125f4:	e796      	b.n	8012524 <ip4_output_if_opt_src+0x54>
      IP_STATS_INC(ip.err);
 80125f6:	4a17      	ldr	r2, [pc, #92]	@ (8012654 <ip4_output_if_opt_src+0x184>)
 80125f8:	f8b2 305c 	ldrh.w	r3, [r2, #92]	@ 0x5c
 80125fc:	3301      	adds	r3, #1
 80125fe:	f8a2 305c 	strh.w	r3, [r2, #92]	@ 0x5c
      return ERR_BUF;
 8012602:	f06f 0001 	mvn.w	r0, #1
 8012606:	e7cf      	b.n	80125a8 <ip4_output_if_opt_src+0xd8>
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
 8012608:	4b13      	ldr	r3, [pc, #76]	@ (8012658 <ip4_output_if_opt_src+0x188>)
 801260a:	f44f 7262 	mov.w	r2, #904	@ 0x388
 801260e:	4915      	ldr	r1, [pc, #84]	@ (8012664 <ip4_output_if_opt_src+0x194>)
 8012610:	4813      	ldr	r0, [pc, #76]	@ (8012660 <ip4_output_if_opt_src+0x190>)
 8012612:	f001 fcb5 	bl	8013f80 <iprintf>
 8012616:	e78f      	b.n	8012538 <ip4_output_if_opt_src+0x68>
      ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY4);
 8012618:	4b13      	ldr	r3, [pc, #76]	@ (8012668 <ip4_output_if_opt_src+0x198>)
 801261a:	681b      	ldr	r3, [r3, #0]
 801261c:	60eb      	str	r3, [r5, #12]
 801261e:	e7ae      	b.n	801257e <ip4_output_if_opt_src+0xae>
    if (p->len < IP_HLEN) {
 8012620:	8963      	ldrh	r3, [r4, #10]
 8012622:	2b13      	cmp	r3, #19
 8012624:	d904      	bls.n	8012630 <ip4_output_if_opt_src+0x160>
    iphdr = (struct ip_hdr *)p->payload;
 8012626:	6863      	ldr	r3, [r4, #4]
    ip4_addr_copy(dest_addr, iphdr->dest);
 8012628:	691b      	ldr	r3, [r3, #16]
 801262a:	9301      	str	r3, [sp, #4]
    dest = &dest_addr;
 801262c:	af01      	add	r7, sp, #4
 801262e:	e7a9      	b.n	8012584 <ip4_output_if_opt_src+0xb4>
      IP_STATS_INC(ip.err);
 8012630:	4a08      	ldr	r2, [pc, #32]	@ (8012654 <ip4_output_if_opt_src+0x184>)
 8012632:	f8b2 305c 	ldrh.w	r3, [r2, #92]	@ 0x5c
 8012636:	3301      	adds	r3, #1
 8012638:	f8a2 305c 	strh.w	r3, [r2, #92]	@ 0x5c
      return ERR_BUF;
 801263c:	f06f 0001 	mvn.w	r0, #1
 8012640:	e7b2      	b.n	80125a8 <ip4_output_if_opt_src+0xd8>
    return ip4_frag(p, netif, dest);
 8012642:	463a      	mov	r2, r7
 8012644:	4649      	mov	r1, r9
 8012646:	4620      	mov	r0, r4
 8012648:	f000 fc70 	bl	8012f2c <ip4_frag>
 801264c:	e7ac      	b.n	80125a8 <ip4_output_if_opt_src+0xd8>
 801264e:	bf00      	nop
 8012650:	24014438 	.word	0x24014438
 8012654:	240141b4 	.word	0x240141b4
 8012658:	08018878 	.word	0x08018878
 801265c:	080188ac 	.word	0x080188ac
 8012660:	08015744 	.word	0x08015744
 8012664:	080188b8 	.word	0x080188b8
 8012668:	08018fc0 	.word	0x08018fc0

0801266c <ip4_output_if_opt>:
{
 801266c:	b510      	push	{r4, lr}
 801266e:	b086      	sub	sp, #24
 8012670:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
  if (dest != LWIP_IP_HDRINCL) {
 8012672:	4694      	mov	ip, r2
 8012674:	b11a      	cbz	r2, 801267e <ip4_output_if_opt+0x12>
    if (ip4_addr_isany(src)) {
 8012676:	b109      	cbz	r1, 801267c <ip4_output_if_opt+0x10>
 8012678:	680a      	ldr	r2, [r1, #0]
 801267a:	b902      	cbnz	r2, 801267e <ip4_output_if_opt+0x12>
      src_used = netif_ip4_addr(netif);
 801267c:	1d21      	adds	r1, r4, #4
  return ip4_output_if_opt_src(p, src_used, dest, ttl, tos, proto, netif,
 801267e:	f8bd 2030 	ldrh.w	r2, [sp, #48]	@ 0x30
 8012682:	9204      	str	r2, [sp, #16]
 8012684:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 8012686:	9203      	str	r2, [sp, #12]
 8012688:	9402      	str	r4, [sp, #8]
 801268a:	f89d 2024 	ldrb.w	r2, [sp, #36]	@ 0x24
 801268e:	9201      	str	r2, [sp, #4]
 8012690:	f89d 2020 	ldrb.w	r2, [sp, #32]
 8012694:	9200      	str	r2, [sp, #0]
 8012696:	4662      	mov	r2, ip
 8012698:	f7ff ff1a 	bl	80124d0 <ip4_output_if_opt_src>
}
 801269c:	b006      	add	sp, #24
 801269e:	bd10      	pop	{r4, pc}

080126a0 <ip4_output_if>:
{
 80126a0:	b510      	push	{r4, lr}
 80126a2:	b086      	sub	sp, #24
  return ip4_output_if_opt(p, src, dest, ttl, tos, proto, netif, NULL, 0);
 80126a4:	2400      	movs	r4, #0
 80126a6:	9404      	str	r4, [sp, #16]
 80126a8:	9403      	str	r4, [sp, #12]
 80126aa:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
 80126ac:	9402      	str	r4, [sp, #8]
 80126ae:	f89d 4024 	ldrb.w	r4, [sp, #36]	@ 0x24
 80126b2:	9401      	str	r4, [sp, #4]
 80126b4:	f89d 4020 	ldrb.w	r4, [sp, #32]
 80126b8:	9400      	str	r4, [sp, #0]
 80126ba:	f7ff ffd7 	bl	801266c <ip4_output_if_opt>
}
 80126be:	b006      	add	sp, #24
 80126c0:	bd10      	pop	{r4, pc}

080126c2 <ip4_output_if_src>:
{
 80126c2:	b510      	push	{r4, lr}
 80126c4:	b086      	sub	sp, #24
  return ip4_output_if_opt_src(p, src, dest, ttl, tos, proto, netif, NULL, 0);
 80126c6:	2400      	movs	r4, #0
 80126c8:	9404      	str	r4, [sp, #16]
 80126ca:	9403      	str	r4, [sp, #12]
 80126cc:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
 80126ce:	9402      	str	r4, [sp, #8]
 80126d0:	f89d 4024 	ldrb.w	r4, [sp, #36]	@ 0x24
 80126d4:	9401      	str	r4, [sp, #4]
 80126d6:	f89d 4020 	ldrb.w	r4, [sp, #32]
 80126da:	9400      	str	r4, [sp, #0]
 80126dc:	f7ff fef8 	bl	80124d0 <ip4_output_if_opt_src>
}
 80126e0:	b006      	add	sp, #24
 80126e2:	bd10      	pop	{r4, pc}

080126e4 <ip4_addr_isbroadcast_u32>:
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t
ip4_addr_isbroadcast_u32(u32_t addr, const struct netif *netif)
{
 80126e4:	4603      	mov	r3, r0
  ip4_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
 80126e6:	1e42      	subs	r2, r0, #1
 80126e8:	f112 0f03 	cmn.w	r2, #3
 80126ec:	d812      	bhi.n	8012714 <ip4_addr_isbroadcast_u32+0x30>
      (addr == IPADDR_ANY)) {
    return 1;
    /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
 80126ee:	f891 002d 	ldrb.w	r0, [r1, #45]	@ 0x2d
 80126f2:	f010 0002 	ands.w	r0, r0, #2
 80126f6:	d014      	beq.n	8012722 <ip4_addr_isbroadcast_u32+0x3e>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
    /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(netif_ip4_addr(netif))) {
 80126f8:	684a      	ldr	r2, [r1, #4]
 80126fa:	429a      	cmp	r2, r3
 80126fc:	d00c      	beq.n	8012718 <ip4_addr_isbroadcast_u32+0x34>
    return 0;
    /*  on the same (sub) network... */
  } else if (ip4_addr_netcmp(&ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif))
 80126fe:	6889      	ldr	r1, [r1, #8]
 8012700:	405a      	eors	r2, r3
 8012702:	420a      	tst	r2, r1
 8012704:	d10a      	bne.n	801271c <ip4_addr_isbroadcast_u32+0x38>
             /* ...and host identifier bits are all ones? =>... */
             && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
 8012706:	43ca      	mvns	r2, r1
 8012708:	ea23 0301 	bic.w	r3, r3, r1
 801270c:	429a      	cmp	r2, r3
 801270e:	d007      	beq.n	8012720 <ip4_addr_isbroadcast_u32+0x3c>
                 (IPADDR_BROADCAST & ~ip4_addr_get_u32(netif_ip4_netmask(netif))))) {
    /* => network broadcast address */
    return 1;
  } else {
    return 0;
 8012710:	2000      	movs	r0, #0
 8012712:	4770      	bx	lr
    return 1;
 8012714:	2001      	movs	r0, #1
 8012716:	4770      	bx	lr
    return 0;
 8012718:	2000      	movs	r0, #0
 801271a:	4770      	bx	lr
    return 0;
 801271c:	2000      	movs	r0, #0
 801271e:	4770      	bx	lr
    return 1;
 8012720:	2001      	movs	r0, #1
  }
}
 8012722:	4770      	bx	lr

08012724 <ip4addr_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
ip4addr_aton(const char *cp, ip4_addr_t *addr)
{
 8012724:	b530      	push	{r4, r5, lr}
 8012726:	b085      	sub	sp, #20
 8012728:	460d      	mov	r5, r1
  u8_t base;
  char c;
  u32_t parts[4];
  u32_t *pp = parts;

  c = *cp;
 801272a:	7803      	ldrb	r3, [r0, #0]
  u32_t *pp = parts;
 801272c:	46ec      	mov	ip, sp
 801272e:	e035      	b.n	801279c <ip4addr_aton+0x78>
      return 0;
    }
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
 8012730:	1c42      	adds	r2, r0, #1
 8012732:	7843      	ldrb	r3, [r0, #1]
      if (c == 'x' || c == 'X') {
 8012734:	2b58      	cmp	r3, #88	@ 0x58
 8012736:	bf18      	it	ne
 8012738:	2b78      	cmpne	r3, #120	@ 0x78
 801273a:	d103      	bne.n	8012744 <ip4addr_aton+0x20>
        base = 16;
        c = *++cp;
 801273c:	7883      	ldrb	r3, [r0, #2]
 801273e:	3002      	adds	r0, #2
        base = 16;
 8012740:	2110      	movs	r1, #16
 8012742:	e033      	b.n	80127ac <ip4addr_aton+0x88>
      c = *++cp;
 8012744:	4610      	mov	r0, r2
      } else {
        base = 8;
 8012746:	2108      	movs	r1, #8
 8012748:	e030      	b.n	80127ac <ip4addr_aton+0x88>
      }
    }
    for (;;) {
      if (lwip_isdigit(c)) {
        val = (val * base) + (u32_t)(c - '0');
 801274a:	fb04 3301 	mla	r3, r4, r1, r3
 801274e:	f1a3 0430 	sub.w	r4, r3, #48	@ 0x30
        c = *++cp;
 8012752:	f810 3f01 	ldrb.w	r3, [r0, #1]!
      if (lwip_isdigit(c)) {
 8012756:	4a47      	ldr	r2, [pc, #284]	@ (8012874 <ip4addr_aton+0x150>)
 8012758:	5cd2      	ldrb	r2, [r2, r3]
 801275a:	f012 0f04 	tst.w	r2, #4
 801275e:	d1f4      	bne.n	801274a <ip4addr_aton+0x26>
      } else if (base == 16 && lwip_isxdigit(c)) {
 8012760:	2910      	cmp	r1, #16
 8012762:	d110      	bne.n	8012786 <ip4addr_aton+0x62>
 8012764:	f012 0f44 	tst.w	r2, #68	@ 0x44
 8012768:	d00d      	beq.n	8012786 <ip4addr_aton+0x62>
        val = (val << 4) | (u32_t)(c + 10 - (lwip_islower(c) ? 'a' : 'A'));
 801276a:	0124      	lsls	r4, r4, #4
 801276c:	330a      	adds	r3, #10
 801276e:	f002 0203 	and.w	r2, r2, #3
 8012772:	2a02      	cmp	r2, #2
 8012774:	d005      	beq.n	8012782 <ip4addr_aton+0x5e>
 8012776:	2241      	movs	r2, #65	@ 0x41
 8012778:	1a9b      	subs	r3, r3, r2
 801277a:	431c      	orrs	r4, r3
        c = *++cp;
 801277c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8012780:	e7e9      	b.n	8012756 <ip4addr_aton+0x32>
        val = (val << 4) | (u32_t)(c + 10 - (lwip_islower(c) ? 'a' : 'A'));
 8012782:	2261      	movs	r2, #97	@ 0x61
 8012784:	e7f8      	b.n	8012778 <ip4addr_aton+0x54>
      } else {
        break;
      }
    }
    if (c == '.') {
 8012786:	2b2e      	cmp	r3, #46	@ 0x2e
 8012788:	d112      	bne.n	80127b0 <ip4addr_aton+0x8c>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3) {
 801278a:	ab03      	add	r3, sp, #12
 801278c:	459c      	cmp	ip, r3
 801278e:	d258      	bcs.n	8012842 <ip4addr_aton+0x11e>
        return 0;
      }
      *pp++ = val;
 8012790:	4662      	mov	r2, ip
 8012792:	f842 4b04 	str.w	r4, [r2], #4
      c = *++cp;
 8012796:	7843      	ldrb	r3, [r0, #1]
      *pp++ = val;
 8012798:	4694      	mov	ip, r2
      c = *++cp;
 801279a:	3001      	adds	r0, #1
    if (!lwip_isdigit(c)) {
 801279c:	4a35      	ldr	r2, [pc, #212]	@ (8012874 <ip4addr_aton+0x150>)
 801279e:	5cd2      	ldrb	r2, [r2, r3]
 80127a0:	f012 0f04 	tst.w	r2, #4
 80127a4:	d04b      	beq.n	801283e <ip4addr_aton+0x11a>
    if (c == '0') {
 80127a6:	2b30      	cmp	r3, #48	@ 0x30
 80127a8:	d0c2      	beq.n	8012730 <ip4addr_aton+0xc>
    base = 10;
 80127aa:	210a      	movs	r1, #10
        base = 8;
 80127ac:	2400      	movs	r4, #0
 80127ae:	e7d2      	b.n	8012756 <ip4addr_aton+0x32>
    }
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && !lwip_isspace(c)) {
 80127b0:	b113      	cbz	r3, 80127b8 <ip4addr_aton+0x94>
 80127b2:	f012 0f08 	tst.w	r2, #8
 80127b6:	d047      	beq.n	8012848 <ip4addr_aton+0x124>
  }
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  switch (pp - parts + 1) {
 80127b8:	466b      	mov	r3, sp
 80127ba:	ebac 0003 	sub.w	r0, ip, r3
 80127be:	1080      	asrs	r0, r0, #2
 80127c0:	3001      	adds	r0, #1
 80127c2:	2804      	cmp	r0, #4
 80127c4:	d834      	bhi.n	8012830 <ip4addr_aton+0x10c>
 80127c6:	e8df f000 	tbb	[pc, r0]
 80127ca:	0b3d      	.short	0x0b3d
 80127cc:	1303      	.short	0x1303
 80127ce:	21          	.byte	0x21
 80127cf:	00          	.byte	0x00

    case 1:             /* a -- 32 bits */
      break;

    case 2:             /* a.b -- 8.24 bits */
      if (val > 0xffffffUL) {
 80127d0:	f1b4 7f80 	cmp.w	r4, #16777216	@ 0x1000000
 80127d4:	d23a      	bcs.n	801284c <ip4addr_aton+0x128>
        return 0;
      }
      if (parts[0] > 0xff) {
 80127d6:	9b00      	ldr	r3, [sp, #0]
 80127d8:	2bff      	cmp	r3, #255	@ 0xff
 80127da:	d839      	bhi.n	8012850 <ip4addr_aton+0x12c>
        return 0;
      }
      val |= parts[0] << 24;
 80127dc:	ea44 6403 	orr.w	r4, r4, r3, lsl #24
      break;
    default:
      LWIP_ASSERT("unhandled", 0);
      break;
  }
  if (addr) {
 80127e0:	2d00      	cmp	r5, #0
 80127e2:	d045      	beq.n	8012870 <ip4addr_aton+0x14c>
    ip4_addr_set_u32(addr, lwip_htonl(val));
 80127e4:	4620      	mov	r0, r4
 80127e6:	f7f8 f9c0 	bl	800ab6a <lwip_htonl>
 80127ea:	6028      	str	r0, [r5, #0]
  }
  return 1;
 80127ec:	2001      	movs	r0, #1
 80127ee:	e029      	b.n	8012844 <ip4addr_aton+0x120>
      if (val > 0xffff) {
 80127f0:	f5b4 3f80 	cmp.w	r4, #65536	@ 0x10000
 80127f4:	d22e      	bcs.n	8012854 <ip4addr_aton+0x130>
      if ((parts[0] > 0xff) || (parts[1] > 0xff)) {
 80127f6:	9a00      	ldr	r2, [sp, #0]
 80127f8:	2aff      	cmp	r2, #255	@ 0xff
 80127fa:	d82d      	bhi.n	8012858 <ip4addr_aton+0x134>
 80127fc:	9b01      	ldr	r3, [sp, #4]
 80127fe:	2bff      	cmp	r3, #255	@ 0xff
 8012800:	d82c      	bhi.n	801285c <ip4addr_aton+0x138>
      val |= (parts[0] << 24) | (parts[1] << 16);
 8012802:	041b      	lsls	r3, r3, #16
 8012804:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8012808:	431c      	orrs	r4, r3
      break;
 801280a:	e7e9      	b.n	80127e0 <ip4addr_aton+0xbc>
      if (val > 0xff) {
 801280c:	2cff      	cmp	r4, #255	@ 0xff
 801280e:	d827      	bhi.n	8012860 <ip4addr_aton+0x13c>
      if ((parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff)) {
 8012810:	9900      	ldr	r1, [sp, #0]
 8012812:	29ff      	cmp	r1, #255	@ 0xff
 8012814:	d826      	bhi.n	8012864 <ip4addr_aton+0x140>
 8012816:	9b01      	ldr	r3, [sp, #4]
 8012818:	2bff      	cmp	r3, #255	@ 0xff
 801281a:	d825      	bhi.n	8012868 <ip4addr_aton+0x144>
 801281c:	9a02      	ldr	r2, [sp, #8]
 801281e:	2aff      	cmp	r2, #255	@ 0xff
 8012820:	d824      	bhi.n	801286c <ip4addr_aton+0x148>
      val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
 8012822:	041b      	lsls	r3, r3, #16
 8012824:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8012828:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 801282c:	431c      	orrs	r4, r3
      break;
 801282e:	e7d7      	b.n	80127e0 <ip4addr_aton+0xbc>
      LWIP_ASSERT("unhandled", 0);
 8012830:	4b11      	ldr	r3, [pc, #68]	@ (8012878 <ip4addr_aton+0x154>)
 8012832:	22f9      	movs	r2, #249	@ 0xf9
 8012834:	4911      	ldr	r1, [pc, #68]	@ (801287c <ip4addr_aton+0x158>)
 8012836:	4812      	ldr	r0, [pc, #72]	@ (8012880 <ip4addr_aton+0x15c>)
 8012838:	f001 fba2 	bl	8013f80 <iprintf>
      break;
 801283c:	e7d0      	b.n	80127e0 <ip4addr_aton+0xbc>
      return 0;
 801283e:	2000      	movs	r0, #0
 8012840:	e000      	b.n	8012844 <ip4addr_aton+0x120>
        return 0;
 8012842:	2000      	movs	r0, #0
}
 8012844:	b005      	add	sp, #20
 8012846:	bd30      	pop	{r4, r5, pc}
    return 0;
 8012848:	2000      	movs	r0, #0
 801284a:	e7fb      	b.n	8012844 <ip4addr_aton+0x120>
        return 0;
 801284c:	2000      	movs	r0, #0
 801284e:	e7f9      	b.n	8012844 <ip4addr_aton+0x120>
        return 0;
 8012850:	2000      	movs	r0, #0
 8012852:	e7f7      	b.n	8012844 <ip4addr_aton+0x120>
        return 0;
 8012854:	2000      	movs	r0, #0
 8012856:	e7f5      	b.n	8012844 <ip4addr_aton+0x120>
        return 0;
 8012858:	2000      	movs	r0, #0
 801285a:	e7f3      	b.n	8012844 <ip4addr_aton+0x120>
 801285c:	2000      	movs	r0, #0
 801285e:	e7f1      	b.n	8012844 <ip4addr_aton+0x120>
        return 0;
 8012860:	2000      	movs	r0, #0
 8012862:	e7ef      	b.n	8012844 <ip4addr_aton+0x120>
        return 0;
 8012864:	2000      	movs	r0, #0
 8012866:	e7ed      	b.n	8012844 <ip4addr_aton+0x120>
 8012868:	2000      	movs	r0, #0
 801286a:	e7eb      	b.n	8012844 <ip4addr_aton+0x120>
 801286c:	2000      	movs	r0, #0
 801286e:	e7e9      	b.n	8012844 <ip4addr_aton+0x120>
  return 1;
 8012870:	2001      	movs	r0, #1
 8012872:	e7e7      	b.n	8012844 <ip4addr_aton+0x120>
 8012874:	08019a48 	.word	0x08019a48
 8012878:	080188e8 	.word	0x080188e8
 801287c:	08018924 	.word	0x08018924
 8012880:	08015744 	.word	0x08015744

08012884 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 8012884:	b538      	push	{r3, r4, r5, lr}
 8012886:	4604      	mov	r4, r0
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
 8012888:	4b0c      	ldr	r3, [pc, #48]	@ (80128bc <ip_reass_dequeue_datagram+0x38>)
 801288a:	681b      	ldr	r3, [r3, #0]
 801288c:	4283      	cmp	r3, r0
 801288e:	d008      	beq.n	80128a2 <ip_reass_dequeue_datagram+0x1e>
 8012890:	460d      	mov	r5, r1
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
 8012892:	b151      	cbz	r1, 80128aa <ip_reass_dequeue_datagram+0x26>
    prev->next = ipr->next;
 8012894:	6823      	ldr	r3, [r4, #0]
 8012896:	602b      	str	r3, [r5, #0]
  }

  /* now we can free the ip_reassdata struct */
  memp_free(MEMP_REASSDATA, ipr);
 8012898:	4621      	mov	r1, r4
 801289a:	2004      	movs	r0, #4
 801289c:	f7f8 fe2c 	bl	800b4f8 <memp_free>
}
 80128a0:	bd38      	pop	{r3, r4, r5, pc}
    reassdatagrams = ipr->next;
 80128a2:	6802      	ldr	r2, [r0, #0]
 80128a4:	4b05      	ldr	r3, [pc, #20]	@ (80128bc <ip_reass_dequeue_datagram+0x38>)
 80128a6:	601a      	str	r2, [r3, #0]
 80128a8:	e7f6      	b.n	8012898 <ip_reass_dequeue_datagram+0x14>
    LWIP_ASSERT("sanity check linked list", prev != NULL);
 80128aa:	4b05      	ldr	r3, [pc, #20]	@ (80128c0 <ip_reass_dequeue_datagram+0x3c>)
 80128ac:	f240 1245 	movw	r2, #325	@ 0x145
 80128b0:	4904      	ldr	r1, [pc, #16]	@ (80128c4 <ip_reass_dequeue_datagram+0x40>)
 80128b2:	4805      	ldr	r0, [pc, #20]	@ (80128c8 <ip_reass_dequeue_datagram+0x44>)
 80128b4:	f001 fb64 	bl	8013f80 <iprintf>
 80128b8:	e7ec      	b.n	8012894 <ip_reass_dequeue_datagram+0x10>
 80128ba:	bf00      	nop
 80128bc:	2401443c 	.word	0x2401443c
 80128c0:	08018930 	.word	0x08018930
 80128c4:	0801896c 	.word	0x0801896c
 80128c8:	08015744 	.word	0x08015744

080128cc <ip_reass_free_complete_datagram>:
{
 80128cc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80128d0:	4680      	mov	r8, r0
 80128d2:	4689      	mov	r9, r1
  LWIP_ASSERT("prev != ipr", prev != ipr);
 80128d4:	4281      	cmp	r1, r0
 80128d6:	d015      	beq.n	8012904 <ip_reass_free_complete_datagram+0x38>
  if (prev != NULL) {
 80128d8:	f1b9 0f00 	cmp.w	r9, #0
 80128dc:	d009      	beq.n	80128f2 <ip_reass_free_complete_datagram+0x26>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
 80128de:	f8d9 3000 	ldr.w	r3, [r9]
 80128e2:	4543      	cmp	r3, r8
 80128e4:	d005      	beq.n	80128f2 <ip_reass_free_complete_datagram+0x26>
 80128e6:	4b31      	ldr	r3, [pc, #196]	@ (80129ac <ip_reass_free_complete_datagram+0xe0>)
 80128e8:	22ad      	movs	r2, #173	@ 0xad
 80128ea:	4931      	ldr	r1, [pc, #196]	@ (80129b0 <ip_reass_free_complete_datagram+0xe4>)
 80128ec:	4831      	ldr	r0, [pc, #196]	@ (80129b4 <ip_reass_free_complete_datagram+0xe8>)
 80128ee:	f001 fb47 	bl	8013f80 <iprintf>
  iprh = (struct ip_reass_helper *)ipr->p->payload;
 80128f2:	f8d8 4004 	ldr.w	r4, [r8, #4]
 80128f6:	6863      	ldr	r3, [r4, #4]
  if (iprh->start == 0) {
 80128f8:	889a      	ldrh	r2, [r3, #4]
 80128fa:	b152      	cbz	r2, 8012912 <ip_reass_free_complete_datagram+0x46>
  u16_t pbufs_freed = 0;
 80128fc:	2600      	movs	r6, #0
  p = ipr->p;
 80128fe:	f8d8 5004 	ldr.w	r5, [r8, #4]
  while (p != NULL) {
 8012902:	e02b      	b.n	801295c <ip_reass_free_complete_datagram+0x90>
  LWIP_ASSERT("prev != ipr", prev != ipr);
 8012904:	4b29      	ldr	r3, [pc, #164]	@ (80129ac <ip_reass_free_complete_datagram+0xe0>)
 8012906:	22ab      	movs	r2, #171	@ 0xab
 8012908:	492b      	ldr	r1, [pc, #172]	@ (80129b8 <ip_reass_free_complete_datagram+0xec>)
 801290a:	482a      	ldr	r0, [pc, #168]	@ (80129b4 <ip_reass_free_complete_datagram+0xe8>)
 801290c:	f001 fb38 	bl	8013f80 <iprintf>
 8012910:	e7e2      	b.n	80128d8 <ip_reass_free_complete_datagram+0xc>
    ipr->p = iprh->next_pbuf;
 8012912:	681b      	ldr	r3, [r3, #0]
 8012914:	f8c8 3004 	str.w	r3, [r8, #4]
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
 8012918:	6863      	ldr	r3, [r4, #4]
 801291a:	f8d8 2008 	ldr.w	r2, [r8, #8]
 801291e:	f8d8 500c 	ldr.w	r5, [r8, #12]
 8012922:	f8d8 0010 	ldr.w	r0, [r8, #16]
 8012926:	f8d8 1014 	ldr.w	r1, [r8, #20]
 801292a:	601a      	str	r2, [r3, #0]
 801292c:	605d      	str	r5, [r3, #4]
 801292e:	6098      	str	r0, [r3, #8]
 8012930:	60d9      	str	r1, [r3, #12]
 8012932:	f8d8 2018 	ldr.w	r2, [r8, #24]
 8012936:	611a      	str	r2, [r3, #16]
    icmp_time_exceeded(p, ICMP_TE_FRAG);
 8012938:	2101      	movs	r1, #1
 801293a:	4620      	mov	r0, r4
 801293c:	f7ff f9cc 	bl	8011cd8 <icmp_time_exceeded>
    clen = pbuf_clen(p);
 8012940:	4620      	mov	r0, r4
 8012942:	f7f9 fa5d 	bl	800be00 <pbuf_clen>
 8012946:	4606      	mov	r6, r0
    pbuf_free(p);
 8012948:	4620      	mov	r0, r4
 801294a:	f7f9 f8f1 	bl	800bb30 <pbuf_free>
 801294e:	e7d6      	b.n	80128fe <ip_reass_free_complete_datagram+0x32>
    pbufs_freed = (u16_t)(pbufs_freed + clen);
 8012950:	4434      	add	r4, r6
 8012952:	b2a6      	uxth	r6, r4
    pbuf_free(pcur);
 8012954:	4628      	mov	r0, r5
 8012956:	f7f9 f8eb 	bl	800bb30 <pbuf_free>
    p = iprh->next_pbuf;
 801295a:	463d      	mov	r5, r7
  while (p != NULL) {
 801295c:	b185      	cbz	r5, 8012980 <ip_reass_free_complete_datagram+0xb4>
    iprh = (struct ip_reass_helper *)p->payload;
 801295e:	686b      	ldr	r3, [r5, #4]
    p = iprh->next_pbuf;
 8012960:	681f      	ldr	r7, [r3, #0]
    clen = pbuf_clen(pcur);
 8012962:	4628      	mov	r0, r5
 8012964:	f7f9 fa4c 	bl	800be00 <pbuf_clen>
 8012968:	4604      	mov	r4, r0
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
 801296a:	1833      	adds	r3, r6, r0
 801296c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8012970:	dbee      	blt.n	8012950 <ip_reass_free_complete_datagram+0x84>
 8012972:	4b0e      	ldr	r3, [pc, #56]	@ (80129ac <ip_reass_free_complete_datagram+0xe0>)
 8012974:	22cc      	movs	r2, #204	@ 0xcc
 8012976:	4911      	ldr	r1, [pc, #68]	@ (80129bc <ip_reass_free_complete_datagram+0xf0>)
 8012978:	480e      	ldr	r0, [pc, #56]	@ (80129b4 <ip_reass_free_complete_datagram+0xe8>)
 801297a:	f001 fb01 	bl	8013f80 <iprintf>
 801297e:	e7e7      	b.n	8012950 <ip_reass_free_complete_datagram+0x84>
  ip_reass_dequeue_datagram(ipr, prev);
 8012980:	4649      	mov	r1, r9
 8012982:	4640      	mov	r0, r8
 8012984:	f7ff ff7e 	bl	8012884 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= pbufs_freed", ip_reass_pbufcount >= pbufs_freed);
 8012988:	4b0d      	ldr	r3, [pc, #52]	@ (80129c0 <ip_reass_free_complete_datagram+0xf4>)
 801298a:	881b      	ldrh	r3, [r3, #0]
 801298c:	42b3      	cmp	r3, r6
 801298e:	d306      	bcc.n	801299e <ip_reass_free_complete_datagram+0xd2>
  ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - pbufs_freed);
 8012990:	4a0b      	ldr	r2, [pc, #44]	@ (80129c0 <ip_reass_free_complete_datagram+0xf4>)
 8012992:	8813      	ldrh	r3, [r2, #0]
 8012994:	1b9b      	subs	r3, r3, r6
 8012996:	8013      	strh	r3, [r2, #0]
}
 8012998:	4630      	mov	r0, r6
 801299a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  LWIP_ASSERT("ip_reass_pbufcount >= pbufs_freed", ip_reass_pbufcount >= pbufs_freed);
 801299e:	4b03      	ldr	r3, [pc, #12]	@ (80129ac <ip_reass_free_complete_datagram+0xe0>)
 80129a0:	22d2      	movs	r2, #210	@ 0xd2
 80129a2:	4908      	ldr	r1, [pc, #32]	@ (80129c4 <ip_reass_free_complete_datagram+0xf8>)
 80129a4:	4803      	ldr	r0, [pc, #12]	@ (80129b4 <ip_reass_free_complete_datagram+0xe8>)
 80129a6:	f001 faeb 	bl	8013f80 <iprintf>
 80129aa:	e7f1      	b.n	8012990 <ip_reass_free_complete_datagram+0xc4>
 80129ac:	08018930 	.word	0x08018930
 80129b0:	08018994 	.word	0x08018994
 80129b4:	08015744 	.word	0x08015744
 80129b8:	08018988 	.word	0x08018988
 80129bc:	080189a8 	.word	0x080189a8
 80129c0:	2401443a 	.word	0x2401443a
 80129c4:	080189c8 	.word	0x080189c8

080129c8 <ip_reass_remove_oldest_datagram>:
{
 80129c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80129ca:	4605      	mov	r5, r0
 80129cc:	460f      	mov	r7, r1
  int pbufs_freed = 0, pbufs_freed_current;
 80129ce:	2600      	movs	r6, #0
 80129d0:	e02e      	b.n	8012a30 <ip_reass_remove_oldest_datagram+0x68>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 80129d2:	699a      	ldr	r2, [r3, #24]
 80129d4:	f8d5 e010 	ldr.w	lr, [r5, #16]
 80129d8:	4572      	cmp	r2, lr
 80129da:	d111      	bne.n	8012a00 <ip_reass_remove_oldest_datagram+0x38>
 80129dc:	f8b3 e00c 	ldrh.w	lr, [r3, #12]
 80129e0:	88aa      	ldrh	r2, [r5, #4]
 80129e2:	4596      	cmp	lr, r2
 80129e4:	d10c      	bne.n	8012a00 <ip_reass_remove_oldest_datagram+0x38>
 80129e6:	e001      	b.n	80129ec <ip_reass_remove_oldest_datagram+0x24>
          oldest_prev = prev;
 80129e8:	4661      	mov	r1, ip
          oldest = r;
 80129ea:	4618      	mov	r0, r3
      if (r->next != NULL) {
 80129ec:	681a      	ldr	r2, [r3, #0]
 80129ee:	b192      	cbz	r2, 8012a16 <ip_reass_remove_oldest_datagram+0x4e>
 80129f0:	469c      	mov	ip, r3
 80129f2:	4613      	mov	r3, r2
    while (r != NULL) {
 80129f4:	b18b      	cbz	r3, 8012a1a <ip_reass_remove_oldest_datagram+0x52>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 80129f6:	695a      	ldr	r2, [r3, #20]
 80129f8:	f8d5 e00c 	ldr.w	lr, [r5, #12]
 80129fc:	4572      	cmp	r2, lr
 80129fe:	d0e8      	beq.n	80129d2 <ip_reass_remove_oldest_datagram+0xa>
        other_datagrams++;
 8012a00:	3401      	adds	r4, #1
        if (oldest == NULL) {
 8012a02:	2800      	cmp	r0, #0
 8012a04:	d0f0      	beq.n	80129e8 <ip_reass_remove_oldest_datagram+0x20>
        } else if (r->timer <= oldest->timer) {
 8012a06:	f893 e01f 	ldrb.w	lr, [r3, #31]
 8012a0a:	7fc2      	ldrb	r2, [r0, #31]
 8012a0c:	4596      	cmp	lr, r2
 8012a0e:	d8ed      	bhi.n	80129ec <ip_reass_remove_oldest_datagram+0x24>
          oldest_prev = prev;
 8012a10:	4661      	mov	r1, ip
          oldest = r;
 8012a12:	4618      	mov	r0, r3
 8012a14:	e7ea      	b.n	80129ec <ip_reass_remove_oldest_datagram+0x24>
      if (r->next != NULL) {
 8012a16:	4663      	mov	r3, ip
 8012a18:	e7ea      	b.n	80129f0 <ip_reass_remove_oldest_datagram+0x28>
    if (oldest != NULL) {
 8012a1a:	b110      	cbz	r0, 8012a22 <ip_reass_remove_oldest_datagram+0x5a>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, oldest_prev);
 8012a1c:	f7ff ff56 	bl	80128cc <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
 8012a20:	4406      	add	r6, r0
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
 8012a22:	2c01      	cmp	r4, #1
 8012a24:	bfd4      	ite	le
 8012a26:	2400      	movle	r4, #0
 8012a28:	2401      	movgt	r4, #1
 8012a2a:	42be      	cmp	r6, r7
 8012a2c:	da07      	bge.n	8012a3e <ip_reass_remove_oldest_datagram+0x76>
 8012a2e:	b134      	cbz	r4, 8012a3e <ip_reass_remove_oldest_datagram+0x76>
    r = reassdatagrams;
 8012a30:	4b04      	ldr	r3, [pc, #16]	@ (8012a44 <ip_reass_remove_oldest_datagram+0x7c>)
 8012a32:	681b      	ldr	r3, [r3, #0]
    other_datagrams = 0;
 8012a34:	2400      	movs	r4, #0
    oldest_prev = NULL;
 8012a36:	4621      	mov	r1, r4
    prev = NULL;
 8012a38:	46a4      	mov	ip, r4
    oldest = NULL;
 8012a3a:	4620      	mov	r0, r4
    while (r != NULL) {
 8012a3c:	e7da      	b.n	80129f4 <ip_reass_remove_oldest_datagram+0x2c>
}
 8012a3e:	4630      	mov	r0, r6
 8012a40:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8012a42:	bf00      	nop
 8012a44:	2401443c 	.word	0x2401443c

08012a48 <ip_frag_free_pbuf_custom_ref>:
}

/** Free a struct pbuf_custom_ref */
static void
ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref *p)
{
 8012a48:	b510      	push	{r4, lr}
  LWIP_ASSERT("p != NULL", p != NULL);
 8012a4a:	4604      	mov	r4, r0
 8012a4c:	b120      	cbz	r0, 8012a58 <ip_frag_free_pbuf_custom_ref+0x10>
  memp_free(MEMP_FRAG_PBUF, p);
 8012a4e:	4621      	mov	r1, r4
 8012a50:	2005      	movs	r0, #5
 8012a52:	f7f8 fd51 	bl	800b4f8 <memp_free>
}
 8012a56:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("p != NULL", p != NULL);
 8012a58:	4b03      	ldr	r3, [pc, #12]	@ (8012a68 <ip_frag_free_pbuf_custom_ref+0x20>)
 8012a5a:	f44f 7231 	mov.w	r2, #708	@ 0x2c4
 8012a5e:	4903      	ldr	r1, [pc, #12]	@ (8012a6c <ip_frag_free_pbuf_custom_ref+0x24>)
 8012a60:	4803      	ldr	r0, [pc, #12]	@ (8012a70 <ip_frag_free_pbuf_custom_ref+0x28>)
 8012a62:	f001 fa8d 	bl	8013f80 <iprintf>
 8012a66:	e7f2      	b.n	8012a4e <ip_frag_free_pbuf_custom_ref+0x6>
 8012a68:	08018930 	.word	0x08018930
 8012a6c:	0801592c 	.word	0x0801592c
 8012a70:	08015744 	.word	0x08015744

08012a74 <ipfrag_free_pbuf_custom>:

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void
ipfrag_free_pbuf_custom(struct pbuf *p)
{
 8012a74:	b510      	push	{r4, lr}
  struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref *)p;
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
 8012a76:	4604      	mov	r4, r0
 8012a78:	b138      	cbz	r0, 8012a8a <ipfrag_free_pbuf_custom+0x16>
  LWIP_ASSERT("pcr == p", (void *)pcr == (void *)p);
  if (pcr->original != NULL) {
 8012a7a:	6960      	ldr	r0, [r4, #20]
 8012a7c:	b108      	cbz	r0, 8012a82 <ipfrag_free_pbuf_custom+0xe>
    pbuf_free(pcr->original);
 8012a7e:	f7f9 f857 	bl	800bb30 <pbuf_free>
  }
  ip_frag_free_pbuf_custom_ref(pcr);
 8012a82:	4620      	mov	r0, r4
 8012a84:	f7ff ffe0 	bl	8012a48 <ip_frag_free_pbuf_custom_ref>
}
 8012a88:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
 8012a8a:	4b04      	ldr	r3, [pc, #16]	@ (8012a9c <ipfrag_free_pbuf_custom+0x28>)
 8012a8c:	f240 22ce 	movw	r2, #718	@ 0x2ce
 8012a90:	4903      	ldr	r1, [pc, #12]	@ (8012aa0 <ipfrag_free_pbuf_custom+0x2c>)
 8012a92:	4804      	ldr	r0, [pc, #16]	@ (8012aa4 <ipfrag_free_pbuf_custom+0x30>)
 8012a94:	f001 fa74 	bl	8013f80 <iprintf>
 8012a98:	e7ef      	b.n	8012a7a <ipfrag_free_pbuf_custom+0x6>
 8012a9a:	bf00      	nop
 8012a9c:	08018930 	.word	0x08018930
 8012aa0:	080189ec 	.word	0x080189ec
 8012aa4:	08015744 	.word	0x08015744

08012aa8 <ip_reass_chain_frag_into_datagram_and_validate>:
{
 8012aa8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8012aac:	4680      	mov	r8, r0
 8012aae:	460d      	mov	r5, r1
 8012ab0:	4691      	mov	r9, r2
  fraghdr = (struct ip_hdr *)new_p->payload;
 8012ab2:	684c      	ldr	r4, [r1, #4]
  len = lwip_ntohs(IPH_LEN(fraghdr));
 8012ab4:	8860      	ldrh	r0, [r4, #2]
 8012ab6:	f7f8 f853 	bl	800ab60 <lwip_htons>
  hlen = IPH_HL_BYTES(fraghdr);
 8012aba:	7823      	ldrb	r3, [r4, #0]
 8012abc:	f003 030f 	and.w	r3, r3, #15
  if (hlen > len) {
 8012ac0:	ebb0 0f83 	cmp.w	r0, r3, lsl #2
 8012ac4:	d203      	bcs.n	8012ace <ip_reass_chain_frag_into_datagram_and_validate+0x26>
    return IP_REASS_VALIDATE_PBUF_DROPPED;
 8012ac6:	f04f 30ff 	mov.w	r0, #4294967295
}
 8012aca:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8012ace:	009a      	lsls	r2, r3, #2
  len = (u16_t)(len - hlen);
 8012ad0:	1a80      	subs	r0, r0, r2
 8012ad2:	b287      	uxth	r7, r0
  offset = IPH_OFFSET_BYTES(fraghdr);
 8012ad4:	88e0      	ldrh	r0, [r4, #6]
 8012ad6:	f7f8 f843 	bl	800ab60 <lwip_htons>
 8012ada:	f3c0 0c0c 	ubfx	ip, r0, #0, #13
 8012ade:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
  iprh = (struct ip_reass_helper *)new_p->payload;
 8012ae2:	686e      	ldr	r6, [r5, #4]
  iprh->next_pbuf = NULL;
 8012ae4:	2300      	movs	r3, #0
 8012ae6:	7033      	strb	r3, [r6, #0]
 8012ae8:	7073      	strb	r3, [r6, #1]
 8012aea:	70b3      	strb	r3, [r6, #2]
 8012aec:	70f3      	strb	r3, [r6, #3]
  iprh->start = offset;
 8012aee:	f8a6 c004 	strh.w	ip, [r6, #4]
  iprh->end = (u16_t)(offset + len);
 8012af2:	eb07 000c 	add.w	r0, r7, ip
 8012af6:	fa1f fe80 	uxth.w	lr, r0
 8012afa:	80f0      	strh	r0, [r6, #6]
  if (iprh->end < offset) {
 8012afc:	45e6      	cmp	lr, ip
 8012afe:	f0c0 8085 	bcc.w	8012c0c <ip_reass_chain_frag_into_datagram_and_validate+0x164>
  for (q = ipr->p; q != NULL;) {
 8012b02:	f8d8 1004 	ldr.w	r1, [r8, #4]
  int valid = 1;
 8012b06:	2701      	movs	r7, #1
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev = NULL;
 8012b08:	461c      	mov	r4, r3
  for (q = ipr->p; q != NULL;) {
 8012b0a:	e01f      	b.n	8012b4c <ip_reass_chain_frag_into_datagram_and_validate+0xa4>
      iprh->next_pbuf = q;
 8012b0c:	6031      	str	r1, [r6, #0]
      if (iprh_prev != NULL) {
 8012b0e:	b1ac      	cbz	r4, 8012b3c <ip_reass_chain_frag_into_datagram_and_validate+0x94>
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
 8012b10:	88e2      	ldrh	r2, [r4, #6]
 8012b12:	4562      	cmp	r2, ip
 8012b14:	d87d      	bhi.n	8012c12 <ip_reass_chain_frag_into_datagram_and_validate+0x16a>
 8012b16:	889b      	ldrh	r3, [r3, #4]
 8012b18:	459e      	cmp	lr, r3
 8012b1a:	d87d      	bhi.n	8012c18 <ip_reass_chain_frag_into_datagram_and_validate+0x170>
        iprh_prev->next_pbuf = new_p;
 8012b1c:	6025      	str	r5, [r4, #0]
        if (iprh_prev->end != iprh->start) {
 8012b1e:	88b3      	ldrh	r3, [r6, #4]
 8012b20:	429a      	cmp	r2, r3
 8012b22:	d000      	beq.n	8012b26 <ip_reass_chain_frag_into_datagram_and_validate+0x7e>
          valid = 0;
 8012b24:	2700      	movs	r7, #0
  if (q == NULL) {
 8012b26:	b319      	cbz	r1, 8012b70 <ip_reass_chain_frag_into_datagram_and_validate+0xc8>
  if (is_last || ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0)) {
 8012b28:	f1b9 0f00 	cmp.w	r9, #0
 8012b2c:	d141      	bne.n	8012bb2 <ip_reass_chain_frag_into_datagram_and_validate+0x10a>
 8012b2e:	f898 301e 	ldrb.w	r3, [r8, #30]
 8012b32:	f013 0f01 	tst.w	r3, #1
 8012b36:	d13c      	bne.n	8012bb2 <ip_reass_chain_frag_into_datagram_and_validate+0x10a>
  return IP_REASS_VALIDATE_PBUF_QUEUED; /* not yet valid! */
 8012b38:	4648      	mov	r0, r9
 8012b3a:	e7c6      	b.n	8012aca <ip_reass_chain_frag_into_datagram_and_validate+0x22>
        if (iprh->end > iprh_tmp->start) {
 8012b3c:	889b      	ldrh	r3, [r3, #4]
 8012b3e:	459e      	cmp	lr, r3
 8012b40:	d86d      	bhi.n	8012c1e <ip_reass_chain_frag_into_datagram_and_validate+0x176>
        ipr->p = new_p;
 8012b42:	f8c8 5004 	str.w	r5, [r8, #4]
 8012b46:	e7ee      	b.n	8012b26 <ip_reass_chain_frag_into_datagram_and_validate+0x7e>
    q = iprh_tmp->next_pbuf;
 8012b48:	6819      	ldr	r1, [r3, #0]
    iprh_prev = iprh_tmp;
 8012b4a:	461c      	mov	r4, r3
  for (q = ipr->p; q != NULL;) {
 8012b4c:	2900      	cmp	r1, #0
 8012b4e:	d0ea      	beq.n	8012b26 <ip_reass_chain_frag_into_datagram_and_validate+0x7e>
    iprh_tmp = (struct ip_reass_helper *)q->payload;
 8012b50:	684b      	ldr	r3, [r1, #4]
    if (iprh->start < iprh_tmp->start) {
 8012b52:	889a      	ldrh	r2, [r3, #4]
 8012b54:	4562      	cmp	r2, ip
 8012b56:	d8d9      	bhi.n	8012b0c <ip_reass_chain_frag_into_datagram_and_validate+0x64>
    } else if (iprh->start == iprh_tmp->start) {
 8012b58:	4562      	cmp	r2, ip
 8012b5a:	d063      	beq.n	8012c24 <ip_reass_chain_frag_into_datagram_and_validate+0x17c>
    } else if (iprh->start < iprh_tmp->end) {
 8012b5c:	88d9      	ldrh	r1, [r3, #6]
 8012b5e:	4561      	cmp	r1, ip
 8012b60:	d863      	bhi.n	8012c2a <ip_reass_chain_frag_into_datagram_and_validate+0x182>
      if (iprh_prev != NULL) {
 8012b62:	2c00      	cmp	r4, #0
 8012b64:	d0f0      	beq.n	8012b48 <ip_reass_chain_frag_into_datagram_and_validate+0xa0>
        if (iprh_prev->end != iprh_tmp->start) {
 8012b66:	88e1      	ldrh	r1, [r4, #6]
 8012b68:	428a      	cmp	r2, r1
 8012b6a:	d0ed      	beq.n	8012b48 <ip_reass_chain_frag_into_datagram_and_validate+0xa0>
          valid = 0;
 8012b6c:	2700      	movs	r7, #0
 8012b6e:	e7eb      	b.n	8012b48 <ip_reass_chain_frag_into_datagram_and_validate+0xa0>
    if (iprh_prev != NULL) {
 8012b70:	b194      	cbz	r4, 8012b98 <ip_reass_chain_frag_into_datagram_and_validate+0xf0>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
 8012b72:	88e2      	ldrh	r2, [r4, #6]
 8012b74:	88b3      	ldrh	r3, [r6, #4]
 8012b76:	429a      	cmp	r2, r3
 8012b78:	d806      	bhi.n	8012b88 <ip_reass_chain_frag_into_datagram_and_validate+0xe0>
      iprh_prev->next_pbuf = new_p;
 8012b7a:	6025      	str	r5, [r4, #0]
      if (iprh_prev->end != iprh->start) {
 8012b7c:	88e2      	ldrh	r2, [r4, #6]
 8012b7e:	88b3      	ldrh	r3, [r6, #4]
 8012b80:	429a      	cmp	r2, r3
 8012b82:	d0d1      	beq.n	8012b28 <ip_reass_chain_frag_into_datagram_and_validate+0x80>
        valid = 0;
 8012b84:	2700      	movs	r7, #0
 8012b86:	e7cf      	b.n	8012b28 <ip_reass_chain_frag_into_datagram_and_validate+0x80>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
 8012b88:	4b29      	ldr	r3, [pc, #164]	@ (8012c30 <ip_reass_chain_frag_into_datagram_and_validate+0x188>)
 8012b8a:	f44f 72db 	mov.w	r2, #438	@ 0x1b6
 8012b8e:	4929      	ldr	r1, [pc, #164]	@ (8012c34 <ip_reass_chain_frag_into_datagram_and_validate+0x18c>)
 8012b90:	4829      	ldr	r0, [pc, #164]	@ (8012c38 <ip_reass_chain_frag_into_datagram_and_validate+0x190>)
 8012b92:	f001 f9f5 	bl	8013f80 <iprintf>
 8012b96:	e7f0      	b.n	8012b7a <ip_reass_chain_frag_into_datagram_and_validate+0xd2>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
 8012b98:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8012b9c:	b133      	cbz	r3, 8012bac <ip_reass_chain_frag_into_datagram_and_validate+0x104>
 8012b9e:	4b24      	ldr	r3, [pc, #144]	@ (8012c30 <ip_reass_chain_frag_into_datagram_and_validate+0x188>)
 8012ba0:	f44f 72df 	mov.w	r2, #446	@ 0x1be
 8012ba4:	4925      	ldr	r1, [pc, #148]	@ (8012c3c <ip_reass_chain_frag_into_datagram_and_validate+0x194>)
 8012ba6:	4824      	ldr	r0, [pc, #144]	@ (8012c38 <ip_reass_chain_frag_into_datagram_and_validate+0x190>)
 8012ba8:	f001 f9ea 	bl	8013f80 <iprintf>
      ipr->p = new_p;
 8012bac:	f8c8 5004 	str.w	r5, [r8, #4]
 8012bb0:	e7ba      	b.n	8012b28 <ip_reass_chain_frag_into_datagram_and_validate+0x80>
    if (valid) {
 8012bb2:	b34f      	cbz	r7, 8012c08 <ip_reass_chain_frag_into_datagram_and_validate+0x160>
      if ((ipr->p == NULL) || (((struct ip_reass_helper *)ipr->p->payload)->start != 0)) {
 8012bb4:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8012bb8:	b31b      	cbz	r3, 8012c02 <ip_reass_chain_frag_into_datagram_and_validate+0x15a>
 8012bba:	6858      	ldr	r0, [r3, #4]
 8012bbc:	8883      	ldrh	r3, [r0, #4]
 8012bbe:	bb13      	cbnz	r3, 8012c06 <ip_reass_chain_frag_into_datagram_and_validate+0x15e>
        q = iprh->next_pbuf;
 8012bc0:	6832      	ldr	r2, [r6, #0]
        while (q != NULL) {
 8012bc2:	b14a      	cbz	r2, 8012bd8 <ip_reass_chain_frag_into_datagram_and_validate+0x130>
          iprh = (struct ip_reass_helper *)q->payload;
 8012bc4:	6853      	ldr	r3, [r2, #4]
          if (iprh_prev->end != iprh->start) {
 8012bc6:	88f1      	ldrh	r1, [r6, #6]
 8012bc8:	889a      	ldrh	r2, [r3, #4]
 8012bca:	4291      	cmp	r1, r2
 8012bcc:	d102      	bne.n	8012bd4 <ip_reass_chain_frag_into_datagram_and_validate+0x12c>
          q = iprh->next_pbuf;
 8012bce:	681a      	ldr	r2, [r3, #0]
          iprh = (struct ip_reass_helper *)q->payload;
 8012bd0:	461e      	mov	r6, r3
 8012bd2:	e7f6      	b.n	8012bc2 <ip_reass_chain_frag_into_datagram_and_validate+0x11a>
 8012bd4:	461e      	mov	r6, r3
            valid = 0;
 8012bd6:	2700      	movs	r7, #0
        if (valid) {
 8012bd8:	b1b7      	cbz	r7, 8012c08 <ip_reass_chain_frag_into_datagram_and_validate+0x160>
          LWIP_ASSERT("sanity check",
 8012bda:	42b0      	cmp	r0, r6
 8012bdc:	d009      	beq.n	8012bf2 <ip_reass_chain_frag_into_datagram_and_validate+0x14a>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
 8012bde:	6833      	ldr	r3, [r6, #0]
 8012be0:	b193      	cbz	r3, 8012c08 <ip_reass_chain_frag_into_datagram_and_validate+0x160>
 8012be2:	4b13      	ldr	r3, [pc, #76]	@ (8012c30 <ip_reass_chain_frag_into_datagram_and_validate+0x188>)
 8012be4:	f44f 72f1 	mov.w	r2, #482	@ 0x1e2
 8012be8:	4915      	ldr	r1, [pc, #84]	@ (8012c40 <ip_reass_chain_frag_into_datagram_and_validate+0x198>)
 8012bea:	4813      	ldr	r0, [pc, #76]	@ (8012c38 <ip_reass_chain_frag_into_datagram_and_validate+0x190>)
 8012bec:	f001 f9c8 	bl	8013f80 <iprintf>
 8012bf0:	e00a      	b.n	8012c08 <ip_reass_chain_frag_into_datagram_and_validate+0x160>
          LWIP_ASSERT("sanity check",
 8012bf2:	4b0f      	ldr	r3, [pc, #60]	@ (8012c30 <ip_reass_chain_frag_into_datagram_and_validate+0x188>)
 8012bf4:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 8012bf8:	4912      	ldr	r1, [pc, #72]	@ (8012c44 <ip_reass_chain_frag_into_datagram_and_validate+0x19c>)
 8012bfa:	480f      	ldr	r0, [pc, #60]	@ (8012c38 <ip_reass_chain_frag_into_datagram_and_validate+0x190>)
 8012bfc:	f001 f9c0 	bl	8013f80 <iprintf>
 8012c00:	e7ed      	b.n	8012bde <ip_reass_chain_frag_into_datagram_and_validate+0x136>
        valid = 0;
 8012c02:	2700      	movs	r7, #0
 8012c04:	e000      	b.n	8012c08 <ip_reass_chain_frag_into_datagram_and_validate+0x160>
 8012c06:	2700      	movs	r7, #0
    return valid ? IP_REASS_VALIDATE_TELEGRAM_FINISHED : IP_REASS_VALIDATE_PBUF_QUEUED;
 8012c08:	4638      	mov	r0, r7
 8012c0a:	e75e      	b.n	8012aca <ip_reass_chain_frag_into_datagram_and_validate+0x22>
    return IP_REASS_VALIDATE_PBUF_DROPPED;
 8012c0c:	f04f 30ff 	mov.w	r0, #4294967295
 8012c10:	e75b      	b.n	8012aca <ip_reass_chain_frag_into_datagram_and_validate+0x22>
          return IP_REASS_VALIDATE_PBUF_DROPPED;
 8012c12:	f04f 30ff 	mov.w	r0, #4294967295
 8012c16:	e758      	b.n	8012aca <ip_reass_chain_frag_into_datagram_and_validate+0x22>
 8012c18:	f04f 30ff 	mov.w	r0, #4294967295
 8012c1c:	e755      	b.n	8012aca <ip_reass_chain_frag_into_datagram_and_validate+0x22>
          return IP_REASS_VALIDATE_PBUF_DROPPED;
 8012c1e:	f04f 30ff 	mov.w	r0, #4294967295
 8012c22:	e752      	b.n	8012aca <ip_reass_chain_frag_into_datagram_and_validate+0x22>
      return IP_REASS_VALIDATE_PBUF_DROPPED;
 8012c24:	f04f 30ff 	mov.w	r0, #4294967295
 8012c28:	e74f      	b.n	8012aca <ip_reass_chain_frag_into_datagram_and_validate+0x22>
      return IP_REASS_VALIDATE_PBUF_DROPPED;
 8012c2a:	f04f 30ff 	mov.w	r0, #4294967295
 8012c2e:	e74c      	b.n	8012aca <ip_reass_chain_frag_into_datagram_and_validate+0x22>
 8012c30:	08018930 	.word	0x08018930
 8012c34:	080189f8 	.word	0x080189f8
 8012c38:	08015744 	.word	0x08015744
 8012c3c:	08018a18 	.word	0x08018a18
 8012c40:	08018a60 	.word	0x08018a60
 8012c44:	08018a50 	.word	0x08018a50

08012c48 <ip_frag_alloc_pbuf_custom_ref>:
{
 8012c48:	b508      	push	{r3, lr}
  return (struct pbuf_custom_ref *)memp_malloc(MEMP_FRAG_PBUF);
 8012c4a:	2005      	movs	r0, #5
 8012c4c:	f7f8 fc1e 	bl	800b48c <memp_malloc>
}
 8012c50:	bd08      	pop	{r3, pc}
	...

08012c54 <ip_reass_enqueue_new_datagram>:
{
 8012c54:	b570      	push	{r4, r5, r6, lr}
 8012c56:	4605      	mov	r5, r0
 8012c58:	460e      	mov	r6, r1
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 8012c5a:	2004      	movs	r0, #4
 8012c5c:	f7f8 fc16 	bl	800b48c <memp_malloc>
  if (ipr == NULL) {
 8012c60:	4604      	mov	r4, r0
 8012c62:	b1b0      	cbz	r0, 8012c92 <ip_reass_enqueue_new_datagram+0x3e>
  memset(ipr, 0, sizeof(struct ip_reassdata));
 8012c64:	2220      	movs	r2, #32
 8012c66:	2100      	movs	r1, #0
 8012c68:	4620      	mov	r0, r4
 8012c6a:	f001 fb25 	bl	80142b8 <memset>
  ipr->timer = IP_REASS_MAXAGE;
 8012c6e:	230f      	movs	r3, #15
 8012c70:	77e3      	strb	r3, [r4, #31]
  ipr->next = reassdatagrams;
 8012c72:	4b11      	ldr	r3, [pc, #68]	@ (8012cb8 <ip_reass_enqueue_new_datagram+0x64>)
 8012c74:	681a      	ldr	r2, [r3, #0]
 8012c76:	6022      	str	r2, [r4, #0]
  reassdatagrams = ipr;
 8012c78:	601c      	str	r4, [r3, #0]
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
 8012c7a:	682b      	ldr	r3, [r5, #0]
 8012c7c:	6868      	ldr	r0, [r5, #4]
 8012c7e:	68a9      	ldr	r1, [r5, #8]
 8012c80:	68ea      	ldr	r2, [r5, #12]
 8012c82:	60a3      	str	r3, [r4, #8]
 8012c84:	60e0      	str	r0, [r4, #12]
 8012c86:	6121      	str	r1, [r4, #16]
 8012c88:	6162      	str	r2, [r4, #20]
 8012c8a:	692b      	ldr	r3, [r5, #16]
 8012c8c:	61a3      	str	r3, [r4, #24]
}
 8012c8e:	4620      	mov	r0, r4
 8012c90:	bd70      	pop	{r4, r5, r6, pc}
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
 8012c92:	4631      	mov	r1, r6
 8012c94:	4628      	mov	r0, r5
 8012c96:	f7ff fe97 	bl	80129c8 <ip_reass_remove_oldest_datagram>
 8012c9a:	42b0      	cmp	r0, r6
 8012c9c:	da06      	bge.n	8012cac <ip_reass_enqueue_new_datagram+0x58>
    if (ipr == NULL)
 8012c9e:	2c00      	cmp	r4, #0
 8012ca0:	d1e0      	bne.n	8012c64 <ip_reass_enqueue_new_datagram+0x10>
      IPFRAG_STATS_INC(ip_frag.memerr);
 8012ca2:	4a06      	ldr	r2, [pc, #24]	@ (8012cbc <ip_reass_enqueue_new_datagram+0x68>)
 8012ca4:	8f93      	ldrh	r3, [r2, #60]	@ 0x3c
 8012ca6:	3301      	adds	r3, #1
 8012ca8:	8793      	strh	r3, [r2, #60]	@ 0x3c
      return NULL;
 8012caa:	e7f0      	b.n	8012c8e <ip_reass_enqueue_new_datagram+0x3a>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 8012cac:	2004      	movs	r0, #4
 8012cae:	f7f8 fbed 	bl	800b48c <memp_malloc>
 8012cb2:	4604      	mov	r4, r0
 8012cb4:	e7f3      	b.n	8012c9e <ip_reass_enqueue_new_datagram+0x4a>
 8012cb6:	bf00      	nop
 8012cb8:	2401443c 	.word	0x2401443c
 8012cbc:	240141b4 	.word	0x240141b4

08012cc0 <ip_reass_tmr>:
{
 8012cc0:	b538      	push	{r3, r4, r5, lr}
  r = reassdatagrams;
 8012cc2:	4b09      	ldr	r3, [pc, #36]	@ (8012ce8 <ip_reass_tmr+0x28>)
 8012cc4:	6818      	ldr	r0, [r3, #0]
  struct ip_reassdata *r, *prev = NULL;
 8012cc6:	2400      	movs	r4, #0
  while (r != NULL) {
 8012cc8:	e003      	b.n	8012cd2 <ip_reass_tmr+0x12>
      r->timer--;
 8012cca:	3b01      	subs	r3, #1
 8012ccc:	77c3      	strb	r3, [r0, #31]
      prev = r;
 8012cce:	4604      	mov	r4, r0
      r = r->next;
 8012cd0:	6800      	ldr	r0, [r0, #0]
  while (r != NULL) {
 8012cd2:	b140      	cbz	r0, 8012ce6 <ip_reass_tmr+0x26>
    if (r->timer > 0) {
 8012cd4:	7fc3      	ldrb	r3, [r0, #31]
 8012cd6:	2b00      	cmp	r3, #0
 8012cd8:	d1f7      	bne.n	8012cca <ip_reass_tmr+0xa>
      r = r->next;
 8012cda:	6805      	ldr	r5, [r0, #0]
      ip_reass_free_complete_datagram(tmp, prev);
 8012cdc:	4621      	mov	r1, r4
 8012cde:	f7ff fdf5 	bl	80128cc <ip_reass_free_complete_datagram>
      r = r->next;
 8012ce2:	4628      	mov	r0, r5
 8012ce4:	e7f5      	b.n	8012cd2 <ip_reass_tmr+0x12>
}
 8012ce6:	bd38      	pop	{r3, r4, r5, pc}
 8012ce8:	2401443c 	.word	0x2401443c

08012cec <ip4_reass>:
{
 8012cec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8012cf0:	4606      	mov	r6, r0
  IPFRAG_STATS_INC(ip_frag.recv);
 8012cf2:	4a86      	ldr	r2, [pc, #536]	@ (8012f0c <ip4_reass+0x220>)
 8012cf4:	8e53      	ldrh	r3, [r2, #50]	@ 0x32
 8012cf6:	3301      	adds	r3, #1
 8012cf8:	8653      	strh	r3, [r2, #50]	@ 0x32
  fraghdr = (struct ip_hdr *)p->payload;
 8012cfa:	6845      	ldr	r5, [r0, #4]
  if (IPH_HL_BYTES(fraghdr) != IP_HLEN) {
 8012cfc:	782b      	ldrb	r3, [r5, #0]
 8012cfe:	f003 030f 	and.w	r3, r3, #15
 8012d02:	2b05      	cmp	r3, #5
 8012d04:	d11e      	bne.n	8012d44 <ip4_reass+0x58>
  offset = IPH_OFFSET_BYTES(fraghdr);
 8012d06:	88e8      	ldrh	r0, [r5, #6]
 8012d08:	f7f7 ff2a 	bl	800ab60 <lwip_htons>
 8012d0c:	f3c0 080c 	ubfx	r8, r0, #0, #13
 8012d10:	ea4f 08c8 	mov.w	r8, r8, lsl #3
  len = lwip_ntohs(IPH_LEN(fraghdr));
 8012d14:	8868      	ldrh	r0, [r5, #2]
 8012d16:	f7f7 ff23 	bl	800ab60 <lwip_htons>
  hlen = IPH_HL_BYTES(fraghdr);
 8012d1a:	782b      	ldrb	r3, [r5, #0]
 8012d1c:	f003 030f 	and.w	r3, r3, #15
 8012d20:	009a      	lsls	r2, r3, #2
  if (hlen > len) {
 8012d22:	ebb0 0f83 	cmp.w	r0, r3, lsl #2
 8012d26:	d312      	bcc.n	8012d4e <ip4_reass+0x62>
  len = (u16_t)(len - hlen);
 8012d28:	1a80      	subs	r0, r0, r2
 8012d2a:	b287      	uxth	r7, r0
  clen = pbuf_clen(p);
 8012d2c:	4630      	mov	r0, r6
 8012d2e:	f7f9 f867 	bl	800be00 <pbuf_clen>
 8012d32:	4681      	mov	r9, r0
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 8012d34:	4b76      	ldr	r3, [pc, #472]	@ (8012f10 <ip4_reass+0x224>)
 8012d36:	881b      	ldrh	r3, [r3, #0]
 8012d38:	4403      	add	r3, r0
 8012d3a:	2b0a      	cmp	r3, #10
 8012d3c:	dc12      	bgt.n	8012d64 <ip4_reass+0x78>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 8012d3e:	4b75      	ldr	r3, [pc, #468]	@ (8012f14 <ip4_reass+0x228>)
 8012d40:	681c      	ldr	r4, [r3, #0]
 8012d42:	e01f      	b.n	8012d84 <ip4_reass+0x98>
    IPFRAG_STATS_INC(ip_frag.err);
 8012d44:	f8b2 3044 	ldrh.w	r3, [r2, #68]	@ 0x44
 8012d48:	3301      	adds	r3, #1
 8012d4a:	f8a2 3044 	strh.w	r3, [r2, #68]	@ 0x44
  IPFRAG_STATS_INC(ip_frag.drop);
 8012d4e:	4a6f      	ldr	r2, [pc, #444]	@ (8012f0c <ip4_reass+0x220>)
 8012d50:	8ed3      	ldrh	r3, [r2, #54]	@ 0x36
 8012d52:	3301      	adds	r3, #1
 8012d54:	86d3      	strh	r3, [r2, #54]	@ 0x36
  pbuf_free(p);
 8012d56:	4630      	mov	r0, r6
 8012d58:	f7f8 feea 	bl	800bb30 <pbuf_free>
  return NULL;
 8012d5c:	2600      	movs	r6, #0
}
 8012d5e:	4630      	mov	r0, r6
 8012d60:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 8012d64:	4601      	mov	r1, r0
 8012d66:	4628      	mov	r0, r5
 8012d68:	f7ff fe2e 	bl	80129c8 <ip_reass_remove_oldest_datagram>
 8012d6c:	b120      	cbz	r0, 8012d78 <ip4_reass+0x8c>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
 8012d6e:	4b68      	ldr	r3, [pc, #416]	@ (8012f10 <ip4_reass+0x224>)
 8012d70:	881b      	ldrh	r3, [r3, #0]
 8012d72:	444b      	add	r3, r9
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 8012d74:	2b0a      	cmp	r3, #10
 8012d76:	dde2      	ble.n	8012d3e <ip4_reass+0x52>
      IPFRAG_STATS_INC(ip_frag.memerr);
 8012d78:	4a64      	ldr	r2, [pc, #400]	@ (8012f0c <ip4_reass+0x220>)
 8012d7a:	8f93      	ldrh	r3, [r2, #60]	@ 0x3c
 8012d7c:	3301      	adds	r3, #1
 8012d7e:	8793      	strh	r3, [r2, #60]	@ 0x3c
      goto nullreturn;
 8012d80:	e7e5      	b.n	8012d4e <ip4_reass+0x62>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 8012d82:	6824      	ldr	r4, [r4, #0]
 8012d84:	b18c      	cbz	r4, 8012daa <ip4_reass+0xbe>
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
 8012d86:	6962      	ldr	r2, [r4, #20]
 8012d88:	68eb      	ldr	r3, [r5, #12]
 8012d8a:	429a      	cmp	r2, r3
 8012d8c:	d1f9      	bne.n	8012d82 <ip4_reass+0x96>
 8012d8e:	69a2      	ldr	r2, [r4, #24]
 8012d90:	692b      	ldr	r3, [r5, #16]
 8012d92:	429a      	cmp	r2, r3
 8012d94:	d1f5      	bne.n	8012d82 <ip4_reass+0x96>
 8012d96:	89a2      	ldrh	r2, [r4, #12]
 8012d98:	88ab      	ldrh	r3, [r5, #4]
 8012d9a:	429a      	cmp	r2, r3
 8012d9c:	d1f1      	bne.n	8012d82 <ip4_reass+0x96>
      IPFRAG_STATS_INC(ip_frag.cachehit);
 8012d9e:	4a5b      	ldr	r2, [pc, #364]	@ (8012f0c <ip4_reass+0x220>)
 8012da0:	f8b2 3046 	ldrh.w	r3, [r2, #70]	@ 0x46
 8012da4:	3301      	adds	r3, #1
 8012da6:	f8a2 3046 	strh.w	r3, [r2, #70]	@ 0x46
  if (ipr == NULL) {
 8012daa:	b374      	cbz	r4, 8012e0a <ip4_reass+0x11e>
    if (((lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
 8012dac:	88e8      	ldrh	r0, [r5, #6]
 8012dae:	f7f7 fed7 	bl	800ab60 <lwip_htons>
 8012db2:	f3c0 000c 	ubfx	r0, r0, #0, #13
 8012db6:	b380      	cbz	r0, 8012e1a <ip4_reass+0x12e>
  is_last = (IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0;
 8012db8:	88ed      	ldrh	r5, [r5, #6]
 8012dba:	f005 0520 	and.w	r5, r5, #32
 8012dbe:	2d00      	cmp	r5, #0
 8012dc0:	bf0c      	ite	eq
 8012dc2:	2201      	moveq	r2, #1
 8012dc4:	2200      	movne	r2, #0
  if (is_last) {
 8012dc6:	d108      	bne.n	8012dda <ip4_reass+0xee>
    u16_t datagram_len = (u16_t)(offset + len);
 8012dc8:	eb08 0307 	add.w	r3, r8, r7
 8012dcc:	b29b      	uxth	r3, r3
    if ((datagram_len < offset) || (datagram_len > (0xFFFF - IP_HLEN))) {
 8012dce:	f64f 71eb 	movw	r1, #65515	@ 0xffeb
 8012dd2:	428b      	cmp	r3, r1
 8012dd4:	bf98      	it	ls
 8012dd6:	4598      	cmpls	r8, r3
 8012dd8:	d87a      	bhi.n	8012ed0 <ip4_reass+0x1e4>
  valid = ip_reass_chain_frag_into_datagram_and_validate(ipr, p, is_last);
 8012dda:	4631      	mov	r1, r6
 8012ddc:	4620      	mov	r0, r4
 8012dde:	f7ff fe63 	bl	8012aa8 <ip_reass_chain_frag_into_datagram_and_validate>
  if (valid == IP_REASS_VALIDATE_PBUF_DROPPED) {
 8012de2:	f1b0 3fff 	cmp.w	r0, #4294967295
 8012de6:	d073      	beq.n	8012ed0 <ip4_reass+0x1e4>
  ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount + clen);
 8012de8:	4b49      	ldr	r3, [pc, #292]	@ (8012f10 <ip4_reass+0x224>)
 8012dea:	881a      	ldrh	r2, [r3, #0]
 8012dec:	4491      	add	r9, r2
 8012dee:	f8a3 9000 	strh.w	r9, [r3]
  if (is_last) {
 8012df2:	b935      	cbnz	r5, 8012e02 <ip4_reass+0x116>
    u16_t datagram_len = (u16_t)(offset + len);
 8012df4:	44b8      	add	r8, r7
    ipr->datagram_len = datagram_len;
 8012df6:	f8a4 801c 	strh.w	r8, [r4, #28]
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 8012dfa:	7fa3      	ldrb	r3, [r4, #30]
 8012dfc:	f043 0301 	orr.w	r3, r3, #1
 8012e00:	77a3      	strb	r3, [r4, #30]
  if (valid == IP_REASS_VALIDATE_TELEGRAM_FINISHED) {
 8012e02:	2801      	cmp	r0, #1
 8012e04:	d01b      	beq.n	8012e3e <ip4_reass+0x152>
  return NULL;
 8012e06:	2600      	movs	r6, #0
 8012e08:	e7a9      	b.n	8012d5e <ip4_reass+0x72>
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
 8012e0a:	4649      	mov	r1, r9
 8012e0c:	4628      	mov	r0, r5
 8012e0e:	f7ff ff21 	bl	8012c54 <ip_reass_enqueue_new_datagram>
    if (ipr == NULL) {
 8012e12:	4604      	mov	r4, r0
 8012e14:	2800      	cmp	r0, #0
 8012e16:	d1cf      	bne.n	8012db8 <ip4_reass+0xcc>
 8012e18:	e799      	b.n	8012d4e <ip4_reass+0x62>
        ((lwip_ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 8012e1a:	89e0      	ldrh	r0, [r4, #14]
 8012e1c:	f7f7 fea0 	bl	800ab60 <lwip_htons>
    if (((lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
 8012e20:	f3c0 000c 	ubfx	r0, r0, #0, #13
 8012e24:	2800      	cmp	r0, #0
 8012e26:	d0c7      	beq.n	8012db8 <ip4_reass+0xcc>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
 8012e28:	682b      	ldr	r3, [r5, #0]
 8012e2a:	6868      	ldr	r0, [r5, #4]
 8012e2c:	68a9      	ldr	r1, [r5, #8]
 8012e2e:	68ea      	ldr	r2, [r5, #12]
 8012e30:	60a3      	str	r3, [r4, #8]
 8012e32:	60e0      	str	r0, [r4, #12]
 8012e34:	6121      	str	r1, [r4, #16]
 8012e36:	6162      	str	r2, [r4, #20]
 8012e38:	692b      	ldr	r3, [r5, #16]
 8012e3a:	61a3      	str	r3, [r4, #24]
 8012e3c:	e7bc      	b.n	8012db8 <ip4_reass+0xcc>
    u16_t datagram_len = (u16_t)(ipr->datagram_len + IP_HLEN);
 8012e3e:	8ba0      	ldrh	r0, [r4, #28]
 8012e40:	3014      	adds	r0, #20
    r = ((struct ip_reass_helper *)ipr->p->payload)->next_pbuf;
 8012e42:	6863      	ldr	r3, [r4, #4]
 8012e44:	685e      	ldr	r6, [r3, #4]
 8012e46:	6835      	ldr	r5, [r6, #0]
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 8012e48:	68a3      	ldr	r3, [r4, #8]
 8012e4a:	68e7      	ldr	r7, [r4, #12]
 8012e4c:	6921      	ldr	r1, [r4, #16]
 8012e4e:	6962      	ldr	r2, [r4, #20]
 8012e50:	6033      	str	r3, [r6, #0]
 8012e52:	6077      	str	r7, [r6, #4]
 8012e54:	60b1      	str	r1, [r6, #8]
 8012e56:	60f2      	str	r2, [r6, #12]
 8012e58:	69a3      	ldr	r3, [r4, #24]
 8012e5a:	6133      	str	r3, [r6, #16]
    IPH_LEN_SET(fraghdr, lwip_htons(datagram_len));
 8012e5c:	b280      	uxth	r0, r0
 8012e5e:	f7f7 fe7f 	bl	800ab60 <lwip_htons>
 8012e62:	8070      	strh	r0, [r6, #2]
    IPH_OFFSET_SET(fraghdr, 0);
 8012e64:	2300      	movs	r3, #0
 8012e66:	71b3      	strb	r3, [r6, #6]
 8012e68:	71f3      	strb	r3, [r6, #7]
    IPH_CHKSUM_SET(fraghdr, 0);
 8012e6a:	72b3      	strb	r3, [r6, #10]
 8012e6c:	72f3      	strb	r3, [r6, #11]
    p = ipr->p;
 8012e6e:	6866      	ldr	r6, [r4, #4]
    while (r != NULL) {
 8012e70:	e009      	b.n	8012e86 <ip4_reass+0x19a>
      iprh = (struct ip_reass_helper *)r->payload;
 8012e72:	686f      	ldr	r7, [r5, #4]
      pbuf_remove_header(r, IP_HLEN);
 8012e74:	2114      	movs	r1, #20
 8012e76:	4628      	mov	r0, r5
 8012e78:	f7f8 fe14 	bl	800baa4 <pbuf_remove_header>
      pbuf_cat(p, r);
 8012e7c:	4629      	mov	r1, r5
 8012e7e:	4630      	mov	r0, r6
 8012e80:	f7f8 ffe4 	bl	800be4c <pbuf_cat>
      r = iprh->next_pbuf;
 8012e84:	683d      	ldr	r5, [r7, #0]
    while (r != NULL) {
 8012e86:	2d00      	cmp	r5, #0
 8012e88:	d1f3      	bne.n	8012e72 <ip4_reass+0x186>
    if (ipr == reassdatagrams) {
 8012e8a:	4b22      	ldr	r3, [pc, #136]	@ (8012f14 <ip4_reass+0x228>)
 8012e8c:	6819      	ldr	r1, [r3, #0]
 8012e8e:	428c      	cmp	r4, r1
 8012e90:	d005      	beq.n	8012e9e <ip4_reass+0x1b2>
      for (ipr_prev = reassdatagrams; ipr_prev != NULL; ipr_prev = ipr_prev->next) {
 8012e92:	b129      	cbz	r1, 8012ea0 <ip4_reass+0x1b4>
        if (ipr_prev->next == ipr) {
 8012e94:	680b      	ldr	r3, [r1, #0]
 8012e96:	429c      	cmp	r4, r3
 8012e98:	d002      	beq.n	8012ea0 <ip4_reass+0x1b4>
      for (ipr_prev = reassdatagrams; ipr_prev != NULL; ipr_prev = ipr_prev->next) {
 8012e9a:	4619      	mov	r1, r3
 8012e9c:	e7f9      	b.n	8012e92 <ip4_reass+0x1a6>
      ipr_prev = NULL;
 8012e9e:	4629      	mov	r1, r5
    ip_reass_dequeue_datagram(ipr, ipr_prev);
 8012ea0:	4620      	mov	r0, r4
 8012ea2:	f7ff fcef 	bl	8012884 <ip_reass_dequeue_datagram>
    clen = pbuf_clen(p);
 8012ea6:	4630      	mov	r0, r6
 8012ea8:	f7f8 ffaa 	bl	800be00 <pbuf_clen>
 8012eac:	4604      	mov	r4, r0
    LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= clen);
 8012eae:	4b18      	ldr	r3, [pc, #96]	@ (8012f10 <ip4_reass+0x224>)
 8012eb0:	881b      	ldrh	r3, [r3, #0]
 8012eb2:	4283      	cmp	r3, r0
 8012eb4:	d304      	bcc.n	8012ec0 <ip4_reass+0x1d4>
    ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - clen);
 8012eb6:	4a16      	ldr	r2, [pc, #88]	@ (8012f10 <ip4_reass+0x224>)
 8012eb8:	8813      	ldrh	r3, [r2, #0]
 8012eba:	1b1b      	subs	r3, r3, r4
 8012ebc:	8013      	strh	r3, [r2, #0]
    return p;
 8012ebe:	e74e      	b.n	8012d5e <ip4_reass+0x72>
    LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= clen);
 8012ec0:	4b15      	ldr	r3, [pc, #84]	@ (8012f18 <ip4_reass+0x22c>)
 8012ec2:	f240 229b 	movw	r2, #667	@ 0x29b
 8012ec6:	4915      	ldr	r1, [pc, #84]	@ (8012f1c <ip4_reass+0x230>)
 8012ec8:	4815      	ldr	r0, [pc, #84]	@ (8012f20 <ip4_reass+0x234>)
 8012eca:	f001 f859 	bl	8013f80 <iprintf>
 8012ece:	e7f2      	b.n	8012eb6 <ip4_reass+0x1ca>
  LWIP_ASSERT("ipr != NULL", ipr != NULL);
 8012ed0:	b19c      	cbz	r4, 8012efa <ip4_reass+0x20e>
  if (ipr->p == NULL) {
 8012ed2:	6863      	ldr	r3, [r4, #4]
 8012ed4:	2b00      	cmp	r3, #0
 8012ed6:	f47f af3a 	bne.w	8012d4e <ip4_reass+0x62>
    LWIP_ASSERT("not firstalthough just enqueued", ipr == reassdatagrams);
 8012eda:	4b0e      	ldr	r3, [pc, #56]	@ (8012f14 <ip4_reass+0x228>)
 8012edc:	681b      	ldr	r3, [r3, #0]
 8012ede:	429c      	cmp	r4, r3
 8012ee0:	d006      	beq.n	8012ef0 <ip4_reass+0x204>
 8012ee2:	4b0d      	ldr	r3, [pc, #52]	@ (8012f18 <ip4_reass+0x22c>)
 8012ee4:	f240 22ab 	movw	r2, #683	@ 0x2ab
 8012ee8:	490e      	ldr	r1, [pc, #56]	@ (8012f24 <ip4_reass+0x238>)
 8012eea:	480d      	ldr	r0, [pc, #52]	@ (8012f20 <ip4_reass+0x234>)
 8012eec:	f001 f848 	bl	8013f80 <iprintf>
    ip_reass_dequeue_datagram(ipr, NULL);
 8012ef0:	2100      	movs	r1, #0
 8012ef2:	4620      	mov	r0, r4
 8012ef4:	f7ff fcc6 	bl	8012884 <ip_reass_dequeue_datagram>
 8012ef8:	e729      	b.n	8012d4e <ip4_reass+0x62>
  LWIP_ASSERT("ipr != NULL", ipr != NULL);
 8012efa:	4b07      	ldr	r3, [pc, #28]	@ (8012f18 <ip4_reass+0x22c>)
 8012efc:	f44f 722a 	mov.w	r2, #680	@ 0x2a8
 8012f00:	4909      	ldr	r1, [pc, #36]	@ (8012f28 <ip4_reass+0x23c>)
 8012f02:	4807      	ldr	r0, [pc, #28]	@ (8012f20 <ip4_reass+0x234>)
 8012f04:	f001 f83c 	bl	8013f80 <iprintf>
 8012f08:	e7e3      	b.n	8012ed2 <ip4_reass+0x1e6>
 8012f0a:	bf00      	nop
 8012f0c:	240141b4 	.word	0x240141b4
 8012f10:	2401443a 	.word	0x2401443a
 8012f14:	2401443c 	.word	0x2401443c
 8012f18:	08018930 	.word	0x08018930
 8012f1c:	08018a84 	.word	0x08018a84
 8012f20:	08015744 	.word	0x08015744
 8012f24:	08018aac 	.word	0x08018aac
 8012f28:	08018aa0 	.word	0x08018aa0

08012f2c <ip4_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t
ip4_frag(struct pbuf *p, struct netif *netif, const ip4_addr_t *dest)
{
 8012f2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012f30:	b08b      	sub	sp, #44	@ 0x2c
 8012f32:	4605      	mov	r5, r0
 8012f34:	9106      	str	r1, [sp, #24]
 8012f36:	9208      	str	r2, [sp, #32]
  u16_t newpbuflen = 0;
  u16_t left_to_copy;
#endif
  struct ip_hdr *original_iphdr;
  struct ip_hdr *iphdr;
  const u16_t nfb = (u16_t)((netif->mtu - IP_HLEN) / 8);
 8012f38:	8c8b      	ldrh	r3, [r1, #36]	@ 0x24
 8012f3a:	3b14      	subs	r3, #20
 8012f3c:	d421      	bmi.n	8012f82 <ip4_frag+0x56>
 8012f3e:	f3c3 03cf 	ubfx	r3, r3, #3, #16
 8012f42:	9305      	str	r3, [sp, #20]
  int last;
  u16_t poff = IP_HLEN;
  u16_t tmp;
  int mf_set;

  original_iphdr = (struct ip_hdr *)p->payload;
 8012f44:	f8d5 8004 	ldr.w	r8, [r5, #4]
  iphdr = original_iphdr;
  if (IPH_HL_BYTES(iphdr) != IP_HLEN) {
 8012f48:	f898 3000 	ldrb.w	r3, [r8]
 8012f4c:	f003 030f 	and.w	r3, r3, #15
 8012f50:	2b05      	cmp	r3, #5
 8012f52:	f040 80dc 	bne.w	801310e <ip4_frag+0x1e2>
    /* ip4_frag() does not support IP options */
    return ERR_VAL;
  }
  LWIP_ERROR("ip4_frag(): pbuf too short", p->len >= IP_HLEN, return ERR_VAL);
 8012f56:	896b      	ldrh	r3, [r5, #10]
 8012f58:	2b13      	cmp	r3, #19
 8012f5a:	d914      	bls.n	8012f86 <ip4_frag+0x5a>

  /* Save original offset */
  tmp = lwip_ntohs(IPH_OFFSET(iphdr));
 8012f5c:	f8b8 0006 	ldrh.w	r0, [r8, #6]
 8012f60:	f7f7 fdfe 	bl	800ab60 <lwip_htons>
  ofo = tmp & IP_OFFMASK;
 8012f64:	f3c0 030c 	ubfx	r3, r0, #0, #13
 8012f68:	9304      	str	r3, [sp, #16]
  /* already fragmented? if so, the last fragment we create must have MF, too */
  mf_set = tmp & IP_MF;
 8012f6a:	f400 5300 	and.w	r3, r0, #8192	@ 0x2000
 8012f6e:	9309      	str	r3, [sp, #36]	@ 0x24

  left = (u16_t)(p->tot_len - IP_HLEN);
 8012f70:	892b      	ldrh	r3, [r5, #8]
 8012f72:	3b14      	subs	r3, #20
 8012f74:	fa1f fb83 	uxth.w	fp, r3
  u16_t poff = IP_HLEN;
 8012f78:	2714      	movs	r7, #20
  u16_t newpbuflen = 0;
 8012f7a:	2400      	movs	r4, #0
 8012f7c:	f8cd b008 	str.w	fp, [sp, #8]

  while (left) {
 8012f80:	e096      	b.n	80130b0 <ip4_frag+0x184>
  const u16_t nfb = (u16_t)((netif->mtu - IP_HLEN) / 8);
 8012f82:	3307      	adds	r3, #7
 8012f84:	e7db      	b.n	8012f3e <ip4_frag+0x12>
  LWIP_ERROR("ip4_frag(): pbuf too short", p->len >= IP_HLEN, return ERR_VAL);
 8012f86:	4b65      	ldr	r3, [pc, #404]	@ (801311c <ip4_frag+0x1f0>)
 8012f88:	f44f 723f 	mov.w	r2, #764	@ 0x2fc
 8012f8c:	4964      	ldr	r1, [pc, #400]	@ (8013120 <ip4_frag+0x1f4>)
 8012f8e:	4865      	ldr	r0, [pc, #404]	@ (8013124 <ip4_frag+0x1f8>)
 8012f90:	f000 fff6 	bl	8013f80 <iprintf>
 8012f94:	f06f 0005 	mvn.w	r0, #5
 8012f98:	e042      	b.n	8013020 <ip4_frag+0xf4>
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
    if (rambuf == NULL) {
      goto memerr;
    }
    LWIP_ASSERT("this needs a pbuf in one piece!",
 8012f9a:	4b60      	ldr	r3, [pc, #384]	@ (801311c <ip4_frag+0x1f0>)
 8012f9c:	f44f 7249 	mov.w	r2, #804	@ 0x324
 8012fa0:	4961      	ldr	r1, [pc, #388]	@ (8013128 <ip4_frag+0x1fc>)
 8012fa2:	4860      	ldr	r0, [pc, #384]	@ (8013124 <ip4_frag+0x1f8>)
 8012fa4:	f000 ffec 	bl	8013f80 <iprintf>
 8012fa8:	e098      	b.n	80130dc <ip4_frag+0x1b0>

    left_to_copy = fragsize;
    while (left_to_copy) {
      struct pbuf_custom_ref *pcr;
      u16_t plen = (u16_t)(p->len - poff);
      LWIP_ASSERT("p->len >= poff", p->len >= poff);
 8012faa:	4b5c      	ldr	r3, [pc, #368]	@ (801311c <ip4_frag+0x1f0>)
 8012fac:	f240 322d 	movw	r2, #813	@ 0x32d
 8012fb0:	495e      	ldr	r1, [pc, #376]	@ (801312c <ip4_frag+0x200>)
 8012fb2:	485c      	ldr	r0, [pc, #368]	@ (8013124 <ip4_frag+0x1f8>)
 8012fb4:	f000 ffe4 	bl	8013f80 <iprintf>
 8012fb8:	e026      	b.n	8013008 <ip4_frag+0xdc>
      if (!newpbuflen) {
        poff = 0;
        p = p->next;
        continue;
      }
      pcr = ip_frag_alloc_pbuf_custom_ref();
 8012fba:	f7ff fe45 	bl	8012c48 <ip_frag_alloc_pbuf_custom_ref>
      if (pcr == NULL) {
 8012fbe:	4683      	mov	fp, r0
 8012fc0:	b348      	cbz	r0, 8013016 <ip4_frag+0xea>
        pbuf_free(rambuf);
        goto memerr;
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc,
                                    (u8_t *)p->payload + poff, newpbuflen);
 8012fc2:	686b      	ldr	r3, [r5, #4]
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc,
 8012fc4:	9401      	str	r4, [sp, #4]
 8012fc6:	443b      	add	r3, r7
 8012fc8:	9300      	str	r3, [sp, #0]
 8012fca:	4603      	mov	r3, r0
 8012fcc:	2241      	movs	r2, #65	@ 0x41
 8012fce:	4621      	mov	r1, r4
 8012fd0:	2000      	movs	r0, #0
 8012fd2:	f7f8 fd43 	bl	800ba5c <pbuf_alloced_custom>
      if (newpbuf == NULL) {
 8012fd6:	4680      	mov	r8, r0
 8012fd8:	b328      	cbz	r0, 8013026 <ip4_frag+0xfa>
        ip_frag_free_pbuf_custom_ref(pcr);
        pbuf_free(rambuf);
        goto memerr;
      }
      pbuf_ref(p);
 8012fda:	4628      	mov	r0, r5
 8012fdc:	f7f8 ff1a 	bl	800be14 <pbuf_ref>
      pcr->original = p;
 8012fe0:	f8cb 5014 	str.w	r5, [fp, #20]
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
 8012fe4:	4b52      	ldr	r3, [pc, #328]	@ (8013130 <ip4_frag+0x204>)
 8012fe6:	f8cb 3010 	str.w	r3, [fp, #16]

      /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
 8012fea:	4641      	mov	r1, r8
 8012fec:	4648      	mov	r0, r9
 8012fee:	f7f8 ff2d 	bl	800be4c <pbuf_cat>
      left_to_copy = (u16_t)(left_to_copy - newpbuflen);
 8012ff2:	1b36      	subs	r6, r6, r4
 8012ff4:	b2b6      	uxth	r6, r6
      if (left_to_copy) {
 8012ff6:	b1fe      	cbz	r6, 8013038 <ip4_frag+0x10c>
        poff = 0;
        p = p->next;
 8012ff8:	682d      	ldr	r5, [r5, #0]
{
 8012ffa:	2700      	movs	r7, #0
    while (left_to_copy) {
 8012ffc:	b1e6      	cbz	r6, 8013038 <ip4_frag+0x10c>
      u16_t plen = (u16_t)(p->len - poff);
 8012ffe:	896b      	ldrh	r3, [r5, #10]
 8013000:	1bdc      	subs	r4, r3, r7
 8013002:	b2a4      	uxth	r4, r4
      LWIP_ASSERT("p->len >= poff", p->len >= poff);
 8013004:	42bb      	cmp	r3, r7
 8013006:	d3d0      	bcc.n	8012faa <ip4_frag+0x7e>
      newpbuflen = LWIP_MIN(left_to_copy, plen);
 8013008:	42b4      	cmp	r4, r6
 801300a:	bf28      	it	cs
 801300c:	4634      	movcs	r4, r6
      if (!newpbuflen) {
 801300e:	2c00      	cmp	r4, #0
 8013010:	d1d3      	bne.n	8012fba <ip4_frag+0x8e>
        p = p->next;
 8013012:	682d      	ldr	r5, [r5, #0]
        continue;
 8013014:	e7f1      	b.n	8012ffa <ip4_frag+0xce>
        pbuf_free(rambuf);
 8013016:	4648      	mov	r0, r9
 8013018:	f7f8 fd8a 	bl	800bb30 <pbuf_free>
  }
  MIB2_STATS_INC(mib2.ipfragoks);
  return ERR_OK;
memerr:
  MIB2_STATS_INC(mib2.ipfragfails);
  return ERR_MEM;
 801301c:	f04f 30ff 	mov.w	r0, #4294967295
}
 8013020:	b00b      	add	sp, #44	@ 0x2c
 8013022:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ip_frag_free_pbuf_custom_ref(pcr);
 8013026:	4658      	mov	r0, fp
 8013028:	f7ff fd0e 	bl	8012a48 <ip_frag_free_pbuf_custom_ref>
        pbuf_free(rambuf);
 801302c:	4648      	mov	r0, r9
 801302e:	f7f8 fd7f 	bl	800bb30 <pbuf_free>
  return ERR_MEM;
 8013032:	f04f 30ff 	mov.w	r0, #4294967295
        goto memerr;
 8013036:	e7f3      	b.n	8013020 <ip4_frag+0xf4>
    poff = (u16_t)(poff + newpbuflen);
 8013038:	f8dd 801c 	ldr.w	r8, [sp, #28]
 801303c:	4427      	add	r7, r4
 801303e:	b2bf      	uxth	r7, r7
    last = (left <= netif->mtu - IP_HLEN);
 8013040:	9b06      	ldr	r3, [sp, #24]
 8013042:	8c9a      	ldrh	r2, [r3, #36]	@ 0x24
 8013044:	3a13      	subs	r2, #19
    tmp = (IP_OFFMASK & (ofo));
 8013046:	9b04      	ldr	r3, [sp, #16]
 8013048:	f3c3 000c 	ubfx	r0, r3, #0, #13
    if (!last || mf_set) {
 801304c:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 801304e:	3b00      	subs	r3, #0
 8013050:	bf18      	it	ne
 8013052:	2301      	movne	r3, #1
 8013054:	9902      	ldr	r1, [sp, #8]
 8013056:	428a      	cmp	r2, r1
 8013058:	bfd8      	it	le
 801305a:	f043 0301 	orrle.w	r3, r3, #1
 801305e:	b10b      	cbz	r3, 8013064 <ip4_frag+0x138>
      tmp = tmp | IP_MF;
 8013060:	f440 5000 	orr.w	r0, r0, #8192	@ 0x2000
    IPH_OFFSET_SET(iphdr, lwip_htons(tmp));
 8013064:	f7f7 fd7c 	bl	800ab60 <lwip_htons>
 8013068:	f8aa 0006 	strh.w	r0, [sl, #6]
    IPH_LEN_SET(iphdr, lwip_htons((u16_t)(fragsize + IP_HLEN)));
 801306c:	9e03      	ldr	r6, [sp, #12]
 801306e:	f106 0014 	add.w	r0, r6, #20
 8013072:	b280      	uxth	r0, r0
 8013074:	f7f7 fd74 	bl	800ab60 <lwip_htons>
 8013078:	f8aa 0002 	strh.w	r0, [sl, #2]
    IPH_CHKSUM_SET(iphdr, 0);
 801307c:	2300      	movs	r3, #0
 801307e:	f88a 300a 	strb.w	r3, [sl, #10]
 8013082:	f88a 300b 	strb.w	r3, [sl, #11]
    netif->output(netif, rambuf, dest);
 8013086:	9806      	ldr	r0, [sp, #24]
 8013088:	6943      	ldr	r3, [r0, #20]
 801308a:	9a08      	ldr	r2, [sp, #32]
 801308c:	4649      	mov	r1, r9
 801308e:	4798      	blx	r3
    IPFRAG_STATS_INC(ip_frag.xmit);
 8013090:	4a28      	ldr	r2, [pc, #160]	@ (8013134 <ip4_frag+0x208>)
 8013092:	8e13      	ldrh	r3, [r2, #48]	@ 0x30
 8013094:	3301      	adds	r3, #1
 8013096:	8613      	strh	r3, [r2, #48]	@ 0x30
    pbuf_free(rambuf);
 8013098:	4648      	mov	r0, r9
 801309a:	f7f8 fd49 	bl	800bb30 <pbuf_free>
    left = (u16_t)(left - fragsize);
 801309e:	9b02      	ldr	r3, [sp, #8]
 80130a0:	1b9b      	subs	r3, r3, r6
 80130a2:	b29b      	uxth	r3, r3
 80130a4:	9302      	str	r3, [sp, #8]
    ofo = (u16_t)(ofo + nfb);
 80130a6:	9b04      	ldr	r3, [sp, #16]
 80130a8:	9a05      	ldr	r2, [sp, #20]
 80130aa:	4413      	add	r3, r2
 80130ac:	b29b      	uxth	r3, r3
 80130ae:	9304      	str	r3, [sp, #16]
  while (left) {
 80130b0:	9b02      	ldr	r3, [sp, #8]
 80130b2:	b353      	cbz	r3, 801310a <ip4_frag+0x1de>
    fragsize = LWIP_MIN(left, (u16_t)(nfb * 8));
 80130b4:	9b05      	ldr	r3, [sp, #20]
 80130b6:	00db      	lsls	r3, r3, #3
 80130b8:	b29b      	uxth	r3, r3
 80130ba:	9a02      	ldr	r2, [sp, #8]
 80130bc:	4293      	cmp	r3, r2
 80130be:	bf28      	it	cs
 80130c0:	4613      	movcs	r3, r2
 80130c2:	9303      	str	r3, [sp, #12]
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
 80130c4:	f44f 7220 	mov.w	r2, #640	@ 0x280
 80130c8:	2114      	movs	r1, #20
 80130ca:	200e      	movs	r0, #14
 80130cc:	f7f8 fd98 	bl	800bc00 <pbuf_alloc>
    if (rambuf == NULL) {
 80130d0:	4681      	mov	r9, r0
 80130d2:	b1f8      	cbz	r0, 8013114 <ip4_frag+0x1e8>
    LWIP_ASSERT("this needs a pbuf in one piece!",
 80130d4:	8943      	ldrh	r3, [r0, #10]
 80130d6:	2b13      	cmp	r3, #19
 80130d8:	f67f af5f 	bls.w	8012f9a <ip4_frag+0x6e>
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
 80130dc:	f8d9 3004 	ldr.w	r3, [r9, #4]
 80130e0:	f8d8 2000 	ldr.w	r2, [r8]
 80130e4:	f8d8 6004 	ldr.w	r6, [r8, #4]
 80130e8:	f8d8 0008 	ldr.w	r0, [r8, #8]
 80130ec:	f8d8 100c 	ldr.w	r1, [r8, #12]
 80130f0:	601a      	str	r2, [r3, #0]
 80130f2:	605e      	str	r6, [r3, #4]
 80130f4:	6098      	str	r0, [r3, #8]
 80130f6:	60d9      	str	r1, [r3, #12]
 80130f8:	f8d8 2010 	ldr.w	r2, [r8, #16]
 80130fc:	611a      	str	r2, [r3, #16]
    iphdr = (struct ip_hdr *)rambuf->payload;
 80130fe:	f8d9 a004 	ldr.w	sl, [r9, #4]
    left_to_copy = fragsize;
 8013102:	9e03      	ldr	r6, [sp, #12]
 8013104:	f8cd 801c 	str.w	r8, [sp, #28]
    while (left_to_copy) {
 8013108:	e778      	b.n	8012ffc <ip4_frag+0xd0>
  return ERR_OK;
 801310a:	2000      	movs	r0, #0
 801310c:	e788      	b.n	8013020 <ip4_frag+0xf4>
    return ERR_VAL;
 801310e:	f06f 0005 	mvn.w	r0, #5
 8013112:	e785      	b.n	8013020 <ip4_frag+0xf4>
  return ERR_MEM;
 8013114:	f04f 30ff 	mov.w	r0, #4294967295
 8013118:	e782      	b.n	8013020 <ip4_frag+0xf4>
 801311a:	bf00      	nop
 801311c:	08018930 	.word	0x08018930
 8013120:	08018acc 	.word	0x08018acc
 8013124:	08015744 	.word	0x08015744
 8013128:	08018ae8 	.word	0x08018ae8
 801312c:	08018b08 	.word	0x08018b08
 8013130:	08012a75 	.word	0x08012a75
 8013134:	240141b4 	.word	0x240141b4

08013138 <ethernet_input>:
 * @see ETHARP_SUPPORT_VLAN
 * @see LWIP_HOOK_VLAN_CHECK
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
 8013138:	b570      	push	{r4, r5, r6, lr}
 801313a:	4604      	mov	r4, r0
  u16_t next_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  LWIP_ASSERT_CORE_LOCKED();

  if (p->len <= SIZEOF_ETH_HDR) {
 801313c:	8943      	ldrh	r3, [r0, #10]
 801313e:	2b0e      	cmp	r3, #14
 8013140:	d924      	bls.n	801318c <ethernet_input+0x54>
 8013142:	460d      	mov	r5, r1
    ETHARP_STATS_INC(etharp.drop);
    MIB2_STATS_NETIF_INC(netif, ifinerrors);
    goto free_and_return;
  }

  if (p->if_idx == NETIF_NO_INDEX) {
 8013144:	7bc3      	ldrb	r3, [r0, #15]
 8013146:	b91b      	cbnz	r3, 8013150 <ethernet_input+0x18>
    p->if_idx = netif_get_index(netif);
 8013148:	f891 3030 	ldrb.w	r3, [r1, #48]	@ 0x30
 801314c:	3301      	adds	r3, #1
 801314e:	73c3      	strb	r3, [r0, #15]
  }

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = (struct eth_hdr *)p->payload;
 8013150:	6860      	ldr	r0, [r4, #4]
               (unsigned char)ethhdr->dest.addr[3], (unsigned char)ethhdr->dest.addr[4], (unsigned char)ethhdr->dest.addr[5],
               (unsigned char)ethhdr->src.addr[0],  (unsigned char)ethhdr->src.addr[1],  (unsigned char)ethhdr->src.addr[2],
               (unsigned char)ethhdr->src.addr[3],  (unsigned char)ethhdr->src.addr[4],  (unsigned char)ethhdr->src.addr[5],
               lwip_htons(ethhdr->type)));

  type = ethhdr->type;
 8013152:	8986      	ldrh	r6, [r0, #12]

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, lwip_htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
 8013154:	7803      	ldrb	r3, [r0, #0]
 8013156:	f013 0f01 	tst.w	r3, #1
 801315a:	d00a      	beq.n	8013172 <ethernet_input+0x3a>
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_IP4_MULTICAST_ADDR_0) {
 801315c:	2b01      	cmp	r3, #1
 801315e:	d021      	beq.n	80131a4 <ethernet_input+0x6c>
             (ethhdr->dest.addr[1] == LL_IP6_MULTICAST_ADDR_1)) {
      /* mark the pbuf as link-layer multicast */
      p->flags |= PBUF_FLAG_LLMCAST;
    }
#endif /* LWIP_IPV6 */
    else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
 8013160:	2206      	movs	r2, #6
 8013162:	4929      	ldr	r1, [pc, #164]	@ (8013208 <ethernet_input+0xd0>)
 8013164:	f001 f87e 	bl	8014264 <memcmp>
 8013168:	b918      	cbnz	r0, 8013172 <ethernet_input+0x3a>
      /* mark the pbuf as link-layer broadcast */
      p->flags |= PBUF_FLAG_LLBCAST;
 801316a:	7b63      	ldrb	r3, [r4, #13]
 801316c:	f043 0308 	orr.w	r3, r3, #8
 8013170:	7363      	strb	r3, [r4, #13]
    }
  }

  switch (type) {
 8013172:	2e08      	cmp	r6, #8
 8013174:	d021      	beq.n	80131ba <ethernet_input+0x82>
 8013176:	f5b6 6fc1 	cmp.w	r6, #1544	@ 0x608
 801317a:	d02e      	beq.n	80131da <ethernet_input+0xa2>
#ifdef LWIP_HOOK_UNKNOWN_ETH_PROTOCOL
      if (LWIP_HOOK_UNKNOWN_ETH_PROTOCOL(p, netif) == ERR_OK) {
        break;
      }
#endif
      ETHARP_STATS_INC(etharp.proterr);
 801317c:	4b23      	ldr	r3, [pc, #140]	@ (801320c <ethernet_input+0xd4>)
 801317e:	8d1a      	ldrh	r2, [r3, #40]	@ 0x28
 8013180:	3201      	adds	r2, #1
 8013182:	851a      	strh	r2, [r3, #40]	@ 0x28
      ETHARP_STATS_INC(etharp.drop);
 8013184:	8bda      	ldrh	r2, [r3, #30]
 8013186:	3201      	adds	r2, #1
 8013188:	83da      	strh	r2, [r3, #30]
      MIB2_STATS_NETIF_INC(netif, ifinunknownprotos);
      goto free_and_return;
 801318a:	e006      	b.n	801319a <ethernet_input+0x62>
    ETHARP_STATS_INC(etharp.proterr);
 801318c:	4b1f      	ldr	r3, [pc, #124]	@ (801320c <ethernet_input+0xd4>)
 801318e:	8d1a      	ldrh	r2, [r3, #40]	@ 0x28
 8013190:	3201      	adds	r2, #1
 8013192:	851a      	strh	r2, [r3, #40]	@ 0x28
    ETHARP_STATS_INC(etharp.drop);
 8013194:	8bda      	ldrh	r2, [r3, #30]
 8013196:	3201      	adds	r2, #1
 8013198:	83da      	strh	r2, [r3, #30]
  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;

free_and_return:
  pbuf_free(p);
 801319a:	4620      	mov	r0, r4
 801319c:	f7f8 fcc8 	bl	800bb30 <pbuf_free>
  return ERR_OK;
}
 80131a0:	2000      	movs	r0, #0
 80131a2:	bd70      	pop	{r4, r5, r6, pc}
      if ((ethhdr->dest.addr[1] == LL_IP4_MULTICAST_ADDR_1) &&
 80131a4:	7843      	ldrb	r3, [r0, #1]
 80131a6:	2b00      	cmp	r3, #0
 80131a8:	d1e3      	bne.n	8013172 <ethernet_input+0x3a>
          (ethhdr->dest.addr[2] == LL_IP4_MULTICAST_ADDR_2)) {
 80131aa:	7883      	ldrb	r3, [r0, #2]
      if ((ethhdr->dest.addr[1] == LL_IP4_MULTICAST_ADDR_1) &&
 80131ac:	2b5e      	cmp	r3, #94	@ 0x5e
 80131ae:	d1e0      	bne.n	8013172 <ethernet_input+0x3a>
        p->flags |= PBUF_FLAG_LLMCAST;
 80131b0:	7b63      	ldrb	r3, [r4, #13]
 80131b2:	f043 0310 	orr.w	r3, r3, #16
 80131b6:	7363      	strb	r3, [r4, #13]
 80131b8:	e7db      	b.n	8013172 <ethernet_input+0x3a>
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 80131ba:	f895 302d 	ldrb.w	r3, [r5, #45]	@ 0x2d
 80131be:	f013 0f08 	tst.w	r3, #8
 80131c2:	d0ea      	beq.n	801319a <ethernet_input+0x62>
      if (pbuf_remove_header(p, next_hdr_offset)) {
 80131c4:	210e      	movs	r1, #14
 80131c6:	4620      	mov	r0, r4
 80131c8:	f7f8 fc6c 	bl	800baa4 <pbuf_remove_header>
 80131cc:	2800      	cmp	r0, #0
 80131ce:	d1e4      	bne.n	801319a <ethernet_input+0x62>
        ip4_input(p, netif);
 80131d0:	4629      	mov	r1, r5
 80131d2:	4620      	mov	r0, r4
 80131d4:	f7ff f85a 	bl	801228c <ip4_input>
      break;
 80131d8:	e7e2      	b.n	80131a0 <ethernet_input+0x68>
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 80131da:	f895 302d 	ldrb.w	r3, [r5, #45]	@ 0x2d
 80131de:	f013 0f08 	tst.w	r3, #8
 80131e2:	d0da      	beq.n	801319a <ethernet_input+0x62>
      if (pbuf_remove_header(p, next_hdr_offset)) {
 80131e4:	210e      	movs	r1, #14
 80131e6:	4620      	mov	r0, r4
 80131e8:	f7f8 fc5c 	bl	800baa4 <pbuf_remove_header>
 80131ec:	b138      	cbz	r0, 80131fe <ethernet_input+0xc6>
        ETHARP_STATS_INC(etharp.lenerr);
 80131ee:	4b07      	ldr	r3, [pc, #28]	@ (801320c <ethernet_input+0xd4>)
 80131f0:	8c5a      	ldrh	r2, [r3, #34]	@ 0x22
 80131f2:	3201      	adds	r2, #1
 80131f4:	845a      	strh	r2, [r3, #34]	@ 0x22
        ETHARP_STATS_INC(etharp.drop);
 80131f6:	8bda      	ldrh	r2, [r3, #30]
 80131f8:	3201      	adds	r2, #1
 80131fa:	83da      	strh	r2, [r3, #30]
        goto free_and_return;
 80131fc:	e7cd      	b.n	801319a <ethernet_input+0x62>
        etharp_input(p, netif);
 80131fe:	4629      	mov	r1, r5
 8013200:	4620      	mov	r0, r4
 8013202:	f7fe f96f 	bl	80114e4 <etharp_input>
      break;
 8013206:	e7cb      	b.n	80131a0 <ethernet_input+0x68>
 8013208:	08018fcc 	.word	0x08018fcc
 801320c:	240141b4 	.word	0x240141b4

08013210 <ethernet_output>:
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
err_t
ethernet_output(struct netif * netif, struct pbuf * p,
                const struct eth_addr * src, const struct eth_addr * dst,
                u16_t eth_type) {
 8013210:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013214:	4605      	mov	r5, r0
 8013216:	460c      	mov	r4, r1
 8013218:	4616      	mov	r6, r2
 801321a:	461f      	mov	r7, r3
  struct eth_hdr *ethhdr;
  u16_t eth_type_be = lwip_htons(eth_type);
 801321c:	f8bd 0018 	ldrh.w	r0, [sp, #24]
 8013220:	f7f7 fc9e 	bl	800ab60 <lwip_htons>
 8013224:	4680      	mov	r8, r0

    eth_type_be = PP_HTONS(ETHTYPE_VLAN);
  } else
#endif /* ETHARP_SUPPORT_VLAN && defined(LWIP_HOOK_VLAN_SET) */
  {
    if (pbuf_add_header(p, SIZEOF_ETH_HDR) != 0) {
 8013226:	210e      	movs	r1, #14
 8013228:	4620      	mov	r0, r4
 801322a:	f7f8 fc36 	bl	800ba9a <pbuf_add_header>
 801322e:	b9a8      	cbnz	r0, 801325c <ethernet_output+0x4c>
    }
  }

  LWIP_ASSERT_CORE_LOCKED();

  ethhdr = (struct eth_hdr *)p->payload;
 8013230:	6861      	ldr	r1, [r4, #4]
  ethhdr->type = eth_type_be;
 8013232:	f8a1 800c 	strh.w	r8, [r1, #12]
  SMEMCPY(&ethhdr->dest, dst, ETH_HWADDR_LEN);
 8013236:	683b      	ldr	r3, [r7, #0]
 8013238:	600b      	str	r3, [r1, #0]
 801323a:	88bb      	ldrh	r3, [r7, #4]
 801323c:	808b      	strh	r3, [r1, #4]
  SMEMCPY(&ethhdr->src,  src, ETH_HWADDR_LEN);
 801323e:	6833      	ldr	r3, [r6, #0]
 8013240:	f8c1 3006 	str.w	r3, [r1, #6]
 8013244:	88b3      	ldrh	r3, [r6, #4]
 8013246:	814b      	strh	r3, [r1, #10]

  LWIP_ASSERT("netif->hwaddr_len must be 6 for ethernet_output!",
 8013248:	f895 302c 	ldrb.w	r3, [r5, #44]	@ 0x2c
 801324c:	2b06      	cmp	r3, #6
 801324e:	d10c      	bne.n	801326a <ethernet_output+0x5a>
              (netif->hwaddr_len == ETH_HWADDR_LEN));
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
              ("ethernet_output: sending packet %p\n", (void *)p));

  /* send the packet */
  return netif->linkoutput(netif, p);
 8013250:	69ab      	ldr	r3, [r5, #24]
 8013252:	4621      	mov	r1, r4
 8013254:	4628      	mov	r0, r5
 8013256:	4798      	blx	r3
pbuf_header_failed:
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
              ("ethernet_output: could not allocate room for header.\n"));
  LINK_STATS_INC(link.lenerr);
  return ERR_BUF;
}
 8013258:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LINK_STATS_INC(link.lenerr);
 801325c:	4a07      	ldr	r2, [pc, #28]	@ (801327c <ethernet_output+0x6c>)
 801325e:	8953      	ldrh	r3, [r2, #10]
 8013260:	3301      	adds	r3, #1
 8013262:	8153      	strh	r3, [r2, #10]
  return ERR_BUF;
 8013264:	f06f 0001 	mvn.w	r0, #1
 8013268:	e7f6      	b.n	8013258 <ethernet_output+0x48>
  LWIP_ASSERT("netif->hwaddr_len must be 6 for ethernet_output!",
 801326a:	4b05      	ldr	r3, [pc, #20]	@ (8013280 <ethernet_output+0x70>)
 801326c:	f44f 7299 	mov.w	r2, #306	@ 0x132
 8013270:	4904      	ldr	r1, [pc, #16]	@ (8013284 <ethernet_output+0x74>)
 8013272:	4805      	ldr	r0, [pc, #20]	@ (8013288 <ethernet_output+0x78>)
 8013274:	f000 fe84 	bl	8013f80 <iprintf>
 8013278:	e7ea      	b.n	8013250 <ethernet_output+0x40>
 801327a:	bf00      	nop
 801327c:	240141b4 	.word	0x240141b4
 8013280:	08018b18 	.word	0x08018b18
 8013284:	08018b50 	.word	0x08018b50
 8013288:	08015744 	.word	0x08015744

0801328c <sys_mbox_new>:
#endif

/*-----------------------------------------------------------------------------------*/
//  Creates an empty mailbox.
err_t sys_mbox_new(sys_mbox_t *mbox, int size)
{
 801328c:	b510      	push	{r4, lr}
 801328e:	b084      	sub	sp, #16
 8013290:	4604      	mov	r4, r0
#if (osCMSIS < 0x20000U)
  osMessageQDef(QUEUE, size, void *);
 8013292:	9100      	str	r1, [sp, #0]
 8013294:	2304      	movs	r3, #4
 8013296:	9301      	str	r3, [sp, #4]
 8013298:	2100      	movs	r1, #0
 801329a:	9102      	str	r1, [sp, #8]
 801329c:	9103      	str	r1, [sp, #12]
  *mbox = osMessageCreate(osMessageQ(QUEUE), NULL);
 801329e:	4668      	mov	r0, sp
 80132a0:	f7f3 fe33 	bl	8006f0a <osMessageCreate>
 80132a4:	6020      	str	r0, [r4, #0]
#else
  *mbox = osMessageQueueNew(size, sizeof(void *), NULL);
#endif
#if SYS_STATS
  ++lwip_stats.sys.mbox.used;
 80132a6:	4a0b      	ldr	r2, [pc, #44]	@ (80132d4 <sys_mbox_new+0x48>)
 80132a8:	f8b2 3118 	ldrh.w	r3, [r2, #280]	@ 0x118
 80132ac:	3301      	adds	r3, #1
 80132ae:	b29b      	uxth	r3, r3
 80132b0:	f8a2 3118 	strh.w	r3, [r2, #280]	@ 0x118
  if(lwip_stats.sys.mbox.max < lwip_stats.sys.mbox.used)
 80132b4:	f8b2 211a 	ldrh.w	r2, [r2, #282]	@ 0x11a
 80132b8:	4293      	cmp	r3, r2
 80132ba:	d902      	bls.n	80132c2 <sys_mbox_new+0x36>
  {
    lwip_stats.sys.mbox.max = lwip_stats.sys.mbox.used;
 80132bc:	4a05      	ldr	r2, [pc, #20]	@ (80132d4 <sys_mbox_new+0x48>)
 80132be:	f8a2 311a 	strh.w	r3, [r2, #282]	@ 0x11a
  }
#endif /* SYS_STATS */
  if(*mbox == NULL)
 80132c2:	6823      	ldr	r3, [r4, #0]
 80132c4:	b113      	cbz	r3, 80132cc <sys_mbox_new+0x40>
    return ERR_MEM;

  return ERR_OK;
 80132c6:	2000      	movs	r0, #0
}
 80132c8:	b004      	add	sp, #16
 80132ca:	bd10      	pop	{r4, pc}
    return ERR_MEM;
 80132cc:	f04f 30ff 	mov.w	r0, #4294967295
 80132d0:	e7fa      	b.n	80132c8 <sys_mbox_new+0x3c>
 80132d2:	bf00      	nop
 80132d4:	240141b4 	.word	0x240141b4

080132d8 <sys_mbox_free>:
  Deallocates a mailbox. If there are messages still present in the
  mailbox when the mailbox is deallocated, it is an indication of a
  programming error in lwIP and the developer should be notified.
*/
void sys_mbox_free(sys_mbox_t *mbox)
{
 80132d8:	b510      	push	{r4, lr}
 80132da:	4604      	mov	r4, r0
#if (osCMSIS < 0x20000U)
  if(osMessageWaiting(*mbox))
 80132dc:	6800      	ldr	r0, [r0, #0]
 80132de:	f7f3 fea5 	bl	800702c <osMessageWaiting>
 80132e2:	b128      	cbz	r0, 80132f0 <sys_mbox_free+0x18>
#endif
  {
    /* Line for breakpoint.  Should never break here! */
    portNOP();
#if SYS_STATS
    lwip_stats.sys.mbox.err++;
 80132e4:	4a07      	ldr	r2, [pc, #28]	@ (8013304 <sys_mbox_free+0x2c>)
 80132e6:	f8b2 311c 	ldrh.w	r3, [r2, #284]	@ 0x11c
 80132ea:	3301      	adds	r3, #1
 80132ec:	f8a2 311c 	strh.w	r3, [r2, #284]	@ 0x11c
#endif /* SYS_STATS */

  }
#if (osCMSIS < 0x20000U)
  osMessageDelete(*mbox);
 80132f0:	6820      	ldr	r0, [r4, #0]
 80132f2:	f7f3 fea8 	bl	8007046 <osMessageDelete>
#else
  osMessageQueueDelete(*mbox);
#endif
#if SYS_STATS
  --lwip_stats.sys.mbox.used;
 80132f6:	4a03      	ldr	r2, [pc, #12]	@ (8013304 <sys_mbox_free+0x2c>)
 80132f8:	f8b2 3118 	ldrh.w	r3, [r2, #280]	@ 0x118
 80132fc:	3b01      	subs	r3, #1
 80132fe:	f8a2 3118 	strh.w	r3, [r2, #280]	@ 0x118
#endif /* SYS_STATS */
}
 8013302:	bd10      	pop	{r4, pc}
 8013304:	240141b4 	.word	0x240141b4

08013308 <sys_mbox_trypost>:


/*-----------------------------------------------------------------------------------*/
//   Try to post the "msg" to the mailbox.
err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
{
 8013308:	b508      	push	{r3, lr}
  err_t result;
#if (osCMSIS < 0x20000U)
  if(osMessagePut(*mbox, (uint32_t)msg, 0) == osOK)
 801330a:	2200      	movs	r2, #0
 801330c:	6800      	ldr	r0, [r0, #0]
 801330e:	f7f3 fe11 	bl	8006f34 <osMessagePut>
 8013312:	b908      	cbnz	r0, 8013318 <sys_mbox_trypost+0x10>
#else
  if(osMessageQueuePut(*mbox, &msg, 0, 0) == osOK)
#endif
  {
    result = ERR_OK;
 8013314:	2000      	movs	r0, #0
    lwip_stats.sys.mbox.err++;
#endif /* SYS_STATS */
  }

  return result;
}
 8013316:	bd08      	pop	{r3, pc}
    lwip_stats.sys.mbox.err++;
 8013318:	4a04      	ldr	r2, [pc, #16]	@ (801332c <sys_mbox_trypost+0x24>)
 801331a:	f8b2 311c 	ldrh.w	r3, [r2, #284]	@ 0x11c
 801331e:	3301      	adds	r3, #1
 8013320:	f8a2 311c 	strh.w	r3, [r2, #284]	@ 0x11c
    result = ERR_MEM;
 8013324:	f04f 30ff 	mov.w	r0, #4294967295
 8013328:	e7f5      	b.n	8013316 <sys_mbox_trypost+0xe>
 801332a:	bf00      	nop
 801332c:	240141b4 	.word	0x240141b4

08013330 <sys_arch_mbox_fetch>:

  Note that a function with a similar name, sys_mbox_fetch(), is
  implemented by lwIP.
*/
u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout)
{
 8013330:	b5f0      	push	{r4, r5, r6, r7, lr}
 8013332:	b089      	sub	sp, #36	@ 0x24
 8013334:	4605      	mov	r5, r0
 8013336:	460f      	mov	r7, r1
 8013338:	4614      	mov	r4, r2
#if (osCMSIS < 0x20000U)
  osEvent event;
  uint32_t starttime = osKernelSysTick();
 801333a:	f7f3 fca8 	bl	8006c8e <osKernelSysTick>
 801333e:	4606      	mov	r6, r0
#else
  osStatus_t status;
  uint32_t starttime = osKernelGetTickCount();
#endif
  if(timeout != 0)
 8013340:	b18c      	cbz	r4, 8013366 <sys_arch_mbox_fetch+0x36>
  {
#if (osCMSIS < 0x20000U)
    event = osMessageGet (*mbox, timeout);
 8013342:	4622      	mov	r2, r4
 8013344:	6829      	ldr	r1, [r5, #0]
 8013346:	a805      	add	r0, sp, #20
 8013348:	f7f3 fe27 	bl	8006f9a <osMessageGet>

    if(event.status == osEventMessage)
 801334c:	9b05      	ldr	r3, [sp, #20]
 801334e:	2b10      	cmp	r3, #16
 8013350:	d003      	beq.n	801335a <sys_arch_mbox_fetch+0x2a>
      return (osKernelGetTickCount() - starttime);
    }
#endif
    else
    {
      return SYS_ARCH_TIMEOUT;
 8013352:	f04f 30ff 	mov.w	r0, #4294967295
#else
    osMessageQueueGet(*mbox, msg, 0, osWaitForever );
    return (osKernelGetTickCount() - starttime);
#endif
  }
}
 8013356:	b009      	add	sp, #36	@ 0x24
 8013358:	bdf0      	pop	{r4, r5, r6, r7, pc}
      *msg = (void *)event.value.v;
 801335a:	9b06      	ldr	r3, [sp, #24]
 801335c:	603b      	str	r3, [r7, #0]
      return (osKernelSysTick() - starttime);
 801335e:	f7f3 fc96 	bl	8006c8e <osKernelSysTick>
 8013362:	1b80      	subs	r0, r0, r6
 8013364:	e7f7      	b.n	8013356 <sys_arch_mbox_fetch+0x26>
    event = osMessageGet (*mbox, osWaitForever);
 8013366:	466c      	mov	r4, sp
 8013368:	f04f 32ff 	mov.w	r2, #4294967295
 801336c:	6829      	ldr	r1, [r5, #0]
 801336e:	4620      	mov	r0, r4
 8013370:	f7f3 fe13 	bl	8006f9a <osMessageGet>
 8013374:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8013378:	ab08      	add	r3, sp, #32
 801337a:	e903 0007 	stmdb	r3, {r0, r1, r2}
    *msg = (void *)event.value.v;
 801337e:	6039      	str	r1, [r7, #0]
    return (osKernelSysTick() - starttime);
 8013380:	f7f3 fc85 	bl	8006c8e <osKernelSysTick>
 8013384:	1b80      	subs	r0, r0, r6
 8013386:	e7e6      	b.n	8013356 <sys_arch_mbox_fetch+0x26>

08013388 <sys_arch_mbox_tryfetch>:
/*
  Similar to sys_arch_mbox_fetch, but if message is not ready immediately, we'll
  return with SYS_MBOX_EMPTY.  On success, 0 is returned.
*/
u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg)
{
 8013388:	b510      	push	{r4, lr}
 801338a:	b084      	sub	sp, #16
 801338c:	460c      	mov	r4, r1
#if (osCMSIS < 0x20000U)
  osEvent event;

  event = osMessageGet (*mbox, 0);
 801338e:	2200      	movs	r2, #0
 8013390:	6801      	ldr	r1, [r0, #0]
 8013392:	a801      	add	r0, sp, #4
 8013394:	f7f3 fe01 	bl	8006f9a <osMessageGet>

  if(event.status == osEventMessage)
 8013398:	9b01      	ldr	r3, [sp, #4]
 801339a:	2b10      	cmp	r3, #16
 801339c:	d003      	beq.n	80133a6 <sys_arch_mbox_tryfetch+0x1e>
#endif
    return ERR_OK;
  }
  else
  {
    return SYS_MBOX_EMPTY;
 801339e:	f04f 30ff 	mov.w	r0, #4294967295
  }
}
 80133a2:	b004      	add	sp, #16
 80133a4:	bd10      	pop	{r4, pc}
    *msg = (void *)event.value.v;
 80133a6:	9b02      	ldr	r3, [sp, #8]
 80133a8:	6023      	str	r3, [r4, #0]
    return ERR_OK;
 80133aa:	2000      	movs	r0, #0
 80133ac:	e7f9      	b.n	80133a2 <sys_arch_mbox_tryfetch+0x1a>

080133ae <sys_mbox_valid>:
/*----------------------------------------------------------------------------------*/
int sys_mbox_valid(sys_mbox_t *mbox)
{
  if (*mbox == SYS_MBOX_NULL)
 80133ae:	6803      	ldr	r3, [r0, #0]
 80133b0:	b10b      	cbz	r3, 80133b6 <sys_mbox_valid+0x8>
    return 0;
  else
    return 1;
 80133b2:	2001      	movs	r0, #1
}
 80133b4:	4770      	bx	lr
    return 0;
 80133b6:	2000      	movs	r0, #0
 80133b8:	4770      	bx	lr

080133ba <sys_mbox_set_invalid>:
/*-----------------------------------------------------------------------------------*/
void sys_mbox_set_invalid(sys_mbox_t *mbox)
{
  *mbox = SYS_MBOX_NULL;
 80133ba:	2300      	movs	r3, #0
 80133bc:	6003      	str	r3, [r0, #0]
}
 80133be:	4770      	bx	lr

080133c0 <sys_sem_new>:

/*-----------------------------------------------------------------------------------*/
//  Creates a new semaphore. The "count" argument specifies
//  the initial state of the semaphore.
err_t sys_sem_new(sys_sem_t *sem, u8_t count)
{
 80133c0:	b530      	push	{r4, r5, lr}
 80133c2:	b083      	sub	sp, #12
 80133c4:	4604      	mov	r4, r0
 80133c6:	460d      	mov	r5, r1
#if (osCMSIS < 0x20000U)
  osSemaphoreDef(SEM);
 80133c8:	2300      	movs	r3, #0
 80133ca:	9300      	str	r3, [sp, #0]
 80133cc:	9301      	str	r3, [sp, #4]
  *sem = osSemaphoreCreate (osSemaphore(SEM), 1);
 80133ce:	2101      	movs	r1, #1
 80133d0:	4668      	mov	r0, sp
 80133d2:	f7f3 fd06 	bl	8006de2 <osSemaphoreCreate>
 80133d6:	6020      	str	r0, [r4, #0]
#else
  *sem = osSemaphoreNew(UINT16_MAX, count, NULL);
#endif

  if(*sem == NULL)
 80133d8:	b180      	cbz	r0, 80133fc <sys_sem_new+0x3c>
    ++lwip_stats.sys.sem.err;
#endif /* SYS_STATS */
    return ERR_MEM;
  }

  if(count == 0)	// Means it can't be taken
 80133da:	b1c5      	cbz	r5, 801340e <sys_sem_new+0x4e>
    osSemaphoreAcquire(*sem, 0);
#endif
  }

#if SYS_STATS
  ++lwip_stats.sys.sem.used;
 80133dc:	4a0f      	ldr	r2, [pc, #60]	@ (801341c <sys_sem_new+0x5c>)
 80133de:	f8b2 310c 	ldrh.w	r3, [r2, #268]	@ 0x10c
 80133e2:	3301      	adds	r3, #1
 80133e4:	b29b      	uxth	r3, r3
 80133e6:	f8a2 310c 	strh.w	r3, [r2, #268]	@ 0x10c
  if (lwip_stats.sys.sem.max < lwip_stats.sys.sem.used) {
 80133ea:	f8b2 210e 	ldrh.w	r2, [r2, #270]	@ 0x10e
 80133ee:	4293      	cmp	r3, r2
 80133f0:	d911      	bls.n	8013416 <sys_sem_new+0x56>
    lwip_stats.sys.sem.max = lwip_stats.sys.sem.used;
 80133f2:	4a0a      	ldr	r2, [pc, #40]	@ (801341c <sys_sem_new+0x5c>)
 80133f4:	f8a2 310e 	strh.w	r3, [r2, #270]	@ 0x10e
  }
#endif /* SYS_STATS */

  return ERR_OK;
 80133f8:	2000      	movs	r0, #0
 80133fa:	e00d      	b.n	8013418 <sys_sem_new+0x58>
    ++lwip_stats.sys.sem.err;
 80133fc:	4a07      	ldr	r2, [pc, #28]	@ (801341c <sys_sem_new+0x5c>)
 80133fe:	f8b2 3110 	ldrh.w	r3, [r2, #272]	@ 0x110
 8013402:	3301      	adds	r3, #1
 8013404:	f8a2 3110 	strh.w	r3, [r2, #272]	@ 0x110
    return ERR_MEM;
 8013408:	f04f 30ff 	mov.w	r0, #4294967295
 801340c:	e004      	b.n	8013418 <sys_sem_new+0x58>
    osSemaphoreWait(*sem, 0);
 801340e:	2100      	movs	r1, #0
 8013410:	f7f3 fd13 	bl	8006e3a <osSemaphoreWait>
 8013414:	e7e2      	b.n	80133dc <sys_sem_new+0x1c>
  return ERR_OK;
 8013416:	2000      	movs	r0, #0
}
 8013418:	b003      	add	sp, #12
 801341a:	bd30      	pop	{r4, r5, pc}
 801341c:	240141b4 	.word	0x240141b4

08013420 <sys_arch_sem_wait>:

  Notice that lwIP implements a function with a similar name,
  sys_sem_wait(), that uses the sys_arch_sem_wait() function.
*/
u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
{
 8013420:	b570      	push	{r4, r5, r6, lr}
 8013422:	4604      	mov	r4, r0
 8013424:	460e      	mov	r6, r1
#if (osCMSIS < 0x20000U)
  uint32_t starttime = osKernelSysTick();
 8013426:	f7f3 fc32 	bl	8006c8e <osKernelSysTick>
 801342a:	4605      	mov	r5, r0
#else
  uint32_t starttime = osKernelGetTickCount();
#endif
  if(timeout != 0)
 801342c:	b956      	cbnz	r6, 8013444 <sys_arch_sem_wait+0x24>
    }
  }
  else
  {
#if (osCMSIS < 0x20000U)
    while(osSemaphoreWait (*sem, osWaitForever) != osOK);
 801342e:	f04f 31ff 	mov.w	r1, #4294967295
 8013432:	6820      	ldr	r0, [r4, #0]
 8013434:	f7f3 fd01 	bl	8006e3a <osSemaphoreWait>
 8013438:	2800      	cmp	r0, #0
 801343a:	d1f8      	bne.n	801342e <sys_arch_sem_wait+0xe>
    return (osKernelSysTick() - starttime);
 801343c:	f7f3 fc27 	bl	8006c8e <osKernelSysTick>
 8013440:	1b40      	subs	r0, r0, r5
#else
    while(osSemaphoreAcquire(*sem, osWaitForever) != osOK);
    return (osKernelGetTickCount() - starttime);
#endif
  }
}
 8013442:	bd70      	pop	{r4, r5, r6, pc}
    if(osSemaphoreWait (*sem, timeout) == osOK)
 8013444:	4631      	mov	r1, r6
 8013446:	6820      	ldr	r0, [r4, #0]
 8013448:	f7f3 fcf7 	bl	8006e3a <osSemaphoreWait>
 801344c:	b110      	cbz	r0, 8013454 <sys_arch_sem_wait+0x34>
      return SYS_ARCH_TIMEOUT;
 801344e:	f04f 30ff 	mov.w	r0, #4294967295
 8013452:	e7f6      	b.n	8013442 <sys_arch_sem_wait+0x22>
      return (osKernelSysTick() - starttime);
 8013454:	f7f3 fc1b 	bl	8006c8e <osKernelSysTick>
 8013458:	1b40      	subs	r0, r0, r5
 801345a:	e7f2      	b.n	8013442 <sys_arch_sem_wait+0x22>

0801345c <sys_sem_signal>:

/*-----------------------------------------------------------------------------------*/
// Signals a semaphore
void sys_sem_signal(sys_sem_t *sem)
{
 801345c:	b508      	push	{r3, lr}
  osSemaphoreRelease(*sem);
 801345e:	6800      	ldr	r0, [r0, #0]
 8013460:	f7f3 fd1a 	bl	8006e98 <osSemaphoreRelease>
}
 8013464:	bd08      	pop	{r3, pc}
	...

08013468 <sys_sem_free>:

/*-----------------------------------------------------------------------------------*/
// Deallocates a semaphore
void sys_sem_free(sys_sem_t *sem)
{
 8013468:	b508      	push	{r3, lr}
#if SYS_STATS
  --lwip_stats.sys.sem.used;
 801346a:	4a05      	ldr	r2, [pc, #20]	@ (8013480 <sys_sem_free+0x18>)
 801346c:	f8b2 310c 	ldrh.w	r3, [r2, #268]	@ 0x10c
 8013470:	3b01      	subs	r3, #1
 8013472:	f8a2 310c 	strh.w	r3, [r2, #268]	@ 0x10c
#endif /* SYS_STATS */

  osSemaphoreDelete(*sem);
 8013476:	6800      	ldr	r0, [r0, #0]
 8013478:	f7f3 fd3b 	bl	8006ef2 <osSemaphoreDelete>
}
 801347c:	bd08      	pop	{r3, pc}
 801347e:	bf00      	nop
 8013480:	240141b4 	.word	0x240141b4

08013484 <sys_sem_valid>:
/*-----------------------------------------------------------------------------------*/
int sys_sem_valid(sys_sem_t *sem)
{
  if (*sem == SYS_SEM_NULL)
 8013484:	6803      	ldr	r3, [r0, #0]
 8013486:	b10b      	cbz	r3, 801348c <sys_sem_valid+0x8>
    return 0;
  else
    return 1;
 8013488:	2001      	movs	r0, #1
}
 801348a:	4770      	bx	lr
    return 0;
 801348c:	2000      	movs	r0, #0
 801348e:	4770      	bx	lr

08013490 <sys_sem_set_invalid>:

/*-----------------------------------------------------------------------------------*/
void sys_sem_set_invalid(sys_sem_t *sem)
{
  *sem = SYS_SEM_NULL;
 8013490:	2300      	movs	r3, #0
 8013492:	6003      	str	r3, [r0, #0]
}
 8013494:	4770      	bx	lr
	...

08013498 <sys_init>:
#else
osMutexId_t lwip_sys_mutex;
#endif
// Initialize sys arch
void sys_init(void)
{
 8013498:	b508      	push	{r3, lr}
#if (osCMSIS < 0x20000U)
  lwip_sys_mutex = osMutexCreate(osMutex(lwip_sys_mutex));
 801349a:	4803      	ldr	r0, [pc, #12]	@ (80134a8 <sys_init+0x10>)
 801349c:	f7f3 fc39 	bl	8006d12 <osMutexCreate>
 80134a0:	4b02      	ldr	r3, [pc, #8]	@ (80134ac <sys_init+0x14>)
 80134a2:	6018      	str	r0, [r3, #0]
#else
  lwip_sys_mutex = osMutexNew(NULL);
#endif
}
 80134a4:	bd08      	pop	{r3, pc}
 80134a6:	bf00      	nop
 80134a8:	08018fd4 	.word	0x08018fd4
 80134ac:	24014440 	.word	0x24014440

080134b0 <sys_mutex_new>:
                                      /* Mutexes*/
/*-----------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------*/
#if LWIP_COMPAT_MUTEX == 0
/* Create a new mutex*/
err_t sys_mutex_new(sys_mutex_t *mutex) {
 80134b0:	b510      	push	{r4, lr}
 80134b2:	b082      	sub	sp, #8
 80134b4:	4604      	mov	r4, r0

#if (osCMSIS < 0x20000U)
  osMutexDef(MUTEX);
 80134b6:	2300      	movs	r3, #0
 80134b8:	9300      	str	r3, [sp, #0]
 80134ba:	9301      	str	r3, [sp, #4]
  *mutex = osMutexCreate(osMutex(MUTEX));
 80134bc:	4668      	mov	r0, sp
 80134be:	f7f3 fc28 	bl	8006d12 <osMutexCreate>
 80134c2:	6020      	str	r0, [r4, #0]
#else
  *mutex = osMutexNew(NULL);
#endif

  if(*mutex == NULL)
 80134c4:	b178      	cbz	r0, 80134e6 <sys_mutex_new+0x36>
#endif /* SYS_STATS */
    return ERR_MEM;
  }

#if SYS_STATS
  ++lwip_stats.sys.mutex.used;
 80134c6:	4a0e      	ldr	r2, [pc, #56]	@ (8013500 <sys_mutex_new+0x50>)
 80134c8:	f8b2 3112 	ldrh.w	r3, [r2, #274]	@ 0x112
 80134cc:	3301      	adds	r3, #1
 80134ce:	b29b      	uxth	r3, r3
 80134d0:	f8a2 3112 	strh.w	r3, [r2, #274]	@ 0x112
  if (lwip_stats.sys.mutex.max < lwip_stats.sys.mutex.used) {
 80134d4:	f8b2 2114 	ldrh.w	r2, [r2, #276]	@ 0x114
 80134d8:	4293      	cmp	r3, r2
 80134da:	d90d      	bls.n	80134f8 <sys_mutex_new+0x48>
    lwip_stats.sys.mutex.max = lwip_stats.sys.mutex.used;
 80134dc:	4a08      	ldr	r2, [pc, #32]	@ (8013500 <sys_mutex_new+0x50>)
 80134de:	f8a2 3114 	strh.w	r3, [r2, #276]	@ 0x114
  }
#endif /* SYS_STATS */
  return ERR_OK;
 80134e2:	2000      	movs	r0, #0
 80134e4:	e009      	b.n	80134fa <sys_mutex_new+0x4a>
    ++lwip_stats.sys.mutex.err;
 80134e6:	4a06      	ldr	r2, [pc, #24]	@ (8013500 <sys_mutex_new+0x50>)
 80134e8:	f8b2 3116 	ldrh.w	r3, [r2, #278]	@ 0x116
 80134ec:	3301      	adds	r3, #1
 80134ee:	f8a2 3116 	strh.w	r3, [r2, #278]	@ 0x116
    return ERR_MEM;
 80134f2:	f04f 30ff 	mov.w	r0, #4294967295
 80134f6:	e000      	b.n	80134fa <sys_mutex_new+0x4a>
  return ERR_OK;
 80134f8:	2000      	movs	r0, #0
}
 80134fa:	b002      	add	sp, #8
 80134fc:	bd10      	pop	{r4, pc}
 80134fe:	bf00      	nop
 8013500:	240141b4 	.word	0x240141b4

08013504 <sys_mutex_lock>:
  osMutexDelete(*mutex);
}
/*-----------------------------------------------------------------------------------*/
/* Lock a mutex*/
void sys_mutex_lock(sys_mutex_t *mutex)
{
 8013504:	b508      	push	{r3, lr}
#if (osCMSIS < 0x20000U)
  osMutexWait(*mutex, osWaitForever);
 8013506:	f04f 31ff 	mov.w	r1, #4294967295
 801350a:	6800      	ldr	r0, [r0, #0]
 801350c:	f7f3 fc0c 	bl	8006d28 <osMutexWait>
#else
  osMutexAcquire(*mutex, osWaitForever);
#endif
}
 8013510:	bd08      	pop	{r3, pc}

08013512 <sys_mutex_unlock>:

/*-----------------------------------------------------------------------------------*/
/* Unlock a mutex*/
void sys_mutex_unlock(sys_mutex_t *mutex)
{
 8013512:	b508      	push	{r3, lr}
  osMutexRelease(*mutex);
 8013514:	6800      	ldr	r0, [r0, #0]
 8013516:	f7f3 fc37 	bl	8006d88 <osMutexRelease>
}
 801351a:	bd08      	pop	{r3, pc}

0801351c <sys_thread_new>:
  function "thread()". The "arg" argument will be passed as an argument to the
  thread() function. The id of the new thread is returned. Both the id and
  the priority are system dependent.
*/
sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread , void *arg, int stacksize, int prio)
{
 801351c:	b510      	push	{r4, lr}
 801351e:	b088      	sub	sp, #32
#if (osCMSIS < 0x20000U)
  const osThreadDef_t os_thread_def = { (char *)name, (os_pthread)thread, (osPriority)prio, 0, stacksize};
 8013520:	2400      	movs	r4, #0
 8013522:	9401      	str	r4, [sp, #4]
 8013524:	9402      	str	r4, [sp, #8]
 8013526:	9403      	str	r4, [sp, #12]
 8013528:	9404      	str	r4, [sp, #16]
 801352a:	9405      	str	r4, [sp, #20]
 801352c:	9406      	str	r4, [sp, #24]
 801352e:	9407      	str	r4, [sp, #28]
 8013530:	9001      	str	r0, [sp, #4]
 8013532:	9102      	str	r1, [sp, #8]
 8013534:	f9bd 1028 	ldrsh.w	r1, [sp, #40]	@ 0x28
 8013538:	f8ad 100c 	strh.w	r1, [sp, #12]
 801353c:	9305      	str	r3, [sp, #20]
  return osThreadCreate(&os_thread_def, arg);
 801353e:	4611      	mov	r1, r2
 8013540:	a801      	add	r0, sp, #4
 8013542:	f7f3 fbae 	bl	8006ca2 <osThreadCreate>
                        .stack_size = stacksize,
                        .priority = (osPriority_t)prio,
                      };
  return osThreadNew(thread, arg, &attributes);
#endif
}
 8013546:	b008      	add	sp, #32
 8013548:	bd10      	pop	{r4, pc}
	...

0801354c <sys_arch_protect>:

  Note: This function is based on FreeRTOS API, because no equivalent CMSIS-RTOS
        API is available
*/
sys_prot_t sys_arch_protect(void)
{
 801354c:	b508      	push	{r3, lr}
#if (osCMSIS < 0x20000U)
  osMutexWait(lwip_sys_mutex, osWaitForever);
 801354e:	f04f 31ff 	mov.w	r1, #4294967295
 8013552:	4b03      	ldr	r3, [pc, #12]	@ (8013560 <sys_arch_protect+0x14>)
 8013554:	6818      	ldr	r0, [r3, #0]
 8013556:	f7f3 fbe7 	bl	8006d28 <osMutexWait>
#else
  osMutexAcquire(lwip_sys_mutex, osWaitForever);
#endif
  return (sys_prot_t)1;
}
 801355a:	2001      	movs	r0, #1
 801355c:	bd08      	pop	{r3, pc}
 801355e:	bf00      	nop
 8013560:	24014440 	.word	0x24014440

08013564 <sys_arch_unprotect>:

  Note: This function is based on FreeRTOS API, because no equivalent CMSIS-RTOS
        API is available
*/
void sys_arch_unprotect(sys_prot_t pval)
{
 8013564:	b508      	push	{r3, lr}
  ( void ) pval;
  osMutexRelease(lwip_sys_mutex);
 8013566:	4b02      	ldr	r3, [pc, #8]	@ (8013570 <sys_arch_unprotect+0xc>)
 8013568:	6818      	ldr	r0, [r3, #0]
 801356a:	f7f3 fc0d 	bl	8006d88 <osMutexRelease>
}
 801356e:	bd08      	pop	{r3, pc}
 8013570:	24014440 	.word	0x24014440

08013574 <ethernet_link_status_updated>:
#else
    BSP_LED_Off(LED2);
    BSP_LED_On(LED3); 
#endif /* LWIP_DHCP */
  }
}
 8013574:	4770      	bx	lr

08013576 <ETH_PHY_IO_DeInit>:
  * @retval 0 if OK, -1 if ERROR
  */
int32_t ETH_PHY_IO_DeInit (void)
{
  return 0;
}
 8013576:	2000      	movs	r0, #0
 8013578:	4770      	bx	lr
	...

0801357c <low_level_output>:
{
 801357c:	b530      	push	{r4, r5, lr}
 801357e:	b08d      	sub	sp, #52	@ 0x34
 8013580:	460c      	mov	r4, r1
  memset(Txbuffer, 0 , ETH_TX_DESC_CNT*sizeof(ETH_BufferTypeDef));
 8013582:	2230      	movs	r2, #48	@ 0x30
 8013584:	2100      	movs	r1, #0
 8013586:	4668      	mov	r0, sp
 8013588:	f000 fe96 	bl	80142b8 <memset>
  for(q = p; q != NULL; q = q->next)
 801358c:	4622      	mov	r2, r4
  uint32_t i = 0U;
 801358e:	2300      	movs	r3, #0
  for(q = p; q != NULL; q = q->next)
 8013590:	e003      	b.n	801359a <low_level_output+0x1e>
    if(q->next == NULL)
 8013592:	6811      	ldr	r1, [r2, #0]
 8013594:	b1f1      	cbz	r1, 80135d4 <low_level_output+0x58>
    i++;
 8013596:	3301      	adds	r3, #1
  for(q = p; q != NULL; q = q->next)
 8013598:	6812      	ldr	r2, [r2, #0]
 801359a:	b322      	cbz	r2, 80135e6 <low_level_output+0x6a>
    if(i >= ETH_TX_DESC_CNT)
 801359c:	2b03      	cmp	r3, #3
 801359e:	d83c      	bhi.n	801361a <low_level_output+0x9e>
    Txbuffer[i].buffer = q->payload;
 80135a0:	6851      	ldr	r1, [r2, #4]
 80135a2:	eb03 0c43 	add.w	ip, r3, r3, lsl #1
 80135a6:	a80c      	add	r0, sp, #48	@ 0x30
 80135a8:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
 80135ac:	f84c 1c30 	str.w	r1, [ip, #-48]
    Txbuffer[i].len = q->len;
 80135b0:	8951      	ldrh	r1, [r2, #10]
 80135b2:	f84c 1c2c 	str.w	r1, [ip, #-44]
    if(i>0)
 80135b6:	2b00      	cmp	r3, #0
 80135b8:	d0eb      	beq.n	8013592 <low_level_output+0x16>
      Txbuffer[i-1].next = &Txbuffer[i];
 80135ba:	f103 3cff 	add.w	ip, r3, #4294967295
 80135be:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 80135c2:	eb0d 0181 	add.w	r1, sp, r1, lsl #2
 80135c6:	eb0c 0c4c 	add.w	ip, ip, ip, lsl #1
 80135ca:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
 80135ce:	f84c 1c28 	str.w	r1, [ip, #-40]
 80135d2:	e7de      	b.n	8013592 <low_level_output+0x16>
      Txbuffer[i].next = NULL;
 80135d4:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 80135d8:	a80c      	add	r0, sp, #48	@ 0x30
 80135da:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 80135de:	2000      	movs	r0, #0
 80135e0:	f841 0c28 	str.w	r0, [r1, #-40]
 80135e4:	e7d7      	b.n	8013596 <low_level_output+0x1a>
  TxConfig.Length = p->tot_len;
 80135e6:	8923      	ldrh	r3, [r4, #8]
 80135e8:	4d0e      	ldr	r5, [pc, #56]	@ (8013624 <low_level_output+0xa8>)
 80135ea:	606b      	str	r3, [r5, #4]
  TxConfig.TxBuffer = Txbuffer;
 80135ec:	f8c5 d008 	str.w	sp, [r5, #8]
  TxConfig.pData = p;
 80135f0:	636c      	str	r4, [r5, #52]	@ 0x34
  pbuf_ref(p);
 80135f2:	4620      	mov	r0, r4
 80135f4:	f7f8 fc0e 	bl	800be14 <pbuf_ref>
  HAL_ETH_Transmit_IT(&heth, &TxConfig);
 80135f8:	4629      	mov	r1, r5
 80135fa:	480b      	ldr	r0, [pc, #44]	@ (8013628 <low_level_output+0xac>)
 80135fc:	f7ee fcc2 	bl	8001f84 <HAL_ETH_Transmit_IT>
  while(osSemaphoreWait(TxPktSemaphore, TIME_WAITING_FOR_INPUT)!=osOK)
 8013600:	f04f 31ff 	mov.w	r1, #4294967295
 8013604:	4b09      	ldr	r3, [pc, #36]	@ (801362c <low_level_output+0xb0>)
 8013606:	6818      	ldr	r0, [r3, #0]
 8013608:	f7f3 fc17 	bl	8006e3a <osSemaphoreWait>
 801360c:	2800      	cmp	r0, #0
 801360e:	d1f7      	bne.n	8013600 <low_level_output+0x84>
  HAL_ETH_ReleaseTxPacket(&heth);
 8013610:	4805      	ldr	r0, [pc, #20]	@ (8013628 <low_level_output+0xac>)
 8013612:	f7ee fd6a 	bl	80020ea <HAL_ETH_ReleaseTxPacket>
  return errval;
 8013616:	2000      	movs	r0, #0
 8013618:	e001      	b.n	801361e <low_level_output+0xa2>
      return ERR_IF;
 801361a:	f06f 000b 	mvn.w	r0, #11
}
 801361e:	b00d      	add	sp, #52	@ 0x34
 8013620:	bd30      	pop	{r4, r5, pc}
 8013622:	bf00      	nop
 8013624:	24014468 	.word	0x24014468
 8013628:	240144a0 	.word	0x240144a0
 801362c:	24014550 	.word	0x24014550

08013630 <low_level_init>:
{
 8013630:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013634:	b0a6      	sub	sp, #152	@ 0x98
 8013636:	4604      	mov	r4, r0
  ETH_MACConfigTypeDef MACConf = {0};
 8013638:	2264      	movs	r2, #100	@ 0x64
 801363a:	2100      	movs	r1, #0
 801363c:	a80d      	add	r0, sp, #52	@ 0x34
 801363e:	f000 fe3b 	bl	80142b8 <memset>
  uint8_t macaddress[6]= {ETH_MAC_ADDR0, ETH_MAC_ADDR1, ETH_MAC_ADDR2, ETH_MAC_ADDR3, ETH_MAC_ADDR4, ETH_MAC_ADDR5};
 8013642:	4d55      	ldr	r5, [pc, #340]	@ (8013798 <low_level_init+0x168>)
 8013644:	e895 0003 	ldmia.w	r5, {r0, r1}
 8013648:	9007      	str	r0, [sp, #28]
 801364a:	f8ad 1020 	strh.w	r1, [sp, #32]
  heth.Instance = ETH;
 801364e:	4853      	ldr	r0, [pc, #332]	@ (801379c <low_level_init+0x16c>)
 8013650:	4b53      	ldr	r3, [pc, #332]	@ (80137a0 <low_level_init+0x170>)
 8013652:	6003      	str	r3, [r0, #0]
  heth.Init.MACAddr = macaddress;
 8013654:	ab07      	add	r3, sp, #28
 8013656:	6043      	str	r3, [r0, #4]
  heth.Init.MediaInterface = HAL_ETH_RMII_MODE;
 8013658:	2701      	movs	r7, #1
 801365a:	7207      	strb	r7, [r0, #8]
  heth.Init.RxDesc = DMARxDscrTab;
 801365c:	4b51      	ldr	r3, [pc, #324]	@ (80137a4 <low_level_init+0x174>)
 801365e:	6103      	str	r3, [r0, #16]
  heth.Init.TxDesc = DMATxDscrTab;
 8013660:	4b51      	ldr	r3, [pc, #324]	@ (80137a8 <low_level_init+0x178>)
 8013662:	60c3      	str	r3, [r0, #12]
  heth.Init.RxBuffLen = ETH_RX_BUFFER_SIZE;
 8013664:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 8013668:	6143      	str	r3, [r0, #20]
  HAL_ETH_Init(&heth);
 801366a:	f7ee ffd5 	bl	8002618 <HAL_ETH_Init>
  netif->hwaddr_len = ETH_HWADDR_LEN;
 801366e:	2306      	movs	r3, #6
 8013670:	f884 302c 	strb.w	r3, [r4, #44]	@ 0x2c
  netif->hwaddr[0] =  ETH_MAC_ADDR0;
 8013674:	2600      	movs	r6, #0
 8013676:	f884 6026 	strb.w	r6, [r4, #38]	@ 0x26
  netif->hwaddr[1] =  ETH_MAC_ADDR1;
 801367a:	2380      	movs	r3, #128	@ 0x80
 801367c:	f884 3027 	strb.w	r3, [r4, #39]	@ 0x27
  netif->hwaddr[2] =  ETH_MAC_ADDR2;
 8013680:	23e1      	movs	r3, #225	@ 0xe1
 8013682:	f884 3028 	strb.w	r3, [r4, #40]	@ 0x28
  netif->hwaddr[3] =  ETH_MAC_ADDR3;
 8013686:	2370      	movs	r3, #112	@ 0x70
 8013688:	f884 3029 	strb.w	r3, [r4, #41]	@ 0x29
  netif->hwaddr[4] =  ETH_MAC_ADDR4;
 801368c:	f884 602a 	strb.w	r6, [r4, #42]	@ 0x2a
  netif->hwaddr[5] =  ETH_MAC_ADDR5;
 8013690:	f884 702b 	strb.w	r7, [r4, #43]	@ 0x2b
  netif->mtu = ETH_MAX_PAYLOAD;
 8013694:	f240 53dc 	movw	r3, #1500	@ 0x5dc
 8013698:	84a3      	strh	r3, [r4, #36]	@ 0x24
  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_BROADCAST;
 801369a:	f894 302d 	ldrb.w	r3, [r4, #45]	@ 0x2d
 801369e:	f043 030a 	orr.w	r3, r3, #10
 80136a2:	f884 302d 	strb.w	r3, [r4, #45]	@ 0x2d
  LWIP_MEMPOOL_INIT(RX_POOL);
 80136a6:	4841      	ldr	r0, [pc, #260]	@ (80137ac <low_level_init+0x17c>)
 80136a8:	f7f7 fea6 	bl	800b3f8 <memp_init_pool>
  memset(&TxConfig, 0 , sizeof(ETH_TxPacketConfig));
 80136ac:	f8df 8110 	ldr.w	r8, [pc, #272]	@ 80137c0 <low_level_init+0x190>
 80136b0:	2238      	movs	r2, #56	@ 0x38
 80136b2:	4631      	mov	r1, r6
 80136b4:	4640      	mov	r0, r8
 80136b6:	f000 fdff 	bl	80142b8 <memset>
  TxConfig.Attributes = ETH_TX_PACKETS_FEATURES_CSUM | ETH_TX_PACKETS_FEATURES_CRCPAD;
 80136ba:	2321      	movs	r3, #33	@ 0x21
 80136bc:	f8c8 3000 	str.w	r3, [r8]
  TxConfig.ChecksumCtrl = ETH_CHECKSUM_IPHDR_PAYLOAD_INSERT_PHDR_CALC;
 80136c0:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
 80136c4:	f8c8 3014 	str.w	r3, [r8, #20]
  RxPktSemaphore = xSemaphoreCreateBinary();
 80136c8:	2203      	movs	r2, #3
 80136ca:	4631      	mov	r1, r6
 80136cc:	4638      	mov	r0, r7
 80136ce:	f7f3 fe59 	bl	8007384 <xQueueGenericCreate>
 80136d2:	4b37      	ldr	r3, [pc, #220]	@ (80137b0 <low_level_init+0x180>)
 80136d4:	6018      	str	r0, [r3, #0]
  TxPktSemaphore = xSemaphoreCreateBinary();
 80136d6:	2203      	movs	r2, #3
 80136d8:	4631      	mov	r1, r6
 80136da:	4638      	mov	r0, r7
 80136dc:	f7f3 fe52 	bl	8007384 <xQueueGenericCreate>
 80136e0:	4b34      	ldr	r3, [pc, #208]	@ (80137b4 <low_level_init+0x184>)
 80136e2:	6018      	str	r0, [r3, #0]
  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
 80136e4:	46ee      	mov	lr, sp
 80136e6:	f105 0c08 	add.w	ip, r5, #8
 80136ea:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80136ee:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 80136f2:	e89c 0007 	ldmia.w	ip, {r0, r1, r2}
 80136f6:	e88e 0007 	stmia.w	lr, {r0, r1, r2}
  osThreadCreate (osThread(EthIf), netif);
 80136fa:	4621      	mov	r1, r4
 80136fc:	4668      	mov	r0, sp
 80136fe:	f7f3 fad0 	bl	8006ca2 <osThreadCreate>
  LAN8742_RegisterBusIO(&LAN8742, &LAN8742_IOCtx);
 8013702:	4d2d      	ldr	r5, [pc, #180]	@ (80137b8 <low_level_init+0x188>)
 8013704:	492d      	ldr	r1, [pc, #180]	@ (80137bc <low_level_init+0x18c>)
 8013706:	4628      	mov	r0, r5
 8013708:	f7ed fd53 	bl	80011b2 <LAN8742_RegisterBusIO>
  LAN8742_Init(&LAN8742);
 801370c:	4628      	mov	r0, r5
 801370e:	f7ed fd6f 	bl	80011f0 <LAN8742_Init>
  PHYLinkState = LAN8742_GetLinkState(&LAN8742);
 8013712:	4628      	mov	r0, r5
 8013714:	f7ed fdd4 	bl	80012c0 <LAN8742_GetLinkState>
  if(PHYLinkState <= LAN8742_STATUS_LINK_DOWN)
 8013718:	42b8      	cmp	r0, r7
 801371a:	dd09      	ble.n	8013730 <low_level_init+0x100>
    switch (PHYLinkState)
 801371c:	2804      	cmp	r0, #4
 801371e:	d00e      	beq.n	801373e <low_level_init+0x10e>
 8013720:	2805      	cmp	r0, #5
 8013722:	d010      	beq.n	8013746 <low_level_init+0x116>
 8013724:	2803      	cmp	r0, #3
 8013726:	d132      	bne.n	801378e <low_level_init+0x15e>
      speed = ETH_SPEED_100M;
 8013728:	f44f 4680 	mov.w	r6, #16384	@ 0x4000
      duplex = ETH_HALFDUPLEX_MODE;
 801372c:	2700      	movs	r7, #0
 801372e:	e00c      	b.n	801374a <low_level_init+0x11a>
    netif_set_link_down(netif);
 8013730:	4620      	mov	r0, r4
 8013732:	f7f8 f8b5 	bl	800b8a0 <netif_set_link_down>
    netif_set_down(netif);
 8013736:	4620      	mov	r0, r4
 8013738:	f7f8 f874 	bl	800b824 <netif_set_down>
 801373c:	e024      	b.n	8013788 <low_level_init+0x158>
      speed = ETH_SPEED_10M;
 801373e:	2600      	movs	r6, #0
      duplex = ETH_FULLDUPLEX_MODE;
 8013740:	f44f 5700 	mov.w	r7, #8192	@ 0x2000
 8013744:	e001      	b.n	801374a <low_level_init+0x11a>
      speed = ETH_SPEED_10M;
 8013746:	2600      	movs	r6, #0
      duplex = ETH_HALFDUPLEX_MODE;
 8013748:	4637      	mov	r7, r6
    HAL_ETH_GetMACConfig(&heth, &MACConf);
 801374a:	4d14      	ldr	r5, [pc, #80]	@ (801379c <low_level_init+0x16c>)
 801374c:	a90d      	add	r1, sp, #52	@ 0x34
 801374e:	4628      	mov	r0, r5
 8013750:	f7ee fe24 	bl	800239c <HAL_ETH_GetMACConfig>
    MACConf.DuplexMode = duplex;
 8013754:	9713      	str	r7, [sp, #76]	@ 0x4c
    MACConf.Speed = speed;
 8013756:	9612      	str	r6, [sp, #72]	@ 0x48
    HAL_ETH_SetMACConfig(&heth, &MACConf);
 8013758:	a90d      	add	r1, sp, #52	@ 0x34
 801375a:	4628      	mov	r0, r5
 801375c:	f7ee ff11 	bl	8002582 <HAL_ETH_SetMACConfig>
    HAL_ETH_GetMACFilterConfig(&heth, &pFilterConfig);
 8013760:	a909      	add	r1, sp, #36	@ 0x24
 8013762:	4628      	mov	r0, r5
 8013764:	f7ef f82c 	bl	80027c0 <HAL_ETH_GetMACFilterConfig>
    pFilterConfig.PassAllMulticast = ENABLE;
 8013768:	2301      	movs	r3, #1
 801376a:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
    HAL_ETH_SetMACFilterConfig(&heth, &pFilterConfig);
 801376e:	a909      	add	r1, sp, #36	@ 0x24
 8013770:	4628      	mov	r0, r5
 8013772:	f7ee fff5 	bl	8002760 <HAL_ETH_SetMACFilterConfig>
    HAL_ETH_Start_IT(&heth);
 8013776:	4628      	mov	r0, r5
 8013778:	f7ee fba6 	bl	8001ec8 <HAL_ETH_Start_IT>
    netif_set_up(netif);
 801377c:	4620      	mov	r0, r4
 801377e:	f7f8 f833 	bl	800b7e8 <netif_set_up>
    netif_set_link_up(netif);
 8013782:	4620      	mov	r0, r4
 8013784:	f7f8 f86e 	bl	800b864 <netif_set_link_up>
}
 8013788:	b026      	add	sp, #152	@ 0x98
 801378a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    switch (PHYLinkState)
 801378e:	f44f 4680 	mov.w	r6, #16384	@ 0x4000
 8013792:	f44f 5700 	mov.w	r7, #8192	@ 0x2000
 8013796:	e7d8      	b.n	801374a <low_level_init+0x11a>
 8013798:	080152ec 	.word	0x080152ec
 801379c:	240144a0 	.word	0x240144a0
 80137a0:	40028000 	.word	0x40028000
 80137a4:	24003270 	.word	0x24003270
 80137a8:	24003210 	.word	0x24003210
 80137ac:	08018fdc 	.word	0x08018fdc
 80137b0:	24014554 	.word	0x24014554
 80137b4:	24014550 	.word	0x24014550
 80137b8:	24014448 	.word	0x24014448
 80137bc:	2400001c 	.word	0x2400001c
 80137c0:	24014468 	.word	0x24014468

080137c4 <low_level_input>:
{
 80137c4:	b500      	push	{lr}
 80137c6:	b083      	sub	sp, #12
  struct pbuf *p = NULL;
 80137c8:	2300      	movs	r3, #0
 80137ca:	9301      	str	r3, [sp, #4]
  if(RxAllocStatus == RX_ALLOC_OK)
 80137cc:	4b05      	ldr	r3, [pc, #20]	@ (80137e4 <low_level_input+0x20>)
 80137ce:	781b      	ldrb	r3, [r3, #0]
 80137d0:	b11b      	cbz	r3, 80137da <low_level_input+0x16>
}
 80137d2:	9801      	ldr	r0, [sp, #4]
 80137d4:	b003      	add	sp, #12
 80137d6:	f85d fb04 	ldr.w	pc, [sp], #4
    HAL_ETH_ReadData(&heth, (void **)&p);
 80137da:	a901      	add	r1, sp, #4
 80137dc:	4802      	ldr	r0, [pc, #8]	@ (80137e8 <low_level_input+0x24>)
 80137de:	f7ee fc05 	bl	8001fec <HAL_ETH_ReadData>
 80137e2:	e7f6      	b.n	80137d2 <low_level_input+0xe>
 80137e4:	24014558 	.word	0x24014558
 80137e8:	240144a0 	.word	0x240144a0

080137ec <ethernetif_input>:
{
 80137ec:	b538      	push	{r3, r4, r5, lr}
 80137ee:	4605      	mov	r5, r0
    if (osSemaphoreWait( RxPktSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
 80137f0:	f04f 31ff 	mov.w	r1, #4294967295
 80137f4:	4b0b      	ldr	r3, [pc, #44]	@ (8013824 <ethernetif_input+0x38>)
 80137f6:	6818      	ldr	r0, [r3, #0]
 80137f8:	f7f3 fb1f 	bl	8006e3a <osSemaphoreWait>
 80137fc:	2800      	cmp	r0, #0
 80137fe:	d1f7      	bne.n	80137f0 <ethernetif_input+0x4>
 8013800:	e001      	b.n	8013806 <ethernetif_input+0x1a>
      }while(p!=NULL);
 8013802:	2c00      	cmp	r4, #0
 8013804:	d0f4      	beq.n	80137f0 <ethernetif_input+0x4>
        p = low_level_input( netif );
 8013806:	4628      	mov	r0, r5
 8013808:	f7ff ffdc 	bl	80137c4 <low_level_input>
        if (p != NULL)
 801380c:	4604      	mov	r4, r0
 801380e:	2800      	cmp	r0, #0
 8013810:	d0f7      	beq.n	8013802 <ethernetif_input+0x16>
          if (netif->input( p, netif) != ERR_OK )
 8013812:	692b      	ldr	r3, [r5, #16]
 8013814:	4629      	mov	r1, r5
 8013816:	4798      	blx	r3
 8013818:	2800      	cmp	r0, #0
 801381a:	d0f2      	beq.n	8013802 <ethernetif_input+0x16>
            pbuf_free(p);
 801381c:	4620      	mov	r0, r4
 801381e:	f7f8 f987 	bl	800bb30 <pbuf_free>
 8013822:	e7ee      	b.n	8013802 <ethernetif_input+0x16>
 8013824:	24014554 	.word	0x24014554

08013828 <pbuf_free_custom>:
{
 8013828:	b508      	push	{r3, lr}
 801382a:	4601      	mov	r1, r0
  LWIP_MEMPOOL_FREE(RX_POOL, custom_pbuf);
 801382c:	4807      	ldr	r0, [pc, #28]	@ (801384c <pbuf_free_custom+0x24>)
 801382e:	f7f7 fe47 	bl	800b4c0 <memp_free_pool>
  if (RxAllocStatus == RX_ALLOC_ERROR)
 8013832:	4b07      	ldr	r3, [pc, #28]	@ (8013850 <pbuf_free_custom+0x28>)
 8013834:	781b      	ldrb	r3, [r3, #0]
 8013836:	2b01      	cmp	r3, #1
 8013838:	d000      	beq.n	801383c <pbuf_free_custom+0x14>
}
 801383a:	bd08      	pop	{r3, pc}
    RxAllocStatus = RX_ALLOC_OK;
 801383c:	4b04      	ldr	r3, [pc, #16]	@ (8013850 <pbuf_free_custom+0x28>)
 801383e:	2200      	movs	r2, #0
 8013840:	701a      	strb	r2, [r3, #0]
    osSemaphoreRelease(RxPktSemaphore);
 8013842:	4b04      	ldr	r3, [pc, #16]	@ (8013854 <pbuf_free_custom+0x2c>)
 8013844:	6818      	ldr	r0, [r3, #0]
 8013846:	f7f3 fb27 	bl	8006e98 <osSemaphoreRelease>
}
 801384a:	e7f6      	b.n	801383a <pbuf_free_custom+0x12>
 801384c:	08018fdc 	.word	0x08018fdc
 8013850:	24014558 	.word	0x24014558
 8013854:	24014554 	.word	0x24014554

08013858 <ETH_PHY_IO_GetTick>:
/**
  * @brief  Get the time in millisecons used for internal PHY driver process.
  * @retval Time value
  */
int32_t ETH_PHY_IO_GetTick(void)
{
 8013858:	b508      	push	{r3, lr}
  return HAL_GetTick();
 801385a:	f7ed fdcd 	bl	80013f8 <HAL_GetTick>
}
 801385e:	bd08      	pop	{r3, pc}

08013860 <ETH_PHY_IO_Init>:
{
 8013860:	b508      	push	{r3, lr}
  HAL_ETH_SetMDIOClockRange(&heth);
 8013862:	4802      	ldr	r0, [pc, #8]	@ (801386c <ETH_PHY_IO_Init+0xc>)
 8013864:	f7ee fe9c 	bl	80025a0 <HAL_ETH_SetMDIOClockRange>
}
 8013868:	2000      	movs	r0, #0
 801386a:	bd08      	pop	{r3, pc}
 801386c:	240144a0 	.word	0x240144a0

08013870 <ETH_PHY_IO_ReadReg>:
{
 8013870:	b508      	push	{r3, lr}
 8013872:	4613      	mov	r3, r2
  if(HAL_ETH_ReadPHYRegister(&heth, DevAddr, RegAddr, pRegVal) != HAL_OK)
 8013874:	460a      	mov	r2, r1
 8013876:	4601      	mov	r1, r0
 8013878:	4803      	ldr	r0, [pc, #12]	@ (8013888 <ETH_PHY_IO_ReadReg+0x18>)
 801387a:	f7ee fd2a 	bl	80022d2 <HAL_ETH_ReadPHYRegister>
 801387e:	b900      	cbnz	r0, 8013882 <ETH_PHY_IO_ReadReg+0x12>
}
 8013880:	bd08      	pop	{r3, pc}
    return -1;
 8013882:	f04f 30ff 	mov.w	r0, #4294967295
 8013886:	e7fb      	b.n	8013880 <ETH_PHY_IO_ReadReg+0x10>
 8013888:	240144a0 	.word	0x240144a0

0801388c <ETH_PHY_IO_WriteReg>:
{
 801388c:	b508      	push	{r3, lr}
 801388e:	4613      	mov	r3, r2
  if(HAL_ETH_WritePHYRegister(&heth, DevAddr, RegAddr, RegVal) != HAL_OK)
 8013890:	460a      	mov	r2, r1
 8013892:	4601      	mov	r1, r0
 8013894:	4803      	ldr	r0, [pc, #12]	@ (80138a4 <ETH_PHY_IO_WriteReg+0x18>)
 8013896:	f7ee fd4d 	bl	8002334 <HAL_ETH_WritePHYRegister>
 801389a:	b900      	cbnz	r0, 801389e <ETH_PHY_IO_WriteReg+0x12>
}
 801389c:	bd08      	pop	{r3, pc}
    return -1;
 801389e:	f04f 30ff 	mov.w	r0, #4294967295
 80138a2:	e7fb      	b.n	801389c <ETH_PHY_IO_WriteReg+0x10>
 80138a4:	240144a0 	.word	0x240144a0

080138a8 <ethernetif_init>:
{
 80138a8:	b510      	push	{r4, lr}
  LWIP_ASSERT("netif != NULL", (netif != NULL));
 80138aa:	4604      	mov	r4, r0
 80138ac:	b170      	cbz	r0, 80138cc <ethernetif_init+0x24>
  netif->name[0] = IFNAME0;
 80138ae:	2373      	movs	r3, #115	@ 0x73
 80138b0:	f884 302e 	strb.w	r3, [r4, #46]	@ 0x2e
  netif->name[1] = IFNAME1;
 80138b4:	2374      	movs	r3, #116	@ 0x74
 80138b6:	f884 302f 	strb.w	r3, [r4, #47]	@ 0x2f
  netif->output = etharp_output;
 80138ba:	4b08      	ldr	r3, [pc, #32]	@ (80138dc <ethernetif_init+0x34>)
 80138bc:	6163      	str	r3, [r4, #20]
  netif->linkoutput = low_level_output;
 80138be:	4b08      	ldr	r3, [pc, #32]	@ (80138e0 <ethernetif_init+0x38>)
 80138c0:	61a3      	str	r3, [r4, #24]
  low_level_init(netif);
 80138c2:	4620      	mov	r0, r4
 80138c4:	f7ff feb4 	bl	8013630 <low_level_init>
}
 80138c8:	2000      	movs	r0, #0
 80138ca:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("netif != NULL", (netif != NULL));
 80138cc:	4b05      	ldr	r3, [pc, #20]	@ (80138e4 <ethernetif_init+0x3c>)
 80138ce:	f44f 72c4 	mov.w	r2, #392	@ 0x188
 80138d2:	4905      	ldr	r1, [pc, #20]	@ (80138e8 <ethernetif_init+0x40>)
 80138d4:	4805      	ldr	r0, [pc, #20]	@ (80138ec <ethernetif_init+0x44>)
 80138d6:	f000 fb53 	bl	8013f80 <iprintf>
 80138da:	e7e8      	b.n	80138ae <ethernetif_init+0x6>
 80138dc:	080118e1 	.word	0x080118e1
 80138e0:	0801357d 	.word	0x0801357d
 80138e4:	08018b84 	.word	0x08018b84
 80138e8:	080184d4 	.word	0x080184d4
 80138ec:	08015744 	.word	0x08015744

080138f0 <sys_now>:
{
 80138f0:	b508      	push	{r3, lr}
  return HAL_GetTick();
 80138f2:	f7ed fd81 	bl	80013f8 <HAL_GetTick>
}
 80138f6:	bd08      	pop	{r3, pc}

080138f8 <HAL_ETH_MspInit>:
{
 80138f8:	b530      	push	{r4, r5, lr}
 80138fa:	b08d      	sub	sp, #52	@ 0x34
  GPIO_InitTypeDef GPIO_InitStructure = {0};
 80138fc:	2500      	movs	r5, #0
 80138fe:	9507      	str	r5, [sp, #28]
 8013900:	9508      	str	r5, [sp, #32]
 8013902:	9509      	str	r5, [sp, #36]	@ 0x24
 8013904:	950a      	str	r5, [sp, #40]	@ 0x28
 8013906:	950b      	str	r5, [sp, #44]	@ 0x2c
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8013908:	4c3b      	ldr	r4, [pc, #236]	@ (80139f8 <HAL_ETH_MspInit+0x100>)
 801390a:	f8d4 30e0 	ldr.w	r3, [r4, #224]	@ 0xe0
 801390e:	f043 0301 	orr.w	r3, r3, #1
 8013912:	f8c4 30e0 	str.w	r3, [r4, #224]	@ 0xe0
 8013916:	f8d4 30e0 	ldr.w	r3, [r4, #224]	@ 0xe0
 801391a:	f003 0301 	and.w	r3, r3, #1
 801391e:	9300      	str	r3, [sp, #0]
 8013920:	9b00      	ldr	r3, [sp, #0]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8013922:	f8d4 30e0 	ldr.w	r3, [r4, #224]	@ 0xe0
 8013926:	f043 0302 	orr.w	r3, r3, #2
 801392a:	f8c4 30e0 	str.w	r3, [r4, #224]	@ 0xe0
 801392e:	f8d4 30e0 	ldr.w	r3, [r4, #224]	@ 0xe0
 8013932:	f003 0302 	and.w	r3, r3, #2
 8013936:	9301      	str	r3, [sp, #4]
 8013938:	9b01      	ldr	r3, [sp, #4]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 801393a:	f8d4 30e0 	ldr.w	r3, [r4, #224]	@ 0xe0
 801393e:	f043 0304 	orr.w	r3, r3, #4
 8013942:	f8c4 30e0 	str.w	r3, [r4, #224]	@ 0xe0
 8013946:	f8d4 30e0 	ldr.w	r3, [r4, #224]	@ 0xe0
 801394a:	f003 0304 	and.w	r3, r3, #4
 801394e:	9302      	str	r3, [sp, #8]
 8013950:	9b02      	ldr	r3, [sp, #8]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 8013952:	f8d4 30e0 	ldr.w	r3, [r4, #224]	@ 0xe0
 8013956:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801395a:	f8c4 30e0 	str.w	r3, [r4, #224]	@ 0xe0
 801395e:	f8d4 30e0 	ldr.w	r3, [r4, #224]	@ 0xe0
 8013962:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8013966:	9303      	str	r3, [sp, #12]
 8013968:	9b03      	ldr	r3, [sp, #12]
  GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
 801396a:	2302      	movs	r3, #2
 801396c:	930a      	str	r3, [sp, #40]	@ 0x28
  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
 801396e:	9308      	str	r3, [sp, #32]
  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
 8013970:	230b      	movs	r3, #11
 8013972:	930b      	str	r3, [sp, #44]	@ 0x2c
  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
 8013974:	2386      	movs	r3, #134	@ 0x86
 8013976:	9307      	str	r3, [sp, #28]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
 8013978:	a907      	add	r1, sp, #28
 801397a:	4820      	ldr	r0, [pc, #128]	@ (80139fc <HAL_ETH_MspInit+0x104>)
 801397c:	f7ee ff62 	bl	8002844 <HAL_GPIO_Init>
  GPIO_InitStructure.Pin = GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13;
 8013980:	f44f 5360 	mov.w	r3, #14336	@ 0x3800
 8013984:	9307      	str	r3, [sp, #28]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
 8013986:	a907      	add	r1, sp, #28
 8013988:	481d      	ldr	r0, [pc, #116]	@ (8013a00 <HAL_ETH_MspInit+0x108>)
 801398a:	f7ee ff5b 	bl	8002844 <HAL_GPIO_Init>
  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
 801398e:	2332      	movs	r3, #50	@ 0x32
 8013990:	9307      	str	r3, [sp, #28]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 8013992:	a907      	add	r1, sp, #28
 8013994:	481b      	ldr	r0, [pc, #108]	@ (8013a04 <HAL_ETH_MspInit+0x10c>)
 8013996:	f7ee ff55 	bl	8002844 <HAL_GPIO_Init>
  HAL_NVIC_SetPriority(ETH_IRQn, 0x7, 0);
 801399a:	462a      	mov	r2, r5
 801399c:	2107      	movs	r1, #7
 801399e:	203d      	movs	r0, #61	@ 0x3d
 80139a0:	f7ed fdc0 	bl	8001524 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(ETH_IRQn);
 80139a4:	203d      	movs	r0, #61	@ 0x3d
 80139a6:	f7ed fde1 	bl	800156c <HAL_NVIC_EnableIRQ>
  __HAL_RCC_ETH1MAC_CLK_ENABLE();
 80139aa:	f8d4 30d8 	ldr.w	r3, [r4, #216]	@ 0xd8
 80139ae:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 80139b2:	f8c4 30d8 	str.w	r3, [r4, #216]	@ 0xd8
 80139b6:	f8d4 30d8 	ldr.w	r3, [r4, #216]	@ 0xd8
 80139ba:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 80139be:	9304      	str	r3, [sp, #16]
 80139c0:	9b04      	ldr	r3, [sp, #16]
  __HAL_RCC_ETH1TX_CLK_ENABLE();
 80139c2:	f8d4 30d8 	ldr.w	r3, [r4, #216]	@ 0xd8
 80139c6:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80139ca:	f8c4 30d8 	str.w	r3, [r4, #216]	@ 0xd8
 80139ce:	f8d4 30d8 	ldr.w	r3, [r4, #216]	@ 0xd8
 80139d2:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 80139d6:	9305      	str	r3, [sp, #20]
 80139d8:	9b05      	ldr	r3, [sp, #20]
  __HAL_RCC_ETH1RX_CLK_ENABLE();
 80139da:	f8d4 30d8 	ldr.w	r3, [r4, #216]	@ 0xd8
 80139de:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 80139e2:	f8c4 30d8 	str.w	r3, [r4, #216]	@ 0xd8
 80139e6:	f8d4 30d8 	ldr.w	r3, [r4, #216]	@ 0xd8
 80139ea:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80139ee:	9306      	str	r3, [sp, #24]
 80139f0:	9b06      	ldr	r3, [sp, #24]
}
 80139f2:	b00d      	add	sp, #52	@ 0x34
 80139f4:	bd30      	pop	{r4, r5, pc}
 80139f6:	bf00      	nop
 80139f8:	58024400 	.word	0x58024400
 80139fc:	58020000 	.word	0x58020000
 8013a00:	58020400 	.word	0x58020400
 8013a04:	58020800 	.word	0x58020800

08013a08 <HAL_ETH_RxCpltCallback>:
{
 8013a08:	b508      	push	{r3, lr}
  osSemaphoreRelease(RxPktSemaphore);
 8013a0a:	4b02      	ldr	r3, [pc, #8]	@ (8013a14 <HAL_ETH_RxCpltCallback+0xc>)
 8013a0c:	6818      	ldr	r0, [r3, #0]
 8013a0e:	f7f3 fa43 	bl	8006e98 <osSemaphoreRelease>
}
 8013a12:	bd08      	pop	{r3, pc}
 8013a14:	24014554 	.word	0x24014554

08013a18 <HAL_ETH_TxCpltCallback>:
{
 8013a18:	b508      	push	{r3, lr}
  osSemaphoreRelease(TxPktSemaphore);
 8013a1a:	4b02      	ldr	r3, [pc, #8]	@ (8013a24 <HAL_ETH_TxCpltCallback+0xc>)
 8013a1c:	6818      	ldr	r0, [r3, #0]
 8013a1e:	f7f3 fa3b 	bl	8006e98 <osSemaphoreRelease>
}
 8013a22:	bd08      	pop	{r3, pc}
 8013a24:	24014550 	.word	0x24014550

08013a28 <HAL_ETH_ErrorCallback>:
{
 8013a28:	b510      	push	{r4, lr}
 8013a2a:	4604      	mov	r4, r0
  if((HAL_ETH_GetDMAError(heth) & ETH_DMACSR_RBU) == ETH_DMACSR_RBU)
 8013a2c:	f7ee ff07 	bl	800283e <HAL_ETH_GetDMAError>
 8013a30:	f010 0f80 	tst.w	r0, #128	@ 0x80
 8013a34:	d106      	bne.n	8013a44 <HAL_ETH_ErrorCallback+0x1c>
  if((HAL_ETH_GetDMAError(heth) & ETH_DMACSR_TBU) == ETH_DMACSR_TBU)
 8013a36:	4620      	mov	r0, r4
 8013a38:	f7ee ff01 	bl	800283e <HAL_ETH_GetDMAError>
 8013a3c:	f010 0f04 	tst.w	r0, #4
 8013a40:	d105      	bne.n	8013a4e <HAL_ETH_ErrorCallback+0x26>
}
 8013a42:	bd10      	pop	{r4, pc}
    osSemaphoreRelease(RxPktSemaphore);
 8013a44:	4b04      	ldr	r3, [pc, #16]	@ (8013a58 <HAL_ETH_ErrorCallback+0x30>)
 8013a46:	6818      	ldr	r0, [r3, #0]
 8013a48:	f7f3 fa26 	bl	8006e98 <osSemaphoreRelease>
 8013a4c:	e7f3      	b.n	8013a36 <HAL_ETH_ErrorCallback+0xe>
    osSemaphoreRelease(TxPktSemaphore);
 8013a4e:	4b03      	ldr	r3, [pc, #12]	@ (8013a5c <HAL_ETH_ErrorCallback+0x34>)
 8013a50:	6818      	ldr	r0, [r3, #0]
 8013a52:	f7f3 fa21 	bl	8006e98 <osSemaphoreRelease>
}
 8013a56:	e7f4      	b.n	8013a42 <HAL_ETH_ErrorCallback+0x1a>
 8013a58:	24014554 	.word	0x24014554
 8013a5c:	24014550 	.word	0x24014550

08013a60 <HAL_ETH_RxAllocateCallback>:
    osDelay(100);
  }
}

void HAL_ETH_RxAllocateCallback(uint8_t **buff)
{
 8013a60:	b510      	push	{r4, lr}
 8013a62:	b082      	sub	sp, #8
 8013a64:	4604      	mov	r4, r0
  struct pbuf_custom *p = LWIP_MEMPOOL_ALLOC(RX_POOL);
 8013a66:	480e      	ldr	r0, [pc, #56]	@ (8013aa0 <HAL_ETH_RxAllocateCallback+0x40>)
 8013a68:	f7f7 fcfa 	bl	800b460 <memp_malloc_pool>
  if (p)
 8013a6c:	b188      	cbz	r0, 8013a92 <HAL_ETH_RxAllocateCallback+0x32>
 8013a6e:	4603      	mov	r3, r0
  {
    /* Get the buff from the struct pbuf address. */
    *buff = (uint8_t *)p + offsetof(RxBuff_t, buff);
 8013a70:	f100 0220 	add.w	r2, r0, #32
 8013a74:	6022      	str	r2, [r4, #0]
    p->custom_free_function = pbuf_free_custom;
 8013a76:	4a0b      	ldr	r2, [pc, #44]	@ (8013aa4 <HAL_ETH_RxAllocateCallback+0x44>)
 8013a78:	6102      	str	r2, [r0, #16]
    /* Initialize the struct pbuf.
    * This must be performed whenever a buffer's allocated because it may be
    * changed by lwIP or the app, e.g., pbuf_free decrements ref. */
    pbuf_alloced_custom(PBUF_RAW, 0, PBUF_REF, p, *buff, ETH_RX_BUFFER_SIZE);
 8013a7a:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 8013a7e:	9201      	str	r2, [sp, #4]
 8013a80:	6822      	ldr	r2, [r4, #0]
 8013a82:	9200      	str	r2, [sp, #0]
 8013a84:	2241      	movs	r2, #65	@ 0x41
 8013a86:	2100      	movs	r1, #0
 8013a88:	4608      	mov	r0, r1
 8013a8a:	f7f7 ffe7 	bl	800ba5c <pbuf_alloced_custom>
  else
  {
    RxAllocStatus = RX_ALLOC_ERROR;
    *buff = NULL;
  }
}
 8013a8e:	b002      	add	sp, #8
 8013a90:	bd10      	pop	{r4, pc}
    RxAllocStatus = RX_ALLOC_ERROR;
 8013a92:	4b05      	ldr	r3, [pc, #20]	@ (8013aa8 <HAL_ETH_RxAllocateCallback+0x48>)
 8013a94:	2201      	movs	r2, #1
 8013a96:	701a      	strb	r2, [r3, #0]
    *buff = NULL;
 8013a98:	2300      	movs	r3, #0
 8013a9a:	6023      	str	r3, [r4, #0]
}
 8013a9c:	e7f7      	b.n	8013a8e <HAL_ETH_RxAllocateCallback+0x2e>
 8013a9e:	bf00      	nop
 8013aa0:	08018fdc 	.word	0x08018fdc
 8013aa4:	08013829 	.word	0x08013829
 8013aa8:	24014558 	.word	0x24014558

08013aac <HAL_ETH_RxLinkCallback>:

void HAL_ETH_RxLinkCallback(void **pStart, void **pEnd, uint8_t *buff, uint16_t Length)
{
 8013aac:	b430      	push	{r4, r5}
  struct pbuf **ppStart = (struct pbuf **)pStart;
  struct pbuf **ppEnd = (struct pbuf **)pEnd;
  struct pbuf *p = NULL;

  /* Get the struct pbuf from the buff address. */
  p = (struct pbuf *)(buff - offsetof(RxBuff_t, buff));
 8013aae:	f1a2 0420 	sub.w	r4, r2, #32
  p->next = NULL;
 8013ab2:	2500      	movs	r5, #0
 8013ab4:	f842 5c20 	str.w	r5, [r2, #-32]
  p->tot_len = 0;
 8013ab8:	f822 5c18 	strh.w	r5, [r2, #-24]
  p->len = Length;
 8013abc:	f822 3c16 	strh.w	r3, [r2, #-22]

  /* Chain the buffer. */
  if (!*ppStart)
 8013ac0:	6805      	ldr	r5, [r0, #0]
 8013ac2:	b125      	cbz	r5, 8013ace <HAL_ETH_RxLinkCallback+0x22>
    *ppStart = p;
  }
  else
  {
    /* Chain the buffer to the end of the packet. */
    (*ppEnd)->next = p;
 8013ac4:	680d      	ldr	r5, [r1, #0]
 8013ac6:	602c      	str	r4, [r5, #0]
  }
  *ppEnd  = p;
 8013ac8:	600c      	str	r4, [r1, #0]

  /* Update the total length of all the buffers of the chain. Each pbuf in the chain should have its tot_len
   * set to its own length, plus the length of all the following pbufs in the chain. */
  for (p = *ppStart; p != NULL; p = p->next)
 8013aca:	6801      	ldr	r1, [r0, #0]
 8013acc:	e005      	b.n	8013ada <HAL_ETH_RxLinkCallback+0x2e>
    *ppStart = p;
 8013ace:	6004      	str	r4, [r0, #0]
 8013ad0:	e7fa      	b.n	8013ac8 <HAL_ETH_RxLinkCallback+0x1c>
  {
    p->tot_len += Length;
 8013ad2:	8908      	ldrh	r0, [r1, #8]
 8013ad4:	4418      	add	r0, r3
 8013ad6:	8108      	strh	r0, [r1, #8]
  for (p = *ppStart; p != NULL; p = p->next)
 8013ad8:	6809      	ldr	r1, [r1, #0]
 8013ada:	2900      	cmp	r1, #0
 8013adc:	d1f9      	bne.n	8013ad2 <HAL_ETH_RxLinkCallback+0x26>
  \param[in]   dsize   size of memory block (in number of bytes)
*/
__STATIC_FORCEINLINE void SCB_InvalidateDCache_by_Addr (void *addr, int32_t dsize)
{
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    if ( dsize > 0 ) { 
 8013ade:	b183      	cbz	r3, 8013b02 <HAL_ETH_RxLinkCallback+0x56>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
 8013ae0:	4611      	mov	r1, r2
 8013ae2:	f002 021f 	and.w	r2, r2, #31
 8013ae6:	4413      	add	r3, r2
  __ASM volatile ("dsb 0xF":::"memory");
 8013ae8:	f3bf 8f4f 	dsb	sy
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
    
      __DSB();

      do {
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
 8013aec:	4a06      	ldr	r2, [pc, #24]	@ (8013b08 <HAL_ETH_RxLinkCallback+0x5c>)
 8013aee:	f8c2 125c 	str.w	r1, [r2, #604]	@ 0x25c
        op_addr += __SCB_DCACHE_LINE_SIZE;
 8013af2:	3120      	adds	r1, #32
        op_size -= __SCB_DCACHE_LINE_SIZE;
 8013af4:	3b20      	subs	r3, #32
      } while ( op_size > 0 );
 8013af6:	2b00      	cmp	r3, #0
 8013af8:	dcf8      	bgt.n	8013aec <HAL_ETH_RxLinkCallback+0x40>
 8013afa:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8013afe:	f3bf 8f6f 	isb	sy
  }

  /* Invalidate data cache because Rx DMA's writing to physical memory makes it stale. */
  SCB_InvalidateDCache_by_Addr((uint32_t *)buff, Length);
}
 8013b02:	bc30      	pop	{r4, r5}
 8013b04:	4770      	bx	lr
 8013b06:	bf00      	nop
 8013b08:	e000ed00 	.word	0xe000ed00

08013b0c <HAL_ETH_TxFreeCallback>:

void HAL_ETH_TxFreeCallback(uint32_t * buff)
{
 8013b0c:	b508      	push	{r3, lr}
  pbuf_free((struct pbuf *)buff);
 8013b0e:	f7f8 f80f 	bl	800bb30 <pbuf_free>
}
 8013b12:	bd08      	pop	{r3, pc}

08013b14 <http_server_netconn_init>:
  * @brief  Initialize the HTTP server (start its thread)
  * @param  none
  * @retval None
  */
void http_server_netconn_init()
{
 8013b14:	b500      	push	{lr}
 8013b16:	b083      	sub	sp, #12
  sys_thread_new("HTTP", http_server_netconn_thread, NULL, DEFAULT_THREAD_STACKSIZE, WEBSERVER_THREAD_PRIO);
 8013b18:	2301      	movs	r3, #1
 8013b1a:	9300      	str	r3, [sp, #0]
 8013b1c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8013b20:	2200      	movs	r2, #0
 8013b22:	4903      	ldr	r1, [pc, #12]	@ (8013b30 <http_server_netconn_init+0x1c>)
 8013b24:	4803      	ldr	r0, [pc, #12]	@ (8013b34 <http_server_netconn_init+0x20>)
 8013b26:	f7ff fcf9 	bl	801351c <sys_thread_new>
}
 8013b2a:	b003      	add	sp, #12
 8013b2c:	f85d fb04 	ldr.w	pc, [sp], #4
 8013b30:	08013d3d 	.word	0x08013d3d
 8013b34:	08018bb8 	.word	0x08018bb8

08013b38 <DynWebPage>:
  *         running tasks and the number of page hits.
  * @param  conn pointer on connection structure
  * @retval None
  */
void DynWebPage(struct netconn *conn)
{
 8013b38:	b570      	push	{r4, r5, r6, lr}
 8013b3a:	f5ad 7d06 	sub.w	sp, sp, #536	@ 0x218
 8013b3e:	4606      	mov	r6, r0
  portCHAR PAGE_BODY[512];
  portCHAR pagehits[10] = {0};
 8013b40:	2100      	movs	r1, #0
 8013b42:	9103      	str	r1, [sp, #12]
 8013b44:	9104      	str	r1, [sp, #16]
 8013b46:	f8ad 1014 	strh.w	r1, [sp, #20]

  memset(PAGE_BODY, 0,512);
 8013b4a:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8013b4e:	a806      	add	r0, sp, #24
 8013b50:	f000 fbb2 	bl	80142b8 <memset>

  /* Update the hit count */
  nPageHits++;
 8013b54:	4b49      	ldr	r3, [pc, #292]	@ (8013c7c <DynWebPage+0x144>)
 8013b56:	681a      	ldr	r2, [r3, #0]
 8013b58:	3201      	adds	r2, #1
 8013b5a:	601a      	str	r2, [r3, #0]
  sprintf(pagehits, "%d", (int)nPageHits);
 8013b5c:	4948      	ldr	r1, [pc, #288]	@ (8013c80 <DynWebPage+0x148>)
 8013b5e:	a803      	add	r0, sp, #12
 8013b60:	f000 fa86 	bl	8014070 <siprintf>
  strcat(PAGE_BODY, pagehits);
 8013b64:	a903      	add	r1, sp, #12
 8013b66:	a806      	add	r0, sp, #24
 8013b68:	f000 fbae 	bl	80142c8 <strcat>
  strcat((char *)PAGE_BODY, "<pre><br>Name          State  Priority  Stack   Num" );
 8013b6c:	a806      	add	r0, sp, #24
 8013b6e:	f7ec fbb7 	bl	80002e0 <strlen>
 8013b72:	4d44      	ldr	r5, [pc, #272]	@ (8013c84 <DynWebPage+0x14c>)
 8013b74:	ab06      	add	r3, sp, #24
 8013b76:	181c      	adds	r4, r3, r0
 8013b78:	f105 0e30 	add.w	lr, r5, #48	@ 0x30
 8013b7c:	46ac      	mov	ip, r5
 8013b7e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8013b82:	6020      	str	r0, [r4, #0]
 8013b84:	6061      	str	r1, [r4, #4]
 8013b86:	60a2      	str	r2, [r4, #8]
 8013b88:	60e3      	str	r3, [r4, #12]
 8013b8a:	4665      	mov	r5, ip
 8013b8c:	3410      	adds	r4, #16
 8013b8e:	45f4      	cmp	ip, lr
 8013b90:	d1f4      	bne.n	8013b7c <DynWebPage+0x44>
 8013b92:	f8dc 0000 	ldr.w	r0, [ip]
 8013b96:	6020      	str	r0, [r4, #0]
  strcat((char *)PAGE_BODY, "<br>---------------------------------------------<br>");
 8013b98:	a806      	add	r0, sp, #24
 8013b9a:	f7ec fba1 	bl	80002e0 <strlen>
 8013b9e:	4d3a      	ldr	r5, [pc, #232]	@ (8013c88 <DynWebPage+0x150>)
 8013ba0:	ab06      	add	r3, sp, #24
 8013ba2:	181c      	adds	r4, r3, r0
 8013ba4:	f105 0e30 	add.w	lr, r5, #48	@ 0x30
 8013ba8:	46ac      	mov	ip, r5
 8013baa:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8013bae:	6020      	str	r0, [r4, #0]
 8013bb0:	6061      	str	r1, [r4, #4]
 8013bb2:	60a2      	str	r2, [r4, #8]
 8013bb4:	60e3      	str	r3, [r4, #12]
 8013bb6:	4665      	mov	r5, ip
 8013bb8:	3410      	adds	r4, #16
 8013bba:	45f4      	cmp	ip, lr
 8013bbc:	d1f4      	bne.n	8013ba8 <DynWebPage+0x70>
 8013bbe:	f8dc 0000 	ldr.w	r0, [ip]
 8013bc2:	6020      	str	r0, [r4, #0]
 8013bc4:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 8013bc8:	80a3      	strh	r3, [r4, #4]

  /* The list of tasks and their status */
  osThreadList((unsigned char *)(PAGE_BODY + strlen(PAGE_BODY)));
 8013bca:	a806      	add	r0, sp, #24
 8013bcc:	f7ec fb88 	bl	80002e0 <strlen>
 8013bd0:	ab06      	add	r3, sp, #24
 8013bd2:	4418      	add	r0, r3
 8013bd4:	f7f3 fa25 	bl	8007022 <osThreadList>
  strcat((char *)PAGE_BODY, "<br><br>---------------------------------------------");
 8013bd8:	a806      	add	r0, sp, #24
 8013bda:	f7ec fb81 	bl	80002e0 <strlen>
 8013bde:	4d2b      	ldr	r5, [pc, #172]	@ (8013c8c <DynWebPage+0x154>)
 8013be0:	ab06      	add	r3, sp, #24
 8013be2:	181c      	adds	r4, r3, r0
 8013be4:	f105 0e30 	add.w	lr, r5, #48	@ 0x30
 8013be8:	46ac      	mov	ip, r5
 8013bea:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8013bee:	6020      	str	r0, [r4, #0]
 8013bf0:	6061      	str	r1, [r4, #4]
 8013bf2:	60a2      	str	r2, [r4, #8]
 8013bf4:	60e3      	str	r3, [r4, #12]
 8013bf6:	4665      	mov	r5, ip
 8013bf8:	3410      	adds	r4, #16
 8013bfa:	45f4      	cmp	ip, lr
 8013bfc:	d1f4      	bne.n	8013be8 <DynWebPage+0xb0>
 8013bfe:	f8dc 0000 	ldr.w	r0, [ip]
 8013c02:	6020      	str	r0, [r4, #0]
 8013c04:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 8013c08:	80a3      	strh	r3, [r4, #4]
  strcat((char *)PAGE_BODY, "<br>B : Blocked, R : Ready, D : Deleted, S : Suspended<br>");
 8013c0a:	a806      	add	r0, sp, #24
 8013c0c:	f7ec fb68 	bl	80002e0 <strlen>
 8013c10:	4c1f      	ldr	r4, [pc, #124]	@ (8013c90 <DynWebPage+0x158>)
 8013c12:	ab06      	add	r3, sp, #24
 8013c14:	eb03 0c00 	add.w	ip, r3, r0
 8013c18:	f104 0e30 	add.w	lr, r4, #48	@ 0x30
 8013c1c:	4625      	mov	r5, r4
 8013c1e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8013c20:	f8cc 0000 	str.w	r0, [ip]
 8013c24:	f8cc 1004 	str.w	r1, [ip, #4]
 8013c28:	f8cc 2008 	str.w	r2, [ip, #8]
 8013c2c:	f8cc 300c 	str.w	r3, [ip, #12]
 8013c30:	462c      	mov	r4, r5
 8013c32:	f10c 0c10 	add.w	ip, ip, #16
 8013c36:	4575      	cmp	r5, lr
 8013c38:	d1f0      	bne.n	8013c1c <DynWebPage+0xe4>
 8013c3a:	cc03      	ldmia	r4!, {r0, r1}
 8013c3c:	f8cc 0000 	str.w	r0, [ip]
 8013c40:	f8cc 1004 	str.w	r1, [ip, #4]
 8013c44:	8822      	ldrh	r2, [r4, #0]
 8013c46:	78a3      	ldrb	r3, [r4, #2]
 8013c48:	f8ac 2008 	strh.w	r2, [ip, #8]
 8013c4c:	f88c 300a 	strb.w	r3, [ip, #10]

  /* Send the dynamically generated page */
  netconn_write(conn, PAGE_START, strlen((char*)PAGE_START), NETCONN_COPY);
 8013c50:	2400      	movs	r4, #0
 8013c52:	9400      	str	r4, [sp, #0]
 8013c54:	2301      	movs	r3, #1
 8013c56:	f240 4274 	movw	r2, #1140	@ 0x474
 8013c5a:	490e      	ldr	r1, [pc, #56]	@ (8013c94 <DynWebPage+0x15c>)
 8013c5c:	4630      	mov	r0, r6
 8013c5e:	f7f5 fbb1 	bl	80093c4 <netconn_write_partly>
  netconn_write(conn, PAGE_BODY, strlen(PAGE_BODY), NETCONN_COPY);
 8013c62:	a806      	add	r0, sp, #24
 8013c64:	f7ec fb3c 	bl	80002e0 <strlen>
 8013c68:	4602      	mov	r2, r0
 8013c6a:	9400      	str	r4, [sp, #0]
 8013c6c:	2301      	movs	r3, #1
 8013c6e:	a906      	add	r1, sp, #24
 8013c70:	4630      	mov	r0, r6
 8013c72:	f7f5 fba7 	bl	80093c4 <netconn_write_partly>
}
 8013c76:	f50d 7d06 	add.w	sp, sp, #536	@ 0x218
 8013c7a:	bd70      	pop	{r4, r5, r6, pc}
 8013c7c:	24014570 	.word	0x24014570
 8013c80:	08015434 	.word	0x08015434
 8013c84:	08018bc0 	.word	0x08018bc0
 8013c88:	08018bf4 	.word	0x08018bf4
 8013c8c:	08018c2c 	.word	0x08018c2c
 8013c90:	08018c64 	.word	0x08018c64
 8013c94:	080194f4 	.word	0x080194f4

08013c98 <http_server_serve>:
{
 8013c98:	b530      	push	{r4, r5, lr}
 8013c9a:	b087      	sub	sp, #28
 8013c9c:	4604      	mov	r4, r0
  recv_err = netconn_recv(conn, &inbuf);
 8013c9e:	a905      	add	r1, sp, #20
 8013ca0:	f7f5 fcfc 	bl	800969c <netconn_recv>
  if (recv_err == ERR_OK)
 8013ca4:	b138      	cbz	r0, 8013cb6 <http_server_serve+0x1e>
  netconn_close(conn);
 8013ca6:	4620      	mov	r0, r4
 8013ca8:	f7f5 fb99 	bl	80093de <netconn_close>
  netbuf_delete(inbuf);
 8013cac:	9805      	ldr	r0, [sp, #20]
 8013cae:	f7f6 fdc1 	bl	800a834 <netbuf_delete>
}
 8013cb2:	b007      	add	sp, #28
 8013cb4:	bd30      	pop	{r4, r5, pc}
    if (netconn_err(conn) == ERR_OK)
 8013cb6:	4620      	mov	r0, r4
 8013cb8:	f7f5 fb96 	bl	80093e8 <netconn_err>
 8013cbc:	2800      	cmp	r0, #0
 8013cbe:	d1f2      	bne.n	8013ca6 <http_server_serve+0xe>
      netbuf_data(inbuf, (void**)&buf, &buflen);
 8013cc0:	f10d 020e 	add.w	r2, sp, #14
 8013cc4:	a904      	add	r1, sp, #16
 8013cc6:	9805      	ldr	r0, [sp, #20]
 8013cc8:	f7f6 fdc4 	bl	800a854 <netbuf_data>
      if ((buflen >=5) && (strncmp(buf, "GET /", 5) == 0))
 8013ccc:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8013cd0:	2b04      	cmp	r3, #4
 8013cd2:	d9e8      	bls.n	8013ca6 <http_server_serve+0xe>
 8013cd4:	9d04      	ldr	r5, [sp, #16]
 8013cd6:	2205      	movs	r2, #5
 8013cd8:	4913      	ldr	r1, [pc, #76]	@ (8013d28 <http_server_serve+0x90>)
 8013cda:	4628      	mov	r0, r5
 8013cdc:	f000 fb03 	bl	80142e6 <strncmp>
 8013ce0:	2800      	cmp	r0, #0
 8013ce2:	d1e0      	bne.n	8013ca6 <http_server_serve+0xe>
        if(strncmp(buf, "GET / ", 6) == 0)
 8013ce4:	2206      	movs	r2, #6
 8013ce6:	4911      	ldr	r1, [pc, #68]	@ (8013d2c <http_server_serve+0x94>)
 8013ce8:	4628      	mov	r0, r5
 8013cea:	f000 fafc 	bl	80142e6 <strncmp>
 8013cee:	b170      	cbz	r0, 8013d0e <http_server_serve+0x76>
        else if((strncmp(buf, "GET /upnp/logw.xml", 18) == 0))
 8013cf0:	2212      	movs	r2, #18
 8013cf2:	490f      	ldr	r1, [pc, #60]	@ (8013d30 <http_server_serve+0x98>)
 8013cf4:	4628      	mov	r0, r5
 8013cf6:	f000 faf6 	bl	80142e6 <strncmp>
 8013cfa:	b960      	cbnz	r0, 8013d16 <http_server_serve+0x7e>
          netconn_write(conn, xmlInfo, sizeof(xmlInfo)-1, NETCONN_NOCOPY);
 8013cfc:	2300      	movs	r3, #0
 8013cfe:	9300      	str	r3, [sp, #0]
 8013d00:	f240 32b7 	movw	r2, #951	@ 0x3b7
 8013d04:	490b      	ldr	r1, [pc, #44]	@ (8013d34 <http_server_serve+0x9c>)
 8013d06:	4620      	mov	r0, r4
 8013d08:	f7f5 fb5c 	bl	80093c4 <netconn_write_partly>
 8013d0c:	e7cb      	b.n	8013ca6 <http_server_serve+0xe>
           DynWebPage(conn);
 8013d0e:	4620      	mov	r0, r4
 8013d10:	f7ff ff12 	bl	8013b38 <DynWebPage>
 8013d14:	e7c7      	b.n	8013ca6 <http_server_serve+0xe>
          netconn_write(conn, notFound_str, sizeof(notFound_str)-1, NETCONN_NOCOPY);
 8013d16:	2300      	movs	r3, #0
 8013d18:	9300      	str	r3, [sp, #0]
 8013d1a:	f240 1249 	movw	r2, #329	@ 0x149
 8013d1e:	4906      	ldr	r1, [pc, #24]	@ (8013d38 <http_server_serve+0xa0>)
 8013d20:	4620      	mov	r0, r4
 8013d22:	f7f5 fb4f 	bl	80093c4 <netconn_write_partly>
 8013d26:	e7be      	b.n	8013ca6 <http_server_serve+0xe>
 8013d28:	08018ca0 	.word	0x08018ca0
 8013d2c:	08018ca8 	.word	0x08018ca8
 8013d30:	08018cb0 	.word	0x08018cb0
 8013d34:	0801913c 	.word	0x0801913c
 8013d38:	08018ff0 	.word	0x08018ff0

08013d3c <http_server_netconn_thread>:
{
 8013d3c:	b510      	push	{r4, lr}
 8013d3e:	b082      	sub	sp, #8
  httpConn = netconn_new(NETCONN_TCP);
 8013d40:	2200      	movs	r2, #0
 8013d42:	4611      	mov	r1, r2
 8013d44:	2010      	movs	r0, #16
 8013d46:	f7f5 f9ff 	bl	8009148 <netconn_new_with_proto_and_callback>
  if (httpConn!= NULL)
 8013d4a:	b130      	cbz	r0, 8013d5a <http_server_netconn_thread+0x1e>
 8013d4c:	4604      	mov	r4, r0
    err = netconn_bind(httpConn, NULL, PORT_TCP_UPNPINFO);
 8013d4e:	f241 22ea 	movw	r2, #4842	@ 0x12ea
 8013d52:	2100      	movs	r1, #0
 8013d54:	f7f5 fa76 	bl	8009244 <netconn_bind>
    if (err == ERR_OK)
 8013d58:	b108      	cbz	r0, 8013d5e <http_server_netconn_thread+0x22>
}
 8013d5a:	b002      	add	sp, #8
 8013d5c:	bd10      	pop	{r4, pc}
      netconn_listen(httpConn);
 8013d5e:	21ff      	movs	r1, #255	@ 0xff
 8013d60:	4620      	mov	r0, r4
 8013d62:	f7f5 fa95 	bl	8009290 <netconn_listen_with_backlog>
        accept_err = netconn_accept(httpConn, &newconn);
 8013d66:	a901      	add	r1, sp, #4
 8013d68:	4620      	mov	r0, r4
 8013d6a:	f7f5 fb4d 	bl	8009408 <netconn_accept>
        if(accept_err == ERR_OK)
 8013d6e:	2800      	cmp	r0, #0
 8013d70:	d1f9      	bne.n	8013d66 <http_server_netconn_thread+0x2a>
          http_server_serve(newconn);
 8013d72:	9801      	ldr	r0, [sp, #4]
 8013d74:	f7ff ff90 	bl	8013c98 <http_server_serve>
          netconn_delete(newconn);
 8013d78:	9801      	ldr	r0, [sp, #4]
 8013d7a:	f7f5 fa53 	bl	8009224 <netconn_delete>
 8013d7e:	e7f2      	b.n	8013d66 <http_server_netconn_thread+0x2a>

08013d80 <rand>:
 8013d80:	4b16      	ldr	r3, [pc, #88]	@ (8013ddc <rand+0x5c>)
 8013d82:	b510      	push	{r4, lr}
 8013d84:	681c      	ldr	r4, [r3, #0]
 8013d86:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 8013d88:	b9b3      	cbnz	r3, 8013db8 <rand+0x38>
 8013d8a:	2018      	movs	r0, #24
 8013d8c:	f000 fbb0 	bl	80144f0 <malloc>
 8013d90:	4602      	mov	r2, r0
 8013d92:	6320      	str	r0, [r4, #48]	@ 0x30
 8013d94:	b920      	cbnz	r0, 8013da0 <rand+0x20>
 8013d96:	4b12      	ldr	r3, [pc, #72]	@ (8013de0 <rand+0x60>)
 8013d98:	4812      	ldr	r0, [pc, #72]	@ (8013de4 <rand+0x64>)
 8013d9a:	2152      	movs	r1, #82	@ 0x52
 8013d9c:	f000 fb40 	bl	8014420 <__assert_func>
 8013da0:	4911      	ldr	r1, [pc, #68]	@ (8013de8 <rand+0x68>)
 8013da2:	4b12      	ldr	r3, [pc, #72]	@ (8013dec <rand+0x6c>)
 8013da4:	e9c0 1300 	strd	r1, r3, [r0]
 8013da8:	4b11      	ldr	r3, [pc, #68]	@ (8013df0 <rand+0x70>)
 8013daa:	6083      	str	r3, [r0, #8]
 8013dac:	230b      	movs	r3, #11
 8013dae:	8183      	strh	r3, [r0, #12]
 8013db0:	2100      	movs	r1, #0
 8013db2:	2001      	movs	r0, #1
 8013db4:	e9c2 0104 	strd	r0, r1, [r2, #16]
 8013db8:	6b21      	ldr	r1, [r4, #48]	@ 0x30
 8013dba:	480e      	ldr	r0, [pc, #56]	@ (8013df4 <rand+0x74>)
 8013dbc:	690b      	ldr	r3, [r1, #16]
 8013dbe:	694c      	ldr	r4, [r1, #20]
 8013dc0:	4a0d      	ldr	r2, [pc, #52]	@ (8013df8 <rand+0x78>)
 8013dc2:	4358      	muls	r0, r3
 8013dc4:	fb02 0004 	mla	r0, r2, r4, r0
 8013dc8:	fba3 3202 	umull	r3, r2, r3, r2
 8013dcc:	3301      	adds	r3, #1
 8013dce:	eb40 0002 	adc.w	r0, r0, r2
 8013dd2:	e9c1 3004 	strd	r3, r0, [r1, #16]
 8013dd6:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
 8013dda:	bd10      	pop	{r4, pc}
 8013ddc:	2400003c 	.word	0x2400003c
 8013de0:	08019969 	.word	0x08019969
 8013de4:	08019980 	.word	0x08019980
 8013de8:	abcd330e 	.word	0xabcd330e
 8013dec:	e66d1234 	.word	0xe66d1234
 8013df0:	0005deec 	.word	0x0005deec
 8013df4:	5851f42d 	.word	0x5851f42d
 8013df8:	4c957f2d 	.word	0x4c957f2d

08013dfc <std>:
 8013dfc:	2300      	movs	r3, #0
 8013dfe:	b510      	push	{r4, lr}
 8013e00:	4604      	mov	r4, r0
 8013e02:	e9c0 3300 	strd	r3, r3, [r0]
 8013e06:	e9c0 3304 	strd	r3, r3, [r0, #16]
 8013e0a:	6083      	str	r3, [r0, #8]
 8013e0c:	8181      	strh	r1, [r0, #12]
 8013e0e:	6643      	str	r3, [r0, #100]	@ 0x64
 8013e10:	81c2      	strh	r2, [r0, #14]
 8013e12:	6183      	str	r3, [r0, #24]
 8013e14:	4619      	mov	r1, r3
 8013e16:	2208      	movs	r2, #8
 8013e18:	305c      	adds	r0, #92	@ 0x5c
 8013e1a:	f000 fa4d 	bl	80142b8 <memset>
 8013e1e:	4b0d      	ldr	r3, [pc, #52]	@ (8013e54 <std+0x58>)
 8013e20:	6263      	str	r3, [r4, #36]	@ 0x24
 8013e22:	4b0d      	ldr	r3, [pc, #52]	@ (8013e58 <std+0x5c>)
 8013e24:	62a3      	str	r3, [r4, #40]	@ 0x28
 8013e26:	4b0d      	ldr	r3, [pc, #52]	@ (8013e5c <std+0x60>)
 8013e28:	62e3      	str	r3, [r4, #44]	@ 0x2c
 8013e2a:	4b0d      	ldr	r3, [pc, #52]	@ (8013e60 <std+0x64>)
 8013e2c:	6323      	str	r3, [r4, #48]	@ 0x30
 8013e2e:	4b0d      	ldr	r3, [pc, #52]	@ (8013e64 <std+0x68>)
 8013e30:	6224      	str	r4, [r4, #32]
 8013e32:	429c      	cmp	r4, r3
 8013e34:	d006      	beq.n	8013e44 <std+0x48>
 8013e36:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 8013e3a:	4294      	cmp	r4, r2
 8013e3c:	d002      	beq.n	8013e44 <std+0x48>
 8013e3e:	33d0      	adds	r3, #208	@ 0xd0
 8013e40:	429c      	cmp	r4, r3
 8013e42:	d105      	bne.n	8013e50 <std+0x54>
 8013e44:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 8013e48:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8013e4c:	f000 bace 	b.w	80143ec <__retarget_lock_init_recursive>
 8013e50:	bd10      	pop	{r4, pc}
 8013e52:	bf00      	nop
 8013e54:	080140b5 	.word	0x080140b5
 8013e58:	080140d7 	.word	0x080140d7
 8013e5c:	0801410f 	.word	0x0801410f
 8013e60:	08014133 	.word	0x08014133
 8013e64:	24014574 	.word	0x24014574

08013e68 <stdio_exit_handler>:
 8013e68:	4a02      	ldr	r2, [pc, #8]	@ (8013e74 <stdio_exit_handler+0xc>)
 8013e6a:	4903      	ldr	r1, [pc, #12]	@ (8013e78 <stdio_exit_handler+0x10>)
 8013e6c:	4803      	ldr	r0, [pc, #12]	@ (8013e7c <stdio_exit_handler+0x14>)
 8013e6e:	f000 b869 	b.w	8013f44 <_fwalk_sglue>
 8013e72:	bf00      	nop
 8013e74:	24000030 	.word	0x24000030
 8013e78:	08014fb1 	.word	0x08014fb1
 8013e7c:	24000040 	.word	0x24000040

08013e80 <cleanup_stdio>:
 8013e80:	6841      	ldr	r1, [r0, #4]
 8013e82:	4b0c      	ldr	r3, [pc, #48]	@ (8013eb4 <cleanup_stdio+0x34>)
 8013e84:	4299      	cmp	r1, r3
 8013e86:	b510      	push	{r4, lr}
 8013e88:	4604      	mov	r4, r0
 8013e8a:	d001      	beq.n	8013e90 <cleanup_stdio+0x10>
 8013e8c:	f001 f890 	bl	8014fb0 <_fflush_r>
 8013e90:	68a1      	ldr	r1, [r4, #8]
 8013e92:	4b09      	ldr	r3, [pc, #36]	@ (8013eb8 <cleanup_stdio+0x38>)
 8013e94:	4299      	cmp	r1, r3
 8013e96:	d002      	beq.n	8013e9e <cleanup_stdio+0x1e>
 8013e98:	4620      	mov	r0, r4
 8013e9a:	f001 f889 	bl	8014fb0 <_fflush_r>
 8013e9e:	68e1      	ldr	r1, [r4, #12]
 8013ea0:	4b06      	ldr	r3, [pc, #24]	@ (8013ebc <cleanup_stdio+0x3c>)
 8013ea2:	4299      	cmp	r1, r3
 8013ea4:	d004      	beq.n	8013eb0 <cleanup_stdio+0x30>
 8013ea6:	4620      	mov	r0, r4
 8013ea8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8013eac:	f001 b880 	b.w	8014fb0 <_fflush_r>
 8013eb0:	bd10      	pop	{r4, pc}
 8013eb2:	bf00      	nop
 8013eb4:	24014574 	.word	0x24014574
 8013eb8:	240145dc 	.word	0x240145dc
 8013ebc:	24014644 	.word	0x24014644

08013ec0 <global_stdio_init.part.0>:
 8013ec0:	b510      	push	{r4, lr}
 8013ec2:	4b0b      	ldr	r3, [pc, #44]	@ (8013ef0 <global_stdio_init.part.0+0x30>)
 8013ec4:	4c0b      	ldr	r4, [pc, #44]	@ (8013ef4 <global_stdio_init.part.0+0x34>)
 8013ec6:	4a0c      	ldr	r2, [pc, #48]	@ (8013ef8 <global_stdio_init.part.0+0x38>)
 8013ec8:	601a      	str	r2, [r3, #0]
 8013eca:	4620      	mov	r0, r4
 8013ecc:	2200      	movs	r2, #0
 8013ece:	2104      	movs	r1, #4
 8013ed0:	f7ff ff94 	bl	8013dfc <std>
 8013ed4:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 8013ed8:	2201      	movs	r2, #1
 8013eda:	2109      	movs	r1, #9
 8013edc:	f7ff ff8e 	bl	8013dfc <std>
 8013ee0:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
 8013ee4:	2202      	movs	r2, #2
 8013ee6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8013eea:	2112      	movs	r1, #18
 8013eec:	f7ff bf86 	b.w	8013dfc <std>
 8013ef0:	240146ac 	.word	0x240146ac
 8013ef4:	24014574 	.word	0x24014574
 8013ef8:	08013e69 	.word	0x08013e69

08013efc <__sfp_lock_acquire>:
 8013efc:	4801      	ldr	r0, [pc, #4]	@ (8013f04 <__sfp_lock_acquire+0x8>)
 8013efe:	f000 ba76 	b.w	80143ee <__retarget_lock_acquire_recursive>
 8013f02:	bf00      	nop
 8013f04:	240146b1 	.word	0x240146b1

08013f08 <__sfp_lock_release>:
 8013f08:	4801      	ldr	r0, [pc, #4]	@ (8013f10 <__sfp_lock_release+0x8>)
 8013f0a:	f000 ba71 	b.w	80143f0 <__retarget_lock_release_recursive>
 8013f0e:	bf00      	nop
 8013f10:	240146b1 	.word	0x240146b1

08013f14 <__sinit>:
 8013f14:	b510      	push	{r4, lr}
 8013f16:	4604      	mov	r4, r0
 8013f18:	f7ff fff0 	bl	8013efc <__sfp_lock_acquire>
 8013f1c:	6a23      	ldr	r3, [r4, #32]
 8013f1e:	b11b      	cbz	r3, 8013f28 <__sinit+0x14>
 8013f20:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8013f24:	f7ff bff0 	b.w	8013f08 <__sfp_lock_release>
 8013f28:	4b04      	ldr	r3, [pc, #16]	@ (8013f3c <__sinit+0x28>)
 8013f2a:	6223      	str	r3, [r4, #32]
 8013f2c:	4b04      	ldr	r3, [pc, #16]	@ (8013f40 <__sinit+0x2c>)
 8013f2e:	681b      	ldr	r3, [r3, #0]
 8013f30:	2b00      	cmp	r3, #0
 8013f32:	d1f5      	bne.n	8013f20 <__sinit+0xc>
 8013f34:	f7ff ffc4 	bl	8013ec0 <global_stdio_init.part.0>
 8013f38:	e7f2      	b.n	8013f20 <__sinit+0xc>
 8013f3a:	bf00      	nop
 8013f3c:	08013e81 	.word	0x08013e81
 8013f40:	240146ac 	.word	0x240146ac

08013f44 <_fwalk_sglue>:
 8013f44:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8013f48:	4607      	mov	r7, r0
 8013f4a:	4688      	mov	r8, r1
 8013f4c:	4614      	mov	r4, r2
 8013f4e:	2600      	movs	r6, #0
 8013f50:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 8013f54:	f1b9 0901 	subs.w	r9, r9, #1
 8013f58:	d505      	bpl.n	8013f66 <_fwalk_sglue+0x22>
 8013f5a:	6824      	ldr	r4, [r4, #0]
 8013f5c:	2c00      	cmp	r4, #0
 8013f5e:	d1f7      	bne.n	8013f50 <_fwalk_sglue+0xc>
 8013f60:	4630      	mov	r0, r6
 8013f62:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8013f66:	89ab      	ldrh	r3, [r5, #12]
 8013f68:	2b01      	cmp	r3, #1
 8013f6a:	d907      	bls.n	8013f7c <_fwalk_sglue+0x38>
 8013f6c:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8013f70:	3301      	adds	r3, #1
 8013f72:	d003      	beq.n	8013f7c <_fwalk_sglue+0x38>
 8013f74:	4629      	mov	r1, r5
 8013f76:	4638      	mov	r0, r7
 8013f78:	47c0      	blx	r8
 8013f7a:	4306      	orrs	r6, r0
 8013f7c:	3568      	adds	r5, #104	@ 0x68
 8013f7e:	e7e9      	b.n	8013f54 <_fwalk_sglue+0x10>

08013f80 <iprintf>:
 8013f80:	b40f      	push	{r0, r1, r2, r3}
 8013f82:	b507      	push	{r0, r1, r2, lr}
 8013f84:	4906      	ldr	r1, [pc, #24]	@ (8013fa0 <iprintf+0x20>)
 8013f86:	ab04      	add	r3, sp, #16
 8013f88:	6808      	ldr	r0, [r1, #0]
 8013f8a:	f853 2b04 	ldr.w	r2, [r3], #4
 8013f8e:	6881      	ldr	r1, [r0, #8]
 8013f90:	9301      	str	r3, [sp, #4]
 8013f92:	f000 fce5 	bl	8014960 <_vfiprintf_r>
 8013f96:	b003      	add	sp, #12
 8013f98:	f85d eb04 	ldr.w	lr, [sp], #4
 8013f9c:	b004      	add	sp, #16
 8013f9e:	4770      	bx	lr
 8013fa0:	2400003c 	.word	0x2400003c

08013fa4 <putchar>:
 8013fa4:	4b02      	ldr	r3, [pc, #8]	@ (8013fb0 <putchar+0xc>)
 8013fa6:	4601      	mov	r1, r0
 8013fa8:	6818      	ldr	r0, [r3, #0]
 8013faa:	6882      	ldr	r2, [r0, #8]
 8013fac:	f001 b89c 	b.w	80150e8 <_putc_r>
 8013fb0:	2400003c 	.word	0x2400003c

08013fb4 <_puts_r>:
 8013fb4:	6a03      	ldr	r3, [r0, #32]
 8013fb6:	b570      	push	{r4, r5, r6, lr}
 8013fb8:	6884      	ldr	r4, [r0, #8]
 8013fba:	4605      	mov	r5, r0
 8013fbc:	460e      	mov	r6, r1
 8013fbe:	b90b      	cbnz	r3, 8013fc4 <_puts_r+0x10>
 8013fc0:	f7ff ffa8 	bl	8013f14 <__sinit>
 8013fc4:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8013fc6:	07db      	lsls	r3, r3, #31
 8013fc8:	d405      	bmi.n	8013fd6 <_puts_r+0x22>
 8013fca:	89a3      	ldrh	r3, [r4, #12]
 8013fcc:	0598      	lsls	r0, r3, #22
 8013fce:	d402      	bmi.n	8013fd6 <_puts_r+0x22>
 8013fd0:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8013fd2:	f000 fa0c 	bl	80143ee <__retarget_lock_acquire_recursive>
 8013fd6:	89a3      	ldrh	r3, [r4, #12]
 8013fd8:	0719      	lsls	r1, r3, #28
 8013fda:	d502      	bpl.n	8013fe2 <_puts_r+0x2e>
 8013fdc:	6923      	ldr	r3, [r4, #16]
 8013fde:	2b00      	cmp	r3, #0
 8013fe0:	d135      	bne.n	801404e <_puts_r+0x9a>
 8013fe2:	4621      	mov	r1, r4
 8013fe4:	4628      	mov	r0, r5
 8013fe6:	f000 f8e7 	bl	80141b8 <__swsetup_r>
 8013fea:	b380      	cbz	r0, 801404e <_puts_r+0x9a>
 8013fec:	f04f 35ff 	mov.w	r5, #4294967295
 8013ff0:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8013ff2:	07da      	lsls	r2, r3, #31
 8013ff4:	d405      	bmi.n	8014002 <_puts_r+0x4e>
 8013ff6:	89a3      	ldrh	r3, [r4, #12]
 8013ff8:	059b      	lsls	r3, r3, #22
 8013ffa:	d402      	bmi.n	8014002 <_puts_r+0x4e>
 8013ffc:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8013ffe:	f000 f9f7 	bl	80143f0 <__retarget_lock_release_recursive>
 8014002:	4628      	mov	r0, r5
 8014004:	bd70      	pop	{r4, r5, r6, pc}
 8014006:	2b00      	cmp	r3, #0
 8014008:	da04      	bge.n	8014014 <_puts_r+0x60>
 801400a:	69a2      	ldr	r2, [r4, #24]
 801400c:	429a      	cmp	r2, r3
 801400e:	dc17      	bgt.n	8014040 <_puts_r+0x8c>
 8014010:	290a      	cmp	r1, #10
 8014012:	d015      	beq.n	8014040 <_puts_r+0x8c>
 8014014:	6823      	ldr	r3, [r4, #0]
 8014016:	1c5a      	adds	r2, r3, #1
 8014018:	6022      	str	r2, [r4, #0]
 801401a:	7019      	strb	r1, [r3, #0]
 801401c:	68a3      	ldr	r3, [r4, #8]
 801401e:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8014022:	3b01      	subs	r3, #1
 8014024:	60a3      	str	r3, [r4, #8]
 8014026:	2900      	cmp	r1, #0
 8014028:	d1ed      	bne.n	8014006 <_puts_r+0x52>
 801402a:	2b00      	cmp	r3, #0
 801402c:	da11      	bge.n	8014052 <_puts_r+0x9e>
 801402e:	4622      	mov	r2, r4
 8014030:	210a      	movs	r1, #10
 8014032:	4628      	mov	r0, r5
 8014034:	f000 f881 	bl	801413a <__swbuf_r>
 8014038:	3001      	adds	r0, #1
 801403a:	d0d7      	beq.n	8013fec <_puts_r+0x38>
 801403c:	250a      	movs	r5, #10
 801403e:	e7d7      	b.n	8013ff0 <_puts_r+0x3c>
 8014040:	4622      	mov	r2, r4
 8014042:	4628      	mov	r0, r5
 8014044:	f000 f879 	bl	801413a <__swbuf_r>
 8014048:	3001      	adds	r0, #1
 801404a:	d1e7      	bne.n	801401c <_puts_r+0x68>
 801404c:	e7ce      	b.n	8013fec <_puts_r+0x38>
 801404e:	3e01      	subs	r6, #1
 8014050:	e7e4      	b.n	801401c <_puts_r+0x68>
 8014052:	6823      	ldr	r3, [r4, #0]
 8014054:	1c5a      	adds	r2, r3, #1
 8014056:	6022      	str	r2, [r4, #0]
 8014058:	220a      	movs	r2, #10
 801405a:	701a      	strb	r2, [r3, #0]
 801405c:	e7ee      	b.n	801403c <_puts_r+0x88>
	...

08014060 <puts>:
 8014060:	4b02      	ldr	r3, [pc, #8]	@ (801406c <puts+0xc>)
 8014062:	4601      	mov	r1, r0
 8014064:	6818      	ldr	r0, [r3, #0]
 8014066:	f7ff bfa5 	b.w	8013fb4 <_puts_r>
 801406a:	bf00      	nop
 801406c:	2400003c 	.word	0x2400003c

08014070 <siprintf>:
 8014070:	b40e      	push	{r1, r2, r3}
 8014072:	b510      	push	{r4, lr}
 8014074:	b09d      	sub	sp, #116	@ 0x74
 8014076:	ab1f      	add	r3, sp, #124	@ 0x7c
 8014078:	9002      	str	r0, [sp, #8]
 801407a:	9006      	str	r0, [sp, #24]
 801407c:	f06f 4100 	mvn.w	r1, #2147483648	@ 0x80000000
 8014080:	480a      	ldr	r0, [pc, #40]	@ (80140ac <siprintf+0x3c>)
 8014082:	9107      	str	r1, [sp, #28]
 8014084:	9104      	str	r1, [sp, #16]
 8014086:	490a      	ldr	r1, [pc, #40]	@ (80140b0 <siprintf+0x40>)
 8014088:	f853 2b04 	ldr.w	r2, [r3], #4
 801408c:	9105      	str	r1, [sp, #20]
 801408e:	2400      	movs	r4, #0
 8014090:	a902      	add	r1, sp, #8
 8014092:	6800      	ldr	r0, [r0, #0]
 8014094:	9301      	str	r3, [sp, #4]
 8014096:	941b      	str	r4, [sp, #108]	@ 0x6c
 8014098:	f000 fb3c 	bl	8014714 <_svfiprintf_r>
 801409c:	9b02      	ldr	r3, [sp, #8]
 801409e:	701c      	strb	r4, [r3, #0]
 80140a0:	b01d      	add	sp, #116	@ 0x74
 80140a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80140a6:	b003      	add	sp, #12
 80140a8:	4770      	bx	lr
 80140aa:	bf00      	nop
 80140ac:	2400003c 	.word	0x2400003c
 80140b0:	ffff0208 	.word	0xffff0208

080140b4 <__sread>:
 80140b4:	b510      	push	{r4, lr}
 80140b6:	460c      	mov	r4, r1
 80140b8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80140bc:	f000 f948 	bl	8014350 <_read_r>
 80140c0:	2800      	cmp	r0, #0
 80140c2:	bfab      	itete	ge
 80140c4:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 80140c6:	89a3      	ldrhlt	r3, [r4, #12]
 80140c8:	181b      	addge	r3, r3, r0
 80140ca:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 80140ce:	bfac      	ite	ge
 80140d0:	6563      	strge	r3, [r4, #84]	@ 0x54
 80140d2:	81a3      	strhlt	r3, [r4, #12]
 80140d4:	bd10      	pop	{r4, pc}

080140d6 <__swrite>:
 80140d6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80140da:	461f      	mov	r7, r3
 80140dc:	898b      	ldrh	r3, [r1, #12]
 80140de:	05db      	lsls	r3, r3, #23
 80140e0:	4605      	mov	r5, r0
 80140e2:	460c      	mov	r4, r1
 80140e4:	4616      	mov	r6, r2
 80140e6:	d505      	bpl.n	80140f4 <__swrite+0x1e>
 80140e8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80140ec:	2302      	movs	r3, #2
 80140ee:	2200      	movs	r2, #0
 80140f0:	f000 f91c 	bl	801432c <_lseek_r>
 80140f4:	89a3      	ldrh	r3, [r4, #12]
 80140f6:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80140fa:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 80140fe:	81a3      	strh	r3, [r4, #12]
 8014100:	4632      	mov	r2, r6
 8014102:	463b      	mov	r3, r7
 8014104:	4628      	mov	r0, r5
 8014106:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 801410a:	f000 b933 	b.w	8014374 <_write_r>

0801410e <__sseek>:
 801410e:	b510      	push	{r4, lr}
 8014110:	460c      	mov	r4, r1
 8014112:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8014116:	f000 f909 	bl	801432c <_lseek_r>
 801411a:	1c43      	adds	r3, r0, #1
 801411c:	89a3      	ldrh	r3, [r4, #12]
 801411e:	bf15      	itete	ne
 8014120:	6560      	strne	r0, [r4, #84]	@ 0x54
 8014122:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 8014126:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 801412a:	81a3      	strheq	r3, [r4, #12]
 801412c:	bf18      	it	ne
 801412e:	81a3      	strhne	r3, [r4, #12]
 8014130:	bd10      	pop	{r4, pc}

08014132 <__sclose>:
 8014132:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8014136:	f000 b8e9 	b.w	801430c <_close_r>

0801413a <__swbuf_r>:
 801413a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801413c:	460e      	mov	r6, r1
 801413e:	4614      	mov	r4, r2
 8014140:	4605      	mov	r5, r0
 8014142:	b118      	cbz	r0, 801414c <__swbuf_r+0x12>
 8014144:	6a03      	ldr	r3, [r0, #32]
 8014146:	b90b      	cbnz	r3, 801414c <__swbuf_r+0x12>
 8014148:	f7ff fee4 	bl	8013f14 <__sinit>
 801414c:	69a3      	ldr	r3, [r4, #24]
 801414e:	60a3      	str	r3, [r4, #8]
 8014150:	89a3      	ldrh	r3, [r4, #12]
 8014152:	071a      	lsls	r2, r3, #28
 8014154:	d501      	bpl.n	801415a <__swbuf_r+0x20>
 8014156:	6923      	ldr	r3, [r4, #16]
 8014158:	b943      	cbnz	r3, 801416c <__swbuf_r+0x32>
 801415a:	4621      	mov	r1, r4
 801415c:	4628      	mov	r0, r5
 801415e:	f000 f82b 	bl	80141b8 <__swsetup_r>
 8014162:	b118      	cbz	r0, 801416c <__swbuf_r+0x32>
 8014164:	f04f 37ff 	mov.w	r7, #4294967295
 8014168:	4638      	mov	r0, r7
 801416a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801416c:	6823      	ldr	r3, [r4, #0]
 801416e:	6922      	ldr	r2, [r4, #16]
 8014170:	1a98      	subs	r0, r3, r2
 8014172:	6963      	ldr	r3, [r4, #20]
 8014174:	b2f6      	uxtb	r6, r6
 8014176:	4283      	cmp	r3, r0
 8014178:	4637      	mov	r7, r6
 801417a:	dc05      	bgt.n	8014188 <__swbuf_r+0x4e>
 801417c:	4621      	mov	r1, r4
 801417e:	4628      	mov	r0, r5
 8014180:	f000 ff16 	bl	8014fb0 <_fflush_r>
 8014184:	2800      	cmp	r0, #0
 8014186:	d1ed      	bne.n	8014164 <__swbuf_r+0x2a>
 8014188:	68a3      	ldr	r3, [r4, #8]
 801418a:	3b01      	subs	r3, #1
 801418c:	60a3      	str	r3, [r4, #8]
 801418e:	6823      	ldr	r3, [r4, #0]
 8014190:	1c5a      	adds	r2, r3, #1
 8014192:	6022      	str	r2, [r4, #0]
 8014194:	701e      	strb	r6, [r3, #0]
 8014196:	6962      	ldr	r2, [r4, #20]
 8014198:	1c43      	adds	r3, r0, #1
 801419a:	429a      	cmp	r2, r3
 801419c:	d004      	beq.n	80141a8 <__swbuf_r+0x6e>
 801419e:	89a3      	ldrh	r3, [r4, #12]
 80141a0:	07db      	lsls	r3, r3, #31
 80141a2:	d5e1      	bpl.n	8014168 <__swbuf_r+0x2e>
 80141a4:	2e0a      	cmp	r6, #10
 80141a6:	d1df      	bne.n	8014168 <__swbuf_r+0x2e>
 80141a8:	4621      	mov	r1, r4
 80141aa:	4628      	mov	r0, r5
 80141ac:	f000 ff00 	bl	8014fb0 <_fflush_r>
 80141b0:	2800      	cmp	r0, #0
 80141b2:	d0d9      	beq.n	8014168 <__swbuf_r+0x2e>
 80141b4:	e7d6      	b.n	8014164 <__swbuf_r+0x2a>
	...

080141b8 <__swsetup_r>:
 80141b8:	b538      	push	{r3, r4, r5, lr}
 80141ba:	4b29      	ldr	r3, [pc, #164]	@ (8014260 <__swsetup_r+0xa8>)
 80141bc:	4605      	mov	r5, r0
 80141be:	6818      	ldr	r0, [r3, #0]
 80141c0:	460c      	mov	r4, r1
 80141c2:	b118      	cbz	r0, 80141cc <__swsetup_r+0x14>
 80141c4:	6a03      	ldr	r3, [r0, #32]
 80141c6:	b90b      	cbnz	r3, 80141cc <__swsetup_r+0x14>
 80141c8:	f7ff fea4 	bl	8013f14 <__sinit>
 80141cc:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80141d0:	0719      	lsls	r1, r3, #28
 80141d2:	d422      	bmi.n	801421a <__swsetup_r+0x62>
 80141d4:	06da      	lsls	r2, r3, #27
 80141d6:	d407      	bmi.n	80141e8 <__swsetup_r+0x30>
 80141d8:	2209      	movs	r2, #9
 80141da:	602a      	str	r2, [r5, #0]
 80141dc:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 80141e0:	81a3      	strh	r3, [r4, #12]
 80141e2:	f04f 30ff 	mov.w	r0, #4294967295
 80141e6:	e033      	b.n	8014250 <__swsetup_r+0x98>
 80141e8:	0758      	lsls	r0, r3, #29
 80141ea:	d512      	bpl.n	8014212 <__swsetup_r+0x5a>
 80141ec:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 80141ee:	b141      	cbz	r1, 8014202 <__swsetup_r+0x4a>
 80141f0:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 80141f4:	4299      	cmp	r1, r3
 80141f6:	d002      	beq.n	80141fe <__swsetup_r+0x46>
 80141f8:	4628      	mov	r0, r5
 80141fa:	f000 f92f 	bl	801445c <_free_r>
 80141fe:	2300      	movs	r3, #0
 8014200:	6363      	str	r3, [r4, #52]	@ 0x34
 8014202:	89a3      	ldrh	r3, [r4, #12]
 8014204:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 8014208:	81a3      	strh	r3, [r4, #12]
 801420a:	2300      	movs	r3, #0
 801420c:	6063      	str	r3, [r4, #4]
 801420e:	6923      	ldr	r3, [r4, #16]
 8014210:	6023      	str	r3, [r4, #0]
 8014212:	89a3      	ldrh	r3, [r4, #12]
 8014214:	f043 0308 	orr.w	r3, r3, #8
 8014218:	81a3      	strh	r3, [r4, #12]
 801421a:	6923      	ldr	r3, [r4, #16]
 801421c:	b94b      	cbnz	r3, 8014232 <__swsetup_r+0x7a>
 801421e:	89a3      	ldrh	r3, [r4, #12]
 8014220:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 8014224:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8014228:	d003      	beq.n	8014232 <__swsetup_r+0x7a>
 801422a:	4621      	mov	r1, r4
 801422c:	4628      	mov	r0, r5
 801422e:	f000 ff1f 	bl	8015070 <__smakebuf_r>
 8014232:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8014236:	f013 0201 	ands.w	r2, r3, #1
 801423a:	d00a      	beq.n	8014252 <__swsetup_r+0x9a>
 801423c:	2200      	movs	r2, #0
 801423e:	60a2      	str	r2, [r4, #8]
 8014240:	6962      	ldr	r2, [r4, #20]
 8014242:	4252      	negs	r2, r2
 8014244:	61a2      	str	r2, [r4, #24]
 8014246:	6922      	ldr	r2, [r4, #16]
 8014248:	b942      	cbnz	r2, 801425c <__swsetup_r+0xa4>
 801424a:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 801424e:	d1c5      	bne.n	80141dc <__swsetup_r+0x24>
 8014250:	bd38      	pop	{r3, r4, r5, pc}
 8014252:	0799      	lsls	r1, r3, #30
 8014254:	bf58      	it	pl
 8014256:	6962      	ldrpl	r2, [r4, #20]
 8014258:	60a2      	str	r2, [r4, #8]
 801425a:	e7f4      	b.n	8014246 <__swsetup_r+0x8e>
 801425c:	2000      	movs	r0, #0
 801425e:	e7f7      	b.n	8014250 <__swsetup_r+0x98>
 8014260:	2400003c 	.word	0x2400003c

08014264 <memcmp>:
 8014264:	b510      	push	{r4, lr}
 8014266:	3901      	subs	r1, #1
 8014268:	4402      	add	r2, r0
 801426a:	4290      	cmp	r0, r2
 801426c:	d101      	bne.n	8014272 <memcmp+0xe>
 801426e:	2000      	movs	r0, #0
 8014270:	e005      	b.n	801427e <memcmp+0x1a>
 8014272:	7803      	ldrb	r3, [r0, #0]
 8014274:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8014278:	42a3      	cmp	r3, r4
 801427a:	d001      	beq.n	8014280 <memcmp+0x1c>
 801427c:	1b18      	subs	r0, r3, r4
 801427e:	bd10      	pop	{r4, pc}
 8014280:	3001      	adds	r0, #1
 8014282:	e7f2      	b.n	801426a <memcmp+0x6>

08014284 <memmove>:
 8014284:	4288      	cmp	r0, r1
 8014286:	b510      	push	{r4, lr}
 8014288:	eb01 0402 	add.w	r4, r1, r2
 801428c:	d902      	bls.n	8014294 <memmove+0x10>
 801428e:	4284      	cmp	r4, r0
 8014290:	4623      	mov	r3, r4
 8014292:	d807      	bhi.n	80142a4 <memmove+0x20>
 8014294:	1e43      	subs	r3, r0, #1
 8014296:	42a1      	cmp	r1, r4
 8014298:	d008      	beq.n	80142ac <memmove+0x28>
 801429a:	f811 2b01 	ldrb.w	r2, [r1], #1
 801429e:	f803 2f01 	strb.w	r2, [r3, #1]!
 80142a2:	e7f8      	b.n	8014296 <memmove+0x12>
 80142a4:	4402      	add	r2, r0
 80142a6:	4601      	mov	r1, r0
 80142a8:	428a      	cmp	r2, r1
 80142aa:	d100      	bne.n	80142ae <memmove+0x2a>
 80142ac:	bd10      	pop	{r4, pc}
 80142ae:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 80142b2:	f802 4d01 	strb.w	r4, [r2, #-1]!
 80142b6:	e7f7      	b.n	80142a8 <memmove+0x24>

080142b8 <memset>:
 80142b8:	4402      	add	r2, r0
 80142ba:	4603      	mov	r3, r0
 80142bc:	4293      	cmp	r3, r2
 80142be:	d100      	bne.n	80142c2 <memset+0xa>
 80142c0:	4770      	bx	lr
 80142c2:	f803 1b01 	strb.w	r1, [r3], #1
 80142c6:	e7f9      	b.n	80142bc <memset+0x4>

080142c8 <strcat>:
 80142c8:	b510      	push	{r4, lr}
 80142ca:	4602      	mov	r2, r0
 80142cc:	7814      	ldrb	r4, [r2, #0]
 80142ce:	4613      	mov	r3, r2
 80142d0:	3201      	adds	r2, #1
 80142d2:	2c00      	cmp	r4, #0
 80142d4:	d1fa      	bne.n	80142cc <strcat+0x4>
 80142d6:	3b01      	subs	r3, #1
 80142d8:	f811 2b01 	ldrb.w	r2, [r1], #1
 80142dc:	f803 2f01 	strb.w	r2, [r3, #1]!
 80142e0:	2a00      	cmp	r2, #0
 80142e2:	d1f9      	bne.n	80142d8 <strcat+0x10>
 80142e4:	bd10      	pop	{r4, pc}

080142e6 <strncmp>:
 80142e6:	b510      	push	{r4, lr}
 80142e8:	b16a      	cbz	r2, 8014306 <strncmp+0x20>
 80142ea:	3901      	subs	r1, #1
 80142ec:	1884      	adds	r4, r0, r2
 80142ee:	f810 2b01 	ldrb.w	r2, [r0], #1
 80142f2:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 80142f6:	429a      	cmp	r2, r3
 80142f8:	d103      	bne.n	8014302 <strncmp+0x1c>
 80142fa:	42a0      	cmp	r0, r4
 80142fc:	d001      	beq.n	8014302 <strncmp+0x1c>
 80142fe:	2a00      	cmp	r2, #0
 8014300:	d1f5      	bne.n	80142ee <strncmp+0x8>
 8014302:	1ad0      	subs	r0, r2, r3
 8014304:	bd10      	pop	{r4, pc}
 8014306:	4610      	mov	r0, r2
 8014308:	e7fc      	b.n	8014304 <strncmp+0x1e>
	...

0801430c <_close_r>:
 801430c:	b538      	push	{r3, r4, r5, lr}
 801430e:	4d06      	ldr	r5, [pc, #24]	@ (8014328 <_close_r+0x1c>)
 8014310:	2300      	movs	r3, #0
 8014312:	4604      	mov	r4, r0
 8014314:	4608      	mov	r0, r1
 8014316:	602b      	str	r3, [r5, #0]
 8014318:	f7ec fd54 	bl	8000dc4 <_close>
 801431c:	1c43      	adds	r3, r0, #1
 801431e:	d102      	bne.n	8014326 <_close_r+0x1a>
 8014320:	682b      	ldr	r3, [r5, #0]
 8014322:	b103      	cbz	r3, 8014326 <_close_r+0x1a>
 8014324:	6023      	str	r3, [r4, #0]
 8014326:	bd38      	pop	{r3, r4, r5, pc}
 8014328:	24014444 	.word	0x24014444

0801432c <_lseek_r>:
 801432c:	b538      	push	{r3, r4, r5, lr}
 801432e:	4d07      	ldr	r5, [pc, #28]	@ (801434c <_lseek_r+0x20>)
 8014330:	4604      	mov	r4, r0
 8014332:	4608      	mov	r0, r1
 8014334:	4611      	mov	r1, r2
 8014336:	2200      	movs	r2, #0
 8014338:	602a      	str	r2, [r5, #0]
 801433a:	461a      	mov	r2, r3
 801433c:	f7ec fd4c 	bl	8000dd8 <_lseek>
 8014340:	1c43      	adds	r3, r0, #1
 8014342:	d102      	bne.n	801434a <_lseek_r+0x1e>
 8014344:	682b      	ldr	r3, [r5, #0]
 8014346:	b103      	cbz	r3, 801434a <_lseek_r+0x1e>
 8014348:	6023      	str	r3, [r4, #0]
 801434a:	bd38      	pop	{r3, r4, r5, pc}
 801434c:	24014444 	.word	0x24014444

08014350 <_read_r>:
 8014350:	b538      	push	{r3, r4, r5, lr}
 8014352:	4d07      	ldr	r5, [pc, #28]	@ (8014370 <_read_r+0x20>)
 8014354:	4604      	mov	r4, r0
 8014356:	4608      	mov	r0, r1
 8014358:	4611      	mov	r1, r2
 801435a:	2200      	movs	r2, #0
 801435c:	602a      	str	r2, [r5, #0]
 801435e:	461a      	mov	r2, r3
 8014360:	f7ec fd12 	bl	8000d88 <_read>
 8014364:	1c43      	adds	r3, r0, #1
 8014366:	d102      	bne.n	801436e <_read_r+0x1e>
 8014368:	682b      	ldr	r3, [r5, #0]
 801436a:	b103      	cbz	r3, 801436e <_read_r+0x1e>
 801436c:	6023      	str	r3, [r4, #0]
 801436e:	bd38      	pop	{r3, r4, r5, pc}
 8014370:	24014444 	.word	0x24014444

08014374 <_write_r>:
 8014374:	b538      	push	{r3, r4, r5, lr}
 8014376:	4d07      	ldr	r5, [pc, #28]	@ (8014394 <_write_r+0x20>)
 8014378:	4604      	mov	r4, r0
 801437a:	4608      	mov	r0, r1
 801437c:	4611      	mov	r1, r2
 801437e:	2200      	movs	r2, #0
 8014380:	602a      	str	r2, [r5, #0]
 8014382:	461a      	mov	r2, r3
 8014384:	f7ec fd10 	bl	8000da8 <_write>
 8014388:	1c43      	adds	r3, r0, #1
 801438a:	d102      	bne.n	8014392 <_write_r+0x1e>
 801438c:	682b      	ldr	r3, [r5, #0]
 801438e:	b103      	cbz	r3, 8014392 <_write_r+0x1e>
 8014390:	6023      	str	r3, [r4, #0]
 8014392:	bd38      	pop	{r3, r4, r5, pc}
 8014394:	24014444 	.word	0x24014444

08014398 <__errno>:
 8014398:	4b01      	ldr	r3, [pc, #4]	@ (80143a0 <__errno+0x8>)
 801439a:	6818      	ldr	r0, [r3, #0]
 801439c:	4770      	bx	lr
 801439e:	bf00      	nop
 80143a0:	2400003c 	.word	0x2400003c

080143a4 <__libc_init_array>:
 80143a4:	b570      	push	{r4, r5, r6, lr}
 80143a6:	4d0d      	ldr	r5, [pc, #52]	@ (80143dc <__libc_init_array+0x38>)
 80143a8:	4c0d      	ldr	r4, [pc, #52]	@ (80143e0 <__libc_init_array+0x3c>)
 80143aa:	1b64      	subs	r4, r4, r5
 80143ac:	10a4      	asrs	r4, r4, #2
 80143ae:	2600      	movs	r6, #0
 80143b0:	42a6      	cmp	r6, r4
 80143b2:	d109      	bne.n	80143c8 <__libc_init_array+0x24>
 80143b4:	4d0b      	ldr	r5, [pc, #44]	@ (80143e4 <__libc_init_array+0x40>)
 80143b6:	4c0c      	ldr	r4, [pc, #48]	@ (80143e8 <__libc_init_array+0x44>)
 80143b8:	f000 ff7e 	bl	80152b8 <_init>
 80143bc:	1b64      	subs	r4, r4, r5
 80143be:	10a4      	asrs	r4, r4, #2
 80143c0:	2600      	movs	r6, #0
 80143c2:	42a6      	cmp	r6, r4
 80143c4:	d105      	bne.n	80143d2 <__libc_init_array+0x2e>
 80143c6:	bd70      	pop	{r4, r5, r6, pc}
 80143c8:	f855 3b04 	ldr.w	r3, [r5], #4
 80143cc:	4798      	blx	r3
 80143ce:	3601      	adds	r6, #1
 80143d0:	e7ee      	b.n	80143b0 <__libc_init_array+0xc>
 80143d2:	f855 3b04 	ldr.w	r3, [r5], #4
 80143d6:	4798      	blx	r3
 80143d8:	3601      	adds	r6, #1
 80143da:	e7f2      	b.n	80143c2 <__libc_init_array+0x1e>
 80143dc:	08019b50 	.word	0x08019b50
 80143e0:	08019b50 	.word	0x08019b50
 80143e4:	08019b50 	.word	0x08019b50
 80143e8:	08019b54 	.word	0x08019b54

080143ec <__retarget_lock_init_recursive>:
 80143ec:	4770      	bx	lr

080143ee <__retarget_lock_acquire_recursive>:
 80143ee:	4770      	bx	lr

080143f0 <__retarget_lock_release_recursive>:
 80143f0:	4770      	bx	lr

080143f2 <strcpy>:
 80143f2:	4603      	mov	r3, r0
 80143f4:	f811 2b01 	ldrb.w	r2, [r1], #1
 80143f8:	f803 2b01 	strb.w	r2, [r3], #1
 80143fc:	2a00      	cmp	r2, #0
 80143fe:	d1f9      	bne.n	80143f4 <strcpy+0x2>
 8014400:	4770      	bx	lr

08014402 <memcpy>:
 8014402:	440a      	add	r2, r1
 8014404:	4291      	cmp	r1, r2
 8014406:	f100 33ff 	add.w	r3, r0, #4294967295
 801440a:	d100      	bne.n	801440e <memcpy+0xc>
 801440c:	4770      	bx	lr
 801440e:	b510      	push	{r4, lr}
 8014410:	f811 4b01 	ldrb.w	r4, [r1], #1
 8014414:	f803 4f01 	strb.w	r4, [r3, #1]!
 8014418:	4291      	cmp	r1, r2
 801441a:	d1f9      	bne.n	8014410 <memcpy+0xe>
 801441c:	bd10      	pop	{r4, pc}
	...

08014420 <__assert_func>:
 8014420:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8014422:	4614      	mov	r4, r2
 8014424:	461a      	mov	r2, r3
 8014426:	4b09      	ldr	r3, [pc, #36]	@ (801444c <__assert_func+0x2c>)
 8014428:	681b      	ldr	r3, [r3, #0]
 801442a:	4605      	mov	r5, r0
 801442c:	68d8      	ldr	r0, [r3, #12]
 801442e:	b14c      	cbz	r4, 8014444 <__assert_func+0x24>
 8014430:	4b07      	ldr	r3, [pc, #28]	@ (8014450 <__assert_func+0x30>)
 8014432:	9100      	str	r1, [sp, #0]
 8014434:	e9cd 3401 	strd	r3, r4, [sp, #4]
 8014438:	4906      	ldr	r1, [pc, #24]	@ (8014454 <__assert_func+0x34>)
 801443a:	462b      	mov	r3, r5
 801443c:	f000 fde0 	bl	8015000 <fiprintf>
 8014440:	f000 feb8 	bl	80151b4 <abort>
 8014444:	4b04      	ldr	r3, [pc, #16]	@ (8014458 <__assert_func+0x38>)
 8014446:	461c      	mov	r4, r3
 8014448:	e7f3      	b.n	8014432 <__assert_func+0x12>
 801444a:	bf00      	nop
 801444c:	2400003c 	.word	0x2400003c
 8014450:	080199d8 	.word	0x080199d8
 8014454:	080199e5 	.word	0x080199e5
 8014458:	08019a13 	.word	0x08019a13

0801445c <_free_r>:
 801445c:	b538      	push	{r3, r4, r5, lr}
 801445e:	4605      	mov	r5, r0
 8014460:	2900      	cmp	r1, #0
 8014462:	d041      	beq.n	80144e8 <_free_r+0x8c>
 8014464:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8014468:	1f0c      	subs	r4, r1, #4
 801446a:	2b00      	cmp	r3, #0
 801446c:	bfb8      	it	lt
 801446e:	18e4      	addlt	r4, r4, r3
 8014470:	f000 f8e8 	bl	8014644 <__malloc_lock>
 8014474:	4a1d      	ldr	r2, [pc, #116]	@ (80144ec <_free_r+0x90>)
 8014476:	6813      	ldr	r3, [r2, #0]
 8014478:	b933      	cbnz	r3, 8014488 <_free_r+0x2c>
 801447a:	6063      	str	r3, [r4, #4]
 801447c:	6014      	str	r4, [r2, #0]
 801447e:	4628      	mov	r0, r5
 8014480:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8014484:	f000 b8e4 	b.w	8014650 <__malloc_unlock>
 8014488:	42a3      	cmp	r3, r4
 801448a:	d908      	bls.n	801449e <_free_r+0x42>
 801448c:	6820      	ldr	r0, [r4, #0]
 801448e:	1821      	adds	r1, r4, r0
 8014490:	428b      	cmp	r3, r1
 8014492:	bf01      	itttt	eq
 8014494:	6819      	ldreq	r1, [r3, #0]
 8014496:	685b      	ldreq	r3, [r3, #4]
 8014498:	1809      	addeq	r1, r1, r0
 801449a:	6021      	streq	r1, [r4, #0]
 801449c:	e7ed      	b.n	801447a <_free_r+0x1e>
 801449e:	461a      	mov	r2, r3
 80144a0:	685b      	ldr	r3, [r3, #4]
 80144a2:	b10b      	cbz	r3, 80144a8 <_free_r+0x4c>
 80144a4:	42a3      	cmp	r3, r4
 80144a6:	d9fa      	bls.n	801449e <_free_r+0x42>
 80144a8:	6811      	ldr	r1, [r2, #0]
 80144aa:	1850      	adds	r0, r2, r1
 80144ac:	42a0      	cmp	r0, r4
 80144ae:	d10b      	bne.n	80144c8 <_free_r+0x6c>
 80144b0:	6820      	ldr	r0, [r4, #0]
 80144b2:	4401      	add	r1, r0
 80144b4:	1850      	adds	r0, r2, r1
 80144b6:	4283      	cmp	r3, r0
 80144b8:	6011      	str	r1, [r2, #0]
 80144ba:	d1e0      	bne.n	801447e <_free_r+0x22>
 80144bc:	6818      	ldr	r0, [r3, #0]
 80144be:	685b      	ldr	r3, [r3, #4]
 80144c0:	6053      	str	r3, [r2, #4]
 80144c2:	4408      	add	r0, r1
 80144c4:	6010      	str	r0, [r2, #0]
 80144c6:	e7da      	b.n	801447e <_free_r+0x22>
 80144c8:	d902      	bls.n	80144d0 <_free_r+0x74>
 80144ca:	230c      	movs	r3, #12
 80144cc:	602b      	str	r3, [r5, #0]
 80144ce:	e7d6      	b.n	801447e <_free_r+0x22>
 80144d0:	6820      	ldr	r0, [r4, #0]
 80144d2:	1821      	adds	r1, r4, r0
 80144d4:	428b      	cmp	r3, r1
 80144d6:	bf04      	itt	eq
 80144d8:	6819      	ldreq	r1, [r3, #0]
 80144da:	685b      	ldreq	r3, [r3, #4]
 80144dc:	6063      	str	r3, [r4, #4]
 80144de:	bf04      	itt	eq
 80144e0:	1809      	addeq	r1, r1, r0
 80144e2:	6021      	streq	r1, [r4, #0]
 80144e4:	6054      	str	r4, [r2, #4]
 80144e6:	e7ca      	b.n	801447e <_free_r+0x22>
 80144e8:	bd38      	pop	{r3, r4, r5, pc}
 80144ea:	bf00      	nop
 80144ec:	240146b8 	.word	0x240146b8

080144f0 <malloc>:
 80144f0:	4b02      	ldr	r3, [pc, #8]	@ (80144fc <malloc+0xc>)
 80144f2:	4601      	mov	r1, r0
 80144f4:	6818      	ldr	r0, [r3, #0]
 80144f6:	f000 b825 	b.w	8014544 <_malloc_r>
 80144fa:	bf00      	nop
 80144fc:	2400003c 	.word	0x2400003c

08014500 <sbrk_aligned>:
 8014500:	b570      	push	{r4, r5, r6, lr}
 8014502:	4e0f      	ldr	r6, [pc, #60]	@ (8014540 <sbrk_aligned+0x40>)
 8014504:	460c      	mov	r4, r1
 8014506:	6831      	ldr	r1, [r6, #0]
 8014508:	4605      	mov	r5, r0
 801450a:	b911      	cbnz	r1, 8014512 <sbrk_aligned+0x12>
 801450c:	f000 fe42 	bl	8015194 <_sbrk_r>
 8014510:	6030      	str	r0, [r6, #0]
 8014512:	4621      	mov	r1, r4
 8014514:	4628      	mov	r0, r5
 8014516:	f000 fe3d 	bl	8015194 <_sbrk_r>
 801451a:	1c43      	adds	r3, r0, #1
 801451c:	d103      	bne.n	8014526 <sbrk_aligned+0x26>
 801451e:	f04f 34ff 	mov.w	r4, #4294967295
 8014522:	4620      	mov	r0, r4
 8014524:	bd70      	pop	{r4, r5, r6, pc}
 8014526:	1cc4      	adds	r4, r0, #3
 8014528:	f024 0403 	bic.w	r4, r4, #3
 801452c:	42a0      	cmp	r0, r4
 801452e:	d0f8      	beq.n	8014522 <sbrk_aligned+0x22>
 8014530:	1a21      	subs	r1, r4, r0
 8014532:	4628      	mov	r0, r5
 8014534:	f000 fe2e 	bl	8015194 <_sbrk_r>
 8014538:	3001      	adds	r0, #1
 801453a:	d1f2      	bne.n	8014522 <sbrk_aligned+0x22>
 801453c:	e7ef      	b.n	801451e <sbrk_aligned+0x1e>
 801453e:	bf00      	nop
 8014540:	240146b4 	.word	0x240146b4

08014544 <_malloc_r>:
 8014544:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8014548:	1ccd      	adds	r5, r1, #3
 801454a:	f025 0503 	bic.w	r5, r5, #3
 801454e:	3508      	adds	r5, #8
 8014550:	2d0c      	cmp	r5, #12
 8014552:	bf38      	it	cc
 8014554:	250c      	movcc	r5, #12
 8014556:	2d00      	cmp	r5, #0
 8014558:	4606      	mov	r6, r0
 801455a:	db01      	blt.n	8014560 <_malloc_r+0x1c>
 801455c:	42a9      	cmp	r1, r5
 801455e:	d904      	bls.n	801456a <_malloc_r+0x26>
 8014560:	230c      	movs	r3, #12
 8014562:	6033      	str	r3, [r6, #0]
 8014564:	2000      	movs	r0, #0
 8014566:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 801456a:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 8014640 <_malloc_r+0xfc>
 801456e:	f000 f869 	bl	8014644 <__malloc_lock>
 8014572:	f8d8 3000 	ldr.w	r3, [r8]
 8014576:	461c      	mov	r4, r3
 8014578:	bb44      	cbnz	r4, 80145cc <_malloc_r+0x88>
 801457a:	4629      	mov	r1, r5
 801457c:	4630      	mov	r0, r6
 801457e:	f7ff ffbf 	bl	8014500 <sbrk_aligned>
 8014582:	1c43      	adds	r3, r0, #1
 8014584:	4604      	mov	r4, r0
 8014586:	d158      	bne.n	801463a <_malloc_r+0xf6>
 8014588:	f8d8 4000 	ldr.w	r4, [r8]
 801458c:	4627      	mov	r7, r4
 801458e:	2f00      	cmp	r7, #0
 8014590:	d143      	bne.n	801461a <_malloc_r+0xd6>
 8014592:	2c00      	cmp	r4, #0
 8014594:	d04b      	beq.n	801462e <_malloc_r+0xea>
 8014596:	6823      	ldr	r3, [r4, #0]
 8014598:	4639      	mov	r1, r7
 801459a:	4630      	mov	r0, r6
 801459c:	eb04 0903 	add.w	r9, r4, r3
 80145a0:	f000 fdf8 	bl	8015194 <_sbrk_r>
 80145a4:	4581      	cmp	r9, r0
 80145a6:	d142      	bne.n	801462e <_malloc_r+0xea>
 80145a8:	6821      	ldr	r1, [r4, #0]
 80145aa:	1a6d      	subs	r5, r5, r1
 80145ac:	4629      	mov	r1, r5
 80145ae:	4630      	mov	r0, r6
 80145b0:	f7ff ffa6 	bl	8014500 <sbrk_aligned>
 80145b4:	3001      	adds	r0, #1
 80145b6:	d03a      	beq.n	801462e <_malloc_r+0xea>
 80145b8:	6823      	ldr	r3, [r4, #0]
 80145ba:	442b      	add	r3, r5
 80145bc:	6023      	str	r3, [r4, #0]
 80145be:	f8d8 3000 	ldr.w	r3, [r8]
 80145c2:	685a      	ldr	r2, [r3, #4]
 80145c4:	bb62      	cbnz	r2, 8014620 <_malloc_r+0xdc>
 80145c6:	f8c8 7000 	str.w	r7, [r8]
 80145ca:	e00f      	b.n	80145ec <_malloc_r+0xa8>
 80145cc:	6822      	ldr	r2, [r4, #0]
 80145ce:	1b52      	subs	r2, r2, r5
 80145d0:	d420      	bmi.n	8014614 <_malloc_r+0xd0>
 80145d2:	2a0b      	cmp	r2, #11
 80145d4:	d917      	bls.n	8014606 <_malloc_r+0xc2>
 80145d6:	1961      	adds	r1, r4, r5
 80145d8:	42a3      	cmp	r3, r4
 80145da:	6025      	str	r5, [r4, #0]
 80145dc:	bf18      	it	ne
 80145de:	6059      	strne	r1, [r3, #4]
 80145e0:	6863      	ldr	r3, [r4, #4]
 80145e2:	bf08      	it	eq
 80145e4:	f8c8 1000 	streq.w	r1, [r8]
 80145e8:	5162      	str	r2, [r4, r5]
 80145ea:	604b      	str	r3, [r1, #4]
 80145ec:	4630      	mov	r0, r6
 80145ee:	f000 f82f 	bl	8014650 <__malloc_unlock>
 80145f2:	f104 000b 	add.w	r0, r4, #11
 80145f6:	1d23      	adds	r3, r4, #4
 80145f8:	f020 0007 	bic.w	r0, r0, #7
 80145fc:	1ac2      	subs	r2, r0, r3
 80145fe:	bf1c      	itt	ne
 8014600:	1a1b      	subne	r3, r3, r0
 8014602:	50a3      	strne	r3, [r4, r2]
 8014604:	e7af      	b.n	8014566 <_malloc_r+0x22>
 8014606:	6862      	ldr	r2, [r4, #4]
 8014608:	42a3      	cmp	r3, r4
 801460a:	bf0c      	ite	eq
 801460c:	f8c8 2000 	streq.w	r2, [r8]
 8014610:	605a      	strne	r2, [r3, #4]
 8014612:	e7eb      	b.n	80145ec <_malloc_r+0xa8>
 8014614:	4623      	mov	r3, r4
 8014616:	6864      	ldr	r4, [r4, #4]
 8014618:	e7ae      	b.n	8014578 <_malloc_r+0x34>
 801461a:	463c      	mov	r4, r7
 801461c:	687f      	ldr	r7, [r7, #4]
 801461e:	e7b6      	b.n	801458e <_malloc_r+0x4a>
 8014620:	461a      	mov	r2, r3
 8014622:	685b      	ldr	r3, [r3, #4]
 8014624:	42a3      	cmp	r3, r4
 8014626:	d1fb      	bne.n	8014620 <_malloc_r+0xdc>
 8014628:	2300      	movs	r3, #0
 801462a:	6053      	str	r3, [r2, #4]
 801462c:	e7de      	b.n	80145ec <_malloc_r+0xa8>
 801462e:	230c      	movs	r3, #12
 8014630:	6033      	str	r3, [r6, #0]
 8014632:	4630      	mov	r0, r6
 8014634:	f000 f80c 	bl	8014650 <__malloc_unlock>
 8014638:	e794      	b.n	8014564 <_malloc_r+0x20>
 801463a:	6005      	str	r5, [r0, #0]
 801463c:	e7d6      	b.n	80145ec <_malloc_r+0xa8>
 801463e:	bf00      	nop
 8014640:	240146b8 	.word	0x240146b8

08014644 <__malloc_lock>:
 8014644:	4801      	ldr	r0, [pc, #4]	@ (801464c <__malloc_lock+0x8>)
 8014646:	f7ff bed2 	b.w	80143ee <__retarget_lock_acquire_recursive>
 801464a:	bf00      	nop
 801464c:	240146b0 	.word	0x240146b0

08014650 <__malloc_unlock>:
 8014650:	4801      	ldr	r0, [pc, #4]	@ (8014658 <__malloc_unlock+0x8>)
 8014652:	f7ff becd 	b.w	80143f0 <__retarget_lock_release_recursive>
 8014656:	bf00      	nop
 8014658:	240146b0 	.word	0x240146b0

0801465c <__ssputs_r>:
 801465c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8014660:	688e      	ldr	r6, [r1, #8]
 8014662:	461f      	mov	r7, r3
 8014664:	42be      	cmp	r6, r7
 8014666:	680b      	ldr	r3, [r1, #0]
 8014668:	4682      	mov	sl, r0
 801466a:	460c      	mov	r4, r1
 801466c:	4690      	mov	r8, r2
 801466e:	d82d      	bhi.n	80146cc <__ssputs_r+0x70>
 8014670:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 8014674:	f412 6f90 	tst.w	r2, #1152	@ 0x480
 8014678:	d026      	beq.n	80146c8 <__ssputs_r+0x6c>
 801467a:	6965      	ldr	r5, [r4, #20]
 801467c:	6909      	ldr	r1, [r1, #16]
 801467e:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8014682:	eba3 0901 	sub.w	r9, r3, r1
 8014686:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 801468a:	1c7b      	adds	r3, r7, #1
 801468c:	444b      	add	r3, r9
 801468e:	106d      	asrs	r5, r5, #1
 8014690:	429d      	cmp	r5, r3
 8014692:	bf38      	it	cc
 8014694:	461d      	movcc	r5, r3
 8014696:	0553      	lsls	r3, r2, #21
 8014698:	d527      	bpl.n	80146ea <__ssputs_r+0x8e>
 801469a:	4629      	mov	r1, r5
 801469c:	f7ff ff52 	bl	8014544 <_malloc_r>
 80146a0:	4606      	mov	r6, r0
 80146a2:	b360      	cbz	r0, 80146fe <__ssputs_r+0xa2>
 80146a4:	6921      	ldr	r1, [r4, #16]
 80146a6:	464a      	mov	r2, r9
 80146a8:	f7ff feab 	bl	8014402 <memcpy>
 80146ac:	89a3      	ldrh	r3, [r4, #12]
 80146ae:	f423 6390 	bic.w	r3, r3, #1152	@ 0x480
 80146b2:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 80146b6:	81a3      	strh	r3, [r4, #12]
 80146b8:	6126      	str	r6, [r4, #16]
 80146ba:	6165      	str	r5, [r4, #20]
 80146bc:	444e      	add	r6, r9
 80146be:	eba5 0509 	sub.w	r5, r5, r9
 80146c2:	6026      	str	r6, [r4, #0]
 80146c4:	60a5      	str	r5, [r4, #8]
 80146c6:	463e      	mov	r6, r7
 80146c8:	42be      	cmp	r6, r7
 80146ca:	d900      	bls.n	80146ce <__ssputs_r+0x72>
 80146cc:	463e      	mov	r6, r7
 80146ce:	6820      	ldr	r0, [r4, #0]
 80146d0:	4632      	mov	r2, r6
 80146d2:	4641      	mov	r1, r8
 80146d4:	f7ff fdd6 	bl	8014284 <memmove>
 80146d8:	68a3      	ldr	r3, [r4, #8]
 80146da:	1b9b      	subs	r3, r3, r6
 80146dc:	60a3      	str	r3, [r4, #8]
 80146de:	6823      	ldr	r3, [r4, #0]
 80146e0:	4433      	add	r3, r6
 80146e2:	6023      	str	r3, [r4, #0]
 80146e4:	2000      	movs	r0, #0
 80146e6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80146ea:	462a      	mov	r2, r5
 80146ec:	f000 fd69 	bl	80151c2 <_realloc_r>
 80146f0:	4606      	mov	r6, r0
 80146f2:	2800      	cmp	r0, #0
 80146f4:	d1e0      	bne.n	80146b8 <__ssputs_r+0x5c>
 80146f6:	6921      	ldr	r1, [r4, #16]
 80146f8:	4650      	mov	r0, sl
 80146fa:	f7ff feaf 	bl	801445c <_free_r>
 80146fe:	230c      	movs	r3, #12
 8014700:	f8ca 3000 	str.w	r3, [sl]
 8014704:	89a3      	ldrh	r3, [r4, #12]
 8014706:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801470a:	81a3      	strh	r3, [r4, #12]
 801470c:	f04f 30ff 	mov.w	r0, #4294967295
 8014710:	e7e9      	b.n	80146e6 <__ssputs_r+0x8a>
	...

08014714 <_svfiprintf_r>:
 8014714:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014718:	4698      	mov	r8, r3
 801471a:	898b      	ldrh	r3, [r1, #12]
 801471c:	061b      	lsls	r3, r3, #24
 801471e:	b09d      	sub	sp, #116	@ 0x74
 8014720:	4607      	mov	r7, r0
 8014722:	460d      	mov	r5, r1
 8014724:	4614      	mov	r4, r2
 8014726:	d510      	bpl.n	801474a <_svfiprintf_r+0x36>
 8014728:	690b      	ldr	r3, [r1, #16]
 801472a:	b973      	cbnz	r3, 801474a <_svfiprintf_r+0x36>
 801472c:	2140      	movs	r1, #64	@ 0x40
 801472e:	f7ff ff09 	bl	8014544 <_malloc_r>
 8014732:	6028      	str	r0, [r5, #0]
 8014734:	6128      	str	r0, [r5, #16]
 8014736:	b930      	cbnz	r0, 8014746 <_svfiprintf_r+0x32>
 8014738:	230c      	movs	r3, #12
 801473a:	603b      	str	r3, [r7, #0]
 801473c:	f04f 30ff 	mov.w	r0, #4294967295
 8014740:	b01d      	add	sp, #116	@ 0x74
 8014742:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8014746:	2340      	movs	r3, #64	@ 0x40
 8014748:	616b      	str	r3, [r5, #20]
 801474a:	2300      	movs	r3, #0
 801474c:	9309      	str	r3, [sp, #36]	@ 0x24
 801474e:	2320      	movs	r3, #32
 8014750:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 8014754:	f8cd 800c 	str.w	r8, [sp, #12]
 8014758:	2330      	movs	r3, #48	@ 0x30
 801475a:	f8df 819c 	ldr.w	r8, [pc, #412]	@ 80148f8 <_svfiprintf_r+0x1e4>
 801475e:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 8014762:	f04f 0901 	mov.w	r9, #1
 8014766:	4623      	mov	r3, r4
 8014768:	469a      	mov	sl, r3
 801476a:	f813 2b01 	ldrb.w	r2, [r3], #1
 801476e:	b10a      	cbz	r2, 8014774 <_svfiprintf_r+0x60>
 8014770:	2a25      	cmp	r2, #37	@ 0x25
 8014772:	d1f9      	bne.n	8014768 <_svfiprintf_r+0x54>
 8014774:	ebba 0b04 	subs.w	fp, sl, r4
 8014778:	d00b      	beq.n	8014792 <_svfiprintf_r+0x7e>
 801477a:	465b      	mov	r3, fp
 801477c:	4622      	mov	r2, r4
 801477e:	4629      	mov	r1, r5
 8014780:	4638      	mov	r0, r7
 8014782:	f7ff ff6b 	bl	801465c <__ssputs_r>
 8014786:	3001      	adds	r0, #1
 8014788:	f000 80a7 	beq.w	80148da <_svfiprintf_r+0x1c6>
 801478c:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 801478e:	445a      	add	r2, fp
 8014790:	9209      	str	r2, [sp, #36]	@ 0x24
 8014792:	f89a 3000 	ldrb.w	r3, [sl]
 8014796:	2b00      	cmp	r3, #0
 8014798:	f000 809f 	beq.w	80148da <_svfiprintf_r+0x1c6>
 801479c:	2300      	movs	r3, #0
 801479e:	f04f 32ff 	mov.w	r2, #4294967295
 80147a2:	e9cd 2305 	strd	r2, r3, [sp, #20]
 80147a6:	f10a 0a01 	add.w	sl, sl, #1
 80147aa:	9304      	str	r3, [sp, #16]
 80147ac:	9307      	str	r3, [sp, #28]
 80147ae:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 80147b2:	931a      	str	r3, [sp, #104]	@ 0x68
 80147b4:	4654      	mov	r4, sl
 80147b6:	2205      	movs	r2, #5
 80147b8:	f814 1b01 	ldrb.w	r1, [r4], #1
 80147bc:	484e      	ldr	r0, [pc, #312]	@ (80148f8 <_svfiprintf_r+0x1e4>)
 80147be:	f7eb fd97 	bl	80002f0 <memchr>
 80147c2:	9a04      	ldr	r2, [sp, #16]
 80147c4:	b9d8      	cbnz	r0, 80147fe <_svfiprintf_r+0xea>
 80147c6:	06d0      	lsls	r0, r2, #27
 80147c8:	bf44      	itt	mi
 80147ca:	2320      	movmi	r3, #32
 80147cc:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 80147d0:	0711      	lsls	r1, r2, #28
 80147d2:	bf44      	itt	mi
 80147d4:	232b      	movmi	r3, #43	@ 0x2b
 80147d6:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 80147da:	f89a 3000 	ldrb.w	r3, [sl]
 80147de:	2b2a      	cmp	r3, #42	@ 0x2a
 80147e0:	d015      	beq.n	801480e <_svfiprintf_r+0xfa>
 80147e2:	9a07      	ldr	r2, [sp, #28]
 80147e4:	4654      	mov	r4, sl
 80147e6:	2000      	movs	r0, #0
 80147e8:	f04f 0c0a 	mov.w	ip, #10
 80147ec:	4621      	mov	r1, r4
 80147ee:	f811 3b01 	ldrb.w	r3, [r1], #1
 80147f2:	3b30      	subs	r3, #48	@ 0x30
 80147f4:	2b09      	cmp	r3, #9
 80147f6:	d94b      	bls.n	8014890 <_svfiprintf_r+0x17c>
 80147f8:	b1b0      	cbz	r0, 8014828 <_svfiprintf_r+0x114>
 80147fa:	9207      	str	r2, [sp, #28]
 80147fc:	e014      	b.n	8014828 <_svfiprintf_r+0x114>
 80147fe:	eba0 0308 	sub.w	r3, r0, r8
 8014802:	fa09 f303 	lsl.w	r3, r9, r3
 8014806:	4313      	orrs	r3, r2
 8014808:	9304      	str	r3, [sp, #16]
 801480a:	46a2      	mov	sl, r4
 801480c:	e7d2      	b.n	80147b4 <_svfiprintf_r+0xa0>
 801480e:	9b03      	ldr	r3, [sp, #12]
 8014810:	1d19      	adds	r1, r3, #4
 8014812:	681b      	ldr	r3, [r3, #0]
 8014814:	9103      	str	r1, [sp, #12]
 8014816:	2b00      	cmp	r3, #0
 8014818:	bfbb      	ittet	lt
 801481a:	425b      	neglt	r3, r3
 801481c:	f042 0202 	orrlt.w	r2, r2, #2
 8014820:	9307      	strge	r3, [sp, #28]
 8014822:	9307      	strlt	r3, [sp, #28]
 8014824:	bfb8      	it	lt
 8014826:	9204      	strlt	r2, [sp, #16]
 8014828:	7823      	ldrb	r3, [r4, #0]
 801482a:	2b2e      	cmp	r3, #46	@ 0x2e
 801482c:	d10a      	bne.n	8014844 <_svfiprintf_r+0x130>
 801482e:	7863      	ldrb	r3, [r4, #1]
 8014830:	2b2a      	cmp	r3, #42	@ 0x2a
 8014832:	d132      	bne.n	801489a <_svfiprintf_r+0x186>
 8014834:	9b03      	ldr	r3, [sp, #12]
 8014836:	1d1a      	adds	r2, r3, #4
 8014838:	681b      	ldr	r3, [r3, #0]
 801483a:	9203      	str	r2, [sp, #12]
 801483c:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 8014840:	3402      	adds	r4, #2
 8014842:	9305      	str	r3, [sp, #20]
 8014844:	f8df a0c0 	ldr.w	sl, [pc, #192]	@ 8014908 <_svfiprintf_r+0x1f4>
 8014848:	7821      	ldrb	r1, [r4, #0]
 801484a:	2203      	movs	r2, #3
 801484c:	4650      	mov	r0, sl
 801484e:	f7eb fd4f 	bl	80002f0 <memchr>
 8014852:	b138      	cbz	r0, 8014864 <_svfiprintf_r+0x150>
 8014854:	9b04      	ldr	r3, [sp, #16]
 8014856:	eba0 000a 	sub.w	r0, r0, sl
 801485a:	2240      	movs	r2, #64	@ 0x40
 801485c:	4082      	lsls	r2, r0
 801485e:	4313      	orrs	r3, r2
 8014860:	3401      	adds	r4, #1
 8014862:	9304      	str	r3, [sp, #16]
 8014864:	f814 1b01 	ldrb.w	r1, [r4], #1
 8014868:	4824      	ldr	r0, [pc, #144]	@ (80148fc <_svfiprintf_r+0x1e8>)
 801486a:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 801486e:	2206      	movs	r2, #6
 8014870:	f7eb fd3e 	bl	80002f0 <memchr>
 8014874:	2800      	cmp	r0, #0
 8014876:	d036      	beq.n	80148e6 <_svfiprintf_r+0x1d2>
 8014878:	4b21      	ldr	r3, [pc, #132]	@ (8014900 <_svfiprintf_r+0x1ec>)
 801487a:	bb1b      	cbnz	r3, 80148c4 <_svfiprintf_r+0x1b0>
 801487c:	9b03      	ldr	r3, [sp, #12]
 801487e:	3307      	adds	r3, #7
 8014880:	f023 0307 	bic.w	r3, r3, #7
 8014884:	3308      	adds	r3, #8
 8014886:	9303      	str	r3, [sp, #12]
 8014888:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 801488a:	4433      	add	r3, r6
 801488c:	9309      	str	r3, [sp, #36]	@ 0x24
 801488e:	e76a      	b.n	8014766 <_svfiprintf_r+0x52>
 8014890:	fb0c 3202 	mla	r2, ip, r2, r3
 8014894:	460c      	mov	r4, r1
 8014896:	2001      	movs	r0, #1
 8014898:	e7a8      	b.n	80147ec <_svfiprintf_r+0xd8>
 801489a:	2300      	movs	r3, #0
 801489c:	3401      	adds	r4, #1
 801489e:	9305      	str	r3, [sp, #20]
 80148a0:	4619      	mov	r1, r3
 80148a2:	f04f 0c0a 	mov.w	ip, #10
 80148a6:	4620      	mov	r0, r4
 80148a8:	f810 2b01 	ldrb.w	r2, [r0], #1
 80148ac:	3a30      	subs	r2, #48	@ 0x30
 80148ae:	2a09      	cmp	r2, #9
 80148b0:	d903      	bls.n	80148ba <_svfiprintf_r+0x1a6>
 80148b2:	2b00      	cmp	r3, #0
 80148b4:	d0c6      	beq.n	8014844 <_svfiprintf_r+0x130>
 80148b6:	9105      	str	r1, [sp, #20]
 80148b8:	e7c4      	b.n	8014844 <_svfiprintf_r+0x130>
 80148ba:	fb0c 2101 	mla	r1, ip, r1, r2
 80148be:	4604      	mov	r4, r0
 80148c0:	2301      	movs	r3, #1
 80148c2:	e7f0      	b.n	80148a6 <_svfiprintf_r+0x192>
 80148c4:	ab03      	add	r3, sp, #12
 80148c6:	9300      	str	r3, [sp, #0]
 80148c8:	462a      	mov	r2, r5
 80148ca:	4b0e      	ldr	r3, [pc, #56]	@ (8014904 <_svfiprintf_r+0x1f0>)
 80148cc:	a904      	add	r1, sp, #16
 80148ce:	4638      	mov	r0, r7
 80148d0:	f3af 8000 	nop.w
 80148d4:	1c42      	adds	r2, r0, #1
 80148d6:	4606      	mov	r6, r0
 80148d8:	d1d6      	bne.n	8014888 <_svfiprintf_r+0x174>
 80148da:	89ab      	ldrh	r3, [r5, #12]
 80148dc:	065b      	lsls	r3, r3, #25
 80148de:	f53f af2d 	bmi.w	801473c <_svfiprintf_r+0x28>
 80148e2:	9809      	ldr	r0, [sp, #36]	@ 0x24
 80148e4:	e72c      	b.n	8014740 <_svfiprintf_r+0x2c>
 80148e6:	ab03      	add	r3, sp, #12
 80148e8:	9300      	str	r3, [sp, #0]
 80148ea:	462a      	mov	r2, r5
 80148ec:	4b05      	ldr	r3, [pc, #20]	@ (8014904 <_svfiprintf_r+0x1f0>)
 80148ee:	a904      	add	r1, sp, #16
 80148f0:	4638      	mov	r0, r7
 80148f2:	f000 f9bb 	bl	8014c6c <_printf_i>
 80148f6:	e7ed      	b.n	80148d4 <_svfiprintf_r+0x1c0>
 80148f8:	08019a14 	.word	0x08019a14
 80148fc:	08019a1e 	.word	0x08019a1e
 8014900:	00000000 	.word	0x00000000
 8014904:	0801465d 	.word	0x0801465d
 8014908:	08019a1a 	.word	0x08019a1a

0801490c <__sfputc_r>:
 801490c:	6893      	ldr	r3, [r2, #8]
 801490e:	3b01      	subs	r3, #1
 8014910:	2b00      	cmp	r3, #0
 8014912:	b410      	push	{r4}
 8014914:	6093      	str	r3, [r2, #8]
 8014916:	da08      	bge.n	801492a <__sfputc_r+0x1e>
 8014918:	6994      	ldr	r4, [r2, #24]
 801491a:	42a3      	cmp	r3, r4
 801491c:	db01      	blt.n	8014922 <__sfputc_r+0x16>
 801491e:	290a      	cmp	r1, #10
 8014920:	d103      	bne.n	801492a <__sfputc_r+0x1e>
 8014922:	f85d 4b04 	ldr.w	r4, [sp], #4
 8014926:	f7ff bc08 	b.w	801413a <__swbuf_r>
 801492a:	6813      	ldr	r3, [r2, #0]
 801492c:	1c58      	adds	r0, r3, #1
 801492e:	6010      	str	r0, [r2, #0]
 8014930:	7019      	strb	r1, [r3, #0]
 8014932:	4608      	mov	r0, r1
 8014934:	f85d 4b04 	ldr.w	r4, [sp], #4
 8014938:	4770      	bx	lr

0801493a <__sfputs_r>:
 801493a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801493c:	4606      	mov	r6, r0
 801493e:	460f      	mov	r7, r1
 8014940:	4614      	mov	r4, r2
 8014942:	18d5      	adds	r5, r2, r3
 8014944:	42ac      	cmp	r4, r5
 8014946:	d101      	bne.n	801494c <__sfputs_r+0x12>
 8014948:	2000      	movs	r0, #0
 801494a:	e007      	b.n	801495c <__sfputs_r+0x22>
 801494c:	f814 1b01 	ldrb.w	r1, [r4], #1
 8014950:	463a      	mov	r2, r7
 8014952:	4630      	mov	r0, r6
 8014954:	f7ff ffda 	bl	801490c <__sfputc_r>
 8014958:	1c43      	adds	r3, r0, #1
 801495a:	d1f3      	bne.n	8014944 <__sfputs_r+0xa>
 801495c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08014960 <_vfiprintf_r>:
 8014960:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014964:	460d      	mov	r5, r1
 8014966:	b09d      	sub	sp, #116	@ 0x74
 8014968:	4614      	mov	r4, r2
 801496a:	4698      	mov	r8, r3
 801496c:	4606      	mov	r6, r0
 801496e:	b118      	cbz	r0, 8014978 <_vfiprintf_r+0x18>
 8014970:	6a03      	ldr	r3, [r0, #32]
 8014972:	b90b      	cbnz	r3, 8014978 <_vfiprintf_r+0x18>
 8014974:	f7ff face 	bl	8013f14 <__sinit>
 8014978:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 801497a:	07d9      	lsls	r1, r3, #31
 801497c:	d405      	bmi.n	801498a <_vfiprintf_r+0x2a>
 801497e:	89ab      	ldrh	r3, [r5, #12]
 8014980:	059a      	lsls	r2, r3, #22
 8014982:	d402      	bmi.n	801498a <_vfiprintf_r+0x2a>
 8014984:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 8014986:	f7ff fd32 	bl	80143ee <__retarget_lock_acquire_recursive>
 801498a:	89ab      	ldrh	r3, [r5, #12]
 801498c:	071b      	lsls	r3, r3, #28
 801498e:	d501      	bpl.n	8014994 <_vfiprintf_r+0x34>
 8014990:	692b      	ldr	r3, [r5, #16]
 8014992:	b99b      	cbnz	r3, 80149bc <_vfiprintf_r+0x5c>
 8014994:	4629      	mov	r1, r5
 8014996:	4630      	mov	r0, r6
 8014998:	f7ff fc0e 	bl	80141b8 <__swsetup_r>
 801499c:	b170      	cbz	r0, 80149bc <_vfiprintf_r+0x5c>
 801499e:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 80149a0:	07dc      	lsls	r4, r3, #31
 80149a2:	d504      	bpl.n	80149ae <_vfiprintf_r+0x4e>
 80149a4:	f04f 30ff 	mov.w	r0, #4294967295
 80149a8:	b01d      	add	sp, #116	@ 0x74
 80149aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80149ae:	89ab      	ldrh	r3, [r5, #12]
 80149b0:	0598      	lsls	r0, r3, #22
 80149b2:	d4f7      	bmi.n	80149a4 <_vfiprintf_r+0x44>
 80149b4:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 80149b6:	f7ff fd1b 	bl	80143f0 <__retarget_lock_release_recursive>
 80149ba:	e7f3      	b.n	80149a4 <_vfiprintf_r+0x44>
 80149bc:	2300      	movs	r3, #0
 80149be:	9309      	str	r3, [sp, #36]	@ 0x24
 80149c0:	2320      	movs	r3, #32
 80149c2:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 80149c6:	f8cd 800c 	str.w	r8, [sp, #12]
 80149ca:	2330      	movs	r3, #48	@ 0x30
 80149cc:	f8df 81ac 	ldr.w	r8, [pc, #428]	@ 8014b7c <_vfiprintf_r+0x21c>
 80149d0:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 80149d4:	f04f 0901 	mov.w	r9, #1
 80149d8:	4623      	mov	r3, r4
 80149da:	469a      	mov	sl, r3
 80149dc:	f813 2b01 	ldrb.w	r2, [r3], #1
 80149e0:	b10a      	cbz	r2, 80149e6 <_vfiprintf_r+0x86>
 80149e2:	2a25      	cmp	r2, #37	@ 0x25
 80149e4:	d1f9      	bne.n	80149da <_vfiprintf_r+0x7a>
 80149e6:	ebba 0b04 	subs.w	fp, sl, r4
 80149ea:	d00b      	beq.n	8014a04 <_vfiprintf_r+0xa4>
 80149ec:	465b      	mov	r3, fp
 80149ee:	4622      	mov	r2, r4
 80149f0:	4629      	mov	r1, r5
 80149f2:	4630      	mov	r0, r6
 80149f4:	f7ff ffa1 	bl	801493a <__sfputs_r>
 80149f8:	3001      	adds	r0, #1
 80149fa:	f000 80a7 	beq.w	8014b4c <_vfiprintf_r+0x1ec>
 80149fe:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8014a00:	445a      	add	r2, fp
 8014a02:	9209      	str	r2, [sp, #36]	@ 0x24
 8014a04:	f89a 3000 	ldrb.w	r3, [sl]
 8014a08:	2b00      	cmp	r3, #0
 8014a0a:	f000 809f 	beq.w	8014b4c <_vfiprintf_r+0x1ec>
 8014a0e:	2300      	movs	r3, #0
 8014a10:	f04f 32ff 	mov.w	r2, #4294967295
 8014a14:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8014a18:	f10a 0a01 	add.w	sl, sl, #1
 8014a1c:	9304      	str	r3, [sp, #16]
 8014a1e:	9307      	str	r3, [sp, #28]
 8014a20:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 8014a24:	931a      	str	r3, [sp, #104]	@ 0x68
 8014a26:	4654      	mov	r4, sl
 8014a28:	2205      	movs	r2, #5
 8014a2a:	f814 1b01 	ldrb.w	r1, [r4], #1
 8014a2e:	4853      	ldr	r0, [pc, #332]	@ (8014b7c <_vfiprintf_r+0x21c>)
 8014a30:	f7eb fc5e 	bl	80002f0 <memchr>
 8014a34:	9a04      	ldr	r2, [sp, #16]
 8014a36:	b9d8      	cbnz	r0, 8014a70 <_vfiprintf_r+0x110>
 8014a38:	06d1      	lsls	r1, r2, #27
 8014a3a:	bf44      	itt	mi
 8014a3c:	2320      	movmi	r3, #32
 8014a3e:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 8014a42:	0713      	lsls	r3, r2, #28
 8014a44:	bf44      	itt	mi
 8014a46:	232b      	movmi	r3, #43	@ 0x2b
 8014a48:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 8014a4c:	f89a 3000 	ldrb.w	r3, [sl]
 8014a50:	2b2a      	cmp	r3, #42	@ 0x2a
 8014a52:	d015      	beq.n	8014a80 <_vfiprintf_r+0x120>
 8014a54:	9a07      	ldr	r2, [sp, #28]
 8014a56:	4654      	mov	r4, sl
 8014a58:	2000      	movs	r0, #0
 8014a5a:	f04f 0c0a 	mov.w	ip, #10
 8014a5e:	4621      	mov	r1, r4
 8014a60:	f811 3b01 	ldrb.w	r3, [r1], #1
 8014a64:	3b30      	subs	r3, #48	@ 0x30
 8014a66:	2b09      	cmp	r3, #9
 8014a68:	d94b      	bls.n	8014b02 <_vfiprintf_r+0x1a2>
 8014a6a:	b1b0      	cbz	r0, 8014a9a <_vfiprintf_r+0x13a>
 8014a6c:	9207      	str	r2, [sp, #28]
 8014a6e:	e014      	b.n	8014a9a <_vfiprintf_r+0x13a>
 8014a70:	eba0 0308 	sub.w	r3, r0, r8
 8014a74:	fa09 f303 	lsl.w	r3, r9, r3
 8014a78:	4313      	orrs	r3, r2
 8014a7a:	9304      	str	r3, [sp, #16]
 8014a7c:	46a2      	mov	sl, r4
 8014a7e:	e7d2      	b.n	8014a26 <_vfiprintf_r+0xc6>
 8014a80:	9b03      	ldr	r3, [sp, #12]
 8014a82:	1d19      	adds	r1, r3, #4
 8014a84:	681b      	ldr	r3, [r3, #0]
 8014a86:	9103      	str	r1, [sp, #12]
 8014a88:	2b00      	cmp	r3, #0
 8014a8a:	bfbb      	ittet	lt
 8014a8c:	425b      	neglt	r3, r3
 8014a8e:	f042 0202 	orrlt.w	r2, r2, #2
 8014a92:	9307      	strge	r3, [sp, #28]
 8014a94:	9307      	strlt	r3, [sp, #28]
 8014a96:	bfb8      	it	lt
 8014a98:	9204      	strlt	r2, [sp, #16]
 8014a9a:	7823      	ldrb	r3, [r4, #0]
 8014a9c:	2b2e      	cmp	r3, #46	@ 0x2e
 8014a9e:	d10a      	bne.n	8014ab6 <_vfiprintf_r+0x156>
 8014aa0:	7863      	ldrb	r3, [r4, #1]
 8014aa2:	2b2a      	cmp	r3, #42	@ 0x2a
 8014aa4:	d132      	bne.n	8014b0c <_vfiprintf_r+0x1ac>
 8014aa6:	9b03      	ldr	r3, [sp, #12]
 8014aa8:	1d1a      	adds	r2, r3, #4
 8014aaa:	681b      	ldr	r3, [r3, #0]
 8014aac:	9203      	str	r2, [sp, #12]
 8014aae:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 8014ab2:	3402      	adds	r4, #2
 8014ab4:	9305      	str	r3, [sp, #20]
 8014ab6:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 8014b8c <_vfiprintf_r+0x22c>
 8014aba:	7821      	ldrb	r1, [r4, #0]
 8014abc:	2203      	movs	r2, #3
 8014abe:	4650      	mov	r0, sl
 8014ac0:	f7eb fc16 	bl	80002f0 <memchr>
 8014ac4:	b138      	cbz	r0, 8014ad6 <_vfiprintf_r+0x176>
 8014ac6:	9b04      	ldr	r3, [sp, #16]
 8014ac8:	eba0 000a 	sub.w	r0, r0, sl
 8014acc:	2240      	movs	r2, #64	@ 0x40
 8014ace:	4082      	lsls	r2, r0
 8014ad0:	4313      	orrs	r3, r2
 8014ad2:	3401      	adds	r4, #1
 8014ad4:	9304      	str	r3, [sp, #16]
 8014ad6:	f814 1b01 	ldrb.w	r1, [r4], #1
 8014ada:	4829      	ldr	r0, [pc, #164]	@ (8014b80 <_vfiprintf_r+0x220>)
 8014adc:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 8014ae0:	2206      	movs	r2, #6
 8014ae2:	f7eb fc05 	bl	80002f0 <memchr>
 8014ae6:	2800      	cmp	r0, #0
 8014ae8:	d03f      	beq.n	8014b6a <_vfiprintf_r+0x20a>
 8014aea:	4b26      	ldr	r3, [pc, #152]	@ (8014b84 <_vfiprintf_r+0x224>)
 8014aec:	bb1b      	cbnz	r3, 8014b36 <_vfiprintf_r+0x1d6>
 8014aee:	9b03      	ldr	r3, [sp, #12]
 8014af0:	3307      	adds	r3, #7
 8014af2:	f023 0307 	bic.w	r3, r3, #7
 8014af6:	3308      	adds	r3, #8
 8014af8:	9303      	str	r3, [sp, #12]
 8014afa:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8014afc:	443b      	add	r3, r7
 8014afe:	9309      	str	r3, [sp, #36]	@ 0x24
 8014b00:	e76a      	b.n	80149d8 <_vfiprintf_r+0x78>
 8014b02:	fb0c 3202 	mla	r2, ip, r2, r3
 8014b06:	460c      	mov	r4, r1
 8014b08:	2001      	movs	r0, #1
 8014b0a:	e7a8      	b.n	8014a5e <_vfiprintf_r+0xfe>
 8014b0c:	2300      	movs	r3, #0
 8014b0e:	3401      	adds	r4, #1
 8014b10:	9305      	str	r3, [sp, #20]
 8014b12:	4619      	mov	r1, r3
 8014b14:	f04f 0c0a 	mov.w	ip, #10
 8014b18:	4620      	mov	r0, r4
 8014b1a:	f810 2b01 	ldrb.w	r2, [r0], #1
 8014b1e:	3a30      	subs	r2, #48	@ 0x30
 8014b20:	2a09      	cmp	r2, #9
 8014b22:	d903      	bls.n	8014b2c <_vfiprintf_r+0x1cc>
 8014b24:	2b00      	cmp	r3, #0
 8014b26:	d0c6      	beq.n	8014ab6 <_vfiprintf_r+0x156>
 8014b28:	9105      	str	r1, [sp, #20]
 8014b2a:	e7c4      	b.n	8014ab6 <_vfiprintf_r+0x156>
 8014b2c:	fb0c 2101 	mla	r1, ip, r1, r2
 8014b30:	4604      	mov	r4, r0
 8014b32:	2301      	movs	r3, #1
 8014b34:	e7f0      	b.n	8014b18 <_vfiprintf_r+0x1b8>
 8014b36:	ab03      	add	r3, sp, #12
 8014b38:	9300      	str	r3, [sp, #0]
 8014b3a:	462a      	mov	r2, r5
 8014b3c:	4b12      	ldr	r3, [pc, #72]	@ (8014b88 <_vfiprintf_r+0x228>)
 8014b3e:	a904      	add	r1, sp, #16
 8014b40:	4630      	mov	r0, r6
 8014b42:	f3af 8000 	nop.w
 8014b46:	4607      	mov	r7, r0
 8014b48:	1c78      	adds	r0, r7, #1
 8014b4a:	d1d6      	bne.n	8014afa <_vfiprintf_r+0x19a>
 8014b4c:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 8014b4e:	07d9      	lsls	r1, r3, #31
 8014b50:	d405      	bmi.n	8014b5e <_vfiprintf_r+0x1fe>
 8014b52:	89ab      	ldrh	r3, [r5, #12]
 8014b54:	059a      	lsls	r2, r3, #22
 8014b56:	d402      	bmi.n	8014b5e <_vfiprintf_r+0x1fe>
 8014b58:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 8014b5a:	f7ff fc49 	bl	80143f0 <__retarget_lock_release_recursive>
 8014b5e:	89ab      	ldrh	r3, [r5, #12]
 8014b60:	065b      	lsls	r3, r3, #25
 8014b62:	f53f af1f 	bmi.w	80149a4 <_vfiprintf_r+0x44>
 8014b66:	9809      	ldr	r0, [sp, #36]	@ 0x24
 8014b68:	e71e      	b.n	80149a8 <_vfiprintf_r+0x48>
 8014b6a:	ab03      	add	r3, sp, #12
 8014b6c:	9300      	str	r3, [sp, #0]
 8014b6e:	462a      	mov	r2, r5
 8014b70:	4b05      	ldr	r3, [pc, #20]	@ (8014b88 <_vfiprintf_r+0x228>)
 8014b72:	a904      	add	r1, sp, #16
 8014b74:	4630      	mov	r0, r6
 8014b76:	f000 f879 	bl	8014c6c <_printf_i>
 8014b7a:	e7e4      	b.n	8014b46 <_vfiprintf_r+0x1e6>
 8014b7c:	08019a14 	.word	0x08019a14
 8014b80:	08019a1e 	.word	0x08019a1e
 8014b84:	00000000 	.word	0x00000000
 8014b88:	0801493b 	.word	0x0801493b
 8014b8c:	08019a1a 	.word	0x08019a1a

08014b90 <_printf_common>:
 8014b90:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8014b94:	4616      	mov	r6, r2
 8014b96:	4698      	mov	r8, r3
 8014b98:	688a      	ldr	r2, [r1, #8]
 8014b9a:	690b      	ldr	r3, [r1, #16]
 8014b9c:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8014ba0:	4293      	cmp	r3, r2
 8014ba2:	bfb8      	it	lt
 8014ba4:	4613      	movlt	r3, r2
 8014ba6:	6033      	str	r3, [r6, #0]
 8014ba8:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 8014bac:	4607      	mov	r7, r0
 8014bae:	460c      	mov	r4, r1
 8014bb0:	b10a      	cbz	r2, 8014bb6 <_printf_common+0x26>
 8014bb2:	3301      	adds	r3, #1
 8014bb4:	6033      	str	r3, [r6, #0]
 8014bb6:	6823      	ldr	r3, [r4, #0]
 8014bb8:	0699      	lsls	r1, r3, #26
 8014bba:	bf42      	ittt	mi
 8014bbc:	6833      	ldrmi	r3, [r6, #0]
 8014bbe:	3302      	addmi	r3, #2
 8014bc0:	6033      	strmi	r3, [r6, #0]
 8014bc2:	6825      	ldr	r5, [r4, #0]
 8014bc4:	f015 0506 	ands.w	r5, r5, #6
 8014bc8:	d106      	bne.n	8014bd8 <_printf_common+0x48>
 8014bca:	f104 0a19 	add.w	sl, r4, #25
 8014bce:	68e3      	ldr	r3, [r4, #12]
 8014bd0:	6832      	ldr	r2, [r6, #0]
 8014bd2:	1a9b      	subs	r3, r3, r2
 8014bd4:	42ab      	cmp	r3, r5
 8014bd6:	dc26      	bgt.n	8014c26 <_printf_common+0x96>
 8014bd8:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 8014bdc:	6822      	ldr	r2, [r4, #0]
 8014bde:	3b00      	subs	r3, #0
 8014be0:	bf18      	it	ne
 8014be2:	2301      	movne	r3, #1
 8014be4:	0692      	lsls	r2, r2, #26
 8014be6:	d42b      	bmi.n	8014c40 <_printf_common+0xb0>
 8014be8:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 8014bec:	4641      	mov	r1, r8
 8014bee:	4638      	mov	r0, r7
 8014bf0:	47c8      	blx	r9
 8014bf2:	3001      	adds	r0, #1
 8014bf4:	d01e      	beq.n	8014c34 <_printf_common+0xa4>
 8014bf6:	6823      	ldr	r3, [r4, #0]
 8014bf8:	6922      	ldr	r2, [r4, #16]
 8014bfa:	f003 0306 	and.w	r3, r3, #6
 8014bfe:	2b04      	cmp	r3, #4
 8014c00:	bf02      	ittt	eq
 8014c02:	68e5      	ldreq	r5, [r4, #12]
 8014c04:	6833      	ldreq	r3, [r6, #0]
 8014c06:	1aed      	subeq	r5, r5, r3
 8014c08:	68a3      	ldr	r3, [r4, #8]
 8014c0a:	bf0c      	ite	eq
 8014c0c:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8014c10:	2500      	movne	r5, #0
 8014c12:	4293      	cmp	r3, r2
 8014c14:	bfc4      	itt	gt
 8014c16:	1a9b      	subgt	r3, r3, r2
 8014c18:	18ed      	addgt	r5, r5, r3
 8014c1a:	2600      	movs	r6, #0
 8014c1c:	341a      	adds	r4, #26
 8014c1e:	42b5      	cmp	r5, r6
 8014c20:	d11a      	bne.n	8014c58 <_printf_common+0xc8>
 8014c22:	2000      	movs	r0, #0
 8014c24:	e008      	b.n	8014c38 <_printf_common+0xa8>
 8014c26:	2301      	movs	r3, #1
 8014c28:	4652      	mov	r2, sl
 8014c2a:	4641      	mov	r1, r8
 8014c2c:	4638      	mov	r0, r7
 8014c2e:	47c8      	blx	r9
 8014c30:	3001      	adds	r0, #1
 8014c32:	d103      	bne.n	8014c3c <_printf_common+0xac>
 8014c34:	f04f 30ff 	mov.w	r0, #4294967295
 8014c38:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8014c3c:	3501      	adds	r5, #1
 8014c3e:	e7c6      	b.n	8014bce <_printf_common+0x3e>
 8014c40:	18e1      	adds	r1, r4, r3
 8014c42:	1c5a      	adds	r2, r3, #1
 8014c44:	2030      	movs	r0, #48	@ 0x30
 8014c46:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 8014c4a:	4422      	add	r2, r4
 8014c4c:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 8014c50:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 8014c54:	3302      	adds	r3, #2
 8014c56:	e7c7      	b.n	8014be8 <_printf_common+0x58>
 8014c58:	2301      	movs	r3, #1
 8014c5a:	4622      	mov	r2, r4
 8014c5c:	4641      	mov	r1, r8
 8014c5e:	4638      	mov	r0, r7
 8014c60:	47c8      	blx	r9
 8014c62:	3001      	adds	r0, #1
 8014c64:	d0e6      	beq.n	8014c34 <_printf_common+0xa4>
 8014c66:	3601      	adds	r6, #1
 8014c68:	e7d9      	b.n	8014c1e <_printf_common+0x8e>
	...

08014c6c <_printf_i>:
 8014c6c:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8014c70:	7e0f      	ldrb	r7, [r1, #24]
 8014c72:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 8014c74:	2f78      	cmp	r7, #120	@ 0x78
 8014c76:	4691      	mov	r9, r2
 8014c78:	4680      	mov	r8, r0
 8014c7a:	460c      	mov	r4, r1
 8014c7c:	469a      	mov	sl, r3
 8014c7e:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 8014c82:	d807      	bhi.n	8014c94 <_printf_i+0x28>
 8014c84:	2f62      	cmp	r7, #98	@ 0x62
 8014c86:	d80a      	bhi.n	8014c9e <_printf_i+0x32>
 8014c88:	2f00      	cmp	r7, #0
 8014c8a:	f000 80d1 	beq.w	8014e30 <_printf_i+0x1c4>
 8014c8e:	2f58      	cmp	r7, #88	@ 0x58
 8014c90:	f000 80b8 	beq.w	8014e04 <_printf_i+0x198>
 8014c94:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 8014c98:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 8014c9c:	e03a      	b.n	8014d14 <_printf_i+0xa8>
 8014c9e:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 8014ca2:	2b15      	cmp	r3, #21
 8014ca4:	d8f6      	bhi.n	8014c94 <_printf_i+0x28>
 8014ca6:	a101      	add	r1, pc, #4	@ (adr r1, 8014cac <_printf_i+0x40>)
 8014ca8:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8014cac:	08014d05 	.word	0x08014d05
 8014cb0:	08014d19 	.word	0x08014d19
 8014cb4:	08014c95 	.word	0x08014c95
 8014cb8:	08014c95 	.word	0x08014c95
 8014cbc:	08014c95 	.word	0x08014c95
 8014cc0:	08014c95 	.word	0x08014c95
 8014cc4:	08014d19 	.word	0x08014d19
 8014cc8:	08014c95 	.word	0x08014c95
 8014ccc:	08014c95 	.word	0x08014c95
 8014cd0:	08014c95 	.word	0x08014c95
 8014cd4:	08014c95 	.word	0x08014c95
 8014cd8:	08014e17 	.word	0x08014e17
 8014cdc:	08014d43 	.word	0x08014d43
 8014ce0:	08014dd1 	.word	0x08014dd1
 8014ce4:	08014c95 	.word	0x08014c95
 8014ce8:	08014c95 	.word	0x08014c95
 8014cec:	08014e39 	.word	0x08014e39
 8014cf0:	08014c95 	.word	0x08014c95
 8014cf4:	08014d43 	.word	0x08014d43
 8014cf8:	08014c95 	.word	0x08014c95
 8014cfc:	08014c95 	.word	0x08014c95
 8014d00:	08014dd9 	.word	0x08014dd9
 8014d04:	6833      	ldr	r3, [r6, #0]
 8014d06:	1d1a      	adds	r2, r3, #4
 8014d08:	681b      	ldr	r3, [r3, #0]
 8014d0a:	6032      	str	r2, [r6, #0]
 8014d0c:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 8014d10:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 8014d14:	2301      	movs	r3, #1
 8014d16:	e09c      	b.n	8014e52 <_printf_i+0x1e6>
 8014d18:	6833      	ldr	r3, [r6, #0]
 8014d1a:	6820      	ldr	r0, [r4, #0]
 8014d1c:	1d19      	adds	r1, r3, #4
 8014d1e:	6031      	str	r1, [r6, #0]
 8014d20:	0606      	lsls	r6, r0, #24
 8014d22:	d501      	bpl.n	8014d28 <_printf_i+0xbc>
 8014d24:	681d      	ldr	r5, [r3, #0]
 8014d26:	e003      	b.n	8014d30 <_printf_i+0xc4>
 8014d28:	0645      	lsls	r5, r0, #25
 8014d2a:	d5fb      	bpl.n	8014d24 <_printf_i+0xb8>
 8014d2c:	f9b3 5000 	ldrsh.w	r5, [r3]
 8014d30:	2d00      	cmp	r5, #0
 8014d32:	da03      	bge.n	8014d3c <_printf_i+0xd0>
 8014d34:	232d      	movs	r3, #45	@ 0x2d
 8014d36:	426d      	negs	r5, r5
 8014d38:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8014d3c:	4858      	ldr	r0, [pc, #352]	@ (8014ea0 <_printf_i+0x234>)
 8014d3e:	230a      	movs	r3, #10
 8014d40:	e011      	b.n	8014d66 <_printf_i+0xfa>
 8014d42:	6821      	ldr	r1, [r4, #0]
 8014d44:	6833      	ldr	r3, [r6, #0]
 8014d46:	0608      	lsls	r0, r1, #24
 8014d48:	f853 5b04 	ldr.w	r5, [r3], #4
 8014d4c:	d402      	bmi.n	8014d54 <_printf_i+0xe8>
 8014d4e:	0649      	lsls	r1, r1, #25
 8014d50:	bf48      	it	mi
 8014d52:	b2ad      	uxthmi	r5, r5
 8014d54:	2f6f      	cmp	r7, #111	@ 0x6f
 8014d56:	4852      	ldr	r0, [pc, #328]	@ (8014ea0 <_printf_i+0x234>)
 8014d58:	6033      	str	r3, [r6, #0]
 8014d5a:	bf14      	ite	ne
 8014d5c:	230a      	movne	r3, #10
 8014d5e:	2308      	moveq	r3, #8
 8014d60:	2100      	movs	r1, #0
 8014d62:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 8014d66:	6866      	ldr	r6, [r4, #4]
 8014d68:	60a6      	str	r6, [r4, #8]
 8014d6a:	2e00      	cmp	r6, #0
 8014d6c:	db05      	blt.n	8014d7a <_printf_i+0x10e>
 8014d6e:	6821      	ldr	r1, [r4, #0]
 8014d70:	432e      	orrs	r6, r5
 8014d72:	f021 0104 	bic.w	r1, r1, #4
 8014d76:	6021      	str	r1, [r4, #0]
 8014d78:	d04b      	beq.n	8014e12 <_printf_i+0x1a6>
 8014d7a:	4616      	mov	r6, r2
 8014d7c:	fbb5 f1f3 	udiv	r1, r5, r3
 8014d80:	fb03 5711 	mls	r7, r3, r1, r5
 8014d84:	5dc7      	ldrb	r7, [r0, r7]
 8014d86:	f806 7d01 	strb.w	r7, [r6, #-1]!
 8014d8a:	462f      	mov	r7, r5
 8014d8c:	42bb      	cmp	r3, r7
 8014d8e:	460d      	mov	r5, r1
 8014d90:	d9f4      	bls.n	8014d7c <_printf_i+0x110>
 8014d92:	2b08      	cmp	r3, #8
 8014d94:	d10b      	bne.n	8014dae <_printf_i+0x142>
 8014d96:	6823      	ldr	r3, [r4, #0]
 8014d98:	07df      	lsls	r7, r3, #31
 8014d9a:	d508      	bpl.n	8014dae <_printf_i+0x142>
 8014d9c:	6923      	ldr	r3, [r4, #16]
 8014d9e:	6861      	ldr	r1, [r4, #4]
 8014da0:	4299      	cmp	r1, r3
 8014da2:	bfde      	ittt	le
 8014da4:	2330      	movle	r3, #48	@ 0x30
 8014da6:	f806 3c01 	strble.w	r3, [r6, #-1]
 8014daa:	f106 36ff 	addle.w	r6, r6, #4294967295
 8014dae:	1b92      	subs	r2, r2, r6
 8014db0:	6122      	str	r2, [r4, #16]
 8014db2:	f8cd a000 	str.w	sl, [sp]
 8014db6:	464b      	mov	r3, r9
 8014db8:	aa03      	add	r2, sp, #12
 8014dba:	4621      	mov	r1, r4
 8014dbc:	4640      	mov	r0, r8
 8014dbe:	f7ff fee7 	bl	8014b90 <_printf_common>
 8014dc2:	3001      	adds	r0, #1
 8014dc4:	d14a      	bne.n	8014e5c <_printf_i+0x1f0>
 8014dc6:	f04f 30ff 	mov.w	r0, #4294967295
 8014dca:	b004      	add	sp, #16
 8014dcc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8014dd0:	6823      	ldr	r3, [r4, #0]
 8014dd2:	f043 0320 	orr.w	r3, r3, #32
 8014dd6:	6023      	str	r3, [r4, #0]
 8014dd8:	4832      	ldr	r0, [pc, #200]	@ (8014ea4 <_printf_i+0x238>)
 8014dda:	2778      	movs	r7, #120	@ 0x78
 8014ddc:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 8014de0:	6823      	ldr	r3, [r4, #0]
 8014de2:	6831      	ldr	r1, [r6, #0]
 8014de4:	061f      	lsls	r7, r3, #24
 8014de6:	f851 5b04 	ldr.w	r5, [r1], #4
 8014dea:	d402      	bmi.n	8014df2 <_printf_i+0x186>
 8014dec:	065f      	lsls	r7, r3, #25
 8014dee:	bf48      	it	mi
 8014df0:	b2ad      	uxthmi	r5, r5
 8014df2:	6031      	str	r1, [r6, #0]
 8014df4:	07d9      	lsls	r1, r3, #31
 8014df6:	bf44      	itt	mi
 8014df8:	f043 0320 	orrmi.w	r3, r3, #32
 8014dfc:	6023      	strmi	r3, [r4, #0]
 8014dfe:	b11d      	cbz	r5, 8014e08 <_printf_i+0x19c>
 8014e00:	2310      	movs	r3, #16
 8014e02:	e7ad      	b.n	8014d60 <_printf_i+0xf4>
 8014e04:	4826      	ldr	r0, [pc, #152]	@ (8014ea0 <_printf_i+0x234>)
 8014e06:	e7e9      	b.n	8014ddc <_printf_i+0x170>
 8014e08:	6823      	ldr	r3, [r4, #0]
 8014e0a:	f023 0320 	bic.w	r3, r3, #32
 8014e0e:	6023      	str	r3, [r4, #0]
 8014e10:	e7f6      	b.n	8014e00 <_printf_i+0x194>
 8014e12:	4616      	mov	r6, r2
 8014e14:	e7bd      	b.n	8014d92 <_printf_i+0x126>
 8014e16:	6833      	ldr	r3, [r6, #0]
 8014e18:	6825      	ldr	r5, [r4, #0]
 8014e1a:	6961      	ldr	r1, [r4, #20]
 8014e1c:	1d18      	adds	r0, r3, #4
 8014e1e:	6030      	str	r0, [r6, #0]
 8014e20:	062e      	lsls	r6, r5, #24
 8014e22:	681b      	ldr	r3, [r3, #0]
 8014e24:	d501      	bpl.n	8014e2a <_printf_i+0x1be>
 8014e26:	6019      	str	r1, [r3, #0]
 8014e28:	e002      	b.n	8014e30 <_printf_i+0x1c4>
 8014e2a:	0668      	lsls	r0, r5, #25
 8014e2c:	d5fb      	bpl.n	8014e26 <_printf_i+0x1ba>
 8014e2e:	8019      	strh	r1, [r3, #0]
 8014e30:	2300      	movs	r3, #0
 8014e32:	6123      	str	r3, [r4, #16]
 8014e34:	4616      	mov	r6, r2
 8014e36:	e7bc      	b.n	8014db2 <_printf_i+0x146>
 8014e38:	6833      	ldr	r3, [r6, #0]
 8014e3a:	1d1a      	adds	r2, r3, #4
 8014e3c:	6032      	str	r2, [r6, #0]
 8014e3e:	681e      	ldr	r6, [r3, #0]
 8014e40:	6862      	ldr	r2, [r4, #4]
 8014e42:	2100      	movs	r1, #0
 8014e44:	4630      	mov	r0, r6
 8014e46:	f7eb fa53 	bl	80002f0 <memchr>
 8014e4a:	b108      	cbz	r0, 8014e50 <_printf_i+0x1e4>
 8014e4c:	1b80      	subs	r0, r0, r6
 8014e4e:	6060      	str	r0, [r4, #4]
 8014e50:	6863      	ldr	r3, [r4, #4]
 8014e52:	6123      	str	r3, [r4, #16]
 8014e54:	2300      	movs	r3, #0
 8014e56:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8014e5a:	e7aa      	b.n	8014db2 <_printf_i+0x146>
 8014e5c:	6923      	ldr	r3, [r4, #16]
 8014e5e:	4632      	mov	r2, r6
 8014e60:	4649      	mov	r1, r9
 8014e62:	4640      	mov	r0, r8
 8014e64:	47d0      	blx	sl
 8014e66:	3001      	adds	r0, #1
 8014e68:	d0ad      	beq.n	8014dc6 <_printf_i+0x15a>
 8014e6a:	6823      	ldr	r3, [r4, #0]
 8014e6c:	079b      	lsls	r3, r3, #30
 8014e6e:	d413      	bmi.n	8014e98 <_printf_i+0x22c>
 8014e70:	68e0      	ldr	r0, [r4, #12]
 8014e72:	9b03      	ldr	r3, [sp, #12]
 8014e74:	4298      	cmp	r0, r3
 8014e76:	bfb8      	it	lt
 8014e78:	4618      	movlt	r0, r3
 8014e7a:	e7a6      	b.n	8014dca <_printf_i+0x15e>
 8014e7c:	2301      	movs	r3, #1
 8014e7e:	4632      	mov	r2, r6
 8014e80:	4649      	mov	r1, r9
 8014e82:	4640      	mov	r0, r8
 8014e84:	47d0      	blx	sl
 8014e86:	3001      	adds	r0, #1
 8014e88:	d09d      	beq.n	8014dc6 <_printf_i+0x15a>
 8014e8a:	3501      	adds	r5, #1
 8014e8c:	68e3      	ldr	r3, [r4, #12]
 8014e8e:	9903      	ldr	r1, [sp, #12]
 8014e90:	1a5b      	subs	r3, r3, r1
 8014e92:	42ab      	cmp	r3, r5
 8014e94:	dcf2      	bgt.n	8014e7c <_printf_i+0x210>
 8014e96:	e7eb      	b.n	8014e70 <_printf_i+0x204>
 8014e98:	2500      	movs	r5, #0
 8014e9a:	f104 0619 	add.w	r6, r4, #25
 8014e9e:	e7f5      	b.n	8014e8c <_printf_i+0x220>
 8014ea0:	08019a25 	.word	0x08019a25
 8014ea4:	08019a36 	.word	0x08019a36

08014ea8 <__sflush_r>:
 8014ea8:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 8014eac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8014eb0:	0716      	lsls	r6, r2, #28
 8014eb2:	4605      	mov	r5, r0
 8014eb4:	460c      	mov	r4, r1
 8014eb6:	d454      	bmi.n	8014f62 <__sflush_r+0xba>
 8014eb8:	684b      	ldr	r3, [r1, #4]
 8014eba:	2b00      	cmp	r3, #0
 8014ebc:	dc02      	bgt.n	8014ec4 <__sflush_r+0x1c>
 8014ebe:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 8014ec0:	2b00      	cmp	r3, #0
 8014ec2:	dd48      	ble.n	8014f56 <__sflush_r+0xae>
 8014ec4:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 8014ec6:	2e00      	cmp	r6, #0
 8014ec8:	d045      	beq.n	8014f56 <__sflush_r+0xae>
 8014eca:	2300      	movs	r3, #0
 8014ecc:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 8014ed0:	682f      	ldr	r7, [r5, #0]
 8014ed2:	6a21      	ldr	r1, [r4, #32]
 8014ed4:	602b      	str	r3, [r5, #0]
 8014ed6:	d030      	beq.n	8014f3a <__sflush_r+0x92>
 8014ed8:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 8014eda:	89a3      	ldrh	r3, [r4, #12]
 8014edc:	0759      	lsls	r1, r3, #29
 8014ede:	d505      	bpl.n	8014eec <__sflush_r+0x44>
 8014ee0:	6863      	ldr	r3, [r4, #4]
 8014ee2:	1ad2      	subs	r2, r2, r3
 8014ee4:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 8014ee6:	b10b      	cbz	r3, 8014eec <__sflush_r+0x44>
 8014ee8:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 8014eea:	1ad2      	subs	r2, r2, r3
 8014eec:	2300      	movs	r3, #0
 8014eee:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 8014ef0:	6a21      	ldr	r1, [r4, #32]
 8014ef2:	4628      	mov	r0, r5
 8014ef4:	47b0      	blx	r6
 8014ef6:	1c43      	adds	r3, r0, #1
 8014ef8:	89a3      	ldrh	r3, [r4, #12]
 8014efa:	d106      	bne.n	8014f0a <__sflush_r+0x62>
 8014efc:	6829      	ldr	r1, [r5, #0]
 8014efe:	291d      	cmp	r1, #29
 8014f00:	d82b      	bhi.n	8014f5a <__sflush_r+0xb2>
 8014f02:	4a2a      	ldr	r2, [pc, #168]	@ (8014fac <__sflush_r+0x104>)
 8014f04:	40ca      	lsrs	r2, r1
 8014f06:	07d6      	lsls	r6, r2, #31
 8014f08:	d527      	bpl.n	8014f5a <__sflush_r+0xb2>
 8014f0a:	2200      	movs	r2, #0
 8014f0c:	6062      	str	r2, [r4, #4]
 8014f0e:	04d9      	lsls	r1, r3, #19
 8014f10:	6922      	ldr	r2, [r4, #16]
 8014f12:	6022      	str	r2, [r4, #0]
 8014f14:	d504      	bpl.n	8014f20 <__sflush_r+0x78>
 8014f16:	1c42      	adds	r2, r0, #1
 8014f18:	d101      	bne.n	8014f1e <__sflush_r+0x76>
 8014f1a:	682b      	ldr	r3, [r5, #0]
 8014f1c:	b903      	cbnz	r3, 8014f20 <__sflush_r+0x78>
 8014f1e:	6560      	str	r0, [r4, #84]	@ 0x54
 8014f20:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 8014f22:	602f      	str	r7, [r5, #0]
 8014f24:	b1b9      	cbz	r1, 8014f56 <__sflush_r+0xae>
 8014f26:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 8014f2a:	4299      	cmp	r1, r3
 8014f2c:	d002      	beq.n	8014f34 <__sflush_r+0x8c>
 8014f2e:	4628      	mov	r0, r5
 8014f30:	f7ff fa94 	bl	801445c <_free_r>
 8014f34:	2300      	movs	r3, #0
 8014f36:	6363      	str	r3, [r4, #52]	@ 0x34
 8014f38:	e00d      	b.n	8014f56 <__sflush_r+0xae>
 8014f3a:	2301      	movs	r3, #1
 8014f3c:	4628      	mov	r0, r5
 8014f3e:	47b0      	blx	r6
 8014f40:	4602      	mov	r2, r0
 8014f42:	1c50      	adds	r0, r2, #1
 8014f44:	d1c9      	bne.n	8014eda <__sflush_r+0x32>
 8014f46:	682b      	ldr	r3, [r5, #0]
 8014f48:	2b00      	cmp	r3, #0
 8014f4a:	d0c6      	beq.n	8014eda <__sflush_r+0x32>
 8014f4c:	2b1d      	cmp	r3, #29
 8014f4e:	d001      	beq.n	8014f54 <__sflush_r+0xac>
 8014f50:	2b16      	cmp	r3, #22
 8014f52:	d11e      	bne.n	8014f92 <__sflush_r+0xea>
 8014f54:	602f      	str	r7, [r5, #0]
 8014f56:	2000      	movs	r0, #0
 8014f58:	e022      	b.n	8014fa0 <__sflush_r+0xf8>
 8014f5a:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8014f5e:	b21b      	sxth	r3, r3
 8014f60:	e01b      	b.n	8014f9a <__sflush_r+0xf2>
 8014f62:	690f      	ldr	r7, [r1, #16]
 8014f64:	2f00      	cmp	r7, #0
 8014f66:	d0f6      	beq.n	8014f56 <__sflush_r+0xae>
 8014f68:	0793      	lsls	r3, r2, #30
 8014f6a:	680e      	ldr	r6, [r1, #0]
 8014f6c:	bf08      	it	eq
 8014f6e:	694b      	ldreq	r3, [r1, #20]
 8014f70:	600f      	str	r7, [r1, #0]
 8014f72:	bf18      	it	ne
 8014f74:	2300      	movne	r3, #0
 8014f76:	eba6 0807 	sub.w	r8, r6, r7
 8014f7a:	608b      	str	r3, [r1, #8]
 8014f7c:	f1b8 0f00 	cmp.w	r8, #0
 8014f80:	dde9      	ble.n	8014f56 <__sflush_r+0xae>
 8014f82:	6a21      	ldr	r1, [r4, #32]
 8014f84:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 8014f86:	4643      	mov	r3, r8
 8014f88:	463a      	mov	r2, r7
 8014f8a:	4628      	mov	r0, r5
 8014f8c:	47b0      	blx	r6
 8014f8e:	2800      	cmp	r0, #0
 8014f90:	dc08      	bgt.n	8014fa4 <__sflush_r+0xfc>
 8014f92:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8014f96:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8014f9a:	81a3      	strh	r3, [r4, #12]
 8014f9c:	f04f 30ff 	mov.w	r0, #4294967295
 8014fa0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8014fa4:	4407      	add	r7, r0
 8014fa6:	eba8 0800 	sub.w	r8, r8, r0
 8014faa:	e7e7      	b.n	8014f7c <__sflush_r+0xd4>
 8014fac:	20400001 	.word	0x20400001

08014fb0 <_fflush_r>:
 8014fb0:	b538      	push	{r3, r4, r5, lr}
 8014fb2:	690b      	ldr	r3, [r1, #16]
 8014fb4:	4605      	mov	r5, r0
 8014fb6:	460c      	mov	r4, r1
 8014fb8:	b913      	cbnz	r3, 8014fc0 <_fflush_r+0x10>
 8014fba:	2500      	movs	r5, #0
 8014fbc:	4628      	mov	r0, r5
 8014fbe:	bd38      	pop	{r3, r4, r5, pc}
 8014fc0:	b118      	cbz	r0, 8014fca <_fflush_r+0x1a>
 8014fc2:	6a03      	ldr	r3, [r0, #32]
 8014fc4:	b90b      	cbnz	r3, 8014fca <_fflush_r+0x1a>
 8014fc6:	f7fe ffa5 	bl	8013f14 <__sinit>
 8014fca:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8014fce:	2b00      	cmp	r3, #0
 8014fd0:	d0f3      	beq.n	8014fba <_fflush_r+0xa>
 8014fd2:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 8014fd4:	07d0      	lsls	r0, r2, #31
 8014fd6:	d404      	bmi.n	8014fe2 <_fflush_r+0x32>
 8014fd8:	0599      	lsls	r1, r3, #22
 8014fda:	d402      	bmi.n	8014fe2 <_fflush_r+0x32>
 8014fdc:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8014fde:	f7ff fa06 	bl	80143ee <__retarget_lock_acquire_recursive>
 8014fe2:	4628      	mov	r0, r5
 8014fe4:	4621      	mov	r1, r4
 8014fe6:	f7ff ff5f 	bl	8014ea8 <__sflush_r>
 8014fea:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8014fec:	07da      	lsls	r2, r3, #31
 8014fee:	4605      	mov	r5, r0
 8014ff0:	d4e4      	bmi.n	8014fbc <_fflush_r+0xc>
 8014ff2:	89a3      	ldrh	r3, [r4, #12]
 8014ff4:	059b      	lsls	r3, r3, #22
 8014ff6:	d4e1      	bmi.n	8014fbc <_fflush_r+0xc>
 8014ff8:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8014ffa:	f7ff f9f9 	bl	80143f0 <__retarget_lock_release_recursive>
 8014ffe:	e7dd      	b.n	8014fbc <_fflush_r+0xc>

08015000 <fiprintf>:
 8015000:	b40e      	push	{r1, r2, r3}
 8015002:	b503      	push	{r0, r1, lr}
 8015004:	4601      	mov	r1, r0
 8015006:	ab03      	add	r3, sp, #12
 8015008:	4805      	ldr	r0, [pc, #20]	@ (8015020 <fiprintf+0x20>)
 801500a:	f853 2b04 	ldr.w	r2, [r3], #4
 801500e:	6800      	ldr	r0, [r0, #0]
 8015010:	9301      	str	r3, [sp, #4]
 8015012:	f7ff fca5 	bl	8014960 <_vfiprintf_r>
 8015016:	b002      	add	sp, #8
 8015018:	f85d eb04 	ldr.w	lr, [sp], #4
 801501c:	b003      	add	sp, #12
 801501e:	4770      	bx	lr
 8015020:	2400003c 	.word	0x2400003c

08015024 <__swhatbuf_r>:
 8015024:	b570      	push	{r4, r5, r6, lr}
 8015026:	460c      	mov	r4, r1
 8015028:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801502c:	2900      	cmp	r1, #0
 801502e:	b096      	sub	sp, #88	@ 0x58
 8015030:	4615      	mov	r5, r2
 8015032:	461e      	mov	r6, r3
 8015034:	da0d      	bge.n	8015052 <__swhatbuf_r+0x2e>
 8015036:	89a3      	ldrh	r3, [r4, #12]
 8015038:	f013 0f80 	tst.w	r3, #128	@ 0x80
 801503c:	f04f 0100 	mov.w	r1, #0
 8015040:	bf14      	ite	ne
 8015042:	2340      	movne	r3, #64	@ 0x40
 8015044:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
 8015048:	2000      	movs	r0, #0
 801504a:	6031      	str	r1, [r6, #0]
 801504c:	602b      	str	r3, [r5, #0]
 801504e:	b016      	add	sp, #88	@ 0x58
 8015050:	bd70      	pop	{r4, r5, r6, pc}
 8015052:	466a      	mov	r2, sp
 8015054:	f000 f87c 	bl	8015150 <_fstat_r>
 8015058:	2800      	cmp	r0, #0
 801505a:	dbec      	blt.n	8015036 <__swhatbuf_r+0x12>
 801505c:	9901      	ldr	r1, [sp, #4]
 801505e:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
 8015062:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
 8015066:	4259      	negs	r1, r3
 8015068:	4159      	adcs	r1, r3
 801506a:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 801506e:	e7eb      	b.n	8015048 <__swhatbuf_r+0x24>

08015070 <__smakebuf_r>:
 8015070:	898b      	ldrh	r3, [r1, #12]
 8015072:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8015074:	079d      	lsls	r5, r3, #30
 8015076:	4606      	mov	r6, r0
 8015078:	460c      	mov	r4, r1
 801507a:	d507      	bpl.n	801508c <__smakebuf_r+0x1c>
 801507c:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 8015080:	6023      	str	r3, [r4, #0]
 8015082:	6123      	str	r3, [r4, #16]
 8015084:	2301      	movs	r3, #1
 8015086:	6163      	str	r3, [r4, #20]
 8015088:	b003      	add	sp, #12
 801508a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801508c:	ab01      	add	r3, sp, #4
 801508e:	466a      	mov	r2, sp
 8015090:	f7ff ffc8 	bl	8015024 <__swhatbuf_r>
 8015094:	9f00      	ldr	r7, [sp, #0]
 8015096:	4605      	mov	r5, r0
 8015098:	4639      	mov	r1, r7
 801509a:	4630      	mov	r0, r6
 801509c:	f7ff fa52 	bl	8014544 <_malloc_r>
 80150a0:	b948      	cbnz	r0, 80150b6 <__smakebuf_r+0x46>
 80150a2:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80150a6:	059a      	lsls	r2, r3, #22
 80150a8:	d4ee      	bmi.n	8015088 <__smakebuf_r+0x18>
 80150aa:	f023 0303 	bic.w	r3, r3, #3
 80150ae:	f043 0302 	orr.w	r3, r3, #2
 80150b2:	81a3      	strh	r3, [r4, #12]
 80150b4:	e7e2      	b.n	801507c <__smakebuf_r+0xc>
 80150b6:	89a3      	ldrh	r3, [r4, #12]
 80150b8:	6020      	str	r0, [r4, #0]
 80150ba:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 80150be:	81a3      	strh	r3, [r4, #12]
 80150c0:	9b01      	ldr	r3, [sp, #4]
 80150c2:	e9c4 0704 	strd	r0, r7, [r4, #16]
 80150c6:	b15b      	cbz	r3, 80150e0 <__smakebuf_r+0x70>
 80150c8:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80150cc:	4630      	mov	r0, r6
 80150ce:	f000 f851 	bl	8015174 <_isatty_r>
 80150d2:	b128      	cbz	r0, 80150e0 <__smakebuf_r+0x70>
 80150d4:	89a3      	ldrh	r3, [r4, #12]
 80150d6:	f023 0303 	bic.w	r3, r3, #3
 80150da:	f043 0301 	orr.w	r3, r3, #1
 80150de:	81a3      	strh	r3, [r4, #12]
 80150e0:	89a3      	ldrh	r3, [r4, #12]
 80150e2:	431d      	orrs	r5, r3
 80150e4:	81a5      	strh	r5, [r4, #12]
 80150e6:	e7cf      	b.n	8015088 <__smakebuf_r+0x18>

080150e8 <_putc_r>:
 80150e8:	b570      	push	{r4, r5, r6, lr}
 80150ea:	460d      	mov	r5, r1
 80150ec:	4614      	mov	r4, r2
 80150ee:	4606      	mov	r6, r0
 80150f0:	b118      	cbz	r0, 80150fa <_putc_r+0x12>
 80150f2:	6a03      	ldr	r3, [r0, #32]
 80150f4:	b90b      	cbnz	r3, 80150fa <_putc_r+0x12>
 80150f6:	f7fe ff0d 	bl	8013f14 <__sinit>
 80150fa:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 80150fc:	07d8      	lsls	r0, r3, #31
 80150fe:	d405      	bmi.n	801510c <_putc_r+0x24>
 8015100:	89a3      	ldrh	r3, [r4, #12]
 8015102:	0599      	lsls	r1, r3, #22
 8015104:	d402      	bmi.n	801510c <_putc_r+0x24>
 8015106:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8015108:	f7ff f971 	bl	80143ee <__retarget_lock_acquire_recursive>
 801510c:	68a3      	ldr	r3, [r4, #8]
 801510e:	3b01      	subs	r3, #1
 8015110:	2b00      	cmp	r3, #0
 8015112:	60a3      	str	r3, [r4, #8]
 8015114:	da05      	bge.n	8015122 <_putc_r+0x3a>
 8015116:	69a2      	ldr	r2, [r4, #24]
 8015118:	4293      	cmp	r3, r2
 801511a:	db12      	blt.n	8015142 <_putc_r+0x5a>
 801511c:	b2eb      	uxtb	r3, r5
 801511e:	2b0a      	cmp	r3, #10
 8015120:	d00f      	beq.n	8015142 <_putc_r+0x5a>
 8015122:	6823      	ldr	r3, [r4, #0]
 8015124:	1c5a      	adds	r2, r3, #1
 8015126:	6022      	str	r2, [r4, #0]
 8015128:	701d      	strb	r5, [r3, #0]
 801512a:	b2ed      	uxtb	r5, r5
 801512c:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 801512e:	07da      	lsls	r2, r3, #31
 8015130:	d405      	bmi.n	801513e <_putc_r+0x56>
 8015132:	89a3      	ldrh	r3, [r4, #12]
 8015134:	059b      	lsls	r3, r3, #22
 8015136:	d402      	bmi.n	801513e <_putc_r+0x56>
 8015138:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 801513a:	f7ff f959 	bl	80143f0 <__retarget_lock_release_recursive>
 801513e:	4628      	mov	r0, r5
 8015140:	bd70      	pop	{r4, r5, r6, pc}
 8015142:	4629      	mov	r1, r5
 8015144:	4622      	mov	r2, r4
 8015146:	4630      	mov	r0, r6
 8015148:	f7fe fff7 	bl	801413a <__swbuf_r>
 801514c:	4605      	mov	r5, r0
 801514e:	e7ed      	b.n	801512c <_putc_r+0x44>

08015150 <_fstat_r>:
 8015150:	b538      	push	{r3, r4, r5, lr}
 8015152:	4d07      	ldr	r5, [pc, #28]	@ (8015170 <_fstat_r+0x20>)
 8015154:	2300      	movs	r3, #0
 8015156:	4604      	mov	r4, r0
 8015158:	4608      	mov	r0, r1
 801515a:	4611      	mov	r1, r2
 801515c:	602b      	str	r3, [r5, #0]
 801515e:	f7eb fe34 	bl	8000dca <_fstat>
 8015162:	1c43      	adds	r3, r0, #1
 8015164:	d102      	bne.n	801516c <_fstat_r+0x1c>
 8015166:	682b      	ldr	r3, [r5, #0]
 8015168:	b103      	cbz	r3, 801516c <_fstat_r+0x1c>
 801516a:	6023      	str	r3, [r4, #0]
 801516c:	bd38      	pop	{r3, r4, r5, pc}
 801516e:	bf00      	nop
 8015170:	24014444 	.word	0x24014444

08015174 <_isatty_r>:
 8015174:	b538      	push	{r3, r4, r5, lr}
 8015176:	4d06      	ldr	r5, [pc, #24]	@ (8015190 <_isatty_r+0x1c>)
 8015178:	2300      	movs	r3, #0
 801517a:	4604      	mov	r4, r0
 801517c:	4608      	mov	r0, r1
 801517e:	602b      	str	r3, [r5, #0]
 8015180:	f7eb fe28 	bl	8000dd4 <_isatty>
 8015184:	1c43      	adds	r3, r0, #1
 8015186:	d102      	bne.n	801518e <_isatty_r+0x1a>
 8015188:	682b      	ldr	r3, [r5, #0]
 801518a:	b103      	cbz	r3, 801518e <_isatty_r+0x1a>
 801518c:	6023      	str	r3, [r4, #0]
 801518e:	bd38      	pop	{r3, r4, r5, pc}
 8015190:	24014444 	.word	0x24014444

08015194 <_sbrk_r>:
 8015194:	b538      	push	{r3, r4, r5, lr}
 8015196:	4d06      	ldr	r5, [pc, #24]	@ (80151b0 <_sbrk_r+0x1c>)
 8015198:	2300      	movs	r3, #0
 801519a:	4604      	mov	r4, r0
 801519c:	4608      	mov	r0, r1
 801519e:	602b      	str	r3, [r5, #0]
 80151a0:	f7eb fe1c 	bl	8000ddc <_sbrk>
 80151a4:	1c43      	adds	r3, r0, #1
 80151a6:	d102      	bne.n	80151ae <_sbrk_r+0x1a>
 80151a8:	682b      	ldr	r3, [r5, #0]
 80151aa:	b103      	cbz	r3, 80151ae <_sbrk_r+0x1a>
 80151ac:	6023      	str	r3, [r4, #0]
 80151ae:	bd38      	pop	{r3, r4, r5, pc}
 80151b0:	24014444 	.word	0x24014444

080151b4 <abort>:
 80151b4:	b508      	push	{r3, lr}
 80151b6:	2006      	movs	r0, #6
 80151b8:	f000 f85a 	bl	8015270 <raise>
 80151bc:	2001      	movs	r0, #1
 80151be:	f7eb fddd 	bl	8000d7c <_exit>

080151c2 <_realloc_r>:
 80151c2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80151c6:	4607      	mov	r7, r0
 80151c8:	4614      	mov	r4, r2
 80151ca:	460d      	mov	r5, r1
 80151cc:	b921      	cbnz	r1, 80151d8 <_realloc_r+0x16>
 80151ce:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80151d2:	4611      	mov	r1, r2
 80151d4:	f7ff b9b6 	b.w	8014544 <_malloc_r>
 80151d8:	b92a      	cbnz	r2, 80151e6 <_realloc_r+0x24>
 80151da:	f7ff f93f 	bl	801445c <_free_r>
 80151de:	4625      	mov	r5, r4
 80151e0:	4628      	mov	r0, r5
 80151e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80151e6:	f000 f85f 	bl	80152a8 <_malloc_usable_size_r>
 80151ea:	4284      	cmp	r4, r0
 80151ec:	4606      	mov	r6, r0
 80151ee:	d802      	bhi.n	80151f6 <_realloc_r+0x34>
 80151f0:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
 80151f4:	d8f4      	bhi.n	80151e0 <_realloc_r+0x1e>
 80151f6:	4621      	mov	r1, r4
 80151f8:	4638      	mov	r0, r7
 80151fa:	f7ff f9a3 	bl	8014544 <_malloc_r>
 80151fe:	4680      	mov	r8, r0
 8015200:	b908      	cbnz	r0, 8015206 <_realloc_r+0x44>
 8015202:	4645      	mov	r5, r8
 8015204:	e7ec      	b.n	80151e0 <_realloc_r+0x1e>
 8015206:	42b4      	cmp	r4, r6
 8015208:	4622      	mov	r2, r4
 801520a:	4629      	mov	r1, r5
 801520c:	bf28      	it	cs
 801520e:	4632      	movcs	r2, r6
 8015210:	f7ff f8f7 	bl	8014402 <memcpy>
 8015214:	4629      	mov	r1, r5
 8015216:	4638      	mov	r0, r7
 8015218:	f7ff f920 	bl	801445c <_free_r>
 801521c:	e7f1      	b.n	8015202 <_realloc_r+0x40>

0801521e <_raise_r>:
 801521e:	291f      	cmp	r1, #31
 8015220:	b538      	push	{r3, r4, r5, lr}
 8015222:	4605      	mov	r5, r0
 8015224:	460c      	mov	r4, r1
 8015226:	d904      	bls.n	8015232 <_raise_r+0x14>
 8015228:	2316      	movs	r3, #22
 801522a:	6003      	str	r3, [r0, #0]
 801522c:	f04f 30ff 	mov.w	r0, #4294967295
 8015230:	bd38      	pop	{r3, r4, r5, pc}
 8015232:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
 8015234:	b112      	cbz	r2, 801523c <_raise_r+0x1e>
 8015236:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 801523a:	b94b      	cbnz	r3, 8015250 <_raise_r+0x32>
 801523c:	4628      	mov	r0, r5
 801523e:	f000 f831 	bl	80152a4 <_getpid_r>
 8015242:	4622      	mov	r2, r4
 8015244:	4601      	mov	r1, r0
 8015246:	4628      	mov	r0, r5
 8015248:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 801524c:	f000 b818 	b.w	8015280 <_kill_r>
 8015250:	2b01      	cmp	r3, #1
 8015252:	d00a      	beq.n	801526a <_raise_r+0x4c>
 8015254:	1c59      	adds	r1, r3, #1
 8015256:	d103      	bne.n	8015260 <_raise_r+0x42>
 8015258:	2316      	movs	r3, #22
 801525a:	6003      	str	r3, [r0, #0]
 801525c:	2001      	movs	r0, #1
 801525e:	e7e7      	b.n	8015230 <_raise_r+0x12>
 8015260:	2100      	movs	r1, #0
 8015262:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
 8015266:	4620      	mov	r0, r4
 8015268:	4798      	blx	r3
 801526a:	2000      	movs	r0, #0
 801526c:	e7e0      	b.n	8015230 <_raise_r+0x12>
	...

08015270 <raise>:
 8015270:	4b02      	ldr	r3, [pc, #8]	@ (801527c <raise+0xc>)
 8015272:	4601      	mov	r1, r0
 8015274:	6818      	ldr	r0, [r3, #0]
 8015276:	f7ff bfd2 	b.w	801521e <_raise_r>
 801527a:	bf00      	nop
 801527c:	2400003c 	.word	0x2400003c

08015280 <_kill_r>:
 8015280:	b538      	push	{r3, r4, r5, lr}
 8015282:	4d07      	ldr	r5, [pc, #28]	@ (80152a0 <_kill_r+0x20>)
 8015284:	2300      	movs	r3, #0
 8015286:	4604      	mov	r4, r0
 8015288:	4608      	mov	r0, r1
 801528a:	4611      	mov	r1, r2
 801528c:	602b      	str	r3, [r5, #0]
 801528e:	f7eb fd6d 	bl	8000d6c <_kill>
 8015292:	1c43      	adds	r3, r0, #1
 8015294:	d102      	bne.n	801529c <_kill_r+0x1c>
 8015296:	682b      	ldr	r3, [r5, #0]
 8015298:	b103      	cbz	r3, 801529c <_kill_r+0x1c>
 801529a:	6023      	str	r3, [r4, #0]
 801529c:	bd38      	pop	{r3, r4, r5, pc}
 801529e:	bf00      	nop
 80152a0:	24014444 	.word	0x24014444

080152a4 <_getpid_r>:
 80152a4:	f7eb bd60 	b.w	8000d68 <_getpid>

080152a8 <_malloc_usable_size_r>:
 80152a8:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80152ac:	1f18      	subs	r0, r3, #4
 80152ae:	2b00      	cmp	r3, #0
 80152b0:	bfbc      	itt	lt
 80152b2:	580b      	ldrlt	r3, [r1, r0]
 80152b4:	18c0      	addlt	r0, r0, r3
 80152b6:	4770      	bx	lr

080152b8 <_init>:
 80152b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80152ba:	bf00      	nop
 80152bc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80152be:	bc08      	pop	{r3}
 80152c0:	469e      	mov	lr, r3
 80152c2:	4770      	bx	lr

080152c4 <_fini>:
 80152c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80152c6:	bf00      	nop
 80152c8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80152ca:	bc08      	pop	{r3}
 80152cc:	469e      	mov	lr, r3
 80152ce:	4770      	bx	lr
